var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/.wrangler/tmp/bundle-QkSCc7/checked-fetch.js
function checkURL(request, init3) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init3) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
var urls;
var init_checked_fetch = __esm({
  "src/.wrangler/tmp/bundle-QkSCc7/checked-fetch.js"() {
    urls = /* @__PURE__ */ new Set();
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request, init3] = argArray;
        checkURL(request, init3);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});

// ../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/process.js
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance, performanceNow, startTime, process, defines;
var init_process = __esm({
  "../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/process.js"() {
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener = noop;
    once = noop;
    off = noop;
    removeListener = noop;
    removeAllListeners = noop;
    emit = noop;
    performance = globalThis.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    startTime = /* @__PURE__ */ new Date();
    process = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    defines = {};
    Object.keys(defines).forEach((key) => {
      const segs = key.split(".");
      let target = process;
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        if (i === segs.length - 1) {
          target[seg] = defines[key];
        } else {
          target = target[seg] || (target[seg] = {});
        }
      }
    });
  }
});

// ../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function base64toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function base64fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(
      encodeChunk(
        uint8,
        i,
        i + maxChunkLength > len2 ? len2 : i + maxChunkLength
      )
    );
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill3, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill3, encoding) : createBuffer(that, size).fill(fill3);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError(
    "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
  );
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError(
      "Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes"
    );
  }
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(
          buffer,
          val,
          byteOffset
        );
      } else {
        return Uint8Array.prototype.lastIndexOf.call(
          buffer,
          val,
          byteOffset
        );
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(
    utf8ToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  );
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(
    utf16leToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  );
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64fromByteArray(buf);
  } else {
    return base64fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      4,
      34028234663852886e22,
      -34028234663852886e22
    );
  }
  ieee754write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      8,
      17976931348623157e292,
      -17976931348623157e292
    );
  }
  ieee754write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units2) {
  units2 = units2 || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units2 -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units2 -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units2 -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units2 -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units2 -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units2 -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units2 -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units2 -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units2) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units2 -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
function ieee754read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function ieee754write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
var lookup, revLookup, Arr, inited, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_Buffer = __esm({
  "../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    Buffer2.kMaxLength = kMaxLength();
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
      }
    }
    Buffer2.alloc = function(size, fill3, encoding) {
      return alloc(null, size, fill3, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var i = byteLength3;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// ../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js
var init_buffer = __esm({
  "../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js"() {
    init_Buffer();
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
  }
});

// ../node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "../node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// ../node_modules/osmtogeojson/lodash.custom.js
var require_lodash_custom = __commonJS({
  "../node_modules/osmtogeojson/lodash.custom.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    (function() {
      var undefined2;
      var VERSION3 = "4.15.0";
      var LARGE_ARRAY_SIZE = 200;
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reFlags = /\w*$/;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          return freeProcess && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function addMapEntry(map, pair) {
        map.set(pair[0], pair[1]);
        return map;
      }
      function addSetEntry(set, value) {
        set.add(value);
        return set;
      }
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayEach(array, iteratee2) {
        var index = -1, length = array ? array.length : 0;
        while (++index < length) {
          if (iteratee2(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee2, accumulator, initAccum) {
        var index = -1, length = array ? array.length : 0;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee2(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array ? array.length : 0;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseTimes(n, iteratee2) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee2(index);
        }
        return result;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty3 = objectProto.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      var objectToString2 = objectProto.toString;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer4 = moduleExports ? root.Buffer : undefined2, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
      var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : undefined2, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max;
      var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
      var nonEnumShadows = !propertyIsEnumerable.call({ "valueOf": 1 }, "valueOf");
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash() {
      }
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? undefined2 : result;
        }
        return hasOwnProperty3.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty3.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values) {
        var index = -1, length = values ? values.length : 0;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        this.__data__ = new ListCache(entries);
      }
      function stackClear() {
        this.__data__ = new ListCache();
      }
      function stackDelete(key) {
        return this.__data__["delete"](key);
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var cache = this.__data__;
        if (cache instanceof ListCache) {
          var pairs = cache.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            return this;
          }
          cache = this.__data__ = new MapCache(pairs);
        }
        cache.set(key, value);
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var result = isArray4(value) || isArguments(value) ? baseTimes(value.length, String) : [];
        var length = result.length, skipIndexes = !!length;
        for (var key in value) {
          if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || typeof key == "number" && value === undefined2 && !(key in object)) {
          object[key] = value;
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty3.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          object[key] = value;
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys2(source), object);
      }
      function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
        var result;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== undefined2) {
          return result;
        }
        if (!isObject4(value)) {
          return value;
        }
        var isArr = isArray4(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer5(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) {
              return object ? value : {};
            }
            result = initCloneObject(isFunc ? {} : value);
            if (!isDeep) {
              return copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, baseClone, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (!isArr) {
          var props = isFull ? getAllKeys(value) : keys2(value);
        }
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
        });
        return result;
      }
      function baseCreate(proto) {
        return isObject4(proto) ? objectCreate(proto) : {};
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseFor = createBaseFor();
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys2);
      }
      function baseGet(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray4(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function baseGetTag(value) {
        return objectToString2.call(value);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function baseIsEqual(value, other, customizer, bitmask, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObject4(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
      }
      function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
        var objIsArr = isArray4(object), othIsArr = isArray4(other), objTag = arrayTag, othTag = arrayTag;
        if (!objIsArr) {
          objTag = getTag(object);
          objTag = objTag == argsTag ? objectTag : objTag;
        }
        if (!othIsArr) {
          othTag = getTag(other);
          othTag = othTag == argsTag ? objectTag : othTag;
        }
        var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
        }
        if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined2 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject4(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction3(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString2.call(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty3.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function baseKeysIn(object) {
        if (!isObject4(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty3.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined2, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        if (!(isArray4(source) || isTypedArray2(source))) {
          var props = baseKeysIn(source);
        }
        arrayEach(props || source, function(srcValue, key) {
          if (props) {
            key = srcValue;
            srcValue = source[key];
          }
          if (isObject4(srcValue)) {
            stack || (stack = new Stack());
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(object[key], srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        });
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          newValue = srcValue;
          if (isArray4(srcValue) || isTypedArray2(srcValue)) {
            if (isArray4(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else {
              isCommon = false;
              newValue = baseClone(srcValue, true);
            }
          } else if (isPlainObject3(srcValue) || isArguments(srcValue)) {
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject4(objValue) || srcIndex && isFunction3(objValue)) {
              isCommon = false;
              newValue = baseClone(srcValue, true);
            } else {
              newValue = objValue;
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function baseRest(func, start) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = array;
          return apply(func, this, otherArgs);
        };
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function castPath(value) {
        return isArray4(value) ? value : stringToPath(value);
      }
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var result = new buffer.constructor(buffer.length);
        buffer.copy(result);
        return result;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneMap(map, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
        return arrayReduce(array, addMapEntry, new map.constructor());
      }
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      function cloneSet(set, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
        return arrayReduce(array, addSetEntry, new set.constructor());
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          assignValue(object, key, newValue === undefined2 ? source[key] : newValue);
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack.get(array);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
                return seen.add(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= UNORDERED_COMPARE_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys2(object), objLength = objProps.length, othProps = keys2(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
            return false;
          }
        }
        var stacked = stack.get(object);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getIteratee() {
        var result = lodash.iteratee || iteratee;
        result = result === iteratee ? baseIteratee : result;
        return arguments.length ? result(arguments[0], arguments[1]) : result;
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result = keys2(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = objectToString2.call(value), Ctor = result == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : undefined2;
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      function hasPath(object, path, hasFunc) {
        path = isKey(path, object) ? [path] : castPath(path);
        var result, index = -1, length = path.length;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result) {
          return result;
        }
        var length = object ? object.length : 0;
        return !!length && isLength(length) && isIndex(key, length) && (isArray4(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result = array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty3.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, cloneFunc, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return cloneMap(object, isDeep, cloneFunc);
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return cloneSet(object, isDeep, cloneFunc);
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject4(object)) {
          return false;
        }
        var type2 = typeof index;
        if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray4(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject4(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || key in Object(object));
        };
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      var stringToPath = memoize(function(string) {
        string = toString6(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, string2) {
          result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function compact(array) {
        var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function forEach3(collection, iteratee2) {
        var func = isArray4(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result);
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function clone(value) {
        return baseClone(value, false, true);
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      function isArguments(value) {
        return isArrayLikeObject(value) && hasOwnProperty3.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
      }
      var isArray4 = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction3(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      var isBuffer5 = nativeIsBuffer || stubFalse;
      function isEmpty(value) {
        if (isArrayLike(value) && (isArray4(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer5(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (nonEnumShadows || isPrototype(value)) {
          return !nativeKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty3.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isFunction3(value) {
        var tag = isObject4(value) ? objectToString2.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject4(value) {
        var type2 = typeof value;
        return !!value && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isPlainObject3(value) {
        if (!isObjectLike(value) || objectToString2.call(value) != objectTag || isHostObject(value)) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
      }
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toString6(value) {
        return value == null ? "" : baseToString(value);
      }
      function get(object, path, defaultValue) {
        var result = object == null ? undefined2 : baseGet(object, path);
        return result === undefined2 ? defaultValue : result;
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, true));
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      lodash.compact = compact;
      lodash.iteratee = iteratee;
      lodash.keys = keys2;
      lodash.keysIn = keysIn;
      lodash.memoize = memoize;
      lodash.merge = merge2;
      lodash.property = property;
      lodash.toPlainObject = toPlainObject;
      lodash.clone = clone;
      lodash.eq = eq;
      lodash.forEach = forEach3;
      lodash.get = get;
      lodash.hasIn = hasIn;
      lodash.identity = identity;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray4;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBuffer = isBuffer5;
      lodash.isEmpty = isEmpty;
      lodash.isFunction = isFunction3;
      lodash.isLength = isLength;
      lodash.isObject = isObject4;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject3;
      lodash.isSymbol = isSymbol2;
      lodash.isTypedArray = isTypedArray2;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.toString = toString6;
      lodash.each = forEach3;
      lodash.VERSION = VERSION3;
      if (freeModule) {
        (freeModule.exports = lodash)._ = lodash;
        freeExports._ = lodash;
      }
    }).call(exports);
  }
});

// ../node_modules/@mapbox/geojson-rewind/index.js
var require_geojson_rewind = __commonJS({
  "../node_modules/@mapbox/geojson-rewind/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = rewind;
    function rewind(gj, outer) {
      var type2 = gj && gj.type, i;
      if (type2 === "FeatureCollection") {
        for (i = 0; i < gj.features.length; i++)
          rewind(gj.features[i], outer);
      } else if (type2 === "GeometryCollection") {
        for (i = 0; i < gj.geometries.length; i++)
          rewind(gj.geometries[i], outer);
      } else if (type2 === "Feature") {
        rewind(gj.geometry, outer);
      } else if (type2 === "Polygon") {
        rewindRings(gj.coordinates, outer);
      } else if (type2 === "MultiPolygon") {
        for (i = 0; i < gj.coordinates.length; i++)
          rewindRings(gj.coordinates[i], outer);
      }
      return gj;
    }
    function rewindRings(rings, outer) {
      if (rings.length === 0)
        return;
      rewindRing(rings[0], outer);
      for (var i = 1; i < rings.length; i++) {
        rewindRing(rings[i], !outer);
      }
    }
    function rewindRing(ring, dir) {
      var area = 0, err = 0;
      for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
        var k = (ring[i][0] - ring[j][0]) * (ring[j][1] + ring[i][1]);
        var m = area + k;
        err += Math.abs(area) >= Math.abs(k) ? area - m + k : k - m + area;
        area = m;
      }
      if (area + err >= 0 !== !!dir)
        ring.reverse();
    }
  }
});

// ../node_modules/osm-polygon-features/polygon-features.json
var require_polygon_features = __commonJS({
  "../node_modules/osm-polygon-features/polygon-features.json"(exports, module) {
    module.exports = [
      {
        key: "building",
        polygon: "all"
      },
      {
        key: "highway",
        polygon: "whitelist",
        values: [
          "services",
          "rest_area",
          "escape",
          "elevator"
        ]
      },
      {
        key: "natural",
        polygon: "blacklist",
        values: [
          "coastline",
          "cliff",
          "ridge",
          "arete",
          "tree_row"
        ]
      },
      {
        key: "landuse",
        polygon: "all"
      },
      {
        key: "waterway",
        polygon: "whitelist",
        values: [
          "riverbank",
          "dock",
          "boatyard",
          "dam"
        ]
      },
      {
        key: "amenity",
        polygon: "all"
      },
      {
        key: "leisure",
        polygon: "all"
      },
      {
        key: "barrier",
        polygon: "whitelist",
        values: [
          "city_wall",
          "ditch",
          "hedge",
          "retaining_wall",
          "wall",
          "spikes"
        ]
      },
      {
        key: "railway",
        polygon: "whitelist",
        values: [
          "station",
          "turntable",
          "roundhouse",
          "platform"
        ]
      },
      {
        key: "area",
        polygon: "all"
      },
      {
        key: "boundary",
        polygon: "all"
      },
      {
        key: "man_made",
        polygon: "blacklist",
        values: [
          "cutline",
          "embankment",
          "pipeline"
        ]
      },
      {
        key: "power",
        polygon: "whitelist",
        values: [
          "plant",
          "substation",
          "generator",
          "transformer"
        ]
      },
      {
        key: "place",
        polygon: "all"
      },
      {
        key: "shop",
        polygon: "all"
      },
      {
        key: "aeroway",
        polygon: "blacklist",
        values: [
          "taxiway"
        ]
      },
      {
        key: "tourism",
        polygon: "all"
      },
      {
        key: "historic",
        polygon: "all"
      },
      {
        key: "public_transport",
        polygon: "all"
      },
      {
        key: "office",
        polygon: "all"
      },
      {
        key: "building:part",
        polygon: "all"
      },
      {
        key: "military",
        polygon: "all"
      },
      {
        key: "ruins",
        polygon: "all"
      },
      {
        key: "area:highway",
        polygon: "all"
      },
      {
        key: "craft",
        polygon: "all"
      },
      {
        key: "golf",
        polygon: "all"
      },
      {
        key: "indoor",
        polygon: "all"
      }
    ];
  }
});

// ../node_modules/osm-polygon-features/index.js
var require_osm_polygon_features = __commonJS({
  "../node_modules/osm-polygon-features/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = require_polygon_features();
  }
});

// ../node_modules/osmtogeojson/index.js
var require_osmtogeojson = __commonJS({
  "../node_modules/osmtogeojson/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var _ = require_lodash_custom();
    var rewind = require_geojson_rewind();
    var polygonFeatures = {};
    require_osm_polygon_features().forEach(function(tags) {
      if (tags.polygon === "all")
        polygonFeatures[tags.key] = true;
      else {
        var list = tags.polygon === "whitelist" ? "included_values" : "excluded_values", tagValuesObj = {};
        tags.values.forEach(function(value) {
          tagValuesObj[value] = true;
        });
        polygonFeatures[tags.key] = {};
        polygonFeatures[tags.key][list] = tagValuesObj;
      }
    });
    function default_deduplicator(objectA, objectB) {
      if ((objectA.version || objectB.version) && objectA.version !== objectB.version) {
        return (+objectA.version || 0) > (+objectB.version || 0) ? objectA : objectB;
      }
      return _.merge(objectA, objectB);
    }
    var osmtogeojson6 = {};
    osmtogeojson6 = function(data, options, featureCallback) {
      options = _.merge(
        {
          verbose: false,
          flatProperties: true,
          uninterestingTags: {
            "source": true,
            "source_ref": true,
            "source:ref": true,
            "history": true,
            "attribution": true,
            "created_by": true,
            "tiger:county": true,
            "tiger:tlid": true,
            "tiger:upload_uuid": true
          },
          polygonFeatures,
          deduplicator: default_deduplicator
        },
        options
      );
      var result;
      if (typeof XMLDocument !== "undefined" && data instanceof XMLDocument || typeof XMLDocument === "undefined" && data.childNodes)
        result = _osmXML2geoJSON(data);
      else
        result = _overpassJSON2geoJSON(data);
      return result;
      function _overpassJSON2geoJSON(json) {
        var nodes = new Array();
        var ways = new Array();
        var rels = new Array();
        function centerGeometry(object) {
          var pseudoNode = _.clone(object);
          pseudoNode.lat = object.center.lat;
          pseudoNode.lon = object.center.lon;
          pseudoNode.__is_center_placeholder = true;
          nodes.push(pseudoNode);
        }
        function boundsGeometry(object) {
          var pseudoWay = _.clone(object);
          pseudoWay.nodes = [];
          function addPseudoNode(lat, lon, i2) {
            var pseudoNode = {
              type: "node",
              id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i2,
              lat,
              lon
            };
            pseudoWay.nodes.push(pseudoNode.id);
            nodes.push(pseudoNode);
          }
          addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.minlon, 1);
          addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.minlon, 2);
          addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.maxlon, 3);
          addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.maxlon, 4);
          pseudoWay.nodes.push(pseudoWay.nodes[0]);
          pseudoWay.__is_bounds_placeholder = true;
          ways.push(pseudoWay);
        }
        function fullGeometryWay(way2) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
          }
          if (!_.isArray(way2.nodes)) {
            way2.nodes = way2.geometry.map(function(nd) {
              if (nd !== null)
                return "_anonymous@" + nd.lat + "/" + nd.lon;
              else
                return "_anonymous@unknown_location";
            });
          }
          way2.geometry.forEach(function(nd, i2) {
            if (nd) {
              addFullGeometryNode(
                nd.lat,
                nd.lon,
                way2.nodes[i2]
              );
            }
          });
        }
        function fullGeometryRelation(rel2) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
          }
          function addFullGeometryWay(geometry, id) {
            if (ways.some(function(way2) {
              return way2.type == "way" && way2.id == id;
            }))
              return;
            var geometryWay = {
              type: "way",
              id,
              nodes: []
            };
            function addFullGeometryWayPseudoNode(lat, lon) {
              var geometryPseudoNode = {
                type: "node",
                id: "_anonymous@" + lat + "/" + lon,
                lat,
                lon
              };
              geometryWay.nodes.push(geometryPseudoNode.id);
              nodes.push(geometryPseudoNode);
            }
            geometry.forEach(function(nd) {
              if (nd) {
                addFullGeometryWayPseudoNode(
                  nd.lat,
                  nd.lon
                );
              } else {
                geometryWay.nodes.push(void 0);
              }
            });
            ways.push(geometryWay);
          }
          rel2.members.forEach(function(member, i2) {
            if (member.type == "node") {
              if (member.lat) {
                addFullGeometryNode(
                  member.lat,
                  member.lon,
                  member.ref
                );
              }
            } else if (member.type == "way") {
              if (member.geometry) {
                member.ref = "_fullGeom" + member.ref;
                addFullGeometryWay(
                  member.geometry,
                  member.ref
                );
              }
            }
          });
        }
        for (var i = 0; i < json.elements.length; i++) {
          switch (json.elements[i].type) {
            case "node":
              var node = json.elements[i];
              nodes.push(node);
              break;
            case "way":
              var way = _.clone(json.elements[i]);
              way.nodes = _.clone(way.nodes);
              ways.push(way);
              if (way.center)
                centerGeometry(way);
              if (way.geometry)
                fullGeometryWay(way);
              else if (way.bounds)
                boundsGeometry(way);
              break;
            case "relation":
              var rel = _.clone(json.elements[i]);
              rel.members = _.clone(rel.members);
              rels.push(rel);
              var has_full_geometry = rel.members && rel.members.some(function(member) {
                return member.type == "node" && member.lat || member.type == "way" && member.geometry && member.geometry.length > 0;
              });
              if (rel.center)
                centerGeometry(rel);
              if (has_full_geometry)
                fullGeometryRelation(rel);
              else if (rel.bounds)
                boundsGeometry(rel);
              break;
            default:
          }
        }
        return _convert2geoJSON(nodes, ways, rels);
      }
      function _osmXML2geoJSON(xml) {
        var nodes = new Array();
        var ways = new Array();
        var rels = new Array();
        function copy_attribute(x, o, attr) {
          if (x.hasAttribute(attr))
            o[attr] = x.getAttribute(attr);
        }
        function centerGeometry(object, centroid2) {
          var pseudoNode = _.clone(object);
          copy_attribute(centroid2, pseudoNode, "lat");
          copy_attribute(centroid2, pseudoNode, "lon");
          pseudoNode.__is_center_placeholder = true;
          nodes.push(pseudoNode);
        }
        function boundsGeometry(object, bounds2) {
          var pseudoWay = _.clone(object);
          pseudoWay.nodes = [];
          function addPseudoNode(lat, lon, i) {
            var pseudoNode = {
              type: "node",
              id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i,
              lat,
              lon
            };
            pseudoWay.nodes.push(pseudoNode.id);
            nodes.push(pseudoNode);
          }
          addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("minlon"), 1);
          addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("minlon"), 2);
          addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("maxlon"), 3);
          addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("maxlon"), 4);
          pseudoWay.nodes.push(pseudoWay.nodes[0]);
          pseudoWay.__is_bounds_placeholder = true;
          ways.push(pseudoWay);
        }
        function fullGeometryWay(way, nds) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
            return geometryNode.id;
          }
          if (!_.isArray(way.nodes)) {
            way.nodes = [];
            _.each(nds, function(nd, i) {
              way.nodes.push("_anonymous@" + nd.getAttribute("lat") + "/" + nd.getAttribute("lon"));
            });
          }
          _.each(nds, function(nd, i) {
            if (nd.getAttribute("lat")) {
              addFullGeometryNode(
                nd.getAttribute("lat"),
                nd.getAttribute("lon"),
                way.nodes[i]
              );
            }
          });
        }
        function fullGeometryRelation(rel, members) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
          }
          function addFullGeometryWay(nds, id) {
            if (ways.some(function(way) {
              return way.type == "way" && way.id == id;
            }))
              return;
            var geometryWay = {
              type: "way",
              id,
              nodes: []
            };
            function addFullGeometryWayPseudoNode(lat, lon) {
              var geometryPseudoNode = {
                type: "node",
                id: "_anonymous@" + lat + "/" + lon,
                lat,
                lon
              };
              geometryWay.nodes.push(geometryPseudoNode.id);
              nodes.push(geometryPseudoNode);
            }
            _.each(nds, function(nd) {
              if (nd.getAttribute("lat")) {
                addFullGeometryWayPseudoNode(
                  nd.getAttribute("lat"),
                  nd.getAttribute("lon")
                );
              } else {
                geometryWay.nodes.push(void 0);
              }
            });
            ways.push(geometryWay);
          }
          _.each(members, function(member, i) {
            if (rel.members[i].type == "node") {
              if (member.getAttribute("lat")) {
                addFullGeometryNode(
                  member.getAttribute("lat"),
                  member.getAttribute("lon"),
                  rel.members[i].ref
                );
              }
            } else if (rel.members[i].type == "way") {
              if (member.getElementsByTagName("nd").length > 0) {
                rel.members[i].ref = "_fullGeom" + rel.members[i].ref;
                addFullGeometryWay(
                  member.getElementsByTagName("nd"),
                  rel.members[i].ref
                );
              }
            }
          });
        }
        _.each(xml.getElementsByTagName("node"), function(node, i) {
          var tags = {};
          _.each(node.getElementsByTagName("tag"), function(tag) {
            tags[tag.getAttribute("k")] = tag.getAttribute("v");
          });
          var nodeObject = {
            "type": "node"
          };
          copy_attribute(node, nodeObject, "id");
          copy_attribute(node, nodeObject, "lat");
          copy_attribute(node, nodeObject, "lon");
          copy_attribute(node, nodeObject, "version");
          copy_attribute(node, nodeObject, "timestamp");
          copy_attribute(node, nodeObject, "changeset");
          copy_attribute(node, nodeObject, "uid");
          copy_attribute(node, nodeObject, "user");
          if (!_.isEmpty(tags))
            nodeObject.tags = tags;
          nodes.push(nodeObject);
        });
        var centroid, bounds;
        _.each(xml.getElementsByTagName("way"), function(way, i) {
          var tags = {};
          var wnodes = [];
          _.each(way.getElementsByTagName("tag"), function(tag) {
            tags[tag.getAttribute("k")] = tag.getAttribute("v");
          });
          var has_full_geometry = false;
          _.each(way.getElementsByTagName("nd"), function(nd, i2) {
            var id;
            if (id = nd.getAttribute("ref"))
              wnodes[i2] = id;
            if (!has_full_geometry && nd.getAttribute("lat"))
              has_full_geometry = true;
          });
          var wayObject = {
            "type": "way"
          };
          copy_attribute(way, wayObject, "id");
          copy_attribute(way, wayObject, "version");
          copy_attribute(way, wayObject, "timestamp");
          copy_attribute(way, wayObject, "changeset");
          copy_attribute(way, wayObject, "uid");
          copy_attribute(way, wayObject, "user");
          if (wnodes.length > 0)
            wayObject.nodes = wnodes;
          if (!_.isEmpty(tags))
            wayObject.tags = tags;
          if (centroid = way.getElementsByTagName("center")[0])
            centerGeometry(wayObject, centroid);
          if (has_full_geometry)
            fullGeometryWay(wayObject, way.getElementsByTagName("nd"));
          else if (bounds = way.getElementsByTagName("bounds")[0])
            boundsGeometry(wayObject, bounds);
          ways.push(wayObject);
        });
        _.each(xml.getElementsByTagName("relation"), function(relation, i) {
          var tags = {};
          var members = [];
          _.each(relation.getElementsByTagName("tag"), function(tag) {
            tags[tag.getAttribute("k")] = tag.getAttribute("v");
          });
          var has_full_geometry = false;
          _.each(relation.getElementsByTagName("member"), function(member, i2) {
            members[i2] = {};
            copy_attribute(member, members[i2], "ref");
            copy_attribute(member, members[i2], "role");
            copy_attribute(member, members[i2], "type");
            if (!has_full_geometry && (members[i2].type == "node" && member.getAttribute("lat")) || members[i2].type == "way" && member.getElementsByTagName("nd").length > 0)
              has_full_geometry = true;
          });
          var relObject = {
            "type": "relation"
          };
          copy_attribute(relation, relObject, "id");
          copy_attribute(relation, relObject, "version");
          copy_attribute(relation, relObject, "timestamp");
          copy_attribute(relation, relObject, "changeset");
          copy_attribute(relation, relObject, "uid");
          copy_attribute(relation, relObject, "user");
          if (members.length > 0)
            relObject.members = members;
          if (!_.isEmpty(tags))
            relObject.tags = tags;
          if (centroid = relation.getElementsByTagName("center")[0])
            centerGeometry(relObject, centroid);
          if (has_full_geometry)
            fullGeometryRelation(relObject, relation.getElementsByTagName("member"));
          else if (bounds = relation.getElementsByTagName("bounds")[0])
            boundsGeometry(relObject, bounds);
          rels.push(relObject);
        });
        return _convert2geoJSON(nodes, ways, rels);
      }
      function _convert2geoJSON(nodes, ways, rels) {
        function has_interesting_tags(t2, ignore_tags) {
          if (typeof ignore_tags !== "object")
            ignore_tags = {};
          if (typeof options.uninterestingTags === "function")
            return !options.uninterestingTags(t2, ignore_tags);
          for (var k in t2)
            if (!(options.uninterestingTags[k] === true) && !(ignore_tags[k] === true || ignore_tags[k] === t2[k]))
              return true;
          return false;
        }
        ;
        function build_meta_information(object) {
          var res = {
            "timestamp": object.timestamp,
            "version": object.version,
            "changeset": object.changeset,
            "user": object.user,
            "uid": object.uid
          };
          for (var k in res)
            if (res[k] === void 0)
              delete res[k];
          return res;
        }
        var nodeids = new Object();
        var poinids = new Object();
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (nodeids[node.id] !== void 0) {
            node = options.deduplicator(node, nodeids[node.id]);
          }
          nodeids[node.id] = node;
          if (typeof node.tags != "undefined" && has_interesting_tags(node.tags))
            poinids[node.id] = true;
        }
        for (var i = 0; i < rels.length; i++) {
          if (_.isArray(rels[i].members)) {
            for (var j = 0; j < rels[i].members.length; j++) {
              if (rels[i].members[j].type == "node")
                poinids[rels[i].members[j].ref] = true;
            }
          }
        }
        var wayids = new Object();
        var waynids = new Object();
        for (var i = 0; i < ways.length; i++) {
          var way = ways[i];
          if (wayids[way.id]) {
            way = options.deduplicator(way, wayids[way.id]);
          }
          wayids[way.id] = way;
          if (_.isArray(way.nodes)) {
            for (var j = 0; j < way.nodes.length; j++) {
              if (typeof way.nodes[j] === "object")
                continue;
              waynids[way.nodes[j]] = true;
              way.nodes[j] = nodeids[way.nodes[j]];
            }
          }
        }
        var pois = new Array();
        for (var id in nodeids) {
          var node = nodeids[id];
          if (!waynids[id] || poinids[id])
            pois.push(node);
        }
        var relids = new Array();
        for (var i = 0; i < rels.length; i++) {
          var rel = rels[i];
          if (relids[rel.id]) {
            rel = options.deduplicator(rel, relids[rel.id]);
          }
          relids[rel.id] = rel;
        }
        var relsmap = { node: {}, way: {}, relation: {} };
        for (var id in relids) {
          var rel = relids[id];
          if (!_.isArray(rel.members)) {
            if (options.verbose)
              console.warn("Relation", rel.type + "/" + rel.id, "ignored because it has no members");
            continue;
          }
          for (var j = 0; j < rel.members.length; j++) {
            var m_type = rel.members[j].type;
            var m_ref = rel.members[j].ref;
            if (typeof m_ref !== "number") {
              m_ref = m_ref.replace("_fullGeom", "");
            }
            if (!relsmap[m_type]) {
              if (options.verbose)
                console.warn("Relation", rel.type + "/" + rel.id, "member", m_type + "/" + m_ref, "ignored because it has an invalid type");
              continue;
            }
            if (typeof relsmap[m_type][m_ref] === "undefined")
              relsmap[m_type][m_ref] = [];
            relsmap[m_type][m_ref].push({
              "role": rel.members[j].role,
              "rel": rel.id,
              "reltags": rel.tags
            });
          }
        }
        var geojson;
        var geojsonnodes = [];
        for (i = 0; i < pois.length; i++) {
          if (typeof pois[i].lon == "undefined" || typeof pois[i].lat == "undefined") {
            if (options.verbose)
              console.warn("POI", pois[i].type + "/" + pois[i].id, "ignored because it lacks coordinates");
            continue;
          }
          var feature = {
            "type": "Feature",
            "id": pois[i].type + "/" + pois[i].id,
            "properties": {
              "type": pois[i].type,
              "id": pois[i].id,
              "tags": pois[i].tags || {},
              "relations": relsmap["node"][pois[i].id] || [],
              "meta": build_meta_information(pois[i])
            },
            "geometry": {
              "type": "Point",
              "coordinates": [+pois[i].lon, +pois[i].lat]
            }
          };
          if (pois[i].__is_center_placeholder)
            feature.properties["geometry"] = "center";
          if (!featureCallback)
            geojsonnodes.push(feature);
          else
            featureCallback(feature);
        }
        var geojsonlines = [];
        var geojsonpolygons = [];
        for (var i = 0; i < rels.length; i++) {
          if (relids[rels[i].id] !== rels[i]) {
            continue;
          }
          if (typeof rels[i].tags != "undefined" && (rels[i].tags["type"] == "route" || rels[i].tags["type"] == "waterway")) {
            let construct_multilinestring2 = function(rel2) {
              var is_tainted = false;
              var members;
              members = rel2.members.filter(function(m) {
                return m.type === "way";
              });
              members = members.map(function(m) {
                var way2 = wayids[m.ref];
                if (way2 === void 0 || way2.nodes === void 0) {
                  if (options.verbose)
                    console.warn("Route " + rel2.type + "/" + rel2.id, "tainted by a missing or incomplete  way", m.type + "/" + m.ref);
                  is_tainted = true;
                  return;
                }
                return {
                  // TODO: this is slow! :(
                  id: m.ref,
                  role: m.role,
                  way: way2,
                  nodes: way2.nodes.filter(function(n) {
                    if (n !== void 0)
                      return true;
                    is_tainted = true;
                    if (options.verbose)
                      console.warn("Route", rel2.type + "/" + rel2.id, "tainted by a way", m.type + "/" + m.ref, "with a missing node");
                    return false;
                  })
                };
              });
              members = _.compact(members);
              var linestrings;
              linestrings = join3(members);
              var coords2 = [];
              coords2 = _.compact(linestrings.map(function(linestring) {
                return _.compact(linestring.map(function(node2) {
                  return [+node2.lon, +node2.lat];
                }));
              }));
              if (coords2.length == 0) {
                if (options.verbose)
                  console.warn("Route", rel2.type + "/" + rel2.id, "contains no coordinates");
                return false;
              }
              var feature2 = {
                "type": "Feature",
                "id": rel2.type + "/" + rel2.id,
                "properties": {
                  "type": rel2.type,
                  "id": rel2.id,
                  "tags": rel2.tags || {},
                  "relations": relsmap[rel2.type][rel2.id] || [],
                  "meta": build_meta_information(rel2)
                },
                "geometry": {
                  "type": coords2.length === 1 ? "LineString" : "MultiLineString",
                  "coordinates": coords2.length === 1 ? coords2[0] : coords2
                }
              };
              if (is_tainted) {
                if (options.verbose)
                  console.warn("Route", rel2.type + "/" + rel2.id, "is tainted");
                feature2.properties["tainted"] = true;
              }
              return feature2;
            };
            var construct_multilinestring = construct_multilinestring2;
            if (!_.isArray(rels[i].members)) {
              if (options.verbose)
                console.warn("Route", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
              continue;
            }
            rels[i].members.forEach(function(m) {
              if (wayids[m.ref] && !has_interesting_tags(wayids[m.ref].tags))
                wayids[m.ref].is_skippablerelationmember = true;
            });
            feature = construct_multilinestring2(rels[i]);
            if (feature === false) {
              if (options.verbose)
                console.warn("Route relation", rels[i].type + "/" + rels[i].id, "ignored because it has invalid geometry");
              continue;
            }
            if (!featureCallback)
              geojsonpolygons.push(feature);
            else
              featureCallback(rewind(feature));
          }
          if (typeof rels[i].tags != "undefined" && (rels[i].tags["type"] == "multipolygon" || rels[i].tags["type"] == "boundary")) {
            let construct_multipolygon2 = function(tag_object, rel2) {
              var is_tainted = false;
              var mp_geometry = simple_mp ? "way" : "relation", mp_id = typeof tag_object.id === "number" ? tag_object.id : +tag_object.id.replace("_fullGeom", "");
              var members;
              members = rel2.members.filter(function(m) {
                return m.type === "way";
              });
              members = members.map(function(m) {
                var way2 = wayids[m.ref];
                if (way2 === void 0 || way2.nodes === void 0) {
                  if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "tainted by a missing or incomplete way", m.type + "/" + m.ref);
                  is_tainted = true;
                  return;
                }
                return {
                  // TODO: this is slow! :(
                  id: m.ref,
                  role: m.role || "outer",
                  way: way2,
                  nodes: way2.nodes.filter(function(n) {
                    if (n !== void 0)
                      return true;
                    is_tainted = true;
                    if (options.verbose)
                      console.warn("Multipolygon", mp_geometry + "/" + mp_id, "tainted by a way", m.type + "/" + m.ref, "with a missing node");
                    return false;
                  })
                };
              });
              members = _.compact(members);
              var outers, inners;
              outers = join3(members.filter(function(m) {
                return m.role === "outer";
              }));
              inners = join3(members.filter(function(m) {
                return m.role === "inner";
              }));
              var mp;
              function findOuter(inner) {
                var polygonIntersectsPolygon = function(outer2, inner2) {
                  for (var i2 = 0; i2 < inner2.length; i2++)
                    if (pointInPolygon(inner2[i2], outer2))
                      return true;
                  return false;
                };
                var mapCoordinates = function(from3) {
                  return from3.map(function(n) {
                    return [+n.lat, +n.lon];
                  });
                };
                var pointInPolygon = function(point, polygon) {
                  var x = point[0], y = point[1], inside = false;
                  for (var i2 = 0, j3 = polygon.length - 1; i2 < polygon.length; j3 = i2++) {
                    var xi = polygon[i2][0], yi = polygon[i2][1];
                    var xj = polygon[j3][0], yj = polygon[j3][1];
                    var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
                    if (intersect)
                      inside = !inside;
                  }
                  return inside;
                };
                var o2, outer;
                inner = mapCoordinates(inner);
                for (o2 = 0; o2 < outers.length; o2++) {
                  outer = mapCoordinates(outers[o2]);
                  if (polygonIntersectsPolygon(outer, inner))
                    return o2;
                }
              }
              mp = outers.map(function(o2) {
                return [o2];
              });
              for (var j2 = 0; j2 < inners.length; j2++) {
                var o = findOuter(inners[j2]);
                if (o !== void 0)
                  mp[o].push(inners[j2]);
                else if (options.verbose)
                  console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains an inner ring with no containing outer");
                ;
              }
              var mp_coords = [];
              mp_coords = _.compact(mp.map(function(cluster) {
                var cl = _.compact(cluster.map(function(ring) {
                  if (ring.length < 4) {
                    if (options.verbose)
                      console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains a ring with less than four nodes");
                    return;
                  }
                  return _.compact(ring.map(function(node2) {
                    return [+node2.lon, +node2.lat];
                  }));
                }));
                if (cl.length == 0) {
                  if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains an empty ring cluster");
                  return;
                }
                return cl;
              }));
              if (mp_coords.length == 0) {
                if (options.verbose)
                  console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains no coordinates");
                return false;
              }
              var mp_type = "MultiPolygon";
              if (mp_coords.length === 1) {
                mp_type = "Polygon";
                mp_coords = mp_coords[0];
              }
              var feature2 = {
                "type": "Feature",
                "id": tag_object.type + "/" + mp_id,
                "properties": {
                  "type": tag_object.type,
                  "id": mp_id,
                  "tags": tag_object.tags || {},
                  "relations": relsmap[tag_object.type][tag_object.id] || [],
                  "meta": build_meta_information(tag_object)
                },
                "geometry": {
                  "type": mp_type,
                  "coordinates": mp_coords
                }
              };
              if (is_tainted) {
                if (options.verbose)
                  console.warn("Multipolygon", mp_geometry + "/" + mp_id, "is tainted");
                feature2.properties["tainted"] = true;
              }
              return feature2;
            };
            var construct_multipolygon = construct_multipolygon2;
            if (!_.isArray(rels[i].members)) {
              if (options.verbose)
                console.warn("Multipolygon", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
              continue;
            }
            var outer_count = 0;
            for (var j = 0; j < rels[i].members.length; j++)
              if (rels[i].members[j].role == "outer")
                outer_count++;
              else if (options.verbose && rels[i].members[j].role != "inner")
                console.warn("Multipolygon", rels[i].type + "/" + rels[i].id, "member", rels[i].members[j].type + "/" + rels[i].members[j].ref, 'ignored because it has an invalid role: "' + rels[i].members[j].role + '"');
            rels[i].members.forEach(function(m) {
              if (wayids[m.ref]) {
                if (m.role === "outer" && !has_interesting_tags(wayids[m.ref].tags, rels[i].tags))
                  wayids[m.ref].is_skippablerelationmember = true;
                if (m.role === "inner" && !has_interesting_tags(wayids[m.ref].tags))
                  wayids[m.ref].is_skippablerelationmember = true;
              }
            });
            if (outer_count == 0) {
              if (options.verbose)
                console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because it has no outer ways");
              continue;
            }
            var simple_mp = false;
            if (outer_count == 1 && !has_interesting_tags(rels[i].tags, { "type": true }))
              simple_mp = true;
            var feature = null;
            if (!simple_mp) {
              feature = construct_multipolygon2(rels[i], rels[i]);
            } else {
              var outer_way = rels[i].members.filter(function(m) {
                return m.role === "outer";
              })[0];
              outer_way = wayids[outer_way.ref];
              if (outer_way === void 0) {
                if (options.verbose)
                  console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because outer way", outer_way.type + "/" + outer_way.ref, "is missing");
                continue;
              }
              outer_way.is_skippablerelationmember = true;
              feature = construct_multipolygon2(outer_way, rels[i]);
            }
            if (feature === false) {
              if (options.verbose)
                console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because it has invalid geometry");
              continue;
            }
            if (!featureCallback)
              geojsonpolygons.push(feature);
            else
              featureCallback(rewind(feature));
          }
        }
        for (var i = 0; i < ways.length; i++) {
          if (wayids[ways[i].id] !== ways[i]) {
            continue;
          }
          if (!_.isArray(ways[i].nodes)) {
            if (options.verbose)
              console.warn("Way", ways[i].type + "/" + ways[i].id, "ignored because it has no nodes");
            continue;
          }
          if (ways[i].is_skippablerelationmember)
            continue;
          if (typeof ways[i].id !== "number") {
            ways[i].id = +ways[i].id.replace("_fullGeom", "");
          }
          ways[i].tainted = false;
          ways[i].hidden = false;
          var coords = new Array();
          for (j = 0; j < ways[i].nodes.length; j++) {
            if (typeof ways[i].nodes[j] == "object")
              coords.push([+ways[i].nodes[j].lon, +ways[i].nodes[j].lat]);
            else {
              if (options.verbose)
                console.warn("Way", ways[i].type + "/" + ways[i].id, "is tainted by an invalid node");
              ways[i].tainted = true;
            }
          }
          if (coords.length <= 1) {
            if (options.verbose)
              console.warn("Way", ways[i].type + "/" + ways[i].id, "ignored because it contains too few nodes");
            continue;
          }
          var way_type = "LineString";
          if (typeof ways[i].nodes[0] != "undefined" && typeof ways[i].nodes[ways[i].nodes.length - 1] != "undefined" && // way has its start/end nodes loaded
          ways[i].nodes[0].id === ways[i].nodes[ways[i].nodes.length - 1].id && // ... and forms a closed ring
          (typeof ways[i].tags != "undefined" && // ... and has tags
          _isPolygonFeature(ways[i].tags) || // or is a placeholder for a bounds geometry
          ways[i].__is_bounds_placeholder)) {
            way_type = "Polygon";
            coords = [coords];
          }
          var feature = {
            "type": "Feature",
            "id": ways[i].type + "/" + ways[i].id,
            "properties": {
              "type": ways[i].type,
              "id": ways[i].id,
              "tags": ways[i].tags || {},
              "relations": relsmap["way"][ways[i].id] || [],
              "meta": build_meta_information(ways[i])
            },
            "geometry": {
              "type": way_type,
              "coordinates": coords
            }
          };
          if (ways[i].tainted) {
            if (options.verbose)
              console.warn("Way", ways[i].type + "/" + ways[i].id, "is tainted");
            feature.properties["tainted"] = true;
          }
          if (ways[i].__is_bounds_placeholder)
            feature.properties["geometry"] = "bounds";
          if (!featureCallback) {
            if (way_type == "LineString")
              geojsonlines.push(feature);
            else
              geojsonpolygons.push(feature);
          } else {
            featureCallback(rewind(feature));
          }
        }
        if (featureCallback)
          return true;
        geojson = {
          "type": "FeatureCollection",
          "features": []
        };
        geojson.features = geojson.features.concat(geojsonpolygons);
        geojson.features = geojson.features.concat(geojsonlines);
        geojson.features = geojson.features.concat(geojsonnodes);
        if (options.flatProperties) {
          geojson.features.forEach(function(f) {
            f.properties = _.merge(
              f.properties.meta,
              f.properties.tags,
              { id: f.properties.type + "/" + f.properties.id }
            );
          });
        }
        geojson = rewind(geojson);
        return geojson;
      }
      function _isPolygonFeature(tags) {
        var polygonFeatures2 = options.polygonFeatures;
        if (typeof polygonFeatures2 === "function")
          return polygonFeatures2(tags);
        if (tags["area"] === "no")
          return false;
        for (var key in tags) {
          var val = tags[key];
          var pfk = polygonFeatures2[key];
          if (typeof pfk === "undefined")
            continue;
          if (val === "no")
            continue;
          if (pfk === true)
            return true;
          if (pfk.included_values && pfk.included_values[val] === true)
            return true;
          if (pfk.excluded_values && pfk.excluded_values[val] !== true)
            return true;
        }
        return false;
      }
    };
    function join3(ways) {
      var _first = function(arr) {
        return arr[0];
      };
      var _last = function(arr) {
        return arr[arr.length - 1];
      };
      var _fitTogether = function(n1, n2) {
        return n1 !== void 0 && n2 !== void 0 && n1.id === n2.id;
      };
      var joined = [], current, first, last, i, how, what;
      while (ways.length) {
        current = ways.pop().nodes.slice();
        joined.push(current);
        while (ways.length && !_fitTogether(_first(current), _last(current))) {
          first = _first(current);
          last = _last(current);
          for (i = 0; i < ways.length; i++) {
            what = ways[i].nodes;
            if (_fitTogether(last, _first(what))) {
              how = current.push;
              what = what.slice(1);
              break;
            } else if (_fitTogether(last, _last(what))) {
              how = current.push;
              what = what.slice(0, -1).reverse();
              break;
            } else if (_fitTogether(first, _last(what))) {
              how = current.unshift;
              what = what.slice(0, -1);
              break;
            } else if (_fitTogether(first, _first(what))) {
              how = current.unshift;
              what = what.slice(1).reverse();
              break;
            } else {
              what = how = null;
            }
          }
          if (!what)
            break;
          ways.splice(i, 1);
          how.apply(current, what);
        }
      }
      return joined;
    }
    osmtogeojson6.toGeojson = osmtogeojson6;
    module.exports = osmtogeojson6;
  }
});

// ../node_modules/@prisma/client/runtime/edge.js
var require_edge = __commonJS({
  "../node_modules/@prisma/client/runtime/edge.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var il = Object.create;
    var tr = Object.defineProperty;
    var sl = Object.getOwnPropertyDescriptor;
    var al = Object.getOwnPropertyNames;
    var ul = Object.getPrototypeOf;
    var ll = Object.prototype.hasOwnProperty;
    var cl = (e, t2, r) => t2 in e ? tr(e, t2, { enumerable: true, configurable: true, writable: true, value: r }) : e[t2] = r;
    var Br = (e, t2) => () => (e && (t2 = e(e = 0)), t2);
    var Z = (e, t2) => () => (t2 || e((t2 = { exports: {} }).exports, t2), t2.exports);
    var rr = (e, t2) => {
      for (var r in t2)
        tr(e, r, { get: t2[r], enumerable: true });
    };
    var vi = (e, t2, r, n) => {
      if (t2 && typeof t2 == "object" || typeof t2 == "function")
        for (let o of al(t2))
          !ll.call(e, o) && o !== r && tr(e, o, { get: () => t2[o], enumerable: !(n = sl(t2, o)) || n.enumerable });
      return e;
    };
    var ve = (e, t2, r) => (r = e != null ? il(ul(e)) : {}, vi(t2 || !e || !e.__esModule ? tr(r, "default", { value: e, enumerable: true }) : r, e));
    var pl = (e) => vi(tr({}, "__esModule", { value: true }), e);
    var Ai = (e, t2, r) => (cl(e, typeof t2 != "symbol" ? t2 + "" : t2, r), r);
    function B(e) {
      return () => e;
    }
    function Ie() {
      return y;
    }
    var y;
    var p = Br(() => {
      "use strict";
      y = { abort: B(void 0), addListener: B(Ie()), allowedNodeEnvironmentFlags: /* @__PURE__ */ new Set(), arch: "x64", argv: ["/bin/node"], argv0: "node", chdir: B(void 0), config: { target_defaults: { cflags: [], default_configuration: "", defines: [], include_dirs: [], libraries: [] }, variables: { clang: 0, host_arch: "x64", node_install_npm: false, node_install_waf: false, node_prefix: "", node_shared_openssl: false, node_shared_v8: false, node_shared_zlib: false, node_use_dtrace: false, node_use_etw: false, node_use_openssl: false, target_arch: "x64", v8_no_strict_aliasing: 0, v8_use_snapshot: false, visibility: "" } }, connected: false, cpuUsage: () => ({ user: 0, system: 0 }), cwd: () => "/", debugPort: 0, disconnect: B(void 0), constrainedMemory: () => {
      }, emit: B(Ie()), emitWarning: B(void 0), env: {}, eventNames: () => [], execArgv: [], execPath: "/", exit: B(void 0), features: { inspector: false, debug: false, uv: false, ipv6: false, tls_alpn: false, tls_sni: false, tls_ocsp: false, tls: false }, getMaxListeners: B(0), getegid: B(0), geteuid: B(0), getgid: B(0), getgroups: B([]), getuid: B(0), hasUncaughtExceptionCaptureCallback: B(false), hrtime: B([0, 0]), platform: "linux", kill: B(true), listenerCount: B(0), listeners: B([]), memoryUsage: B({ arrayBuffers: 0, external: 0, heapTotal: 0, heapUsed: 0, rss: 0 }), nextTick: (e, ...t2) => {
        setTimeout(() => {
          e(...t2);
        }, 0);
      }, off: B(Ie()), on: B(Ie()), once: B(Ie()), openStdin: B({}), pid: 0, ppid: 0, prependListener: B(Ie()), prependOnceListener: B(Ie()), rawListeners: B([]), release: { name: "node" }, removeAllListeners: B(Ie()), removeListener: B(Ie()), resourceUsage: B({ fsRead: 0, fsWrite: 0, involuntaryContextSwitches: 0, ipcReceived: 0, ipcSent: 0, majorPageFault: 0, maxRSS: 0, minorPageFault: 0, sharedMemorySize: 0, signalsCount: 0, swappedOut: 0, systemCPUTime: 0, unsharedDataSize: 0, unsharedStackSize: 0, userCPUTime: 0, voluntaryContextSwitches: 0 }), setMaxListeners: B(Ie()), setUncaughtExceptionCaptureCallback: B(void 0), setegid: B(void 0), seteuid: B(void 0), setgid: B(void 0), setgroups: B(void 0), setuid: B(void 0), stderr: { fd: 2 }, stdin: { fd: 0 }, stdout: { fd: 1 }, title: "node", traceDeprecation: false, umask: B(0), uptime: B(0), version: "", versions: { http_parser: "", node: "", v8: "", ares: "", uv: "", zlib: "", modules: "", openssl: "" } };
    });
    var h;
    var f = Br(() => {
      "use strict";
      h = () => {
      };
      h.prototype = h;
    });
    var Vi = Z((Ot) => {
      "use strict";
      d();
      p();
      f();
      var Ri = (e, t2) => () => (t2 || e((t2 = { exports: {} }).exports, t2), t2.exports), fl = Ri((e) => {
        "use strict";
        e.byteLength = u, e.toByteArray = c, e.fromByteArray = w;
        var t2 = [], r = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (i = 0, s = o.length; i < s; ++i)
          t2[i] = o[i], r[o.charCodeAt(i)] = i;
        var i, s;
        r["-".charCodeAt(0)] = 62, r["_".charCodeAt(0)] = 63;
        function a(E) {
          var b = E.length;
          if (b % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var T = E.indexOf("=");
          T === -1 && (T = b);
          var S = T === b ? 0 : 4 - T % 4;
          return [T, S];
        }
        function u(E) {
          var b = a(E), T = b[0], S = b[1];
          return (T + S) * 3 / 4 - S;
        }
        function l(E, b, T) {
          return (b + T) * 3 / 4 - T;
        }
        function c(E) {
          var b, T = a(E), S = T[0], R = T[1], C = new n(l(E, S, R)), M = 0, N = R > 0 ? S - 4 : S, L;
          for (L = 0; L < N; L += 4)
            b = r[E.charCodeAt(L)] << 18 | r[E.charCodeAt(L + 1)] << 12 | r[E.charCodeAt(L + 2)] << 6 | r[E.charCodeAt(L + 3)], C[M++] = b >> 16 & 255, C[M++] = b >> 8 & 255, C[M++] = b & 255;
          return R === 2 && (b = r[E.charCodeAt(L)] << 2 | r[E.charCodeAt(L + 1)] >> 4, C[M++] = b & 255), R === 1 && (b = r[E.charCodeAt(L)] << 10 | r[E.charCodeAt(L + 1)] << 4 | r[E.charCodeAt(L + 2)] >> 2, C[M++] = b >> 8 & 255, C[M++] = b & 255), C;
        }
        function m(E) {
          return t2[E >> 18 & 63] + t2[E >> 12 & 63] + t2[E >> 6 & 63] + t2[E & 63];
        }
        function g(E, b, T) {
          for (var S, R = [], C = b; C < T; C += 3)
            S = (E[C] << 16 & 16711680) + (E[C + 1] << 8 & 65280) + (E[C + 2] & 255), R.push(m(S));
          return R.join("");
        }
        function w(E) {
          for (var b, T = E.length, S = T % 3, R = [], C = 16383, M = 0, N = T - S; M < N; M += C)
            R.push(g(E, M, M + C > N ? N : M + C));
          return S === 1 ? (b = E[T - 1], R.push(t2[b >> 2] + t2[b << 4 & 63] + "==")) : S === 2 && (b = (E[T - 2] << 8) + E[T - 1], R.push(t2[b >> 10] + t2[b >> 4 & 63] + t2[b << 2 & 63] + "=")), R.join("");
        }
      }), dl = Ri((e) => {
        e.read = function(t2, r, n, o, i) {
          var s, a, u = i * 8 - o - 1, l = (1 << u) - 1, c = l >> 1, m = -7, g = n ? i - 1 : 0, w = n ? -1 : 1, E = t2[r + g];
          for (g += w, s = E & (1 << -m) - 1, E >>= -m, m += u; m > 0; s = s * 256 + t2[r + g], g += w, m -= 8)
            ;
          for (a = s & (1 << -m) - 1, s >>= -m, m += o; m > 0; a = a * 256 + t2[r + g], g += w, m -= 8)
            ;
          if (s === 0)
            s = 1 - c;
          else {
            if (s === l)
              return a ? NaN : (E ? -1 : 1) * (1 / 0);
            a = a + Math.pow(2, o), s = s - c;
          }
          return (E ? -1 : 1) * a * Math.pow(2, s - o);
        }, e.write = function(t2, r, n, o, i, s) {
          var a, u, l, c = s * 8 - i - 1, m = (1 << c) - 1, g = m >> 1, w = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E = o ? 0 : s - 1, b = o ? 1 : -1, T = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
          for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (u = isNaN(r) ? 1 : 0, a = m) : (a = Math.floor(Math.log(r) / Math.LN2), r * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + g >= 1 ? r += w / l : r += w * Math.pow(2, 1 - g), r * l >= 2 && (a++, l /= 2), a + g >= m ? (u = 0, a = m) : a + g >= 1 ? (u = (r * l - 1) * Math.pow(2, i), a = a + g) : (u = r * Math.pow(2, g - 1) * Math.pow(2, i), a = 0)); i >= 8; t2[n + E] = u & 255, E += b, u /= 256, i -= 8)
            ;
          for (a = a << i | u, c += i; c > 0; t2[n + E] = a & 255, E += b, a /= 256, c -= 8)
            ;
          t2[n + E - b] |= T * 128;
        };
      }), Hn = fl(), St = dl(), Ti = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      Ot.Buffer = P;
      Ot.SlowBuffer = bl;
      Ot.INSPECT_MAX_BYTES = 50;
      var jr = 2147483647;
      Ot.kMaxLength = jr;
      P.TYPED_ARRAY_SUPPORT = ml();
      !P.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      function ml() {
        try {
          let e = new Uint8Array(1), t2 = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(t2, Uint8Array.prototype), Object.setPrototypeOf(e, t2), e.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(P.prototype, "parent", { enumerable: true, get: function() {
        if (P.isBuffer(this))
          return this.buffer;
      } });
      Object.defineProperty(P.prototype, "offset", { enumerable: true, get: function() {
        if (P.isBuffer(this))
          return this.byteOffset;
      } });
      function Ve(e) {
        if (e > jr)
          throw new RangeError('The value "' + e + '" is invalid for option "size"');
        let t2 = new Uint8Array(e);
        return Object.setPrototypeOf(t2, P.prototype), t2;
      }
      function P(e, t2, r) {
        if (typeof e == "number") {
          if (typeof t2 == "string")
            throw new TypeError('The "string" argument must be of type string. Received type number');
          return Yn(e);
        }
        return Oi(e, t2, r);
      }
      P.poolSize = 8192;
      function Oi(e, t2, r) {
        if (typeof e == "string")
          return yl(e, t2);
        if (ArrayBuffer.isView(e))
          return hl(e);
        if (e == null)
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
        if (ke(e, ArrayBuffer) || e && ke(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ke(e, SharedArrayBuffer) || e && ke(e.buffer, SharedArrayBuffer)))
          return Ii(e, t2, r);
        if (typeof e == "number")
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        let n = e.valueOf && e.valueOf();
        if (n != null && n !== e)
          return P.from(n, t2, r);
        let o = xl(e);
        if (o)
          return o;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
          return P.from(e[Symbol.toPrimitive]("string"), t2, r);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      }
      P.from = function(e, t2, r) {
        return Oi(e, t2, r);
      };
      Object.setPrototypeOf(P.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(P, Uint8Array);
      function Fi(e) {
        if (typeof e != "number")
          throw new TypeError('"size" argument must be of type number');
        if (e < 0)
          throw new RangeError('The value "' + e + '" is invalid for option "size"');
      }
      function gl(e, t2, r) {
        return Fi(e), e <= 0 ? Ve(e) : t2 !== void 0 ? typeof r == "string" ? Ve(e).fill(t2, r) : Ve(e).fill(t2) : Ve(e);
      }
      P.alloc = function(e, t2, r) {
        return gl(e, t2, r);
      };
      function Yn(e) {
        return Fi(e), Ve(e < 0 ? 0 : Xn(e) | 0);
      }
      P.allocUnsafe = function(e) {
        return Yn(e);
      };
      P.allocUnsafeSlow = function(e) {
        return Yn(e);
      };
      function yl(e, t2) {
        if ((typeof t2 != "string" || t2 === "") && (t2 = "utf8"), !P.isEncoding(t2))
          throw new TypeError("Unknown encoding: " + t2);
        let r = ki(e, t2) | 0, n = Ve(r), o = n.write(e, t2);
        return o !== r && (n = n.slice(0, o)), n;
      }
      function zn(e) {
        let t2 = e.length < 0 ? 0 : Xn(e.length) | 0, r = Ve(t2);
        for (let n = 0; n < t2; n += 1)
          r[n] = e[n] & 255;
        return r;
      }
      function hl(e) {
        if (ke(e, Uint8Array)) {
          let t2 = new Uint8Array(e);
          return Ii(t2.buffer, t2.byteOffset, t2.byteLength);
        }
        return zn(e);
      }
      function Ii(e, t2, r) {
        if (t2 < 0 || e.byteLength < t2)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (e.byteLength < t2 + (r || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let n;
        return t2 === void 0 && r === void 0 ? n = new Uint8Array(e) : r === void 0 ? n = new Uint8Array(e, t2) : n = new Uint8Array(e, t2, r), Object.setPrototypeOf(n, P.prototype), n;
      }
      function xl(e) {
        if (P.isBuffer(e)) {
          let t2 = Xn(e.length) | 0, r = Ve(t2);
          return r.length === 0 || e.copy(r, 0, 0, t2), r;
        }
        if (e.length !== void 0)
          return typeof e.length != "number" || to(e.length) ? Ve(0) : zn(e);
        if (e.type === "Buffer" && Array.isArray(e.data))
          return zn(e.data);
      }
      function Xn(e) {
        if (e >= jr)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + jr.toString(16) + " bytes");
        return e | 0;
      }
      function bl(e) {
        return +e != e && (e = 0), P.alloc(+e);
      }
      P.isBuffer = function(e) {
        return e != null && e._isBuffer === true && e !== P.prototype;
      };
      P.compare = function(e, t2) {
        if (ke(e, Uint8Array) && (e = P.from(e, e.offset, e.byteLength)), ke(t2, Uint8Array) && (t2 = P.from(t2, t2.offset, t2.byteLength)), !P.isBuffer(e) || !P.isBuffer(t2))
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (e === t2)
          return 0;
        let r = e.length, n = t2.length;
        for (let o = 0, i = Math.min(r, n); o < i; ++o)
          if (e[o] !== t2[o]) {
            r = e[o], n = t2[o];
            break;
          }
        return r < n ? -1 : n < r ? 1 : 0;
      };
      P.isEncoding = function(e) {
        switch (String(e).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      P.concat = function(e, t2) {
        if (!Array.isArray(e))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (e.length === 0)
          return P.alloc(0);
        let r;
        if (t2 === void 0)
          for (t2 = 0, r = 0; r < e.length; ++r)
            t2 += e[r].length;
        let n = P.allocUnsafe(t2), o = 0;
        for (r = 0; r < e.length; ++r) {
          let i = e[r];
          if (ke(i, Uint8Array))
            o + i.length > n.length ? (P.isBuffer(i) || (i = P.from(i)), i.copy(n, o)) : Uint8Array.prototype.set.call(n, i, o);
          else if (P.isBuffer(i))
            i.copy(n, o);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          o += i.length;
        }
        return n;
      };
      function ki(e, t2) {
        if (P.isBuffer(e))
          return e.length;
        if (ArrayBuffer.isView(e) || ke(e, ArrayBuffer))
          return e.byteLength;
        if (typeof e != "string")
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
        let r = e.length, n = arguments.length > 2 && arguments[2] === true;
        if (!n && r === 0)
          return 0;
        let o = false;
        for (; ; )
          switch (t2) {
            case "ascii":
            case "latin1":
            case "binary":
              return r;
            case "utf8":
            case "utf-8":
              return Zn(e).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return r * 2;
            case "hex":
              return r >>> 1;
            case "base64":
              return qi(e).length;
            default:
              if (o)
                return n ? -1 : Zn(e).length;
              t2 = ("" + t2).toLowerCase(), o = true;
          }
      }
      P.byteLength = ki;
      function wl(e, t2, r) {
        let n = false;
        if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t2 >>>= 0, r <= t2))
          return "";
        for (e || (e = "utf8"); ; )
          switch (e) {
            case "hex":
              return Ol(this, t2, r);
            case "utf8":
            case "utf-8":
              return _i(this, t2, r);
            case "ascii":
              return Sl(this, t2, r);
            case "latin1":
            case "binary":
              return Rl(this, t2, r);
            case "base64":
              return Cl(this, t2, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Fl(this, t2, r);
            default:
              if (n)
                throw new TypeError("Unknown encoding: " + e);
              e = (e + "").toLowerCase(), n = true;
          }
      }
      P.prototype._isBuffer = true;
      function mt(e, t2, r) {
        let n = e[t2];
        e[t2] = e[r], e[r] = n;
      }
      P.prototype.swap16 = function() {
        let e = this.length;
        if (e % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let t2 = 0; t2 < e; t2 += 2)
          mt(this, t2, t2 + 1);
        return this;
      };
      P.prototype.swap32 = function() {
        let e = this.length;
        if (e % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let t2 = 0; t2 < e; t2 += 4)
          mt(this, t2, t2 + 3), mt(this, t2 + 1, t2 + 2);
        return this;
      };
      P.prototype.swap64 = function() {
        let e = this.length;
        if (e % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let t2 = 0; t2 < e; t2 += 8)
          mt(this, t2, t2 + 7), mt(this, t2 + 1, t2 + 6), mt(this, t2 + 2, t2 + 5), mt(this, t2 + 3, t2 + 4);
        return this;
      };
      P.prototype.toString = function() {
        let e = this.length;
        return e === 0 ? "" : arguments.length === 0 ? _i(this, 0, e) : wl.apply(this, arguments);
      };
      P.prototype.toLocaleString = P.prototype.toString;
      P.prototype.equals = function(e) {
        if (!P.isBuffer(e))
          throw new TypeError("Argument must be a Buffer");
        return this === e ? true : P.compare(this, e) === 0;
      };
      P.prototype.inspect = function() {
        let e = "", t2 = Ot.INSPECT_MAX_BYTES;
        return e = this.toString("hex", 0, t2).replace(/(.{2})/g, "$1 ").trim(), this.length > t2 && (e += " ... "), "<Buffer " + e + ">";
      };
      Ti && (P.prototype[Ti] = P.prototype.inspect);
      P.prototype.compare = function(e, t2, r, n, o) {
        if (ke(e, Uint8Array) && (e = P.from(e, e.offset, e.byteLength)), !P.isBuffer(e))
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
        if (t2 === void 0 && (t2 = 0), r === void 0 && (r = e ? e.length : 0), n === void 0 && (n = 0), o === void 0 && (o = this.length), t2 < 0 || r > e.length || n < 0 || o > this.length)
          throw new RangeError("out of range index");
        if (n >= o && t2 >= r)
          return 0;
        if (n >= o)
          return -1;
        if (t2 >= r)
          return 1;
        if (t2 >>>= 0, r >>>= 0, n >>>= 0, o >>>= 0, this === e)
          return 0;
        let i = o - n, s = r - t2, a = Math.min(i, s), u = this.slice(n, o), l = e.slice(t2, r);
        for (let c = 0; c < a; ++c)
          if (u[c] !== l[c]) {
            i = u[c], s = l[c];
            break;
          }
        return i < s ? -1 : s < i ? 1 : 0;
      };
      function Di(e, t2, r, n, o) {
        if (e.length === 0)
          return -1;
        if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, to(r) && (r = o ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
          if (o)
            return -1;
          r = e.length - 1;
        } else if (r < 0)
          if (o)
            r = 0;
          else
            return -1;
        if (typeof t2 == "string" && (t2 = P.from(t2, n)), P.isBuffer(t2))
          return t2.length === 0 ? -1 : Ci(e, t2, r, n, o);
        if (typeof t2 == "number")
          return t2 = t2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? o ? Uint8Array.prototype.indexOf.call(e, t2, r) : Uint8Array.prototype.lastIndexOf.call(e, t2, r) : Ci(e, [t2], r, n, o);
        throw new TypeError("val must be string, number or Buffer");
      }
      function Ci(e, t2, r, n, o) {
        let i = 1, s = e.length, a = t2.length;
        if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
          if (e.length < 2 || t2.length < 2)
            return -1;
          i = 2, s /= 2, a /= 2, r /= 2;
        }
        function u(c, m) {
          return i === 1 ? c[m] : c.readUInt16BE(m * i);
        }
        let l;
        if (o) {
          let c = -1;
          for (l = r; l < s; l++)
            if (u(e, l) === u(t2, c === -1 ? 0 : l - c)) {
              if (c === -1 && (c = l), l - c + 1 === a)
                return c * i;
            } else
              c !== -1 && (l -= l - c), c = -1;
        } else
          for (r + a > s && (r = s - a), l = r; l >= 0; l--) {
            let c = true;
            for (let m = 0; m < a; m++)
              if (u(e, l + m) !== u(t2, m)) {
                c = false;
                break;
              }
            if (c)
              return l;
          }
        return -1;
      }
      P.prototype.includes = function(e, t2, r) {
        return this.indexOf(e, t2, r) !== -1;
      };
      P.prototype.indexOf = function(e, t2, r) {
        return Di(this, e, t2, r, true);
      };
      P.prototype.lastIndexOf = function(e, t2, r) {
        return Di(this, e, t2, r, false);
      };
      function El(e, t2, r, n) {
        r = Number(r) || 0;
        let o = e.length - r;
        n ? (n = Number(n), n > o && (n = o)) : n = o;
        let i = t2.length;
        n > i / 2 && (n = i / 2);
        let s;
        for (s = 0; s < n; ++s) {
          let a = parseInt(t2.substr(s * 2, 2), 16);
          if (to(a))
            return s;
          e[r + s] = a;
        }
        return s;
      }
      function Pl(e, t2, r, n) {
        return Ur(Zn(t2, e.length - r), e, r, n);
      }
      function vl(e, t2, r, n) {
        return Ur(_l(t2), e, r, n);
      }
      function Al(e, t2, r, n) {
        return Ur(qi(t2), e, r, n);
      }
      function Tl(e, t2, r, n) {
        return Ur(Nl(t2, e.length - r), e, r, n);
      }
      P.prototype.write = function(e, t2, r, n) {
        if (t2 === void 0)
          n = "utf8", r = this.length, t2 = 0;
        else if (r === void 0 && typeof t2 == "string")
          n = t2, r = this.length, t2 = 0;
        else if (isFinite(t2))
          t2 = t2 >>> 0, isFinite(r) ? (r = r >>> 0, n === void 0 && (n = "utf8")) : (n = r, r = void 0);
        else
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let o = this.length - t2;
        if ((r === void 0 || r > o) && (r = o), e.length > 0 && (r < 0 || t2 < 0) || t2 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        n || (n = "utf8");
        let i = false;
        for (; ; )
          switch (n) {
            case "hex":
              return El(this, e, t2, r);
            case "utf8":
            case "utf-8":
              return Pl(this, e, t2, r);
            case "ascii":
            case "latin1":
            case "binary":
              return vl(this, e, t2, r);
            case "base64":
              return Al(this, e, t2, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Tl(this, e, t2, r);
            default:
              if (i)
                throw new TypeError("Unknown encoding: " + n);
              n = ("" + n).toLowerCase(), i = true;
          }
      };
      P.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      function Cl(e, t2, r) {
        return t2 === 0 && r === e.length ? Hn.fromByteArray(e) : Hn.fromByteArray(e.slice(t2, r));
      }
      function _i(e, t2, r) {
        r = Math.min(e.length, r);
        let n = [], o = t2;
        for (; o < r; ) {
          let i = e[o], s = null, a = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
          if (o + a <= r) {
            let u, l, c, m;
            switch (a) {
              case 1:
                i < 128 && (s = i);
                break;
              case 2:
                u = e[o + 1], (u & 192) === 128 && (m = (i & 31) << 6 | u & 63, m > 127 && (s = m));
                break;
              case 3:
                u = e[o + 1], l = e[o + 2], (u & 192) === 128 && (l & 192) === 128 && (m = (i & 15) << 12 | (u & 63) << 6 | l & 63, m > 2047 && (m < 55296 || m > 57343) && (s = m));
                break;
              case 4:
                u = e[o + 1], l = e[o + 2], c = e[o + 3], (u & 192) === 128 && (l & 192) === 128 && (c & 192) === 128 && (m = (i & 15) << 18 | (u & 63) << 12 | (l & 63) << 6 | c & 63, m > 65535 && m < 1114112 && (s = m));
            }
          }
          s === null ? (s = 65533, a = 1) : s > 65535 && (s -= 65536, n.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), n.push(s), o += a;
        }
        return Ml(n);
      }
      var Mi = 4096;
      function Ml(e) {
        let t2 = e.length;
        if (t2 <= Mi)
          return String.fromCharCode.apply(String, e);
        let r = "", n = 0;
        for (; n < t2; )
          r += String.fromCharCode.apply(String, e.slice(n, n += Mi));
        return r;
      }
      function Sl(e, t2, r) {
        let n = "";
        r = Math.min(e.length, r);
        for (let o = t2; o < r; ++o)
          n += String.fromCharCode(e[o] & 127);
        return n;
      }
      function Rl(e, t2, r) {
        let n = "";
        r = Math.min(e.length, r);
        for (let o = t2; o < r; ++o)
          n += String.fromCharCode(e[o]);
        return n;
      }
      function Ol(e, t2, r) {
        let n = e.length;
        (!t2 || t2 < 0) && (t2 = 0), (!r || r < 0 || r > n) && (r = n);
        let o = "";
        for (let i = t2; i < r; ++i)
          o += Ll[e[i]];
        return o;
      }
      function Fl(e, t2, r) {
        let n = e.slice(t2, r), o = "";
        for (let i = 0; i < n.length - 1; i += 2)
          o += String.fromCharCode(n[i] + n[i + 1] * 256);
        return o;
      }
      P.prototype.slice = function(e, t2) {
        let r = this.length;
        e = ~~e, t2 = t2 === void 0 ? r : ~~t2, e < 0 ? (e += r, e < 0 && (e = 0)) : e > r && (e = r), t2 < 0 ? (t2 += r, t2 < 0 && (t2 = 0)) : t2 > r && (t2 = r), t2 < e && (t2 = e);
        let n = this.subarray(e, t2);
        return Object.setPrototypeOf(n, P.prototype), n;
      };
      function ee(e, t2, r) {
        if (e % 1 !== 0 || e < 0)
          throw new RangeError("offset is not uint");
        if (e + t2 > r)
          throw new RangeError("Trying to access beyond buffer length");
      }
      P.prototype.readUintLE = P.prototype.readUIntLE = function(e, t2, r) {
        e = e >>> 0, t2 = t2 >>> 0, r || ee(e, t2, this.length);
        let n = this[e], o = 1, i = 0;
        for (; ++i < t2 && (o *= 256); )
          n += this[e + i] * o;
        return n;
      };
      P.prototype.readUintBE = P.prototype.readUIntBE = function(e, t2, r) {
        e = e >>> 0, t2 = t2 >>> 0, r || ee(e, t2, this.length);
        let n = this[e + --t2], o = 1;
        for (; t2 > 0 && (o *= 256); )
          n += this[e + --t2] * o;
        return n;
      };
      P.prototype.readUint8 = P.prototype.readUInt8 = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 1, this.length), this[e];
      };
      P.prototype.readUint16LE = P.prototype.readUInt16LE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 2, this.length), this[e] | this[e + 1] << 8;
      };
      P.prototype.readUint16BE = P.prototype.readUInt16BE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 2, this.length), this[e] << 8 | this[e + 1];
      };
      P.prototype.readUint32LE = P.prototype.readUInt32LE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
      };
      P.prototype.readUint32BE = P.prototype.readUInt32BE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
      };
      P.prototype.readBigUInt64LE = Ze(function(e) {
        e = e >>> 0, Rt(e, "offset");
        let t2 = this[e], r = this[e + 7];
        (t2 === void 0 || r === void 0) && nr(e, this.length - 8);
        let n = t2 + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, o = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + r * 2 ** 24;
        return BigInt(n) + (BigInt(o) << BigInt(32));
      });
      P.prototype.readBigUInt64BE = Ze(function(e) {
        e = e >>> 0, Rt(e, "offset");
        let t2 = this[e], r = this[e + 7];
        (t2 === void 0 || r === void 0) && nr(e, this.length - 8);
        let n = t2 * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], o = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r;
        return (BigInt(n) << BigInt(32)) + BigInt(o);
      });
      P.prototype.readIntLE = function(e, t2, r) {
        e = e >>> 0, t2 = t2 >>> 0, r || ee(e, t2, this.length);
        let n = this[e], o = 1, i = 0;
        for (; ++i < t2 && (o *= 256); )
          n += this[e + i] * o;
        return o *= 128, n >= o && (n -= Math.pow(2, 8 * t2)), n;
      };
      P.prototype.readIntBE = function(e, t2, r) {
        e = e >>> 0, t2 = t2 >>> 0, r || ee(e, t2, this.length);
        let n = t2, o = 1, i = this[e + --n];
        for (; n > 0 && (o *= 256); )
          i += this[e + --n] * o;
        return o *= 128, i >= o && (i -= Math.pow(2, 8 * t2)), i;
      };
      P.prototype.readInt8 = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
      };
      P.prototype.readInt16LE = function(e, t2) {
        e = e >>> 0, t2 || ee(e, 2, this.length);
        let r = this[e] | this[e + 1] << 8;
        return r & 32768 ? r | 4294901760 : r;
      };
      P.prototype.readInt16BE = function(e, t2) {
        e = e >>> 0, t2 || ee(e, 2, this.length);
        let r = this[e + 1] | this[e] << 8;
        return r & 32768 ? r | 4294901760 : r;
      };
      P.prototype.readInt32LE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
      };
      P.prototype.readInt32BE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
      };
      P.prototype.readBigInt64LE = Ze(function(e) {
        e = e >>> 0, Rt(e, "offset");
        let t2 = this[e], r = this[e + 7];
        (t2 === void 0 || r === void 0) && nr(e, this.length - 8);
        let n = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (r << 24);
        return (BigInt(n) << BigInt(32)) + BigInt(t2 + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
      });
      P.prototype.readBigInt64BE = Ze(function(e) {
        e = e >>> 0, Rt(e, "offset");
        let t2 = this[e], r = this[e + 7];
        (t2 === void 0 || r === void 0) && nr(e, this.length - 8);
        let n = (t2 << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
        return (BigInt(n) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r);
      });
      P.prototype.readFloatLE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 4, this.length), St.read(this, e, true, 23, 4);
      };
      P.prototype.readFloatBE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 4, this.length), St.read(this, e, false, 23, 4);
      };
      P.prototype.readDoubleLE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 8, this.length), St.read(this, e, true, 52, 8);
      };
      P.prototype.readDoubleBE = function(e, t2) {
        return e = e >>> 0, t2 || ee(e, 8, this.length), St.read(this, e, false, 52, 8);
      };
      function ye(e, t2, r, n, o, i) {
        if (!P.isBuffer(e))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (t2 > o || t2 < i)
          throw new RangeError('"value" argument is out of bounds');
        if (r + n > e.length)
          throw new RangeError("Index out of range");
      }
      P.prototype.writeUintLE = P.prototype.writeUIntLE = function(e, t2, r, n) {
        if (e = +e, t2 = t2 >>> 0, r = r >>> 0, !n) {
          let s = Math.pow(2, 8 * r) - 1;
          ye(this, e, t2, r, s, 0);
        }
        let o = 1, i = 0;
        for (this[t2] = e & 255; ++i < r && (o *= 256); )
          this[t2 + i] = e / o & 255;
        return t2 + r;
      };
      P.prototype.writeUintBE = P.prototype.writeUIntBE = function(e, t2, r, n) {
        if (e = +e, t2 = t2 >>> 0, r = r >>> 0, !n) {
          let s = Math.pow(2, 8 * r) - 1;
          ye(this, e, t2, r, s, 0);
        }
        let o = r - 1, i = 1;
        for (this[t2 + o] = e & 255; --o >= 0 && (i *= 256); )
          this[t2 + o] = e / i & 255;
        return t2 + r;
      };
      P.prototype.writeUint8 = P.prototype.writeUInt8 = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 1, 255, 0), this[t2] = e & 255, t2 + 1;
      };
      P.prototype.writeUint16LE = P.prototype.writeUInt16LE = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 2, 65535, 0), this[t2] = e & 255, this[t2 + 1] = e >>> 8, t2 + 2;
      };
      P.prototype.writeUint16BE = P.prototype.writeUInt16BE = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 2, 65535, 0), this[t2] = e >>> 8, this[t2 + 1] = e & 255, t2 + 2;
      };
      P.prototype.writeUint32LE = P.prototype.writeUInt32LE = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 4, 4294967295, 0), this[t2 + 3] = e >>> 24, this[t2 + 2] = e >>> 16, this[t2 + 1] = e >>> 8, this[t2] = e & 255, t2 + 4;
      };
      P.prototype.writeUint32BE = P.prototype.writeUInt32BE = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 4, 4294967295, 0), this[t2] = e >>> 24, this[t2 + 1] = e >>> 16, this[t2 + 2] = e >>> 8, this[t2 + 3] = e & 255, t2 + 4;
      };
      function Ni(e, t2, r, n, o) {
        $i(t2, n, o, e, r, 7);
        let i = Number(t2 & BigInt(4294967295));
        e[r++] = i, i = i >> 8, e[r++] = i, i = i >> 8, e[r++] = i, i = i >> 8, e[r++] = i;
        let s = Number(t2 >> BigInt(32) & BigInt(4294967295));
        return e[r++] = s, s = s >> 8, e[r++] = s, s = s >> 8, e[r++] = s, s = s >> 8, e[r++] = s, r;
      }
      function Li(e, t2, r, n, o) {
        $i(t2, n, o, e, r, 7);
        let i = Number(t2 & BigInt(4294967295));
        e[r + 7] = i, i = i >> 8, e[r + 6] = i, i = i >> 8, e[r + 5] = i, i = i >> 8, e[r + 4] = i;
        let s = Number(t2 >> BigInt(32) & BigInt(4294967295));
        return e[r + 3] = s, s = s >> 8, e[r + 2] = s, s = s >> 8, e[r + 1] = s, s = s >> 8, e[r] = s, r + 8;
      }
      P.prototype.writeBigUInt64LE = Ze(function(e, t2 = 0) {
        return Ni(this, e, t2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      P.prototype.writeBigUInt64BE = Ze(function(e, t2 = 0) {
        return Li(this, e, t2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      P.prototype.writeIntLE = function(e, t2, r, n) {
        if (e = +e, t2 = t2 >>> 0, !n) {
          let a = Math.pow(2, 8 * r - 1);
          ye(this, e, t2, r, a - 1, -a);
        }
        let o = 0, i = 1, s = 0;
        for (this[t2] = e & 255; ++o < r && (i *= 256); )
          e < 0 && s === 0 && this[t2 + o - 1] !== 0 && (s = 1), this[t2 + o] = (e / i >> 0) - s & 255;
        return t2 + r;
      };
      P.prototype.writeIntBE = function(e, t2, r, n) {
        if (e = +e, t2 = t2 >>> 0, !n) {
          let a = Math.pow(2, 8 * r - 1);
          ye(this, e, t2, r, a - 1, -a);
        }
        let o = r - 1, i = 1, s = 0;
        for (this[t2 + o] = e & 255; --o >= 0 && (i *= 256); )
          e < 0 && s === 0 && this[t2 + o + 1] !== 0 && (s = 1), this[t2 + o] = (e / i >> 0) - s & 255;
        return t2 + r;
      };
      P.prototype.writeInt8 = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t2] = e & 255, t2 + 1;
      };
      P.prototype.writeInt16LE = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 2, 32767, -32768), this[t2] = e & 255, this[t2 + 1] = e >>> 8, t2 + 2;
      };
      P.prototype.writeInt16BE = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 2, 32767, -32768), this[t2] = e >>> 8, this[t2 + 1] = e & 255, t2 + 2;
      };
      P.prototype.writeInt32LE = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 4, 2147483647, -2147483648), this[t2] = e & 255, this[t2 + 1] = e >>> 8, this[t2 + 2] = e >>> 16, this[t2 + 3] = e >>> 24, t2 + 4;
      };
      P.prototype.writeInt32BE = function(e, t2, r) {
        return e = +e, t2 = t2 >>> 0, r || ye(this, e, t2, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t2] = e >>> 24, this[t2 + 1] = e >>> 16, this[t2 + 2] = e >>> 8, this[t2 + 3] = e & 255, t2 + 4;
      };
      P.prototype.writeBigInt64LE = Ze(function(e, t2 = 0) {
        return Ni(this, e, t2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      P.prototype.writeBigInt64BE = Ze(function(e, t2 = 0) {
        return Li(this, e, t2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function Bi(e, t2, r, n, o, i) {
        if (r + n > e.length)
          throw new RangeError("Index out of range");
        if (r < 0)
          throw new RangeError("Index out of range");
      }
      function ji(e, t2, r, n, o) {
        return t2 = +t2, r = r >>> 0, o || Bi(e, t2, r, 4, 34028234663852886e22, -34028234663852886e22), St.write(e, t2, r, n, 23, 4), r + 4;
      }
      P.prototype.writeFloatLE = function(e, t2, r) {
        return ji(this, e, t2, true, r);
      };
      P.prototype.writeFloatBE = function(e, t2, r) {
        return ji(this, e, t2, false, r);
      };
      function Ui(e, t2, r, n, o) {
        return t2 = +t2, r = r >>> 0, o || Bi(e, t2, r, 8, 17976931348623157e292, -17976931348623157e292), St.write(e, t2, r, n, 52, 8), r + 8;
      }
      P.prototype.writeDoubleLE = function(e, t2, r) {
        return Ui(this, e, t2, true, r);
      };
      P.prototype.writeDoubleBE = function(e, t2, r) {
        return Ui(this, e, t2, false, r);
      };
      P.prototype.copy = function(e, t2, r, n) {
        if (!P.isBuffer(e))
          throw new TypeError("argument should be a Buffer");
        if (r || (r = 0), !n && n !== 0 && (n = this.length), t2 >= e.length && (t2 = e.length), t2 || (t2 = 0), n > 0 && n < r && (n = r), n === r || e.length === 0 || this.length === 0)
          return 0;
        if (t2 < 0)
          throw new RangeError("targetStart out of bounds");
        if (r < 0 || r >= this.length)
          throw new RangeError("Index out of range");
        if (n < 0)
          throw new RangeError("sourceEnd out of bounds");
        n > this.length && (n = this.length), e.length - t2 < n - r && (n = e.length - t2 + r);
        let o = n - r;
        return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t2, r, n) : Uint8Array.prototype.set.call(e, this.subarray(r, n), t2), o;
      };
      P.prototype.fill = function(e, t2, r, n) {
        if (typeof e == "string") {
          if (typeof t2 == "string" ? (n = t2, t2 = 0, r = this.length) : typeof r == "string" && (n = r, r = this.length), n !== void 0 && typeof n != "string")
            throw new TypeError("encoding must be a string");
          if (typeof n == "string" && !P.isEncoding(n))
            throw new TypeError("Unknown encoding: " + n);
          if (e.length === 1) {
            let i = e.charCodeAt(0);
            (n === "utf8" && i < 128 || n === "latin1") && (e = i);
          }
        } else
          typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
        if (t2 < 0 || this.length < t2 || this.length < r)
          throw new RangeError("Out of range index");
        if (r <= t2)
          return this;
        t2 = t2 >>> 0, r = r === void 0 ? this.length : r >>> 0, e || (e = 0);
        let o;
        if (typeof e == "number")
          for (o = t2; o < r; ++o)
            this[o] = e;
        else {
          let i = P.isBuffer(e) ? e : P.from(e, n), s = i.length;
          if (s === 0)
            throw new TypeError('The value "' + e + '" is invalid for argument "value"');
          for (o = 0; o < r - t2; ++o)
            this[o + t2] = i[o % s];
        }
        return this;
      };
      var Mt = {};
      function eo(e, t2, r) {
        Mt[e] = class extends r {
          constructor() {
            super(), Object.defineProperty(this, "message", { value: t2.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
          }
          get code() {
            return e;
          }
          set code(n) {
            Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n, writable: true });
          }
          toString() {
            return `${this.name} [${e}]: ${this.message}`;
          }
        };
      }
      eo("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
        return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      }, RangeError);
      eo("ERR_INVALID_ARG_TYPE", function(e, t2) {
        return `The "${e}" argument must be of type number. Received type ${typeof t2}`;
      }, TypeError);
      eo("ERR_OUT_OF_RANGE", function(e, t2, r) {
        let n = `The value of "${e}" is out of range.`, o = r;
        return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = Si(String(r)) : typeof r == "bigint" && (o = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (o = Si(o)), o += "n"), n += ` It must be ${t2}. Received ${o}`, n;
      }, RangeError);
      function Si(e) {
        let t2 = "", r = e.length, n = e[0] === "-" ? 1 : 0;
        for (; r >= n + 4; r -= 3)
          t2 = `_${e.slice(r - 3, r)}${t2}`;
        return `${e.slice(0, r)}${t2}`;
      }
      function Il(e, t2, r) {
        Rt(t2, "offset"), (e[t2] === void 0 || e[t2 + r] === void 0) && nr(t2, e.length - (r + 1));
      }
      function $i(e, t2, r, n, o, i) {
        if (e > r || e < t2) {
          let s = typeof t2 == "bigint" ? "n" : "", a;
          throw i > 3 ? t2 === 0 || t2 === BigInt(0) ? a = `>= 0${s} and < 2${s} ** ${(i + 1) * 8}${s}` : a = `>= -(2${s} ** ${(i + 1) * 8 - 1}${s}) and < 2 ** ${(i + 1) * 8 - 1}${s}` : a = `>= ${t2}${s} and <= ${r}${s}`, new Mt.ERR_OUT_OF_RANGE("value", a, e);
        }
        Il(n, o, i);
      }
      function Rt(e, t2) {
        if (typeof e != "number")
          throw new Mt.ERR_INVALID_ARG_TYPE(t2, "number", e);
      }
      function nr(e, t2, r) {
        throw Math.floor(e) !== e ? (Rt(e, r), new Mt.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t2 < 0 ? new Mt.ERR_BUFFER_OUT_OF_BOUNDS() : new Mt.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t2}`, e);
      }
      var kl = /[^+/0-9A-Za-z-_]/g;
      function Dl(e) {
        if (e = e.split("=")[0], e = e.trim().replace(kl, ""), e.length < 2)
          return "";
        for (; e.length % 4 !== 0; )
          e = e + "=";
        return e;
      }
      function Zn(e, t2) {
        t2 = t2 || 1 / 0;
        let r, n = e.length, o = null, i = [];
        for (let s = 0; s < n; ++s) {
          if (r = e.charCodeAt(s), r > 55295 && r < 57344) {
            if (!o) {
              if (r > 56319) {
                (t2 -= 3) > -1 && i.push(239, 191, 189);
                continue;
              } else if (s + 1 === n) {
                (t2 -= 3) > -1 && i.push(239, 191, 189);
                continue;
              }
              o = r;
              continue;
            }
            if (r < 56320) {
              (t2 -= 3) > -1 && i.push(239, 191, 189), o = r;
              continue;
            }
            r = (o - 55296 << 10 | r - 56320) + 65536;
          } else
            o && (t2 -= 3) > -1 && i.push(239, 191, 189);
          if (o = null, r < 128) {
            if ((t2 -= 1) < 0)
              break;
            i.push(r);
          } else if (r < 2048) {
            if ((t2 -= 2) < 0)
              break;
            i.push(r >> 6 | 192, r & 63 | 128);
          } else if (r < 65536) {
            if ((t2 -= 3) < 0)
              break;
            i.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
          } else if (r < 1114112) {
            if ((t2 -= 4) < 0)
              break;
            i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
          } else
            throw new Error("Invalid code point");
        }
        return i;
      }
      function _l(e) {
        let t2 = [];
        for (let r = 0; r < e.length; ++r)
          t2.push(e.charCodeAt(r) & 255);
        return t2;
      }
      function Nl(e, t2) {
        let r, n, o, i = [];
        for (let s = 0; s < e.length && !((t2 -= 2) < 0); ++s)
          r = e.charCodeAt(s), n = r >> 8, o = r % 256, i.push(o), i.push(n);
        return i;
      }
      function qi(e) {
        return Hn.toByteArray(Dl(e));
      }
      function Ur(e, t2, r, n) {
        let o;
        for (o = 0; o < n && !(o + r >= t2.length || o >= e.length); ++o)
          t2[o + r] = e[o];
        return o;
      }
      function ke(e, t2) {
        return e instanceof t2 || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t2.name;
      }
      function to(e) {
        return e !== e;
      }
      var Ll = function() {
        let e = "0123456789abcdef", t2 = new Array(256);
        for (let r = 0; r < 16; ++r) {
          let n = r * 16;
          for (let o = 0; o < 16; ++o)
            t2[n + o] = e[r] + e[o];
        }
        return t2;
      }();
      function Ze(e) {
        return typeof BigInt > "u" ? Bl : e;
      }
      function Bl() {
        throw new Error("BigInt not supported");
      }
    });
    var x;
    var d = Br(() => {
      "use strict";
      x = ve(Vi());
    });
    var go = Z((j) => {
      "use strict";
      d();
      p();
      f();
      var W = (e, t2) => () => (t2 || e((t2 = { exports: {} }).exports, t2), t2.exports), Yi = W((e, t2) => {
        "use strict";
        t2.exports = function() {
          if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
            return false;
          if (typeof Symbol.iterator == "symbol")
            return true;
          var r = {}, n = Symbol("test"), o = Object(n);
          if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(o) !== "[object Symbol]")
            return false;
          var i = 42;
          r[n] = i;
          for (n in r)
            return false;
          if (typeof Object.keys == "function" && Object.keys(r).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(r).length !== 0)
            return false;
          var s = Object.getOwnPropertySymbols(r);
          if (s.length !== 1 || s[0] !== n || !Object.prototype.propertyIsEnumerable.call(r, n))
            return false;
          if (typeof Object.getOwnPropertyDescriptor == "function") {
            var a = Object.getOwnPropertyDescriptor(r, n);
            if (a.value !== i || a.enumerable !== true)
              return false;
          }
          return true;
        };
      }), Qr = W((e, t2) => {
        "use strict";
        var r = Yi();
        t2.exports = function() {
          return r() && !!Symbol.toStringTag;
        };
      }), jl = W((e, t2) => {
        "use strict";
        var r = typeof Symbol < "u" && Symbol, n = Yi();
        t2.exports = function() {
          return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : n();
        };
      }), Ul = W((e, t2) => {
        "use strict";
        var r = { foo: {} }, n = Object;
        t2.exports = function() {
          return { __proto__: r }.foo === r.foo && !({ __proto__: null } instanceof n);
        };
      }), $l = W((e, t2) => {
        "use strict";
        var r = "Function.prototype.bind called on incompatible ", n = Array.prototype.slice, o = Object.prototype.toString, i = "[object Function]";
        t2.exports = function(s) {
          var a = this;
          if (typeof a != "function" || o.call(a) !== i)
            throw new TypeError(r + a);
          for (var u = n.call(arguments, 1), l, c = function() {
            if (this instanceof l) {
              var b = a.apply(this, u.concat(n.call(arguments)));
              return Object(b) === b ? b : this;
            } else
              return a.apply(s, u.concat(n.call(arguments)));
          }, m = Math.max(0, a.length - u.length), g = [], w = 0; w < m; w++)
            g.push("$" + w);
          if (l = h("binder", "return function (" + g.join(",") + "){ return binder.apply(this,arguments); }")(c), a.prototype) {
            var E = function() {
            };
            E.prototype = a.prototype, l.prototype = new E(), E.prototype = null;
          }
          return l;
        };
      }), lo = W((e, t2) => {
        "use strict";
        var r = $l();
        t2.exports = h.prototype.bind || r;
      }), ql = W((e, t2) => {
        "use strict";
        var r = lo();
        t2.exports = r.call(h.call, Object.prototype.hasOwnProperty);
      }), co = W((e, t2) => {
        "use strict";
        var r, n = SyntaxError, o = h, i = TypeError, s = function($) {
          try {
            return o('"use strict"; return (' + $ + ").constructor;")();
          } catch (U) {
          }
        }, a = Object.getOwnPropertyDescriptor;
        if (a)
          try {
            a({}, "");
          } catch ($) {
            a = null;
          }
        var u = function() {
          throw new i();
        }, l = a ? function() {
          try {
            return arguments.callee, u;
          } catch ($) {
            try {
              return a(arguments, "callee").get;
            } catch (U) {
              return u;
            }
          }
        }() : u, c = jl()(), m = Ul()(), g = Object.getPrototypeOf || (m ? function($) {
          return $.__proto__;
        } : null), w = {}, E = typeof Uint8Array > "u" || !g ? r : g(Uint8Array), b = { "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer, "%ArrayIteratorPrototype%": c && g ? g([][Symbol.iterator]()) : r, "%AsyncFromSyncIteratorPrototype%": r, "%AsyncFunction%": w, "%AsyncGenerator%": w, "%AsyncGeneratorFunction%": w, "%AsyncIteratorPrototype%": w, "%Atomics%": typeof Atomics > "u" ? r : Atomics, "%BigInt%": typeof BigInt > "u" ? r : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? r : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": void 0, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry, "%Function%": o, "%GeneratorFunction%": w, "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": c && g ? g(g([][Symbol.iterator]())) : r, "%JSON%": typeof JSON == "object" ? JSON : r, "%Map%": typeof Map > "u" ? r : Map, "%MapIteratorPrototype%": typeof Map > "u" || !c || !g ? r : g((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? r : Promise, "%Proxy%": typeof Proxy > "u" ? r : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? r : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? r : Set, "%SetIteratorPrototype%": typeof Set > "u" || !c || !g ? r : g((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": c && g ? g(""[Symbol.iterator]()) : r, "%Symbol%": c ? Symbol : r, "%SyntaxError%": n, "%ThrowTypeError%": l, "%TypedArray%": E, "%TypeError%": i, "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet };
        if (g)
          try {
            null.error;
          } catch ($) {
            T = g(g($)), b["%Error.prototype%"] = T;
          }
        var T, S = function $(U) {
          var O;
          if (U === "%AsyncFunction%")
            O = s("async function () {}");
          else if (U === "%GeneratorFunction%")
            O = s("function* () {}");
          else if (U === "%AsyncGeneratorFunction%")
            O = s("async function* () {}");
          else if (U === "%AsyncGenerator%") {
            var ie = $("%AsyncGeneratorFunction%");
            ie && (O = ie.prototype);
          } else if (U === "%AsyncIteratorPrototype%") {
            var se = $("%AsyncGenerator%");
            se && g && (O = g(se.prototype));
          }
          return b[U] = O, O;
        }, R = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, C = lo(), M = ql(), N = C.call(h.call, Array.prototype.concat), L = C.call(h.apply, Array.prototype.splice), Te = C.call(h.call, String.prototype.replace), V = C.call(h.call, String.prototype.slice), H = C.call(h.call, RegExp.prototype.exec), Ee = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, z2 = /\\(\\)?/g, Pe = function($) {
          var U = V($, 0, 1), O = V($, -1);
          if (U === "%" && O !== "%")
            throw new n("invalid intrinsic syntax, expected closing `%`");
          if (O === "%" && U !== "%")
            throw new n("invalid intrinsic syntax, expected opening `%`");
          var ie = [];
          return Te($, Ee, function(se, He, Y, pt) {
            ie[ie.length] = Y ? Te(pt, z2, "$1") : He || se;
          }), ie;
        }, We = function($, U) {
          var O = $, ie;
          if (M(R, O) && (ie = R[O], O = "%" + ie[0] + "%"), M(b, O)) {
            var se = b[O];
            if (se === w && (se = S(O)), typeof se > "u" && !U)
              throw new i("intrinsic " + $ + " exists, but is not available. Please file an issue!");
            return { alias: ie, name: O, value: se };
          }
          throw new n("intrinsic " + $ + " does not exist!");
        };
        t2.exports = function($, U) {
          if (typeof $ != "string" || $.length === 0)
            throw new i("intrinsic name must be a non-empty string");
          if (arguments.length > 1 && typeof U != "boolean")
            throw new i('"allowMissing" argument must be a boolean');
          if (H(/^%?[^%]*%?$/, $) === null)
            throw new n("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
          var O = Pe($), ie = O.length > 0 ? O[0] : "", se = We("%" + ie + "%", U), He = se.name, Y = se.value, pt = false, ze = se.alias;
          ze && (ie = ze[0], L(O, N([0, 1], ze)));
          for (var ft = 1, qe = true; ft < O.length; ft += 1) {
            var de = O[ft], dt = V(de, 0, 1), Tt = V(de, -1);
            if ((dt === '"' || dt === "'" || dt === "`" || Tt === '"' || Tt === "'" || Tt === "`") && dt !== Tt)
              throw new n("property names with quotes must have matching quotes");
            if ((de === "constructor" || !qe) && (pt = true), ie += "." + de, He = "%" + ie + "%", M(b, He))
              Y = b[He];
            else if (Y != null) {
              if (!(de in Y)) {
                if (!U)
                  throw new i("base intrinsic for " + $ + " exists, but the property is not available.");
                return;
              }
              if (a && ft + 1 >= O.length) {
                var Ct = a(Y, de);
                qe = !!Ct, qe && "get" in Ct && !("originalValue" in Ct.get) ? Y = Ct.get : Y = Y[de];
              } else
                qe = M(Y, de), Y = Y[de];
              qe && !pt && (b[He] = Y);
            }
          }
          return Y;
        };
      }), Vl = W((e, t2) => {
        "use strict";
        var r = lo(), n = co(), o = n("%Function.prototype.apply%"), i = n("%Function.prototype.call%"), s = n("%Reflect.apply%", true) || r.call(i, o), a = n("%Object.getOwnPropertyDescriptor%", true), u = n("%Object.defineProperty%", true), l = n("%Math.max%");
        if (u)
          try {
            u({}, "a", { value: 1 });
          } catch (m) {
            u = null;
          }
        t2.exports = function(m) {
          var g = s(r, i, arguments);
          if (a && u) {
            var w = a(g, "length");
            w.configurable && u(g, "length", { value: 1 + l(0, m.length - (arguments.length - 1)) });
          }
          return g;
        };
        var c = function() {
          return s(r, o, arguments);
        };
        u ? u(t2.exports, "apply", { value: c }) : t2.exports.apply = c;
      }), po = W((e, t2) => {
        "use strict";
        var r = co(), n = Vl(), o = n(r("String.prototype.indexOf"));
        t2.exports = function(i, s) {
          var a = r(i, !!s);
          return typeof a == "function" && o(i, ".prototype.") > -1 ? n(a) : a;
        };
      }), Kl = W((e, t2) => {
        "use strict";
        var r = Qr()(), n = po(), o = n("Object.prototype.toString"), i = function(u) {
          return r && u && typeof u == "object" && Symbol.toStringTag in u ? false : o(u) === "[object Arguments]";
        }, s = function(u) {
          return i(u) ? true : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && o(u) !== "[object Array]" && o(u.callee) === "[object Function]";
        }, a = function() {
          return i(arguments);
        }();
        i.isLegacyArguments = s, t2.exports = a ? i : s;
      }), Gl = W((e, t2) => {
        "use strict";
        var r = Object.prototype.toString, n = h.prototype.toString, o = /^\s*(?:function)?\*/, i = Qr()(), s = Object.getPrototypeOf, a = function() {
          if (!i)
            return false;
          try {
            return h("return function*() {}")();
          } catch (l) {
          }
        }, u;
        t2.exports = function(l) {
          if (typeof l != "function")
            return false;
          if (o.test(n.call(l)))
            return true;
          if (!i) {
            var c = r.call(l);
            return c === "[object GeneratorFunction]";
          }
          if (!s)
            return false;
          if (typeof u > "u") {
            var m = a();
            u = m ? s(m) : false;
          }
          return s(l) === u;
        };
      }), Jl = W((e, t2) => {
        "use strict";
        var r = h.prototype.toString, n = typeof Reflect == "object" && Reflect !== null && Reflect.apply, o, i;
        if (typeof n == "function" && typeof Object.defineProperty == "function")
          try {
            o = Object.defineProperty({}, "length", { get: function() {
              throw i;
            } }), i = {}, n(function() {
              throw 42;
            }, null, o);
          } catch (M) {
            M !== i && (n = null);
          }
        else
          n = null;
        var s = /^\s*class\b/, a = function(M) {
          try {
            var N = r.call(M);
            return s.test(N);
          } catch (L) {
            return false;
          }
        }, u = function(M) {
          try {
            return a(M) ? false : (r.call(M), true);
          } catch (N) {
            return false;
          }
        }, l = Object.prototype.toString, c = "[object Object]", m = "[object Function]", g = "[object GeneratorFunction]", w = "[object HTMLAllCollection]", E = "[object HTML document.all class]", b = "[object HTMLCollection]", T = typeof Symbol == "function" && !!Symbol.toStringTag, S = !(0 in [,]), R = function() {
          return false;
        };
        typeof document == "object" && (C = document.all, l.call(C) === l.call(document.all) && (R = function(M) {
          if ((S || !M) && (typeof M > "u" || typeof M == "object"))
            try {
              var N = l.call(M);
              return (N === w || N === E || N === b || N === c) && M("") == null;
            } catch (L) {
            }
          return false;
        }));
        var C;
        t2.exports = n ? function(M) {
          if (R(M))
            return true;
          if (!M || typeof M != "function" && typeof M != "object")
            return false;
          try {
            n(M, null, o);
          } catch (N) {
            if (N !== i)
              return false;
          }
          return !a(M) && u(M);
        } : function(M) {
          if (R(M))
            return true;
          if (!M || typeof M != "function" && typeof M != "object")
            return false;
          if (T)
            return u(M);
          if (a(M))
            return false;
          var N = l.call(M);
          return N !== m && N !== g && !/^\[object HTML/.test(N) ? false : u(M);
        };
      }), Xi = W((e, t2) => {
        "use strict";
        var r = Jl(), n = Object.prototype.toString, o = Object.prototype.hasOwnProperty, i = function(l, c, m) {
          for (var g = 0, w = l.length; g < w; g++)
            o.call(l, g) && (m == null ? c(l[g], g, l) : c.call(m, l[g], g, l));
        }, s = function(l, c, m) {
          for (var g = 0, w = l.length; g < w; g++)
            m == null ? c(l.charAt(g), g, l) : c.call(m, l.charAt(g), g, l);
        }, a = function(l, c, m) {
          for (var g in l)
            o.call(l, g) && (m == null ? c(l[g], g, l) : c.call(m, l[g], g, l));
        }, u = function(l, c, m) {
          if (!r(c))
            throw new TypeError("iterator must be a function");
          var g;
          arguments.length >= 3 && (g = m), n.call(l) === "[object Array]" ? i(l, c, g) : typeof l == "string" ? s(l, c, g) : a(l, c, g);
        };
        t2.exports = u;
      }), es = W((e, t2) => {
        "use strict";
        var r = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], n = typeof globalThis > "u" ? globalThis : globalThis;
        t2.exports = function() {
          for (var o = [], i = 0; i < r.length; i++)
            typeof n[r[i]] == "function" && (o[o.length] = r[i]);
          return o;
        };
      }), ts = W((e, t2) => {
        "use strict";
        var r = co(), n = r("%Object.getOwnPropertyDescriptor%", true);
        if (n)
          try {
            n([], "length");
          } catch (o) {
            n = null;
          }
        t2.exports = n;
      }), rs = W((e, t2) => {
        "use strict";
        var r = Xi(), n = es(), o = po(), i = o("Object.prototype.toString"), s = Qr()(), a = ts(), u = typeof globalThis > "u" ? globalThis : globalThis, l = n(), c = o("Array.prototype.indexOf", true) || function(b, T) {
          for (var S = 0; S < b.length; S += 1)
            if (b[S] === T)
              return S;
          return -1;
        }, m = o("String.prototype.slice"), g = {}, w = Object.getPrototypeOf;
        s && a && w && r(l, function(b) {
          var T = new u[b]();
          if (Symbol.toStringTag in T) {
            var S = w(T), R = a(S, Symbol.toStringTag);
            if (!R) {
              var C = w(S);
              R = a(C, Symbol.toStringTag);
            }
            g[b] = R.get;
          }
        });
        var E = function(b) {
          var T = false;
          return r(g, function(S, R) {
            if (!T)
              try {
                T = S.call(b) === R;
              } catch (C) {
              }
          }), T;
        };
        t2.exports = function(b) {
          if (!b || typeof b != "object")
            return false;
          if (!s || !(Symbol.toStringTag in b)) {
            var T = m(i(b), 8, -1);
            return c(l, T) > -1;
          }
          return a ? E(b) : false;
        };
      }), Ql = W((e, t2) => {
        "use strict";
        var r = Xi(), n = es(), o = po(), i = ts(), s = o("Object.prototype.toString"), a = Qr()(), u = typeof globalThis > "u" ? globalThis : globalThis, l = n(), c = o("String.prototype.slice"), m = {}, g = Object.getPrototypeOf;
        a && i && g && r(l, function(b) {
          if (typeof u[b] == "function") {
            var T = new u[b]();
            if (Symbol.toStringTag in T) {
              var S = g(T), R = i(S, Symbol.toStringTag);
              if (!R) {
                var C = g(S);
                R = i(C, Symbol.toStringTag);
              }
              m[b] = R.get;
            }
          }
        });
        var w = function(b) {
          var T = false;
          return r(m, function(S, R) {
            if (!T)
              try {
                var C = S.call(b);
                C === R && (T = C);
              } catch (M) {
              }
          }), T;
        }, E = rs();
        t2.exports = function(b) {
          return E(b) ? !a || !(Symbol.toStringTag in b) ? c(s(b), 8, -1) : w(b) : false;
        };
      }), Wl = W((e) => {
        "use strict";
        var t2 = Kl(), r = Gl(), n = Ql(), o = rs();
        function i(A) {
          return A.call.bind(A);
        }
        var s = typeof BigInt < "u", a = typeof Symbol < "u", u = i(Object.prototype.toString), l = i(Number.prototype.valueOf), c = i(String.prototype.valueOf), m = i(Boolean.prototype.valueOf);
        s && (g = i(BigInt.prototype.valueOf));
        var g;
        a && (w = i(Symbol.prototype.valueOf));
        var w;
        function E(A, ol) {
          if (typeof A != "object")
            return false;
          try {
            return ol(A), true;
          } catch (Hd) {
            return false;
          }
        }
        e.isArgumentsObject = t2, e.isGeneratorFunction = r, e.isTypedArray = o;
        function b(A) {
          return typeof Promise < "u" && A instanceof Promise || A !== null && typeof A == "object" && typeof A.then == "function" && typeof A.catch == "function";
        }
        e.isPromise = b;
        function T(A) {
          return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(A) : o(A) || ft(A);
        }
        e.isArrayBufferView = T;
        function S(A) {
          return n(A) === "Uint8Array";
        }
        e.isUint8Array = S;
        function R(A) {
          return n(A) === "Uint8ClampedArray";
        }
        e.isUint8ClampedArray = R;
        function C(A) {
          return n(A) === "Uint16Array";
        }
        e.isUint16Array = C;
        function M(A) {
          return n(A) === "Uint32Array";
        }
        e.isUint32Array = M;
        function N(A) {
          return n(A) === "Int8Array";
        }
        e.isInt8Array = N;
        function L(A) {
          return n(A) === "Int16Array";
        }
        e.isInt16Array = L;
        function Te(A) {
          return n(A) === "Int32Array";
        }
        e.isInt32Array = Te;
        function V(A) {
          return n(A) === "Float32Array";
        }
        e.isFloat32Array = V;
        function H(A) {
          return n(A) === "Float64Array";
        }
        e.isFloat64Array = H;
        function Ee(A) {
          return n(A) === "BigInt64Array";
        }
        e.isBigInt64Array = Ee;
        function z2(A) {
          return n(A) === "BigUint64Array";
        }
        e.isBigUint64Array = z2;
        function Pe(A) {
          return u(A) === "[object Map]";
        }
        Pe.working = typeof Map < "u" && Pe(/* @__PURE__ */ new Map());
        function We(A) {
          return typeof Map > "u" ? false : Pe.working ? Pe(A) : A instanceof Map;
        }
        e.isMap = We;
        function $(A) {
          return u(A) === "[object Set]";
        }
        $.working = typeof Set < "u" && $(/* @__PURE__ */ new Set());
        function U(A) {
          return typeof Set > "u" ? false : $.working ? $(A) : A instanceof Set;
        }
        e.isSet = U;
        function O(A) {
          return u(A) === "[object WeakMap]";
        }
        O.working = typeof WeakMap < "u" && O(/* @__PURE__ */ new WeakMap());
        function ie(A) {
          return typeof WeakMap > "u" ? false : O.working ? O(A) : A instanceof WeakMap;
        }
        e.isWeakMap = ie;
        function se(A) {
          return u(A) === "[object WeakSet]";
        }
        se.working = typeof WeakSet < "u" && se(/* @__PURE__ */ new WeakSet());
        function He(A) {
          return se(A);
        }
        e.isWeakSet = He;
        function Y(A) {
          return u(A) === "[object ArrayBuffer]";
        }
        Y.working = typeof ArrayBuffer < "u" && Y(new ArrayBuffer());
        function pt(A) {
          return typeof ArrayBuffer > "u" ? false : Y.working ? Y(A) : A instanceof ArrayBuffer;
        }
        e.isArrayBuffer = pt;
        function ze(A) {
          return u(A) === "[object DataView]";
        }
        ze.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ze(new DataView(new ArrayBuffer(1), 0, 1));
        function ft(A) {
          return typeof DataView > "u" ? false : ze.working ? ze(A) : A instanceof DataView;
        }
        e.isDataView = ft;
        var qe = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
        function de(A) {
          return u(A) === "[object SharedArrayBuffer]";
        }
        function dt(A) {
          return typeof qe > "u" ? false : (typeof de.working > "u" && (de.working = de(new qe())), de.working ? de(A) : A instanceof qe);
        }
        e.isSharedArrayBuffer = dt;
        function Tt(A) {
          return u(A) === "[object AsyncFunction]";
        }
        e.isAsyncFunction = Tt;
        function Ct(A) {
          return u(A) === "[object Map Iterator]";
        }
        e.isMapIterator = Ct;
        function Xu(A) {
          return u(A) === "[object Set Iterator]";
        }
        e.isSetIterator = Xu;
        function el(A) {
          return u(A) === "[object Generator]";
        }
        e.isGeneratorObject = el;
        function tl(A) {
          return u(A) === "[object WebAssembly.Module]";
        }
        e.isWebAssemblyCompiledModule = tl;
        function xi(A) {
          return E(A, l);
        }
        e.isNumberObject = xi;
        function bi(A) {
          return E(A, c);
        }
        e.isStringObject = bi;
        function wi(A) {
          return E(A, m);
        }
        e.isBooleanObject = wi;
        function Ei(A) {
          return s && E(A, g);
        }
        e.isBigIntObject = Ei;
        function Pi(A) {
          return a && E(A, w);
        }
        e.isSymbolObject = Pi;
        function rl(A) {
          return xi(A) || bi(A) || wi(A) || Ei(A) || Pi(A);
        }
        e.isBoxedPrimitive = rl;
        function nl(A) {
          return typeof Uint8Array < "u" && (pt(A) || dt(A));
        }
        e.isAnyArrayBuffer = nl, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(A) {
          Object.defineProperty(e, A, { enumerable: false, value: function() {
            throw new Error(A + " is not supported in userland");
          } });
        });
      }), Hl = W((e, t2) => {
        t2.exports = function(r) {
          return r instanceof x.Buffer;
        };
      }), zl = W((e, t2) => {
        typeof Object.create == "function" ? t2.exports = function(r, n) {
          n && (r.super_ = n, r.prototype = Object.create(n.prototype, { constructor: { value: r, enumerable: false, writable: true, configurable: true } }));
        } : t2.exports = function(r, n) {
          if (n) {
            r.super_ = n;
            var o = function() {
            };
            o.prototype = n.prototype, r.prototype = new o(), r.prototype.constructor = r;
          }
        };
      }), ns = Object.getOwnPropertyDescriptors || function(e) {
        for (var t2 = Object.keys(e), r = {}, n = 0; n < t2.length; n++)
          r[t2[n]] = Object.getOwnPropertyDescriptor(e, t2[n]);
        return r;
      }, Zl = /%[sdj%]/g;
      j.format = function(e) {
        if (!Hr(e)) {
          for (var t2 = [], r = 0; r < arguments.length; r++)
            t2.push(Xe(arguments[r]));
          return t2.join(" ");
        }
        for (var r = 1, n = arguments, o = n.length, i = String(e).replace(Zl, function(u) {
          if (u === "%%")
            return "%";
          if (r >= o)
            return u;
          switch (u) {
            case "%s":
              return String(n[r++]);
            case "%d":
              return Number(n[r++]);
            case "%j":
              try {
                return JSON.stringify(n[r++]);
              } catch (l) {
                return "[Circular]";
              }
            default:
              return u;
          }
        }), s = n[r]; r < o; s = n[++r])
          Wr(s) || !Ft(s) ? i += " " + s : i += " " + Xe(s);
        return i;
      };
      j.deprecate = function(e, t2) {
        if (typeof y < "u" && y.noDeprecation === true)
          return e;
        if (typeof y > "u")
          return function() {
            return j.deprecate(e, t2).apply(this, arguments);
          };
        var r = false;
        function n() {
          if (!r) {
            if (y.throwDeprecation)
              throw new Error(t2);
            y.traceDeprecation ? console.trace(t2) : console.error(t2), r = true;
          }
          return e.apply(this, arguments);
        }
        return n;
      };
      var qr = {}, os = /^$/;
      y.env.NODE_DEBUG && (Vr = y.env.NODE_DEBUG, Vr = Vr.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), os = new RegExp("^" + Vr + "$", "i"));
      var Vr;
      j.debuglog = function(e) {
        if (e = e.toUpperCase(), !qr[e])
          if (os.test(e)) {
            var t2 = y.pid;
            qr[e] = function() {
              var r = j.format.apply(j, arguments);
              console.error("%s %d: %s", e, t2, r);
            };
          } else
            qr[e] = function() {
            };
        return qr[e];
      };
      function Xe(e, t2) {
        var r = { seen: [], stylize: Xl };
        return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), fo(t2) ? r.showHidden = t2 : t2 && j._extend(r, t2), yt(r.showHidden) && (r.showHidden = false), yt(r.depth) && (r.depth = 2), yt(r.colors) && (r.colors = false), yt(r.customInspect) && (r.customInspect = true), r.colors && (r.stylize = Yl), Gr(r, e, r.depth);
      }
      j.inspect = Xe;
      Xe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
      Xe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
      function Yl(e, t2) {
        var r = Xe.styles[t2];
        return r ? "\x1B[" + Xe.colors[r][0] + "m" + e + "\x1B[" + Xe.colors[r][1] + "m" : e;
      }
      function Xl(e, t2) {
        return e;
      }
      function ec(e) {
        var t2 = {};
        return e.forEach(function(r, n) {
          t2[r] = true;
        }), t2;
      }
      function Gr(e, t2, r) {
        if (e.customInspect && t2 && Kr(t2.inspect) && t2.inspect !== j.inspect && !(t2.constructor && t2.constructor.prototype === t2)) {
          var n = t2.inspect(r, e);
          return Hr(n) || (n = Gr(e, n, r)), n;
        }
        var o = tc(e, t2);
        if (o)
          return o;
        var i = Object.keys(t2), s = ec(i);
        if (e.showHidden && (i = Object.getOwnPropertyNames(t2)), ir(t2) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
          return so(t2);
        if (i.length === 0) {
          if (Kr(t2)) {
            var a = t2.name ? ": " + t2.name : "";
            return e.stylize("[Function" + a + "]", "special");
          }
          if (or(t2))
            return e.stylize(RegExp.prototype.toString.call(t2), "regexp");
          if (Jr(t2))
            return e.stylize(Date.prototype.toString.call(t2), "date");
          if (ir(t2))
            return so(t2);
        }
        var u = "", l = false, c = ["{", "}"];
        if (is(t2) && (l = true, c = ["[", "]"]), Kr(t2)) {
          var m = t2.name ? ": " + t2.name : "";
          u = " [Function" + m + "]";
        }
        if (or(t2) && (u = " " + RegExp.prototype.toString.call(t2)), Jr(t2) && (u = " " + Date.prototype.toUTCString.call(t2)), ir(t2) && (u = " " + so(t2)), i.length === 0 && (!l || t2.length == 0))
          return c[0] + u + c[1];
        if (r < 0)
          return or(t2) ? e.stylize(RegExp.prototype.toString.call(t2), "regexp") : e.stylize("[Object]", "special");
        e.seen.push(t2);
        var g;
        return l ? g = rc(e, t2, r, s, i) : g = i.map(function(w) {
          return uo(e, t2, r, s, w, l);
        }), e.seen.pop(), nc(g, u, c);
      }
      function tc(e, t2) {
        if (yt(t2))
          return e.stylize("undefined", "undefined");
        if (Hr(t2)) {
          var r = "'" + JSON.stringify(t2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return e.stylize(r, "string");
        }
        if (ss(t2))
          return e.stylize("" + t2, "number");
        if (fo(t2))
          return e.stylize("" + t2, "boolean");
        if (Wr(t2))
          return e.stylize("null", "null");
      }
      function so(e) {
        return "[" + Error.prototype.toString.call(e) + "]";
      }
      function rc(e, t2, r, n, o) {
        for (var i = [], s = 0, a = t2.length; s < a; ++s)
          as(t2, String(s)) ? i.push(uo(e, t2, r, n, String(s), true)) : i.push("");
        return o.forEach(function(u) {
          u.match(/^\d+$/) || i.push(uo(e, t2, r, n, u, true));
        }), i;
      }
      function uo(e, t2, r, n, o, i) {
        var s, a, u;
        if (u = Object.getOwnPropertyDescriptor(t2, o) || { value: t2[o] }, u.get ? u.set ? a = e.stylize("[Getter/Setter]", "special") : a = e.stylize("[Getter]", "special") : u.set && (a = e.stylize("[Setter]", "special")), as(n, o) || (s = "[" + o + "]"), a || (e.seen.indexOf(u.value) < 0 ? (Wr(r) ? a = Gr(e, u.value, null) : a = Gr(e, u.value, r - 1), a.indexOf(`
`) > -1 && (i ? a = a.split(`
`).map(function(l) {
          return "  " + l;
        }).join(`
`).slice(2) : a = `
` + a.split(`
`).map(function(l) {
          return "   " + l;
        }).join(`
`))) : a = e.stylize("[Circular]", "special")), yt(s)) {
          if (i && o.match(/^\d+$/))
            return a;
          s = JSON.stringify("" + o), s.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.slice(1, -1), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"));
        }
        return s + ": " + a;
      }
      function nc(e, t2, r) {
        var n = 0, o = e.reduce(function(i, s) {
          return n++, s.indexOf(`
`) >= 0 && n++, i + s.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        return o > 60 ? r[0] + (t2 === "" ? "" : t2 + `
 `) + " " + e.join(`,
  `) + " " + r[1] : r[0] + t2 + " " + e.join(", ") + " " + r[1];
      }
      j.types = Wl();
      function is(e) {
        return Array.isArray(e);
      }
      j.isArray = is;
      function fo(e) {
        return typeof e == "boolean";
      }
      j.isBoolean = fo;
      function Wr(e) {
        return e === null;
      }
      j.isNull = Wr;
      function oc(e) {
        return e == null;
      }
      j.isNullOrUndefined = oc;
      function ss(e) {
        return typeof e == "number";
      }
      j.isNumber = ss;
      function Hr(e) {
        return typeof e == "string";
      }
      j.isString = Hr;
      function ic(e) {
        return typeof e == "symbol";
      }
      j.isSymbol = ic;
      function yt(e) {
        return e === void 0;
      }
      j.isUndefined = yt;
      function or(e) {
        return Ft(e) && mo(e) === "[object RegExp]";
      }
      j.isRegExp = or;
      j.types.isRegExp = or;
      function Ft(e) {
        return typeof e == "object" && e !== null;
      }
      j.isObject = Ft;
      function Jr(e) {
        return Ft(e) && mo(e) === "[object Date]";
      }
      j.isDate = Jr;
      j.types.isDate = Jr;
      function ir(e) {
        return Ft(e) && (mo(e) === "[object Error]" || e instanceof Error);
      }
      j.isError = ir;
      j.types.isNativeError = ir;
      function Kr(e) {
        return typeof e == "function";
      }
      j.isFunction = Kr;
      function sc(e) {
        return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || typeof e > "u";
      }
      j.isPrimitive = sc;
      j.isBuffer = Hl();
      function mo(e) {
        return Object.prototype.toString.call(e);
      }
      function ao(e) {
        return e < 10 ? "0" + e.toString(10) : e.toString(10);
      }
      var ac = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      function uc() {
        var e = /* @__PURE__ */ new Date(), t2 = [ao(e.getHours()), ao(e.getMinutes()), ao(e.getSeconds())].join(":");
        return [e.getDate(), ac[e.getMonth()], t2].join(" ");
      }
      j.log = function() {
        console.log("%s - %s", uc(), j.format.apply(j, arguments));
      };
      j.inherits = zl();
      j._extend = function(e, t2) {
        if (!t2 || !Ft(t2))
          return e;
        for (var r = Object.keys(t2), n = r.length; n--; )
          e[r[n]] = t2[r[n]];
        return e;
      };
      function as(e, t2) {
        return Object.prototype.hasOwnProperty.call(e, t2);
      }
      var gt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
      j.promisify = function(e) {
        if (typeof e != "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (gt && e[gt]) {
          var t2 = e[gt];
          if (typeof t2 != "function")
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(t2, gt, { value: t2, enumerable: false, writable: false, configurable: true }), t2;
        }
        function t2() {
          for (var r, n, o = new Promise(function(a, u) {
            r = a, n = u;
          }), i = [], s = 0; s < arguments.length; s++)
            i.push(arguments[s]);
          i.push(function(a, u) {
            a ? n(a) : r(u);
          });
          try {
            e.apply(this, i);
          } catch (a) {
            n(a);
          }
          return o;
        }
        return Object.setPrototypeOf(t2, Object.getPrototypeOf(e)), gt && Object.defineProperty(t2, gt, { value: t2, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t2, ns(e));
      };
      j.promisify.custom = gt;
      function lc(e, t2) {
        if (!e) {
          var r = new Error("Promise was rejected with a falsy value");
          r.reason = e, e = r;
        }
        return t2(e);
      }
      function cc(e) {
        if (typeof e != "function")
          throw new TypeError('The "original" argument must be of type Function');
        function t2() {
          for (var r = [], n = 0; n < arguments.length; n++)
            r.push(arguments[n]);
          var o = r.pop();
          if (typeof o != "function")
            throw new TypeError("The last argument must be of type Function");
          var i = this, s = function() {
            return o.apply(i, arguments);
          };
          e.apply(this, r).then(function(a) {
            y.nextTick(s.bind(null, null, a));
          }, function(a) {
            y.nextTick(lc.bind(null, a, s));
          });
        }
        return Object.setPrototypeOf(t2, Object.getPrototypeOf(e)), Object.defineProperties(t2, ns(e)), t2;
      }
      j.callbackify = cc;
    });
    var ls = Z((og, us) => {
      "use strict";
      d();
      p();
      f();
      var It = 1e3, kt = It * 60, Dt = kt * 60, ht = Dt * 24, pc = ht * 7, fc = ht * 365.25;
      us.exports = function(e, t2) {
        t2 = t2 || {};
        var r = typeof e;
        if (r === "string" && e.length > 0)
          return dc(e);
        if (r === "number" && isFinite(e))
          return t2.long ? gc(e) : mc(e);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
      };
      function dc(e) {
        if (e = String(e), !(e.length > 100)) {
          var t2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
          if (t2) {
            var r = parseFloat(t2[1]), n = (t2[2] || "ms").toLowerCase();
            switch (n) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return r * fc;
              case "weeks":
              case "week":
              case "w":
                return r * pc;
              case "days":
              case "day":
              case "d":
                return r * ht;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return r * Dt;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return r * kt;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return r * It;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return r;
              default:
                return;
            }
          }
        }
      }
      function mc(e) {
        var t2 = Math.abs(e);
        return t2 >= ht ? Math.round(e / ht) + "d" : t2 >= Dt ? Math.round(e / Dt) + "h" : t2 >= kt ? Math.round(e / kt) + "m" : t2 >= It ? Math.round(e / It) + "s" : e + "ms";
      }
      function gc(e) {
        var t2 = Math.abs(e);
        return t2 >= ht ? zr(e, t2, ht, "day") : t2 >= Dt ? zr(e, t2, Dt, "hour") : t2 >= kt ? zr(e, t2, kt, "minute") : t2 >= It ? zr(e, t2, It, "second") : e + " ms";
      }
      function zr(e, t2, r, n) {
        var o = t2 >= r * 1.5;
        return Math.round(e / r) + " " + n + (o ? "s" : "");
      }
    });
    var yo = Z((ug, cs) => {
      "use strict";
      d();
      p();
      f();
      function yc(e) {
        r.debug = r, r.default = r, r.coerce = u, r.disable = i, r.enable = o, r.enabled = s, r.humanize = ls(), r.destroy = l, Object.keys(e).forEach((c) => {
          r[c] = e[c];
        }), r.names = [], r.skips = [], r.formatters = {};
        function t2(c) {
          let m = 0;
          for (let g = 0; g < c.length; g++)
            m = (m << 5) - m + c.charCodeAt(g), m |= 0;
          return r.colors[Math.abs(m) % r.colors.length];
        }
        r.selectColor = t2;
        function r(c) {
          let m, g = null, w, E;
          function b(...T) {
            if (!b.enabled)
              return;
            let S = b, R = Number(/* @__PURE__ */ new Date()), C = R - (m || R);
            S.diff = C, S.prev = m, S.curr = R, m = R, T[0] = r.coerce(T[0]), typeof T[0] != "string" && T.unshift("%O");
            let M = 0;
            T[0] = T[0].replace(/%([a-zA-Z%])/g, (L, Te) => {
              if (L === "%%")
                return "%";
              M++;
              let V = r.formatters[Te];
              if (typeof V == "function") {
                let H = T[M];
                L = V.call(S, H), T.splice(M, 1), M--;
              }
              return L;
            }), r.formatArgs.call(S, T), (S.log || r.log).apply(S, T);
          }
          return b.namespace = c, b.useColors = r.useColors(), b.color = r.selectColor(c), b.extend = n, b.destroy = r.destroy, Object.defineProperty(b, "enabled", { enumerable: true, configurable: false, get: () => g !== null ? g : (w !== r.namespaces && (w = r.namespaces, E = r.enabled(c)), E), set: (T) => {
            g = T;
          } }), typeof r.init == "function" && r.init(b), b;
        }
        function n(c, m) {
          let g = r(this.namespace + (typeof m == "undefined" ? ":" : m) + c);
          return g.log = this.log, g;
        }
        function o(c) {
          r.save(c), r.namespaces = c, r.names = [], r.skips = [];
          let m, g = (typeof c == "string" ? c : "").split(/[\s,]+/), w = g.length;
          for (m = 0; m < w; m++)
            g[m] && (c = g[m].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
        }
        function i() {
          let c = [...r.names.map(a), ...r.skips.map(a).map((m) => "-" + m)].join(",");
          return r.enable(""), c;
        }
        function s(c) {
          if (c[c.length - 1] === "*")
            return true;
          let m, g;
          for (m = 0, g = r.skips.length; m < g; m++)
            if (r.skips[m].test(c))
              return false;
          for (m = 0, g = r.names.length; m < g; m++)
            if (r.names[m].test(c))
              return true;
          return false;
        }
        function a(c) {
          return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function u(c) {
          return c instanceof Error ? c.stack || c.message : c;
        }
        function l() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        return r.enable(r.load()), r;
      }
      cs.exports = yc;
    });
    var ps = Z((Ae, Zr) => {
      "use strict";
      d();
      p();
      f();
      Ae.formatArgs = xc;
      Ae.save = bc;
      Ae.load = wc;
      Ae.useColors = hc;
      Ae.storage = Ec();
      Ae.destroy = (() => {
        let e = false;
        return () => {
          e || (e = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
        };
      })();
      Ae.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function hc() {
        return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function xc(e) {
        if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + Zr.exports.humanize(this.diff), !this.useColors)
          return;
        let t2 = "color: " + this.color;
        e.splice(1, 0, t2, "color: inherit");
        let r = 0, n = 0;
        e[0].replace(/%[a-zA-Z%]/g, (o) => {
          o !== "%%" && (r++, o === "%c" && (n = r));
        }), e.splice(n, 0, t2);
      }
      Ae.log = console.debug || console.log || (() => {
      });
      function bc(e) {
        try {
          e ? Ae.storage.setItem("debug", e) : Ae.storage.removeItem("debug");
        } catch (t2) {
        }
      }
      function wc() {
        let e;
        try {
          e = Ae.storage.getItem("debug");
        } catch (t2) {
        }
        return !e && typeof y != "undefined" && "env" in y && (e = y.env.DEBUG), e;
      }
      function Ec() {
        try {
          return localStorage;
        } catch (e) {
        }
      }
      Zr.exports = yo()(Ae);
      var { formatters: Pc } = Zr.exports;
      Pc.j = function(e) {
        try {
          return JSON.stringify(e);
        } catch (t2) {
          return "[UnexpectedJSONParseError]: " + t2.message;
        }
      };
    });
    var ho = Z((Yr) => {
      "use strict";
      d();
      p();
      f();
      Yr.isatty = function() {
        return false;
      };
      function vc() {
        throw new Error("tty.ReadStream is not implemented");
      }
      Yr.ReadStream = vc;
      function Ac() {
        throw new Error("tty.WriteStream is not implemented");
      }
      Yr.WriteStream = Ac;
    });
    var fs = Z(() => {
      "use strict";
      d();
      p();
      f();
    });
    var ms = Z((Ag, ds) => {
      "use strict";
      d();
      p();
      f();
      ds.exports = (e, t2 = y.argv) => {
        let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t2.indexOf(r + e), o = t2.indexOf("--");
        return n !== -1 && (o === -1 || n < o);
      };
    });
    var hs = Z((Sg, ys) => {
      "use strict";
      d();
      p();
      f();
      var Tc = fs(), gs = ho(), Me = ms(), { env: te } = y, et;
      Me("no-color") || Me("no-colors") || Me("color=false") || Me("color=never") ? et = 0 : (Me("color") || Me("colors") || Me("color=true") || Me("color=always")) && (et = 1);
      "FORCE_COLOR" in te && (te.FORCE_COLOR === "true" ? et = 1 : te.FORCE_COLOR === "false" ? et = 0 : et = te.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(te.FORCE_COLOR, 10), 3));
      function xo(e) {
        return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
      }
      function bo(e, t2) {
        if (et === 0)
          return 0;
        if (Me("color=16m") || Me("color=full") || Me("color=truecolor"))
          return 3;
        if (Me("color=256"))
          return 2;
        if (e && !t2 && et === void 0)
          return 0;
        let r = et || 0;
        if (te.TERM === "dumb")
          return r;
        if (y.platform === "win32") {
          let n = Tc.release().split(".");
          return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in te)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => n in te) || te.CI_NAME === "codeship" ? 1 : r;
        if ("TEAMCITY_VERSION" in te)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(te.TEAMCITY_VERSION) ? 1 : 0;
        if (te.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in te) {
          let n = parseInt((te.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (te.TERM_PROGRAM) {
            case "iTerm.app":
              return n >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(te.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(te.TERM) || "COLORTERM" in te ? 1 : r;
      }
      function Cc(e) {
        let t2 = bo(e, e && e.isTTY);
        return xo(t2);
      }
      ys.exports = { supportsColor: Cc, stdout: xo(bo(true, gs.isatty(1))), stderr: xo(bo(true, gs.isatty(2))) };
    });
    var bs = Z((ae, en) => {
      "use strict";
      d();
      p();
      f();
      var Mc = ho(), Xr = go();
      ae.init = Dc;
      ae.log = Fc;
      ae.formatArgs = Rc;
      ae.save = Ic;
      ae.load = kc;
      ae.useColors = Sc;
      ae.destroy = Xr.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      ae.colors = [6, 2, 3, 4, 5, 1];
      try {
        let e = hs();
        e && (e.stderr || e).level >= 2 && (ae.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
      } catch (e) {
      }
      ae.inspectOpts = Object.keys(y.env).filter((e) => /^debug_/i.test(e)).reduce((e, t2) => {
        let r = t2.substring(6).toLowerCase().replace(/_([a-z])/g, (o, i) => i.toUpperCase()), n = y.env[t2];
        return /^(yes|on|true|enabled)$/i.test(n) ? n = true : /^(no|off|false|disabled)$/i.test(n) ? n = false : n === "null" ? n = null : n = Number(n), e[r] = n, e;
      }, {});
      function Sc() {
        return "colors" in ae.inspectOpts ? !!ae.inspectOpts.colors : Mc.isatty(y.stderr.fd);
      }
      function Rc(e) {
        let { namespace: t2, useColors: r } = this;
        if (r) {
          let n = this.color, o = "\x1B[3" + (n < 8 ? n : "8;5;" + n), i = `  ${o};1m${t2} \x1B[0m`;
          e[0] = i + e[0].split(`
`).join(`
` + i), e.push(o + "m+" + en.exports.humanize(this.diff) + "\x1B[0m");
        } else
          e[0] = Oc() + t2 + " " + e[0];
      }
      function Oc() {
        return ae.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
      }
      function Fc(...e) {
        return y.stderr.write(Xr.format(...e) + `
`);
      }
      function Ic(e) {
        e ? y.env.DEBUG = e : delete y.env.DEBUG;
      }
      function kc() {
        return y.env.DEBUG;
      }
      function Dc(e) {
        e.inspectOpts = {};
        let t2 = Object.keys(ae.inspectOpts);
        for (let r = 0; r < t2.length; r++)
          e.inspectOpts[t2[r]] = ae.inspectOpts[t2[r]];
      }
      en.exports = yo()(ae);
      var { formatters: xs } = en.exports;
      xs.o = function(e) {
        return this.inspectOpts.colors = this.useColors, Xr.inspect(e, this.inspectOpts).split(`
`).map((t2) => t2.trim()).join(" ");
      };
      xs.O = function(e) {
        return this.inspectOpts.colors = this.useColors, Xr.inspect(e, this.inspectOpts);
      };
    });
    var Eo = Z((_g, wo) => {
      "use strict";
      d();
      p();
      f();
      typeof y == "undefined" || y.type === "renderer" || y.browser === true || y.__nwjs ? wo.exports = ps() : wo.exports = bs();
    });
    function Bc() {
      return false;
    }
    var jc;
    var Uc;
    var un;
    var Ao = Br(() => {
      "use strict";
      d();
      p();
      f();
      jc = {}, Uc = { existsSync: Bc, promises: jc }, un = Uc;
    });
    var To = Z((Py, Rs) => {
      "use strict";
      d();
      p();
      f();
      function De(e) {
        if (typeof e != "string")
          throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
      }
      function Ss(e, t2) {
        for (var r = "", n = 0, o = -1, i = 0, s, a = 0; a <= e.length; ++a) {
          if (a < e.length)
            s = e.charCodeAt(a);
          else {
            if (s === 47)
              break;
            s = 47;
          }
          if (s === 47) {
            if (!(o === a - 1 || i === 1))
              if (o !== a - 1 && i === 2) {
                if (r.length < 2 || n !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
                  if (r.length > 2) {
                    var u = r.lastIndexOf("/");
                    if (u !== r.length - 1) {
                      u === -1 ? (r = "", n = 0) : (r = r.slice(0, u), n = r.length - 1 - r.lastIndexOf("/")), o = a, i = 0;
                      continue;
                    }
                  } else if (r.length === 2 || r.length === 1) {
                    r = "", n = 0, o = a, i = 0;
                    continue;
                  }
                }
                t2 && (r.length > 0 ? r += "/.." : r = "..", n = 2);
              } else
                r.length > 0 ? r += "/" + e.slice(o + 1, a) : r = e.slice(o + 1, a), n = a - o - 1;
            o = a, i = 0;
          } else
            s === 46 && i !== -1 ? ++i : i = -1;
        }
        return r;
      }
      function $c(e, t2) {
        var r = t2.dir || t2.root, n = t2.base || (t2.name || "") + (t2.ext || "");
        return r ? r === t2.root ? r + n : r + e + n : n;
      }
      var Lt = { resolve: function() {
        for (var e = "", t2 = false, r, n = arguments.length - 1; n >= -1 && !t2; n--) {
          var o;
          n >= 0 ? o = arguments[n] : (r === void 0 && (r = y.cwd()), o = r), De(o), o.length !== 0 && (e = o + "/" + e, t2 = o.charCodeAt(0) === 47);
        }
        return e = Ss(e, !t2), t2 ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
      }, normalize: function(e) {
        if (De(e), e.length === 0)
          return ".";
        var t2 = e.charCodeAt(0) === 47, r = e.charCodeAt(e.length - 1) === 47;
        return e = Ss(e, !t2), e.length === 0 && !t2 && (e = "."), e.length > 0 && r && (e += "/"), t2 ? "/" + e : e;
      }, isAbsolute: function(e) {
        return De(e), e.length > 0 && e.charCodeAt(0) === 47;
      }, join: function() {
        if (arguments.length === 0)
          return ".";
        for (var e, t2 = 0; t2 < arguments.length; ++t2) {
          var r = arguments[t2];
          De(r), r.length > 0 && (e === void 0 ? e = r : e += "/" + r);
        }
        return e === void 0 ? "." : Lt.normalize(e);
      }, relative: function(e, t2) {
        if (De(e), De(t2), e === t2 || (e = Lt.resolve(e), t2 = Lt.resolve(t2), e === t2))
          return "";
        for (var r = 1; r < e.length && e.charCodeAt(r) === 47; ++r)
          ;
        for (var n = e.length, o = n - r, i = 1; i < t2.length && t2.charCodeAt(i) === 47; ++i)
          ;
        for (var s = t2.length, a = s - i, u = o < a ? o : a, l = -1, c = 0; c <= u; ++c) {
          if (c === u) {
            if (a > u) {
              if (t2.charCodeAt(i + c) === 47)
                return t2.slice(i + c + 1);
              if (c === 0)
                return t2.slice(i + c);
            } else
              o > u && (e.charCodeAt(r + c) === 47 ? l = c : c === 0 && (l = 0));
            break;
          }
          var m = e.charCodeAt(r + c), g = t2.charCodeAt(i + c);
          if (m !== g)
            break;
          m === 47 && (l = c);
        }
        var w = "";
        for (c = r + l + 1; c <= n; ++c)
          (c === n || e.charCodeAt(c) === 47) && (w.length === 0 ? w += ".." : w += "/..");
        return w.length > 0 ? w + t2.slice(i + l) : (i += l, t2.charCodeAt(i) === 47 && ++i, t2.slice(i));
      }, _makeLong: function(e) {
        return e;
      }, dirname: function(e) {
        if (De(e), e.length === 0)
          return ".";
        for (var t2 = e.charCodeAt(0), r = t2 === 47, n = -1, o = true, i = e.length - 1; i >= 1; --i)
          if (t2 = e.charCodeAt(i), t2 === 47) {
            if (!o) {
              n = i;
              break;
            }
          } else
            o = false;
        return n === -1 ? r ? "/" : "." : r && n === 1 ? "//" : e.slice(0, n);
      }, basename: function(e, t2) {
        if (t2 !== void 0 && typeof t2 != "string")
          throw new TypeError('"ext" argument must be a string');
        De(e);
        var r = 0, n = -1, o = true, i;
        if (t2 !== void 0 && t2.length > 0 && t2.length <= e.length) {
          if (t2.length === e.length && t2 === e)
            return "";
          var s = t2.length - 1, a = -1;
          for (i = e.length - 1; i >= 0; --i) {
            var u = e.charCodeAt(i);
            if (u === 47) {
              if (!o) {
                r = i + 1;
                break;
              }
            } else
              a === -1 && (o = false, a = i + 1), s >= 0 && (u === t2.charCodeAt(s) ? --s === -1 && (n = i) : (s = -1, n = a));
          }
          return r === n ? n = a : n === -1 && (n = e.length), e.slice(r, n);
        } else {
          for (i = e.length - 1; i >= 0; --i)
            if (e.charCodeAt(i) === 47) {
              if (!o) {
                r = i + 1;
                break;
              }
            } else
              n === -1 && (o = false, n = i + 1);
          return n === -1 ? "" : e.slice(r, n);
        }
      }, extname: function(e) {
        De(e);
        for (var t2 = -1, r = 0, n = -1, o = true, i = 0, s = e.length - 1; s >= 0; --s) {
          var a = e.charCodeAt(s);
          if (a === 47) {
            if (!o) {
              r = s + 1;
              break;
            }
            continue;
          }
          n === -1 && (o = false, n = s + 1), a === 46 ? t2 === -1 ? t2 = s : i !== 1 && (i = 1) : t2 !== -1 && (i = -1);
        }
        return t2 === -1 || n === -1 || i === 0 || i === 1 && t2 === n - 1 && t2 === r + 1 ? "" : e.slice(t2, n);
      }, format: function(e) {
        if (e === null || typeof e != "object")
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
        return $c("/", e);
      }, parse: function(e) {
        De(e);
        var t2 = { root: "", dir: "", base: "", ext: "", name: "" };
        if (e.length === 0)
          return t2;
        var r = e.charCodeAt(0), n = r === 47, o;
        n ? (t2.root = "/", o = 1) : o = 0;
        for (var i = -1, s = 0, a = -1, u = true, l = e.length - 1, c = 0; l >= o; --l) {
          if (r = e.charCodeAt(l), r === 47) {
            if (!u) {
              s = l + 1;
              break;
            }
            continue;
          }
          a === -1 && (u = false, a = l + 1), r === 46 ? i === -1 ? i = l : c !== 1 && (c = 1) : i !== -1 && (c = -1);
        }
        return i === -1 || a === -1 || c === 0 || c === 1 && i === a - 1 && i === s + 1 ? a !== -1 && (s === 0 && n ? t2.base = t2.name = e.slice(1, a) : t2.base = t2.name = e.slice(s, a)) : (s === 0 && n ? (t2.name = e.slice(1, i), t2.base = e.slice(1, a)) : (t2.name = e.slice(s, i), t2.base = e.slice(s, a)), t2.ext = e.slice(i, a)), s > 0 ? t2.dir = e.slice(0, s - 1) : n && (t2.dir = "/"), t2;
      }, sep: "/", delimiter: ":", win32: null, posix: null };
      Lt.posix = Lt;
      Rs.exports = Lt;
    });
    var Is = Z((Oy, Fs) => {
      "use strict";
      d();
      p();
      f();
      Fs.exports = (e) => {
        let t2 = e.match(/^[ \t]*(?=\S)/gm);
        return t2 ? t2.reduce((r, n) => Math.min(r, n.length), 1 / 0) : 0;
      };
    });
    var Ds = Z((Dy, ks) => {
      "use strict";
      d();
      p();
      f();
      var Vc = Is();
      ks.exports = (e) => {
        let t2 = Vc(e);
        if (t2 === 0)
          return e;
        let r = new RegExp(`^[ \\t]{${t2}}`, "gm");
        return e.replace(r, "");
      };
    });
    var Ns = Z((qy, So) => {
      "use strict";
      d();
      p();
      f();
      var Kc = Object.prototype.hasOwnProperty, me = "~";
      function ar() {
      }
      Object.create && (ar.prototype = /* @__PURE__ */ Object.create(null), new ar().__proto__ || (me = false));
      function Gc(e, t2, r) {
        this.fn = e, this.context = t2, this.once = r || false;
      }
      function _s(e, t2, r, n, o) {
        if (typeof r != "function")
          throw new TypeError("The listener must be a function");
        var i = new Gc(r, n || e, o), s = me ? me + t2 : t2;
        return e._events[s] ? e._events[s].fn ? e._events[s] = [e._events[s], i] : e._events[s].push(i) : (e._events[s] = i, e._eventsCount++), e;
      }
      function ln(e, t2) {
        --e._eventsCount === 0 ? e._events = new ar() : delete e._events[t2];
      }
      function le() {
        this._events = new ar(), this._eventsCount = 0;
      }
      le.prototype.eventNames = function() {
        var e = [], t2, r;
        if (this._eventsCount === 0)
          return e;
        for (r in t2 = this._events)
          Kc.call(t2, r) && e.push(me ? r.slice(1) : r);
        return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t2)) : e;
      };
      le.prototype.listeners = function(e) {
        var t2 = me ? me + e : e, r = this._events[t2];
        if (!r)
          return [];
        if (r.fn)
          return [r.fn];
        for (var n = 0, o = r.length, i = new Array(o); n < o; n++)
          i[n] = r[n].fn;
        return i;
      };
      le.prototype.listenerCount = function(e) {
        var t2 = me ? me + e : e, r = this._events[t2];
        return r ? r.fn ? 1 : r.length : 0;
      };
      le.prototype.emit = function(e, t2, r, n, o, i) {
        var s = me ? me + e : e;
        if (!this._events[s])
          return false;
        var a = this._events[s], u = arguments.length, l, c;
        if (a.fn) {
          switch (a.once && this.removeListener(e, a.fn, void 0, true), u) {
            case 1:
              return a.fn.call(a.context), true;
            case 2:
              return a.fn.call(a.context, t2), true;
            case 3:
              return a.fn.call(a.context, t2, r), true;
            case 4:
              return a.fn.call(a.context, t2, r, n), true;
            case 5:
              return a.fn.call(a.context, t2, r, n, o), true;
            case 6:
              return a.fn.call(a.context, t2, r, n, o, i), true;
          }
          for (c = 1, l = new Array(u - 1); c < u; c++)
            l[c - 1] = arguments[c];
          a.fn.apply(a.context, l);
        } else {
          var m = a.length, g;
          for (c = 0; c < m; c++)
            switch (a[c].once && this.removeListener(e, a[c].fn, void 0, true), u) {
              case 1:
                a[c].fn.call(a[c].context);
                break;
              case 2:
                a[c].fn.call(a[c].context, t2);
                break;
              case 3:
                a[c].fn.call(a[c].context, t2, r);
                break;
              case 4:
                a[c].fn.call(a[c].context, t2, r, n);
                break;
              default:
                if (!l)
                  for (g = 1, l = new Array(u - 1); g < u; g++)
                    l[g - 1] = arguments[g];
                a[c].fn.apply(a[c].context, l);
            }
        }
        return true;
      };
      le.prototype.on = function(e, t2, r) {
        return _s(this, e, t2, r, false);
      };
      le.prototype.once = function(e, t2, r) {
        return _s(this, e, t2, r, true);
      };
      le.prototype.removeListener = function(e, t2, r, n) {
        var o = me ? me + e : e;
        if (!this._events[o])
          return this;
        if (!t2)
          return ln(this, o), this;
        var i = this._events[o];
        if (i.fn)
          i.fn === t2 && (!n || i.once) && (!r || i.context === r) && ln(this, o);
        else {
          for (var s = 0, a = [], u = i.length; s < u; s++)
            (i[s].fn !== t2 || n && !i[s].once || r && i[s].context !== r) && a.push(i[s]);
          a.length ? this._events[o] = a.length === 1 ? a[0] : a : ln(this, o);
        }
        return this;
      };
      le.prototype.removeAllListeners = function(e) {
        var t2;
        return e ? (t2 = me ? me + e : e, this._events[t2] && ln(this, t2)) : (this._events = new ar(), this._eventsCount = 0), this;
      };
      le.prototype.off = le.prototype.removeListener;
      le.prototype.addListener = le.prototype.on;
      le.prefixed = me;
      le.EventEmitter = le;
      typeof So < "u" && (So.exports = le);
    });
    var Bs = Z((Jy, Ls) => {
      "use strict";
      d();
      p();
      f();
      Ls.exports = (e, t2 = 1, r) => {
        if (r = { indent: " ", includeEmptyLines: false, ...r }, typeof e != "string")
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
        if (typeof t2 != "number")
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t2}\``);
        if (typeof r.indent != "string")
          throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);
        if (t2 === 0)
          return e;
        let n = r.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return e.replace(n, r.indent.repeat(t2));
      };
    });
    var $s = Z((eh, Us) => {
      "use strict";
      d();
      p();
      f();
      Us.exports = ({ onlyFirst: e = false } = {}) => {
        let t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(t2, e ? void 0 : "g");
      };
    });
    var Vs = Z((oh, qs) => {
      "use strict";
      d();
      p();
      f();
      var zc = $s();
      qs.exports = (e) => typeof e == "string" ? e.replace(zc(), "") : e;
    });
    var Ws = Z(() => {
      "use strict";
      d();
      p();
      f();
    });
    var ui = Z((AM, uu) => {
      "use strict";
      d();
      p();
      f();
      uu.exports = function() {
        function e(t2, r, n, o, i) {
          return t2 < r || n < r ? t2 > n ? n + 1 : t2 + 1 : o === i ? r : r + 1;
        }
        return function(t2, r) {
          if (t2 === r)
            return 0;
          if (t2.length > r.length) {
            var n = t2;
            t2 = r, r = n;
          }
          for (var o = t2.length, i = r.length; o > 0 && t2.charCodeAt(o - 1) === r.charCodeAt(i - 1); )
            o--, i--;
          for (var s = 0; s < o && t2.charCodeAt(s) === r.charCodeAt(s); )
            s++;
          if (o -= s, i -= s, o === 0 || i < 3)
            return i;
          var a = 0, u, l, c, m, g, w, E, b, T, S, R, C, M = [];
          for (u = 0; u < o; u++)
            M.push(u + 1), M.push(t2.charCodeAt(s + u));
          for (var N = M.length - 1; a < i - 3; )
            for (T = r.charCodeAt(s + (l = a)), S = r.charCodeAt(s + (c = a + 1)), R = r.charCodeAt(s + (m = a + 2)), C = r.charCodeAt(s + (g = a + 3)), w = a += 4, u = 0; u < N; u += 2)
              E = M[u], b = M[u + 1], l = e(E, l, c, T, b), c = e(l, c, m, S, b), m = e(c, m, g, R, b), w = e(m, g, w, C, b), M[u] = w, g = m, m = c, c = l, l = E;
          for (; a < i; )
            for (T = r.charCodeAt(s + (l = a)), w = ++a, u = 0; u < N; u += 2)
              E = M[u], M[u] = w = e(E, l, w, T, M[u + 1]), l = E;
          return w;
        };
      }();
    });
    var Wd = {};
    rr(Wd, { DMMF: () => Ce, DMMFClass: () => $r, Debug: () => Po, Decimal: () => je, Extensions: () => ro, MetricsClient: () => Ut, NotFoundError: () => Ke, ObjectEnumValue: () => _e, PrismaClientInitializationError: () => re, PrismaClientKnownRequestError: () => ce, PrismaClientRustPanicError: () => Ge, PrismaClientUnknownRequestError: () => Se, PrismaClientValidationError: () => pe, Public: () => no, Sql: () => xe, Types: () => oo, defineDmmfProperty: () => Js, empty: () => zs, getPrismaClient: () => zu, itxClientDenyList: () => gi, join: () => Hs, makeStrictEnum: () => Zu, objectEnumNames: () => Yc, objectEnumValues: () => pn, raw: () => No, sqltag: () => Lo, warnEnvConflicts: () => void 0, warnOnce: () => lr });
    module.exports = pl(Wd);
    d();
    p();
    f();
    var ro = {};
    rr(ro, { defineExtension: () => Ki, getExtensionContext: () => Gi });
    d();
    p();
    f();
    d();
    p();
    f();
    function Ki(e) {
      return typeof e == "function" ? e : (t2) => t2.$extends(e);
    }
    d();
    p();
    f();
    function Gi(e) {
      return e;
    }
    var no = {};
    rr(no, { validator: () => Ji });
    d();
    p();
    f();
    d();
    p();
    f();
    function Ji(...e) {
      return (t2) => t2;
    }
    var oo = {};
    rr(oo, { Extensions: () => Qi, Public: () => Wi, Result: () => Hi, Utils: () => zi });
    d();
    p();
    f();
    var Qi = {};
    d();
    p();
    f();
    var Wi = {};
    d();
    p();
    f();
    var Hi = {};
    d();
    p();
    f();
    var zi = {};
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    var Ye = (e, t2) => {
      let r = {};
      for (let n of e) {
        let o = n[t2];
        r[o] = n;
      }
      return r;
    };
    function Zi(e) {
      return e.substring(0, 1).toLowerCase() + e.substring(1);
    }
    var $r = class {
      constructor(t2) {
        this.document = t2;
        this.compositeNames = new Set(this.datamodel.types.map((r) => r.name)), this.typeAndModelMap = this.buildTypeModelMap(), this.mappingsMap = this.buildMappingsMap(), this.outputTypeMap = this.buildMergedOutputTypeMap(), this.rootFieldMap = this.buildRootFieldMap(), this.inputTypesByName = this.buildInputTypesMap();
      }
      get datamodel() {
        return this.document.datamodel;
      }
      get mappings() {
        return this.document.mappings;
      }
      get schema() {
        return this.document.schema;
      }
      get inputObjectTypes() {
        return this.schema.inputObjectTypes;
      }
      get outputObjectTypes() {
        return this.schema.outputObjectTypes;
      }
      isComposite(t2) {
        return this.compositeNames.has(t2);
      }
      getOtherOperationNames() {
        return [Object.values(this.mappings.otherOperations.write), Object.values(this.mappings.otherOperations.read)].flat();
      }
      hasEnumInNamespace(t2, r) {
        var n;
        return ((n = this.schema.enumTypes[r]) == null ? void 0 : n.find((o) => o.name === t2)) !== void 0;
      }
      resolveInputObjectType(t2) {
        return this.inputTypesByName.get(io(t2.type, t2.namespace));
      }
      resolveOutputObjectType(t2) {
        var r;
        if (t2.location === "outputObjectTypes")
          return this.outputObjectTypes[(r = t2.namespace) != null ? r : "prisma"].find((n) => n.name === t2.type);
      }
      buildModelMap() {
        return Ye(this.datamodel.models, "name");
      }
      buildTypeMap() {
        return Ye(this.datamodel.types, "name");
      }
      buildTypeModelMap() {
        return { ...this.buildTypeMap(), ...this.buildModelMap() };
      }
      buildMappingsMap() {
        return Ye(this.mappings.modelOperations, "model");
      }
      buildMergedOutputTypeMap() {
        return { model: Ye(this.schema.outputObjectTypes.model, "name"), prisma: Ye(this.schema.outputObjectTypes.prisma, "name") };
      }
      buildRootFieldMap() {
        return { ...Ye(this.outputTypeMap.prisma.Query.fields, "name"), ...Ye(this.outputTypeMap.prisma.Mutation.fields, "name") };
      }
      buildInputTypesMap() {
        let t2 = /* @__PURE__ */ new Map();
        for (let r of this.inputObjectTypes.prisma)
          t2.set(io(r.name, "prisma"), r);
        if (!this.inputObjectTypes.model)
          return t2;
        for (let r of this.inputObjectTypes.model)
          t2.set(io(r.name, "model"), r);
        return t2;
      }
    };
    function io(e, t2) {
      return t2 ? `${t2}.${e}` : e;
    }
    d();
    p();
    f();
    d();
    p();
    f();
    var Ce;
    ((t2) => {
      let e;
      ((C) => (C.findUnique = "findUnique", C.findUniqueOrThrow = "findUniqueOrThrow", C.findFirst = "findFirst", C.findFirstOrThrow = "findFirstOrThrow", C.findMany = "findMany", C.create = "create", C.createMany = "createMany", C.update = "update", C.updateMany = "updateMany", C.upsert = "upsert", C.delete = "delete", C.deleteMany = "deleteMany", C.groupBy = "groupBy", C.count = "count", C.aggregate = "aggregate", C.findRaw = "findRaw", C.aggregateRaw = "aggregateRaw"))(e = t2.ModelAction || (t2.ModelAction = {}));
    })(Ce || (Ce = {}));
    d();
    p();
    f();
    var rn = ve(Eo());
    var _c = 100;
    var tn = [];
    var ws;
    var Es;
    typeof y != "undefined" && typeof ((ws = y.stderr) == null ? void 0 : ws.write) != "function" && (rn.default.log = (Es = console.debug) != null ? Es : console.log);
    function Nc(e) {
      let t2 = (0, rn.default)(e), r = Object.assign((...n) => (t2.log = r.log, n.length !== 0 && tn.push([e, ...n]), tn.length > _c && tn.shift(), t2("", ...n)), t2);
      return r;
    }
    var Po = Object.assign(Nc, rn.default);
    function Ps() {
      tn.length = 0;
    }
    var he = Po;
    d();
    p();
    f();
    var vo;
    var vs;
    var As;
    var Ts;
    var Cs = true;
    typeof y != "undefined" && ({ FORCE_COLOR: vo, NODE_DISABLE_COLORS: vs, NO_COLOR: As, TERM: Ts } = y.env || {}, Cs = y.stdout && y.stdout.isTTY);
    var Lc = { enabled: !vs && As == null && Ts !== "dumb" && (vo != null && vo !== "0" || Cs) };
    function G(e, t2) {
      let r = new RegExp(`\\x1b\\[${t2}m`, "g"), n = `\x1B[${e}m`, o = `\x1B[${t2}m`;
      return function(i) {
        return !Lc.enabled || i == null ? i : n + (~("" + i).indexOf(o) ? i.replace(r, o + n) : i) + o;
      };
    }
    var Vg = G(0, 0);
    var tt = G(1, 22);
    var nn = G(2, 22);
    var Kg = G(3, 23);
    var Ms = G(4, 24);
    var Gg = G(7, 27);
    var Jg = G(8, 28);
    var Qg = G(9, 29);
    var Wg = G(30, 39);
    var _t = G(31, 39);
    var on3 = G(32, 39);
    var sn = G(33, 39);
    var Nt = G(34, 39);
    var Hg = G(35, 39);
    var rt = G(36, 39);
    var zg = G(37, 39);
    var an = G(90, 39);
    var Zg = G(90, 39);
    var Yg = G(40, 49);
    var Xg = G(41, 49);
    var ey = G(42, 49);
    var ty = G(43, 49);
    var ry = G(44, 49);
    var ny = G(45, 49);
    var oy = G(46, 49);
    var iy = G(47, 49);
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    var Os = "library";
    function Co(e) {
      let t2 = qc();
      return t2 || ((e == null ? void 0 : e.config.engineType) === "library" ? "library" : (e == null ? void 0 : e.config.engineType) === "binary" ? "binary" : Os);
    }
    function qc() {
      let e = y.env.PRISMA_CLIENT_ENGINE_TYPE;
      return e === "library" ? "library" : e === "binary" ? "binary" : void 0;
    }
    d();
    p();
    f();
    var sr = ve(To());
    function Mo(e) {
      return sr.default.sep === sr.default.posix.sep ? e : e.split(sr.default.sep).join(sr.default.posix.sep);
    }
    var Bt = {};
    rr(Bt, { error: () => Wc, info: () => Qc, log: () => Jc, query: () => Hc, should: () => js, tags: () => ur, warn: () => Ro });
    d();
    p();
    f();
    var ur = { error: _t("prisma:error"), warn: sn("prisma:warn"), info: rt("prisma:info"), query: Nt("prisma:query") };
    var js = { warn: () => !y.env.PRISMA_DISABLE_WARNINGS };
    function Jc(...e) {
      console.log(...e);
    }
    function Ro(e, ...t2) {
      js.warn() && console.warn(`${ur.warn} ${e}`, ...t2);
    }
    function Qc(e, ...t2) {
      console.info(`${ur.info} ${e}`, ...t2);
    }
    function Wc(e, ...t2) {
      console.error(`${ur.error} ${e}`, ...t2);
    }
    function Hc(e, ...t2) {
      console.log(`${ur.query} ${e}`, ...t2);
    }
    d();
    p();
    f();
    function xt(e, t2) {
      throw new Error(t2);
    }
    d();
    p();
    f();
    function Oo(e, t2) {
      return Object.prototype.hasOwnProperty.call(e, t2);
    }
    d();
    p();
    f();
    var Fo = (e, t2) => e.reduce((r, n) => (r[t2(n)] = n, r), {});
    d();
    p();
    f();
    function jt(e, t2) {
      let r = {};
      for (let n of Object.keys(e))
        r[n] = t2(e[n], n);
      return r;
    }
    d();
    p();
    f();
    function Io(e, t2) {
      if (e.length === 0)
        return;
      let r = e[0];
      for (let n = 1; n < e.length; n++)
        t2(r, e[n]) < 0 && (r = e[n]);
      return r;
    }
    d();
    p();
    f();
    function k(e, t2) {
      Object.defineProperty(e, "name", { value: t2, configurable: true });
    }
    d();
    p();
    f();
    var Ks = /* @__PURE__ */ new Set();
    var lr = (e, t2, ...r) => {
      Ks.has(e) || (Ks.add(e), Ro(t2, ...r));
    };
    d();
    p();
    f();
    var ce = class extends Error {
      constructor(r, { code: n, clientVersion: o, meta: i, batchRequestIdx: s }) {
        super(r);
        this.name = "PrismaClientKnownRequestError", this.code = n, this.clientVersion = o, this.meta = i, Object.defineProperty(this, "batchRequestIdx", { value: s, enumerable: false, writable: true });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    k(ce, "PrismaClientKnownRequestError");
    var Ke = class extends ce {
      constructor(t2, r) {
        super(t2, { code: "P2025", clientVersion: r }), this.name = "NotFoundError";
      }
    };
    k(Ke, "NotFoundError");
    d();
    p();
    f();
    var re = class e extends Error {
      constructor(r, n, o) {
        super(r);
        this.name = "PrismaClientInitializationError", this.clientVersion = n, this.errorCode = o, Error.captureStackTrace(e);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    k(re, "PrismaClientInitializationError");
    d();
    p();
    f();
    var Ge = class extends Error {
      constructor(r, n) {
        super(r);
        this.name = "PrismaClientRustPanicError", this.clientVersion = n;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    k(Ge, "PrismaClientRustPanicError");
    d();
    p();
    f();
    var Se = class extends Error {
      constructor(r, { clientVersion: n, batchRequestIdx: o }) {
        super(r);
        this.name = "PrismaClientUnknownRequestError", this.clientVersion = n, Object.defineProperty(this, "batchRequestIdx", { value: o, writable: true, enumerable: false });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    k(Se, "PrismaClientUnknownRequestError");
    d();
    p();
    f();
    var pe = class extends Error {
      constructor(r, { clientVersion: n }) {
        super(r);
        this.name = "PrismaClientValidationError";
        this.clientVersion = n;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    k(pe, "PrismaClientValidationError");
    d();
    p();
    f();
    var Ut = class {
      constructor(t2) {
        this._engine = t2;
      }
      prometheus(t2) {
        return this._engine.metrics({ format: "prometheus", ...t2 });
      }
      json(t2) {
        return this._engine.metrics({ format: "json", ...t2 });
      }
    };
    d();
    p();
    f();
    d();
    p();
    f();
    function cr(e) {
      let t2;
      return { get() {
        return t2 || (t2 = { value: e() }), t2.value;
      } };
    }
    function Js(e, t2) {
      let r = cr(() => Zc(t2));
      Object.defineProperty(e, "dmmf", { get: () => r.get() });
    }
    function Zc(e) {
      return { datamodel: { models: ko(e.models), enums: ko(e.enums), types: ko(e.types) } };
    }
    function ko(e) {
      return Object.entries(e).map(([t2, r]) => ({ name: t2, ...r }));
    }
    d();
    p();
    f();
    var Yc = ["JsonNullValueInput", "NullableJsonNullValueInput", "JsonNullValueFilter"];
    var cn = Symbol();
    var Do = /* @__PURE__ */ new WeakMap();
    var _e = class {
      constructor(t2) {
        t2 === cn ? Do.set(this, `Prisma.${this._getName()}`) : Do.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return Do.get(this);
      }
    };
    var pr = class extends _e {
      _getNamespace() {
        return "NullTypes";
      }
    };
    var fr = class extends pr {
    };
    _o(fr, "DbNull");
    var dr = class extends pr {
    };
    _o(dr, "JsonNull");
    var mr = class extends pr {
    };
    _o(mr, "AnyNull");
    var pn = { classes: { DbNull: fr, JsonNull: dr, AnyNull: mr }, instances: { DbNull: new fr(cn), JsonNull: new dr(cn), AnyNull: new mr(cn) } };
    function _o(e, t2) {
      Object.defineProperty(e, "name", { value: t2, configurable: true });
    }
    d();
    p();
    f();
    d();
    p();
    f();
    var rp = ve(Eo(), 1);
    function fn(e) {
      return { ok: false, error: e, map() {
        return fn(e);
      }, flatMap() {
        return fn(e);
      } };
    }
    var Xc = class {
      constructor() {
        Ai(this, "registeredErrors", []);
      }
      consumeError(e) {
        return this.registeredErrors[e];
      }
      registerNewError(e) {
        let t2 = 0;
        for (; this.registeredErrors[t2] !== void 0; )
          t2++;
        return this.registeredErrors[t2] = { error: e }, t2;
      }
    };
    var Qs = (e) => {
      let t2 = new Xc(), r = nt(t2, e.startTransaction.bind(e));
      return { errorRegistry: t2, queryRaw: nt(t2, e.queryRaw.bind(e)), executeRaw: nt(t2, e.executeRaw.bind(e)), flavour: e.flavour, startTransaction: async (...n) => (await r(...n)).map((i) => ep(t2, i)), close: nt(t2, e.close.bind(e)) };
    };
    var ep = (e, t2) => ({ flavour: t2.flavour, options: t2.options, queryRaw: nt(e, t2.queryRaw.bind(t2)), executeRaw: nt(e, t2.executeRaw.bind(t2)), commit: nt(e, t2.commit.bind(t2)), rollback: nt(e, t2.rollback.bind(t2)), dispose: tp(e, t2.dispose.bind(t2)) });
    function nt(e, t2) {
      return async (...r) => {
        try {
          return await t2(...r);
        } catch (n) {
          let o = e.registerNewError(n);
          return fn({ kind: "GenericJs", id: o });
        }
      };
    }
    function tp(e, t2) {
      return (...r) => {
        try {
          return t2(...r);
        } catch (n) {
          let o = e.registerNewError(n);
          return fn({ kind: "GenericJs", id: o });
        }
      };
    }
    var O2 = ve(Ws());
    var Hu = ve(Ns());
    Ao();
    var Lr = ve(To());
    d();
    p();
    f();
    var xe = class e {
      constructor(t2, r) {
        if (t2.length - 1 !== r.length)
          throw t2.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t2.length} strings to have ${t2.length - 1} values`);
        let n = r.reduce((s, a) => s + (a instanceof e ? a.values.length : 1), 0);
        this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = t2[0];
        let o = 0, i = 0;
        for (; o < r.length; ) {
          let s = r[o++], a = t2[o];
          if (s instanceof e) {
            this.strings[i] += s.strings[0];
            let u = 0;
            for (; u < s.values.length; )
              this.values[i++] = s.values[u++], this.strings[i] = s.strings[u];
            this.strings[i] += a;
          } else
            this.values[i++] = s, this.strings[i] = a;
        }
      }
      get text() {
        let t2 = 1, r = this.strings[0];
        for (; t2 < this.strings.length; )
          r += `$${t2}${this.strings[t2++]}`;
        return r;
      }
      get sql() {
        let t2 = 1, r = this.strings[0];
        for (; t2 < this.strings.length; )
          r += `?${this.strings[t2++]}`;
        return r;
      }
      inspect() {
        return { text: this.text, sql: this.sql, values: this.values };
      }
    };
    function Hs(e, t2 = ",", r = "", n = "") {
      if (e.length === 0)
        throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      return new xe([r, ...Array(e.length - 1).fill(t2), n], e);
    }
    function No(e) {
      return new xe([e], []);
    }
    var zs = No("");
    function Lo(e, ...t2) {
      return new xe(e, t2);
    }
    d();
    p();
    f();
    d();
    p();
    f();
    function gr(e) {
      return { getKeys() {
        return Object.keys(e);
      }, getPropertyValue(t2) {
        return e[t2];
      } };
    }
    d();
    p();
    f();
    function ge(e, t2) {
      return { getKeys() {
        return [e];
      }, getPropertyValue() {
        return t2();
      } };
    }
    d();
    p();
    f();
    d();
    p();
    f();
    var Ne = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      get(t2) {
        var r;
        return (r = this._map.get(t2)) == null ? void 0 : r.value;
      }
      set(t2, r) {
        this._map.set(t2, { value: r });
      }
      getOrCreate(t2, r) {
        let n = this._map.get(t2);
        if (n)
          return n.value;
        let o = r();
        return this.set(t2, o), o;
      }
    };
    function bt(e) {
      let t2 = new Ne();
      return { getKeys() {
        return e.getKeys();
      }, getPropertyValue(r) {
        return t2.getOrCreate(r, () => e.getPropertyValue(r));
      }, getPropertyDescriptor(r) {
        var n;
        return (n = e.getPropertyDescriptor) == null ? void 0 : n.call(e, r);
      } };
    }
    d();
    p();
    f();
    var Xs = ve(go());
    d();
    p();
    f();
    var dn = { enumerable: true, configurable: true, writable: true };
    function mn(e) {
      let t2 = new Set(e);
      return { getOwnPropertyDescriptor: () => dn, has: (r, n) => t2.has(n), set: (r, n, o) => t2.add(n) && Reflect.set(r, n, o), ownKeys: () => [...t2] };
    }
    var Zs = Symbol.for("nodejs.util.inspect.custom");
    function Le(e, t2) {
      let r = np(t2), n = /* @__PURE__ */ new Set(), o = new Proxy(e, { get(i, s) {
        if (n.has(s))
          return i[s];
        let a = r.get(s);
        return a ? a.getPropertyValue(s) : i[s];
      }, has(i, s) {
        var u, l;
        if (n.has(s))
          return true;
        let a = r.get(s);
        return a ? (l = (u = a.has) == null ? void 0 : u.call(a, s)) != null ? l : true : Reflect.has(i, s);
      }, ownKeys(i) {
        let s = Ys(Reflect.ownKeys(i), r), a = Ys(Array.from(r.keys()), r);
        return [.../* @__PURE__ */ new Set([...s, ...a, ...n])];
      }, set(i, s, a) {
        var l, c;
        let u = r.get(s);
        return ((c = (l = u == null ? void 0 : u.getPropertyDescriptor) == null ? void 0 : l.call(u, s)) == null ? void 0 : c.writable) === false ? false : (n.add(s), Reflect.set(i, s, a));
      }, getOwnPropertyDescriptor(i, s) {
        let a = Reflect.getOwnPropertyDescriptor(i, s);
        if (a && !a.configurable)
          return a;
        let u = r.get(s);
        return u ? u.getPropertyDescriptor ? { ...dn, ...u == null ? void 0 : u.getPropertyDescriptor(s) } : dn : a;
      }, defineProperty(i, s, a) {
        return n.add(s), Reflect.defineProperty(i, s, a);
      } });
      return o[Zs] = function(i, s, a = Xs.inspect) {
        let u = { ...this };
        return delete u[Zs], a(u, s);
      }, o;
    }
    function np(e) {
      let t2 = /* @__PURE__ */ new Map();
      for (let r of e) {
        let n = r.getKeys();
        for (let o of n)
          t2.set(o, r);
      }
      return t2;
    }
    function Ys(e, t2) {
      return e.filter((r) => {
        var o, i;
        let n = t2.get(r);
        return (i = (o = n == null ? void 0 : n.has) == null ? void 0 : o.call(n, r)) != null ? i : true;
      });
    }
    d();
    p();
    f();
    function yr(e) {
      return { getKeys() {
        return e;
      }, has() {
        return false;
      }, getPropertyValue() {
      } };
    }
    d();
    p();
    f();
    d();
    p();
    f();
    var $t = class {
      constructor(t2 = 0, r) {
        this.context = r;
        this.lines = [];
        this.currentLine = "";
        this.currentIndent = 0;
        this.currentIndent = t2;
      }
      write(t2) {
        return typeof t2 == "string" ? this.currentLine += t2 : t2.write(this), this;
      }
      writeJoined(t2, r) {
        let n = r.length - 1;
        for (let o = 0; o < r.length; o++)
          this.write(r[o]), o !== n && this.write(t2);
        return this;
      }
      writeLine(t2) {
        return this.write(t2).newLine();
      }
      newLine() {
        this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = void 0;
        let t2 = this.afterNextNewLineCallback;
        return this.afterNextNewLineCallback = void 0, t2 == null || t2(), this;
      }
      withIndent(t2) {
        return this.indent(), t2(this), this.unindent(), this;
      }
      afterNextNewline(t2) {
        return this.afterNextNewLineCallback = t2, this;
      }
      indent() {
        return this.currentIndent++, this;
      }
      unindent() {
        return this.currentIndent > 0 && this.currentIndent--, this;
      }
      addMarginSymbol(t2) {
        return this.marginSymbol = t2, this;
      }
      toString() {
        return this.lines.concat(this.indentedCurrentLine()).join(`
`);
      }
      getCurrentLineLength() {
        return this.currentLine.length;
      }
      indentedCurrentLine() {
        let t2 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
        return this.marginSymbol ? this.marginSymbol + t2.slice(1) : t2;
      }
    };
    d();
    p();
    f();
    d();
    p();
    f();
    function qt(e) {
      return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
    }
    function gn(e) {
      return e.toString() !== "Invalid Date";
    }
    d();
    p();
    f();
    d();
    p();
    f();
    var Vt = 9e15;
    var at = 1e9;
    var Bo = "0123456789abcdef";
    var hn = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var xn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var jo = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -Vt, maxE: Vt, crypto: false };
    var na;
    var Je;
    var D = true;
    var wn = "[DecimalError] ";
    var st = wn + "Invalid argument: ";
    var oa = wn + "Precision limit exceeded";
    var ia = wn + "crypto unavailable";
    var sa = "[object Decimal]";
    var fe = Math.floor;
    var X = Math.pow;
    var op = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var ip = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var sp = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var aa = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var Oe = 1e7;
    var I = 7;
    var ap = 9007199254740991;
    var up = hn.length - 1;
    var Uo = xn.length - 1;
    var v = { toStringTag: sa };
    v.absoluteValue = v.abs = function() {
      var e = new this.constructor(this);
      return e.s < 0 && (e.s = 1), F(e);
    };
    v.ceil = function() {
      return F(new this.constructor(this), this.e + 1, 2);
    };
    v.clampedTo = v.clamp = function(e, t2) {
      var r, n = this, o = n.constructor;
      if (e = new o(e), t2 = new o(t2), !e.s || !t2.s)
        return new o(NaN);
      if (e.gt(t2))
        throw Error(st + t2);
      return r = n.cmp(e), r < 0 ? e : n.cmp(t2) > 0 ? t2 : new o(n);
    };
    v.comparedTo = v.cmp = function(e) {
      var t2, r, n, o, i = this, s = i.d, a = (e = new i.constructor(e)).d, u = i.s, l = e.s;
      if (!s || !a)
        return !u || !l ? NaN : u !== l ? u : s === a ? 0 : !s ^ u < 0 ? 1 : -1;
      if (!s[0] || !a[0])
        return s[0] ? u : a[0] ? -l : 0;
      if (u !== l)
        return u;
      if (i.e !== e.e)
        return i.e > e.e ^ u < 0 ? 1 : -1;
      for (n = s.length, o = a.length, t2 = 0, r = n < o ? n : o; t2 < r; ++t2)
        if (s[t2] !== a[t2])
          return s[t2] > a[t2] ^ u < 0 ? 1 : -1;
      return n === o ? 0 : n > o ^ u < 0 ? 1 : -1;
    };
    v.cosine = v.cos = function() {
      var e, t2, r = this, n = r.constructor;
      return r.d ? r.d[0] ? (e = n.precision, t2 = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + I, n.rounding = 1, r = lp(n, fa(n, r)), n.precision = e, n.rounding = t2, F(Je == 2 || Je == 3 ? r.neg() : r, e, t2, true)) : new n(1) : new n(NaN);
    };
    v.cubeRoot = v.cbrt = function() {
      var e, t2, r, n, o, i, s, a, u, l, c = this, m = c.constructor;
      if (!c.isFinite() || c.isZero())
        return new m(c);
      for (D = false, i = c.s * X(c.s * c, 1 / 3), !i || Math.abs(i) == 1 / 0 ? (r = ue(c.d), e = c.e, (i = (e - r.length + 1) % 3) && (r += i == 1 || i == -2 ? "0" : "00"), i = X(r, 1 / 3), e = fe((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), i == 1 / 0 ? r = "5e" + e : (r = i.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new m(r), n.s = c.s) : n = new m(i.toString()), s = (e = m.precision) + 3; ; )
        if (a = n, u = a.times(a).times(a), l = u.plus(c), n = K(l.plus(c).times(a), l.plus(u), s + 2, 1), ue(a.d).slice(0, s) === (r = ue(n.d)).slice(0, s))
          if (r = r.slice(s - 3, s + 1), r == "9999" || !o && r == "4999") {
            if (!o && (F(a, e + 1, 0), a.times(a).times(a).eq(c))) {
              n = a;
              break;
            }
            s += 4, o = 1;
          } else {
            (!+r || !+r.slice(1) && r.charAt(0) == "5") && (F(n, e + 1, 1), t2 = !n.times(n).times(n).eq(c));
            break;
          }
      return D = true, F(n, e, m.rounding, t2);
    };
    v.decimalPlaces = v.dp = function() {
      var e, t2 = this.d, r = NaN;
      if (t2) {
        if (e = t2.length - 1, r = (e - fe(this.e / I)) * I, e = t2[e], e)
          for (; e % 10 == 0; e /= 10)
            r--;
        r < 0 && (r = 0);
      }
      return r;
    };
    v.dividedBy = v.div = function(e) {
      return K(this, new this.constructor(e));
    };
    v.dividedToIntegerBy = v.divToInt = function(e) {
      var t2 = this, r = t2.constructor;
      return F(K(t2, new r(e), 0, 1, 1), r.precision, r.rounding);
    };
    v.equals = v.eq = function(e) {
      return this.cmp(e) === 0;
    };
    v.floor = function() {
      return F(new this.constructor(this), this.e + 1, 3);
    };
    v.greaterThan = v.gt = function(e) {
      return this.cmp(e) > 0;
    };
    v.greaterThanOrEqualTo = v.gte = function(e) {
      var t2 = this.cmp(e);
      return t2 == 1 || t2 === 0;
    };
    v.hyperbolicCosine = v.cosh = function() {
      var e, t2, r, n, o, i = this, s = i.constructor, a = new s(1);
      if (!i.isFinite())
        return new s(i.s ? 1 / 0 : NaN);
      if (i.isZero())
        return a;
      r = s.precision, n = s.rounding, s.precision = r + Math.max(i.e, i.sd()) + 4, s.rounding = 1, o = i.d.length, o < 32 ? (e = Math.ceil(o / 3), t2 = (1 / Pn(4, e)).toString()) : (e = 16, t2 = "2.3283064365386962890625e-10"), i = Kt(s, 1, i.times(t2), new s(1), true);
      for (var u, l = e, c = new s(8); l--; )
        u = i.times(i), i = a.minus(u.times(c.minus(u.times(c))));
      return F(i, s.precision = r, s.rounding = n, true);
    };
    v.hyperbolicSine = v.sinh = function() {
      var e, t2, r, n, o = this, i = o.constructor;
      if (!o.isFinite() || o.isZero())
        return new i(o);
      if (t2 = i.precision, r = i.rounding, i.precision = t2 + Math.max(o.e, o.sd()) + 4, i.rounding = 1, n = o.d.length, n < 3)
        o = Kt(i, 2, o, o, true);
      else {
        e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, o = o.times(1 / Pn(5, e)), o = Kt(i, 2, o, o, true);
        for (var s, a = new i(5), u = new i(16), l = new i(20); e--; )
          s = o.times(o), o = o.times(a.plus(s.times(u.times(s).plus(l))));
      }
      return i.precision = t2, i.rounding = r, F(o, t2, r, true);
    };
    v.hyperbolicTangent = v.tanh = function() {
      var e, t2, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t2 = n.rounding, n.precision = e + 7, n.rounding = 1, K(r.sinh(), r.cosh(), n.precision = e, n.rounding = t2)) : new n(r.s);
    };
    v.inverseCosine = v.acos = function() {
      var e, t2 = this, r = t2.constructor, n = t2.abs().cmp(1), o = r.precision, i = r.rounding;
      return n !== -1 ? n === 0 ? t2.isNeg() ? Re(r, o, i) : new r(0) : new r(NaN) : t2.isZero() ? Re(r, o + 4, i).times(0.5) : (r.precision = o + 6, r.rounding = 1, t2 = t2.asin(), e = Re(r, o + 4, i).times(0.5), r.precision = o, r.rounding = i, e.minus(t2));
    };
    v.inverseHyperbolicCosine = v.acosh = function() {
      var e, t2, r = this, n = r.constructor;
      return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t2 = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, D = false, r = r.times(r).minus(1).sqrt().plus(r), D = true, n.precision = e, n.rounding = t2, r.ln()) : new n(r);
    };
    v.inverseHyperbolicSine = v.asinh = function() {
      var e, t2, r = this, n = r.constructor;
      return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t2 = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, D = false, r = r.times(r).plus(1).sqrt().plus(r), D = true, n.precision = e, n.rounding = t2, r.ln());
    };
    v.inverseHyperbolicTangent = v.atanh = function() {
      var e, t2, r, n, o = this, i = o.constructor;
      return o.isFinite() ? o.e >= 0 ? new i(o.abs().eq(1) ? o.s / 0 : o.isZero() ? o : NaN) : (e = i.precision, t2 = i.rounding, n = o.sd(), Math.max(n, e) < 2 * -o.e - 1 ? F(new i(o), e, t2, true) : (i.precision = r = n - o.e, o = K(o.plus(1), new i(1).minus(o), r + e, 1), i.precision = e + 4, i.rounding = 1, o = o.ln(), i.precision = e, i.rounding = t2, o.times(0.5))) : new i(NaN);
    };
    v.inverseSine = v.asin = function() {
      var e, t2, r, n, o = this, i = o.constructor;
      return o.isZero() ? new i(o) : (t2 = o.abs().cmp(1), r = i.precision, n = i.rounding, t2 !== -1 ? t2 === 0 ? (e = Re(i, r + 4, n).times(0.5), e.s = o.s, e) : new i(NaN) : (i.precision = r + 6, i.rounding = 1, o = o.div(new i(1).minus(o.times(o)).sqrt().plus(1)).atan(), i.precision = r, i.rounding = n, o.times(2)));
    };
    v.inverseTangent = v.atan = function() {
      var e, t2, r, n, o, i, s, a, u, l = this, c = l.constructor, m = c.precision, g = c.rounding;
      if (l.isFinite()) {
        if (l.isZero())
          return new c(l);
        if (l.abs().eq(1) && m + 4 <= Uo)
          return s = Re(c, m + 4, g).times(0.25), s.s = l.s, s;
      } else {
        if (!l.s)
          return new c(NaN);
        if (m + 4 <= Uo)
          return s = Re(c, m + 4, g).times(0.5), s.s = l.s, s;
      }
      for (c.precision = a = m + 10, c.rounding = 1, r = Math.min(28, a / I + 2 | 0), e = r; e; --e)
        l = l.div(l.times(l).plus(1).sqrt().plus(1));
      for (D = false, t2 = Math.ceil(a / I), n = 1, u = l.times(l), s = new c(l), o = l; e !== -1; )
        if (o = o.times(u), i = s.minus(o.div(n += 2)), o = o.times(u), s = i.plus(o.div(n += 2)), s.d[t2] !== void 0)
          for (e = t2; s.d[e] === i.d[e] && e--; )
            ;
      return r && (s = s.times(2 << r - 1)), D = true, F(s, c.precision = m, c.rounding = g, true);
    };
    v.isFinite = function() {
      return !!this.d;
    };
    v.isInteger = v.isInt = function() {
      return !!this.d && fe(this.e / I) > this.d.length - 2;
    };
    v.isNaN = function() {
      return !this.s;
    };
    v.isNegative = v.isNeg = function() {
      return this.s < 0;
    };
    v.isPositive = v.isPos = function() {
      return this.s > 0;
    };
    v.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    v.lessThan = v.lt = function(e) {
      return this.cmp(e) < 0;
    };
    v.lessThanOrEqualTo = v.lte = function(e) {
      return this.cmp(e) < 1;
    };
    v.logarithm = v.log = function(e) {
      var t2, r, n, o, i, s, a, u, l = this, c = l.constructor, m = c.precision, g = c.rounding, w = 5;
      if (e == null)
        e = new c(10), t2 = true;
      else {
        if (e = new c(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1))
          return new c(NaN);
        t2 = e.eq(10);
      }
      if (r = l.d, l.s < 0 || !r || !r[0] || l.eq(1))
        return new c(r && !r[0] ? -1 / 0 : l.s != 1 ? NaN : r ? 0 : 1 / 0);
      if (t2)
        if (r.length > 1)
          i = true;
        else {
          for (o = r[0]; o % 10 === 0; )
            o /= 10;
          i = o !== 1;
        }
      if (D = false, a = m + w, s = it(l, a), n = t2 ? bn(c, a + 10) : it(e, a), u = K(s, n, a, 1), hr(u.d, o = m, g))
        do
          if (a += 10, s = it(l, a), n = t2 ? bn(c, a + 10) : it(e, a), u = K(s, n, a, 1), !i) {
            +ue(u.d).slice(o + 1, o + 15) + 1 == 1e14 && (u = F(u, m + 1, 0));
            break;
          }
        while (hr(u.d, o += 10, g));
      return D = true, F(u, m, g);
    };
    v.minus = v.sub = function(e) {
      var t2, r, n, o, i, s, a, u, l, c, m, g, w = this, E = w.constructor;
      if (e = new E(e), !w.d || !e.d)
        return !w.s || !e.s ? e = new E(NaN) : w.d ? e.s = -e.s : e = new E(e.d || w.s !== e.s ? w : NaN), e;
      if (w.s != e.s)
        return e.s = -e.s, w.plus(e);
      if (l = w.d, g = e.d, a = E.precision, u = E.rounding, !l[0] || !g[0]) {
        if (g[0])
          e.s = -e.s;
        else if (l[0])
          e = new E(w);
        else
          return new E(u === 3 ? -0 : 0);
        return D ? F(e, a, u) : e;
      }
      if (r = fe(e.e / I), c = fe(w.e / I), l = l.slice(), i = c - r, i) {
        for (m = i < 0, m ? (t2 = l, i = -i, s = g.length) : (t2 = g, r = c, s = l.length), n = Math.max(Math.ceil(a / I), s) + 2, i > n && (i = n, t2.length = 1), t2.reverse(), n = i; n--; )
          t2.push(0);
        t2.reverse();
      } else {
        for (n = l.length, s = g.length, m = n < s, m && (s = n), n = 0; n < s; n++)
          if (l[n] != g[n]) {
            m = l[n] < g[n];
            break;
          }
        i = 0;
      }
      for (m && (t2 = l, l = g, g = t2, e.s = -e.s), s = l.length, n = g.length - s; n > 0; --n)
        l[s++] = 0;
      for (n = g.length; n > i; ) {
        if (l[--n] < g[n]) {
          for (o = n; o && l[--o] === 0; )
            l[o] = Oe - 1;
          --l[o], l[n] += Oe;
        }
        l[n] -= g[n];
      }
      for (; l[--s] === 0; )
        l.pop();
      for (; l[0] === 0; l.shift())
        --r;
      return l[0] ? (e.d = l, e.e = En(l, r), D ? F(e, a, u) : e) : new E(u === 3 ? -0 : 0);
    };
    v.modulo = v.mod = function(e) {
      var t2, r = this, n = r.constructor;
      return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? F(new n(r), n.precision, n.rounding) : (D = false, n.modulo == 9 ? (t2 = K(r, e.abs(), 0, 3, 1), t2.s *= e.s) : t2 = K(r, e, 0, n.modulo, 1), t2 = t2.times(e), D = true, r.minus(t2));
    };
    v.naturalExponential = v.exp = function() {
      return $o(this);
    };
    v.naturalLogarithm = v.ln = function() {
      return it(this);
    };
    v.negated = v.neg = function() {
      var e = new this.constructor(this);
      return e.s = -e.s, F(e);
    };
    v.plus = v.add = function(e) {
      var t2, r, n, o, i, s, a, u, l, c, m = this, g = m.constructor;
      if (e = new g(e), !m.d || !e.d)
        return !m.s || !e.s ? e = new g(NaN) : m.d || (e = new g(e.d || m.s === e.s ? m : NaN)), e;
      if (m.s != e.s)
        return e.s = -e.s, m.minus(e);
      if (l = m.d, c = e.d, a = g.precision, u = g.rounding, !l[0] || !c[0])
        return c[0] || (e = new g(m)), D ? F(e, a, u) : e;
      if (i = fe(m.e / I), n = fe(e.e / I), l = l.slice(), o = i - n, o) {
        for (o < 0 ? (r = l, o = -o, s = c.length) : (r = c, n = i, s = l.length), i = Math.ceil(a / I), s = i > s ? i + 1 : s + 1, o > s && (o = s, r.length = 1), r.reverse(); o--; )
          r.push(0);
        r.reverse();
      }
      for (s = l.length, o = c.length, s - o < 0 && (o = s, r = c, c = l, l = r), t2 = 0; o; )
        t2 = (l[--o] = l[o] + c[o] + t2) / Oe | 0, l[o] %= Oe;
      for (t2 && (l.unshift(t2), ++n), s = l.length; l[--s] == 0; )
        l.pop();
      return e.d = l, e.e = En(l, n), D ? F(e, a, u) : e;
    };
    v.precision = v.sd = function(e) {
      var t2, r = this;
      if (e !== void 0 && e !== !!e && e !== 1 && e !== 0)
        throw Error(st + e);
      return r.d ? (t2 = ua(r.d), e && r.e + 1 > t2 && (t2 = r.e + 1)) : t2 = NaN, t2;
    };
    v.round = function() {
      var e = this, t2 = e.constructor;
      return F(new t2(e), e.e + 1, t2.rounding);
    };
    v.sine = v.sin = function() {
      var e, t2, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t2 = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + I, n.rounding = 1, r = pp(n, fa(n, r)), n.precision = e, n.rounding = t2, F(Je > 2 ? r.neg() : r, e, t2, true)) : new n(NaN);
    };
    v.squareRoot = v.sqrt = function() {
      var e, t2, r, n, o, i, s = this, a = s.d, u = s.e, l = s.s, c = s.constructor;
      if (l !== 1 || !a || !a[0])
        return new c(!l || l < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
      for (D = false, l = Math.sqrt(+s), l == 0 || l == 1 / 0 ? (t2 = ue(a), (t2.length + u) % 2 == 0 && (t2 += "0"), l = Math.sqrt(t2), u = fe((u + 1) / 2) - (u < 0 || u % 2), l == 1 / 0 ? t2 = "5e" + u : (t2 = l.toExponential(), t2 = t2.slice(0, t2.indexOf("e") + 1) + u), n = new c(t2)) : n = new c(l.toString()), r = (u = c.precision) + 3; ; )
        if (i = n, n = i.plus(K(s, i, r + 2, 1)).times(0.5), ue(i.d).slice(0, r) === (t2 = ue(n.d)).slice(0, r))
          if (t2 = t2.slice(r - 3, r + 1), t2 == "9999" || !o && t2 == "4999") {
            if (!o && (F(i, u + 1, 0), i.times(i).eq(s))) {
              n = i;
              break;
            }
            r += 4, o = 1;
          } else {
            (!+t2 || !+t2.slice(1) && t2.charAt(0) == "5") && (F(n, u + 1, 1), e = !n.times(n).eq(s));
            break;
          }
      return D = true, F(n, u, c.rounding, e);
    };
    v.tangent = v.tan = function() {
      var e, t2, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t2 = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = K(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t2, F(Je == 2 || Je == 4 ? r.neg() : r, e, t2, true)) : new n(NaN);
    };
    v.times = v.mul = function(e) {
      var t2, r, n, o, i, s, a, u, l, c = this, m = c.constructor, g = c.d, w = (e = new m(e)).d;
      if (e.s *= c.s, !g || !g[0] || !w || !w[0])
        return new m(!e.s || g && !g[0] && !w || w && !w[0] && !g ? NaN : !g || !w ? e.s / 0 : e.s * 0);
      for (r = fe(c.e / I) + fe(e.e / I), u = g.length, l = w.length, u < l && (i = g, g = w, w = i, s = u, u = l, l = s), i = [], s = u + l, n = s; n--; )
        i.push(0);
      for (n = l; --n >= 0; ) {
        for (t2 = 0, o = u + n; o > n; )
          a = i[o] + w[n] * g[o - n - 1] + t2, i[o--] = a % Oe | 0, t2 = a / Oe | 0;
        i[o] = (i[o] + t2) % Oe | 0;
      }
      for (; !i[--s]; )
        i.pop();
      return t2 ? ++r : i.shift(), e.d = i, e.e = En(i, r), D ? F(e, m.precision, m.rounding) : e;
    };
    v.toBinary = function(e, t2) {
      return Vo(this, 2, e, t2);
    };
    v.toDecimalPlaces = v.toDP = function(e, t2) {
      var r = this, n = r.constructor;
      return r = new n(r), e === void 0 ? r : (be(e, 0, at), t2 === void 0 ? t2 = n.rounding : be(t2, 0, 8), F(r, e + r.e + 1, t2));
    };
    v.toExponential = function(e, t2) {
      var r, n = this, o = n.constructor;
      return e === void 0 ? r = Be(n, true) : (be(e, 0, at), t2 === void 0 ? t2 = o.rounding : be(t2, 0, 8), n = F(new o(n), e + 1, t2), r = Be(n, true, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
    };
    v.toFixed = function(e, t2) {
      var r, n, o = this, i = o.constructor;
      return e === void 0 ? r = Be(o) : (be(e, 0, at), t2 === void 0 ? t2 = i.rounding : be(t2, 0, 8), n = F(new i(o), e + o.e + 1, t2), r = Be(n, false, e + n.e + 1)), o.isNeg() && !o.isZero() ? "-" + r : r;
    };
    v.toFraction = function(e) {
      var t2, r, n, o, i, s, a, u, l, c, m, g, w = this, E = w.d, b = w.constructor;
      if (!E)
        return new b(w);
      if (l = r = new b(1), n = u = new b(0), t2 = new b(n), i = t2.e = ua(E) - w.e - 1, s = i % I, t2.d[0] = X(10, s < 0 ? I + s : s), e == null)
        e = i > 0 ? t2 : l;
      else {
        if (a = new b(e), !a.isInt() || a.lt(l))
          throw Error(st + a);
        e = a.gt(t2) ? i > 0 ? t2 : l : a;
      }
      for (D = false, a = new b(ue(E)), c = b.precision, b.precision = i = E.length * I * 2; m = K(a, t2, 0, 1, 1), o = r.plus(m.times(n)), o.cmp(e) != 1; )
        r = n, n = o, o = l, l = u.plus(m.times(o)), u = o, o = t2, t2 = a.minus(m.times(o)), a = o;
      return o = K(e.minus(r), n, 0, 1, 1), u = u.plus(o.times(l)), r = r.plus(o.times(n)), u.s = l.s = w.s, g = K(l, n, i, 1).minus(w).abs().cmp(K(u, r, i, 1).minus(w).abs()) < 1 ? [l, n] : [u, r], b.precision = c, D = true, g;
    };
    v.toHexadecimal = v.toHex = function(e, t2) {
      return Vo(this, 16, e, t2);
    };
    v.toNearest = function(e, t2) {
      var r = this, n = r.constructor;
      if (r = new n(r), e == null) {
        if (!r.d)
          return r;
        e = new n(1), t2 = n.rounding;
      } else {
        if (e = new n(e), t2 === void 0 ? t2 = n.rounding : be(t2, 0, 8), !r.d)
          return e.s ? r : e;
        if (!e.d)
          return e.s && (e.s = r.s), e;
      }
      return e.d[0] ? (D = false, r = K(r, e, 0, t2, 1).times(e), D = true, F(r)) : (e.s = r.s, r = e), r;
    };
    v.toNumber = function() {
      return +this;
    };
    v.toOctal = function(e, t2) {
      return Vo(this, 8, e, t2);
    };
    v.toPower = v.pow = function(e) {
      var t2, r, n, o, i, s, a = this, u = a.constructor, l = +(e = new u(e));
      if (!a.d || !e.d || !a.d[0] || !e.d[0])
        return new u(X(+a, l));
      if (a = new u(a), a.eq(1))
        return a;
      if (n = u.precision, i = u.rounding, e.eq(1))
        return F(a, n, i);
      if (t2 = fe(e.e / I), t2 >= e.d.length - 1 && (r = l < 0 ? -l : l) <= ap)
        return o = la(u, a, r, n), e.s < 0 ? new u(1).div(o) : F(o, n, i);
      if (s = a.s, s < 0) {
        if (t2 < e.d.length - 1)
          return new u(NaN);
        if (e.d[t2] & 1 || (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
          return a.s = s, a;
      }
      return r = X(+a, l), t2 = r == 0 || !isFinite(r) ? fe(l * (Math.log("0." + ue(a.d)) / Math.LN10 + a.e + 1)) : new u(r + "").e, t2 > u.maxE + 1 || t2 < u.minE - 1 ? new u(t2 > 0 ? s / 0 : 0) : (D = false, u.rounding = a.s = 1, r = Math.min(12, (t2 + "").length), o = $o(e.times(it(a, n + r)), n), o.d && (o = F(o, n + 5, 1), hr(o.d, n, i) && (t2 = n + 10, o = F($o(e.times(it(a, t2 + r)), t2), t2 + 5, 1), +ue(o.d).slice(n + 1, n + 15) + 1 == 1e14 && (o = F(o, n + 1, 0)))), o.s = s, D = true, u.rounding = i, F(o, n, i));
    };
    v.toPrecision = function(e, t2) {
      var r, n = this, o = n.constructor;
      return e === void 0 ? r = Be(n, n.e <= o.toExpNeg || n.e >= o.toExpPos) : (be(e, 1, at), t2 === void 0 ? t2 = o.rounding : be(t2, 0, 8), n = F(new o(n), e, t2), r = Be(n, e <= n.e || n.e <= o.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
    };
    v.toSignificantDigits = v.toSD = function(e, t2) {
      var r = this, n = r.constructor;
      return e === void 0 ? (e = n.precision, t2 = n.rounding) : (be(e, 1, at), t2 === void 0 ? t2 = n.rounding : be(t2, 0, 8)), F(new n(r), e, t2);
    };
    v.toString = function() {
      var e = this, t2 = e.constructor, r = Be(e, e.e <= t2.toExpNeg || e.e >= t2.toExpPos);
      return e.isNeg() && !e.isZero() ? "-" + r : r;
    };
    v.truncated = v.trunc = function() {
      return F(new this.constructor(this), this.e + 1, 1);
    };
    v.valueOf = v.toJSON = function() {
      var e = this, t2 = e.constructor, r = Be(e, e.e <= t2.toExpNeg || e.e >= t2.toExpPos);
      return e.isNeg() ? "-" + r : r;
    };
    function ue(e) {
      var t2, r, n, o = e.length - 1, i = "", s = e[0];
      if (o > 0) {
        for (i += s, t2 = 1; t2 < o; t2++)
          n = e[t2] + "", r = I - n.length, r && (i += ot(r)), i += n;
        s = e[t2], n = s + "", r = I - n.length, r && (i += ot(r));
      } else if (s === 0)
        return "0";
      for (; s % 10 === 0; )
        s /= 10;
      return i + s;
    }
    function be(e, t2, r) {
      if (e !== ~~e || e < t2 || e > r)
        throw Error(st + e);
    }
    function hr(e, t2, r, n) {
      var o, i, s, a;
      for (i = e[0]; i >= 10; i /= 10)
        --t2;
      return --t2 < 0 ? (t2 += I, o = 0) : (o = Math.ceil((t2 + 1) / I), t2 %= I), i = X(10, I - t2), a = e[o] % i | 0, n == null ? t2 < 3 ? (t2 == 0 ? a = a / 100 | 0 : t2 == 1 && (a = a / 10 | 0), s = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : s = (r < 4 && a + 1 == i || r > 3 && a + 1 == i / 2) && (e[o + 1] / i / 100 | 0) == X(10, t2 - 2) - 1 || (a == i / 2 || a == 0) && (e[o + 1] / i / 100 | 0) == 0 : t2 < 4 ? (t2 == 0 ? a = a / 1e3 | 0 : t2 == 1 ? a = a / 100 | 0 : t2 == 2 && (a = a / 10 | 0), s = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : s = ((n || r < 4) && a + 1 == i || !n && r > 3 && a + 1 == i / 2) && (e[o + 1] / i / 1e3 | 0) == X(10, t2 - 3) - 1, s;
    }
    function yn(e, t2, r) {
      for (var n, o = [0], i, s = 0, a = e.length; s < a; ) {
        for (i = o.length; i--; )
          o[i] *= t2;
        for (o[0] += Bo.indexOf(e.charAt(s++)), n = 0; n < o.length; n++)
          o[n] > r - 1 && (o[n + 1] === void 0 && (o[n + 1] = 0), o[n + 1] += o[n] / r | 0, o[n] %= r);
      }
      return o.reverse();
    }
    function lp(e, t2) {
      var r, n, o;
      if (t2.isZero())
        return t2;
      n = t2.d.length, n < 32 ? (r = Math.ceil(n / 3), o = (1 / Pn(4, r)).toString()) : (r = 16, o = "2.3283064365386962890625e-10"), e.precision += r, t2 = Kt(e, 1, t2.times(o), new e(1));
      for (var i = r; i--; ) {
        var s = t2.times(t2);
        t2 = s.times(s).minus(s).times(8).plus(1);
      }
      return e.precision -= r, t2;
    }
    var K = function() {
      function e(n, o, i) {
        var s, a = 0, u = n.length;
        for (n = n.slice(); u--; )
          s = n[u] * o + a, n[u] = s % i | 0, a = s / i | 0;
        return a && n.unshift(a), n;
      }
      function t2(n, o, i, s) {
        var a, u;
        if (i != s)
          u = i > s ? 1 : -1;
        else
          for (a = u = 0; a < i; a++)
            if (n[a] != o[a]) {
              u = n[a] > o[a] ? 1 : -1;
              break;
            }
        return u;
      }
      function r(n, o, i, s) {
        for (var a = 0; i--; )
          n[i] -= a, a = n[i] < o[i] ? 1 : 0, n[i] = a * s + n[i] - o[i];
        for (; !n[0] && n.length > 1; )
          n.shift();
      }
      return function(n, o, i, s, a, u) {
        var l, c, m, g, w, E, b, T, S, R, C, M, N, L, Te, V, H, Ee, z2, Pe, We = n.constructor, $ = n.s == o.s ? 1 : -1, U = n.d, O = o.d;
        if (!U || !U[0] || !O || !O[0])
          return new We(!n.s || !o.s || (U ? O && U[0] == O[0] : !O) ? NaN : U && U[0] == 0 || !O ? $ * 0 : $ / 0);
        for (u ? (w = 1, c = n.e - o.e) : (u = Oe, w = I, c = fe(n.e / w) - fe(o.e / w)), z2 = O.length, H = U.length, S = new We($), R = S.d = [], m = 0; O[m] == (U[m] || 0); m++)
          ;
        if (O[m] > (U[m] || 0) && c--, i == null ? (L = i = We.precision, s = We.rounding) : a ? L = i + (n.e - o.e) + 1 : L = i, L < 0)
          R.push(1), E = true;
        else {
          if (L = L / w + 2 | 0, m = 0, z2 == 1) {
            for (g = 0, O = O[0], L++; (m < H || g) && L--; m++)
              Te = g * u + (U[m] || 0), R[m] = Te / O | 0, g = Te % O | 0;
            E = g || m < H;
          } else {
            for (g = u / (O[0] + 1) | 0, g > 1 && (O = e(O, g, u), U = e(U, g, u), z2 = O.length, H = U.length), V = z2, C = U.slice(0, z2), M = C.length; M < z2; )
              C[M++] = 0;
            Pe = O.slice(), Pe.unshift(0), Ee = O[0], O[1] >= u / 2 && ++Ee;
            do
              g = 0, l = t2(O, C, z2, M), l < 0 ? (N = C[0], z2 != M && (N = N * u + (C[1] || 0)), g = N / Ee | 0, g > 1 ? (g >= u && (g = u - 1), b = e(O, g, u), T = b.length, M = C.length, l = t2(b, C, T, M), l == 1 && (g--, r(b, z2 < T ? Pe : O, T, u))) : (g == 0 && (l = g = 1), b = O.slice()), T = b.length, T < M && b.unshift(0), r(C, b, M, u), l == -1 && (M = C.length, l = t2(O, C, z2, M), l < 1 && (g++, r(C, z2 < M ? Pe : O, M, u))), M = C.length) : l === 0 && (g++, C = [0]), R[m++] = g, l && C[0] ? C[M++] = U[V] || 0 : (C = [U[V]], M = 1);
            while ((V++ < H || C[0] !== void 0) && L--);
            E = C[0] !== void 0;
          }
          R[0] || R.shift();
        }
        if (w == 1)
          S.e = c, na = E;
        else {
          for (m = 1, g = R[0]; g >= 10; g /= 10)
            m++;
          S.e = m + c * w - 1, F(S, a ? i + S.e + 1 : i, s, E);
        }
        return S;
      };
    }();
    function F(e, t2, r, n) {
      var o, i, s, a, u, l, c, m, g, w = e.constructor;
      e:
        if (t2 != null) {
          if (m = e.d, !m)
            return e;
          for (o = 1, a = m[0]; a >= 10; a /= 10)
            o++;
          if (i = t2 - o, i < 0)
            i += I, s = t2, c = m[g = 0], u = c / X(10, o - s - 1) % 10 | 0;
          else if (g = Math.ceil((i + 1) / I), a = m.length, g >= a)
            if (n) {
              for (; a++ <= g; )
                m.push(0);
              c = u = 0, o = 1, i %= I, s = i - I + 1;
            } else
              break e;
          else {
            for (c = a = m[g], o = 1; a >= 10; a /= 10)
              o++;
            i %= I, s = i - I + o, u = s < 0 ? 0 : c / X(10, o - s - 1) % 10 | 0;
          }
          if (n = n || t2 < 0 || m[g + 1] !== void 0 || (s < 0 ? c : c % X(10, o - s - 1)), l = r < 4 ? (u || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : u > 5 || u == 5 && (r == 4 || n || r == 6 && (i > 0 ? s > 0 ? c / X(10, o - s) : 0 : m[g - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t2 < 1 || !m[0])
            return m.length = 0, l ? (t2 -= e.e + 1, m[0] = X(10, (I - t2 % I) % I), e.e = -t2 || 0) : m[0] = e.e = 0, e;
          if (i == 0 ? (m.length = g, a = 1, g--) : (m.length = g + 1, a = X(10, I - i), m[g] = s > 0 ? (c / X(10, o - s) % X(10, s) | 0) * a : 0), l)
            for (; ; )
              if (g == 0) {
                for (i = 1, s = m[0]; s >= 10; s /= 10)
                  i++;
                for (s = m[0] += a, a = 1; s >= 10; s /= 10)
                  a++;
                i != a && (e.e++, m[0] == Oe && (m[0] = 1));
                break;
              } else {
                if (m[g] += a, m[g] != Oe)
                  break;
                m[g--] = 0, a = 1;
              }
          for (i = m.length; m[--i] === 0; )
            m.pop();
        }
      return D && (e.e > w.maxE ? (e.d = null, e.e = NaN) : e.e < w.minE && (e.e = 0, e.d = [0])), e;
    }
    function Be(e, t2, r) {
      if (!e.isFinite())
        return pa(e);
      var n, o = e.e, i = ue(e.d), s = i.length;
      return t2 ? (r && (n = r - s) > 0 ? i = i.charAt(0) + "." + i.slice(1) + ot(n) : s > 1 && (i = i.charAt(0) + "." + i.slice(1)), i = i + (e.e < 0 ? "e" : "e+") + e.e) : o < 0 ? (i = "0." + ot(-o - 1) + i, r && (n = r - s) > 0 && (i += ot(n))) : o >= s ? (i += ot(o + 1 - s), r && (n = r - o - 1) > 0 && (i = i + "." + ot(n))) : ((n = o + 1) < s && (i = i.slice(0, n) + "." + i.slice(n)), r && (n = r - s) > 0 && (o + 1 === s && (i += "."), i += ot(n))), i;
    }
    function En(e, t2) {
      var r = e[0];
      for (t2 *= I; r >= 10; r /= 10)
        t2++;
      return t2;
    }
    function bn(e, t2, r) {
      if (t2 > up)
        throw D = true, r && (e.precision = r), Error(oa);
      return F(new e(hn), t2, 1, true);
    }
    function Re(e, t2, r) {
      if (t2 > Uo)
        throw Error(oa);
      return F(new e(xn), t2, r, true);
    }
    function ua(e) {
      var t2 = e.length - 1, r = t2 * I + 1;
      if (t2 = e[t2], t2) {
        for (; t2 % 10 == 0; t2 /= 10)
          r--;
        for (t2 = e[0]; t2 >= 10; t2 /= 10)
          r++;
      }
      return r;
    }
    function ot(e) {
      for (var t2 = ""; e--; )
        t2 += "0";
      return t2;
    }
    function la(e, t2, r, n) {
      var o, i = new e(1), s = Math.ceil(n / I + 4);
      for (D = false; ; ) {
        if (r % 2 && (i = i.times(t2), ta(i.d, s) && (o = true)), r = fe(r / 2), r === 0) {
          r = i.d.length - 1, o && i.d[r] === 0 && ++i.d[r];
          break;
        }
        t2 = t2.times(t2), ta(t2.d, s);
      }
      return D = true, i;
    }
    function ea(e) {
      return e.d[e.d.length - 1] & 1;
    }
    function ca(e, t2, r) {
      for (var n, o = new e(t2[0]), i = 0; ++i < t2.length; )
        if (n = new e(t2[i]), n.s)
          o[r](n) && (o = n);
        else {
          o = n;
          break;
        }
      return o;
    }
    function $o(e, t2) {
      var r, n, o, i, s, a, u, l = 0, c = 0, m = 0, g = e.constructor, w = g.rounding, E = g.precision;
      if (!e.d || !e.d[0] || e.e > 17)
        return new g(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : 0 / 0);
      for (t2 == null ? (D = false, u = E) : u = t2, a = new g(0.03125); e.e > -2; )
        e = e.times(a), m += 5;
      for (n = Math.log(X(2, m)) / Math.LN10 * 2 + 5 | 0, u += n, r = i = s = new g(1), g.precision = u; ; ) {
        if (i = F(i.times(e), u, 1), r = r.times(++c), a = s.plus(K(i, r, u, 1)), ue(a.d).slice(0, u) === ue(s.d).slice(0, u)) {
          for (o = m; o--; )
            s = F(s.times(s), u, 1);
          if (t2 == null)
            if (l < 3 && hr(s.d, u - n, w, l))
              g.precision = u += 10, r = i = a = new g(1), c = 0, l++;
            else
              return F(s, g.precision = E, w, D = true);
          else
            return g.precision = E, s;
        }
        s = a;
      }
    }
    function it(e, t2) {
      var r, n, o, i, s, a, u, l, c, m, g, w = 1, E = 10, b = e, T = b.d, S = b.constructor, R = S.rounding, C = S.precision;
      if (b.s < 0 || !T || !T[0] || !b.e && T[0] == 1 && T.length == 1)
        return new S(T && !T[0] ? -1 / 0 : b.s != 1 ? NaN : T ? 0 : b);
      if (t2 == null ? (D = false, c = C) : c = t2, S.precision = c += E, r = ue(T), n = r.charAt(0), Math.abs(i = b.e) < 15e14) {
        for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
          b = b.times(e), r = ue(b.d), n = r.charAt(0), w++;
        i = b.e, n > 1 ? (b = new S("0." + r), i++) : b = new S(n + "." + r.slice(1));
      } else
        return l = bn(S, c + 2, C).times(i + ""), b = it(new S(n + "." + r.slice(1)), c - E).plus(l), S.precision = C, t2 == null ? F(b, C, R, D = true) : b;
      for (m = b, u = s = b = K(b.minus(1), b.plus(1), c, 1), g = F(b.times(b), c, 1), o = 3; ; ) {
        if (s = F(s.times(g), c, 1), l = u.plus(K(s, new S(o), c, 1)), ue(l.d).slice(0, c) === ue(u.d).slice(0, c))
          if (u = u.times(2), i !== 0 && (u = u.plus(bn(S, c + 2, C).times(i + ""))), u = K(u, new S(w), c, 1), t2 == null)
            if (hr(u.d, c - E, R, a))
              S.precision = c += E, l = s = b = K(m.minus(1), m.plus(1), c, 1), g = F(b.times(b), c, 1), o = a = 1;
            else
              return F(u, S.precision = C, R, D = true);
          else
            return S.precision = C, u;
        u = l, o += 2;
      }
    }
    function pa(e) {
      return String(e.s * e.s / 0);
    }
    function qo(e, t2) {
      var r, n, o;
      for ((r = t2.indexOf(".")) > -1 && (t2 = t2.replace(".", "")), (n = t2.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t2.slice(n + 1), t2 = t2.substring(0, n)) : r < 0 && (r = t2.length), n = 0; t2.charCodeAt(n) === 48; n++)
        ;
      for (o = t2.length; t2.charCodeAt(o - 1) === 48; --o)
        ;
      if (t2 = t2.slice(n, o), t2) {
        if (o -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % I, r < 0 && (n += I), n < o) {
          for (n && e.d.push(+t2.slice(0, n)), o -= I; n < o; )
            e.d.push(+t2.slice(n, n += I));
          t2 = t2.slice(n), n = I - t2.length;
        } else
          n -= o;
        for (; n--; )
          t2 += "0";
        e.d.push(+t2), D && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
      } else
        e.e = 0, e.d = [0];
      return e;
    }
    function cp(e, t2) {
      var r, n, o, i, s, a, u, l, c;
      if (t2.indexOf("_") > -1) {
        if (t2 = t2.replace(/(\d)_(?=\d)/g, "$1"), aa.test(t2))
          return qo(e, t2);
      } else if (t2 === "Infinity" || t2 === "NaN")
        return +t2 || (e.s = NaN), e.e = NaN, e.d = null, e;
      if (ip.test(t2))
        r = 16, t2 = t2.toLowerCase();
      else if (op.test(t2))
        r = 2;
      else if (sp.test(t2))
        r = 8;
      else
        throw Error(st + t2);
      for (i = t2.search(/p/i), i > 0 ? (u = +t2.slice(i + 1), t2 = t2.substring(2, i)) : t2 = t2.slice(2), i = t2.indexOf("."), s = i >= 0, n = e.constructor, s && (t2 = t2.replace(".", ""), a = t2.length, i = a - i, o = la(n, new n(r), i, i * 2)), l = yn(t2, r, Oe), c = l.length - 1, i = c; l[i] === 0; --i)
        l.pop();
      return i < 0 ? new n(e.s * 0) : (e.e = En(l, c), e.d = l, D = false, s && (e = K(e, o, a * 4)), u && (e = e.times(Math.abs(u) < 54 ? X(2, u) : wt.pow(2, u))), D = true, e);
    }
    function pp(e, t2) {
      var r, n = t2.d.length;
      if (n < 3)
        return t2.isZero() ? t2 : Kt(e, 2, t2, t2);
      r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t2 = t2.times(1 / Pn(5, r)), t2 = Kt(e, 2, t2, t2);
      for (var o, i = new e(5), s = new e(16), a = new e(20); r--; )
        o = t2.times(t2), t2 = t2.times(i.plus(o.times(s.times(o).minus(a))));
      return t2;
    }
    function Kt(e, t2, r, n, o) {
      var i, s, a, u, l = 1, c = e.precision, m = Math.ceil(c / I);
      for (D = false, u = r.times(r), a = new e(n); ; ) {
        if (s = K(a.times(u), new e(t2++ * t2++), c, 1), a = o ? n.plus(s) : n.minus(s), n = K(s.times(u), new e(t2++ * t2++), c, 1), s = a.plus(n), s.d[m] !== void 0) {
          for (i = m; s.d[i] === a.d[i] && i--; )
            ;
          if (i == -1)
            break;
        }
        i = a, a = n, n = s, s = i, l++;
      }
      return D = true, s.d.length = m + 1, s;
    }
    function Pn(e, t2) {
      for (var r = e; --t2; )
        r *= e;
      return r;
    }
    function fa(e, t2) {
      var r, n = t2.s < 0, o = Re(e, e.precision, 1), i = o.times(0.5);
      if (t2 = t2.abs(), t2.lte(i))
        return Je = n ? 4 : 1, t2;
      if (r = t2.divToInt(o), r.isZero())
        Je = n ? 3 : 2;
      else {
        if (t2 = t2.minus(r.times(o)), t2.lte(i))
          return Je = ea(r) ? n ? 2 : 3 : n ? 4 : 1, t2;
        Je = ea(r) ? n ? 1 : 4 : n ? 3 : 2;
      }
      return t2.minus(o).abs();
    }
    function Vo(e, t2, r, n) {
      var o, i, s, a, u, l, c, m, g, w = e.constructor, E = r !== void 0;
      if (E ? (be(r, 1, at), n === void 0 ? n = w.rounding : be(n, 0, 8)) : (r = w.precision, n = w.rounding), !e.isFinite())
        c = pa(e);
      else {
        for (c = Be(e), s = c.indexOf("."), E ? (o = 2, t2 == 16 ? r = r * 4 - 3 : t2 == 8 && (r = r * 3 - 2)) : o = t2, s >= 0 && (c = c.replace(".", ""), g = new w(1), g.e = c.length - s, g.d = yn(Be(g), 10, o), g.e = g.d.length), m = yn(c, 10, o), i = u = m.length; m[--u] == 0; )
          m.pop();
        if (!m[0])
          c = E ? "0p+0" : "0";
        else {
          if (s < 0 ? i-- : (e = new w(e), e.d = m, e.e = i, e = K(e, g, r, n, 0, o), m = e.d, i = e.e, l = na), s = m[r], a = o / 2, l = l || m[r + 1] !== void 0, l = n < 4 ? (s !== void 0 || l) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || l || n === 6 && m[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), m.length = r, l)
            for (; ++m[--r] > o - 1; )
              m[r] = 0, r || (++i, m.unshift(1));
          for (u = m.length; !m[u - 1]; --u)
            ;
          for (s = 0, c = ""; s < u; s++)
            c += Bo.charAt(m[s]);
          if (E) {
            if (u > 1)
              if (t2 == 16 || t2 == 8) {
                for (s = t2 == 16 ? 4 : 3, --u; u % s; u++)
                  c += "0";
                for (m = yn(c, o, t2), u = m.length; !m[u - 1]; --u)
                  ;
                for (s = 1, c = "1."; s < u; s++)
                  c += Bo.charAt(m[s]);
              } else
                c = c.charAt(0) + "." + c.slice(1);
            c = c + (i < 0 ? "p" : "p+") + i;
          } else if (i < 0) {
            for (; ++i; )
              c = "0" + c;
            c = "0." + c;
          } else if (++i > u)
            for (i -= u; i--; )
              c += "0";
          else
            i < u && (c = c.slice(0, i) + "." + c.slice(i));
        }
        c = (t2 == 16 ? "0x" : t2 == 2 ? "0b" : t2 == 8 ? "0o" : "") + c;
      }
      return e.s < 0 ? "-" + c : c;
    }
    function ta(e, t2) {
      if (e.length > t2)
        return e.length = t2, true;
    }
    function fp(e) {
      return new this(e).abs();
    }
    function dp(e) {
      return new this(e).acos();
    }
    function mp(e) {
      return new this(e).acosh();
    }
    function gp(e, t2) {
      return new this(e).plus(t2);
    }
    function yp(e) {
      return new this(e).asin();
    }
    function hp(e) {
      return new this(e).asinh();
    }
    function xp(e) {
      return new this(e).atan();
    }
    function bp(e) {
      return new this(e).atanh();
    }
    function wp(e, t2) {
      e = new this(e), t2 = new this(t2);
      var r, n = this.precision, o = this.rounding, i = n + 4;
      return !e.s || !t2.s ? r = new this(NaN) : !e.d && !t2.d ? (r = Re(this, i, 1).times(t2.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t2.d || e.isZero() ? (r = t2.s < 0 ? Re(this, n, o) : new this(0), r.s = e.s) : !e.d || t2.isZero() ? (r = Re(this, i, 1).times(0.5), r.s = e.s) : t2.s < 0 ? (this.precision = i, this.rounding = 1, r = this.atan(K(e, t2, i, 1)), t2 = Re(this, i, 1), this.precision = n, this.rounding = o, r = e.s < 0 ? r.minus(t2) : r.plus(t2)) : r = this.atan(K(e, t2, i, 1)), r;
    }
    function Ep(e) {
      return new this(e).cbrt();
    }
    function Pp(e) {
      return F(e = new this(e), e.e + 1, 2);
    }
    function vp(e, t2, r) {
      return new this(e).clamp(t2, r);
    }
    function Ap(e) {
      if (!e || typeof e != "object")
        throw Error(wn + "Object expected");
      var t2, r, n, o = e.defaults === true, i = ["precision", 1, at, "rounding", 0, 8, "toExpNeg", -Vt, 0, "toExpPos", 0, Vt, "maxE", 0, Vt, "minE", -Vt, 0, "modulo", 0, 9];
      for (t2 = 0; t2 < i.length; t2 += 3)
        if (r = i[t2], o && (this[r] = jo[r]), (n = e[r]) !== void 0)
          if (fe(n) === n && n >= i[t2 + 1] && n <= i[t2 + 2])
            this[r] = n;
          else
            throw Error(st + r + ": " + n);
      if (r = "crypto", o && (this[r] = jo[r]), (n = e[r]) !== void 0)
        if (n === true || n === false || n === 0 || n === 1)
          if (n)
            if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes))
              this[r] = true;
            else
              throw Error(ia);
          else
            this[r] = false;
        else
          throw Error(st + r + ": " + n);
      return this;
    }
    function Tp(e) {
      return new this(e).cos();
    }
    function Cp(e) {
      return new this(e).cosh();
    }
    function da(e) {
      var t2, r, n;
      function o(i) {
        var s, a, u, l = this;
        if (!(l instanceof o))
          return new o(i);
        if (l.constructor = o, ra(i)) {
          l.s = i.s, D ? !i.d || i.e > o.maxE ? (l.e = NaN, l.d = null) : i.e < o.minE ? (l.e = 0, l.d = [0]) : (l.e = i.e, l.d = i.d.slice()) : (l.e = i.e, l.d = i.d ? i.d.slice() : i.d);
          return;
        }
        if (u = typeof i, u === "number") {
          if (i === 0) {
            l.s = 1 / i < 0 ? -1 : 1, l.e = 0, l.d = [0];
            return;
          }
          if (i < 0 ? (i = -i, l.s = -1) : l.s = 1, i === ~~i && i < 1e7) {
            for (s = 0, a = i; a >= 10; a /= 10)
              s++;
            D ? s > o.maxE ? (l.e = NaN, l.d = null) : s < o.minE ? (l.e = 0, l.d = [0]) : (l.e = s, l.d = [i]) : (l.e = s, l.d = [i]);
            return;
          } else if (i * 0 !== 0) {
            i || (l.s = NaN), l.e = NaN, l.d = null;
            return;
          }
          return qo(l, i.toString());
        } else if (u !== "string")
          throw Error(st + i);
        return (a = i.charCodeAt(0)) === 45 ? (i = i.slice(1), l.s = -1) : (a === 43 && (i = i.slice(1)), l.s = 1), aa.test(i) ? qo(l, i) : cp(l, i);
      }
      if (o.prototype = v, o.ROUND_UP = 0, o.ROUND_DOWN = 1, o.ROUND_CEIL = 2, o.ROUND_FLOOR = 3, o.ROUND_HALF_UP = 4, o.ROUND_HALF_DOWN = 5, o.ROUND_HALF_EVEN = 6, o.ROUND_HALF_CEIL = 7, o.ROUND_HALF_FLOOR = 8, o.EUCLID = 9, o.config = o.set = Ap, o.clone = da, o.isDecimal = ra, o.abs = fp, o.acos = dp, o.acosh = mp, o.add = gp, o.asin = yp, o.asinh = hp, o.atan = xp, o.atanh = bp, o.atan2 = wp, o.cbrt = Ep, o.ceil = Pp, o.clamp = vp, o.cos = Tp, o.cosh = Cp, o.div = Mp, o.exp = Sp, o.floor = Rp, o.hypot = Op, o.ln = Fp, o.log = Ip, o.log10 = Dp, o.log2 = kp, o.max = _p, o.min = Np, o.mod = Lp, o.mul = Bp, o.pow = jp, o.random = Up, o.round = $p, o.sign = qp, o.sin = Vp, o.sinh = Kp, o.sqrt = Gp, o.sub = Jp, o.sum = Qp, o.tan = Wp, o.tanh = Hp, o.trunc = zp, e === void 0 && (e = {}), e && e.defaults !== true)
        for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t2 = 0; t2 < n.length; )
          e.hasOwnProperty(r = n[t2++]) || (e[r] = this[r]);
      return o.config(e), o;
    }
    function Mp(e, t2) {
      return new this(e).div(t2);
    }
    function Sp(e) {
      return new this(e).exp();
    }
    function Rp(e) {
      return F(e = new this(e), e.e + 1, 3);
    }
    function Op() {
      var e, t2, r = new this(0);
      for (D = false, e = 0; e < arguments.length; )
        if (t2 = new this(arguments[e++]), t2.d)
          r.d && (r = r.plus(t2.times(t2)));
        else {
          if (t2.s)
            return D = true, new this(1 / 0);
          r = t2;
        }
      return D = true, r.sqrt();
    }
    function ra(e) {
      return e instanceof wt || e && e.toStringTag === sa || false;
    }
    function Fp(e) {
      return new this(e).ln();
    }
    function Ip(e, t2) {
      return new this(e).log(t2);
    }
    function kp(e) {
      return new this(e).log(2);
    }
    function Dp(e) {
      return new this(e).log(10);
    }
    function _p() {
      return ca(this, arguments, "lt");
    }
    function Np() {
      return ca(this, arguments, "gt");
    }
    function Lp(e, t2) {
      return new this(e).mod(t2);
    }
    function Bp(e, t2) {
      return new this(e).mul(t2);
    }
    function jp(e, t2) {
      return new this(e).pow(t2);
    }
    function Up(e) {
      var t2, r, n, o, i = 0, s = new this(1), a = [];
      if (e === void 0 ? e = this.precision : be(e, 1, at), n = Math.ceil(e / I), this.crypto)
        if (crypto.getRandomValues)
          for (t2 = crypto.getRandomValues(new Uint32Array(n)); i < n; )
            o = t2[i], o >= 429e7 ? t2[i] = crypto.getRandomValues(new Uint32Array(1))[0] : a[i++] = o % 1e7;
        else if (crypto.randomBytes) {
          for (t2 = crypto.randomBytes(n *= 4); i < n; )
            o = t2[i] + (t2[i + 1] << 8) + (t2[i + 2] << 16) + ((t2[i + 3] & 127) << 24), o >= 214e7 ? crypto.randomBytes(4).copy(t2, i) : (a.push(o % 1e7), i += 4);
          i = n / 4;
        } else
          throw Error(ia);
      else
        for (; i < n; )
          a[i++] = Math.random() * 1e7 | 0;
      for (n = a[--i], e %= I, n && e && (o = X(10, I - e), a[i] = (n / o | 0) * o); a[i] === 0; i--)
        a.pop();
      if (i < 0)
        r = 0, a = [0];
      else {
        for (r = -1; a[0] === 0; r -= I)
          a.shift();
        for (n = 1, o = a[0]; o >= 10; o /= 10)
          n++;
        n < I && (r -= I - n);
      }
      return s.e = r, s.d = a, s;
    }
    function $p(e) {
      return F(e = new this(e), e.e + 1, this.rounding);
    }
    function qp(e) {
      return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
    }
    function Vp(e) {
      return new this(e).sin();
    }
    function Kp(e) {
      return new this(e).sinh();
    }
    function Gp(e) {
      return new this(e).sqrt();
    }
    function Jp(e, t2) {
      return new this(e).sub(t2);
    }
    function Qp() {
      var e = 0, t2 = arguments, r = new this(t2[e]);
      for (D = false; r.s && ++e < t2.length; )
        r = r.plus(t2[e]);
      return D = true, F(r, this.precision, this.rounding);
    }
    function Wp(e) {
      return new this(e).tan();
    }
    function Hp(e) {
      return new this(e).tanh();
    }
    function zp(e) {
      return F(e = new this(e), e.e + 1, 1);
    }
    v[Symbol.for("nodejs.util.inspect.custom")] = v.toString;
    v[Symbol.toStringTag] = "Decimal";
    var wt = v.constructor = da(jo);
    hn = new wt(hn);
    xn = new wt(xn);
    var je = wt;
    function Gt(e) {
      return wt.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
    }
    d();
    p();
    f();
    var xr = class {
      constructor(t2, r, n, o, i) {
        this.modelName = t2, this.name = r, this.typeName = n, this.isList = o, this.isEnum = i;
      }
      _toGraphQLInputType() {
        let t2 = this.isList ? "List" : "", r = this.isEnum ? "Enum" : "";
        return `${t2}${r}${this.typeName}FieldRefInput<${this.modelName}>`;
      }
    };
    function Jt(e) {
      return e instanceof xr;
    }
    d();
    p();
    f();
    d();
    p();
    f();
    var vn = class {
      constructor(t2) {
        this.value = t2;
      }
      write(t2) {
        t2.write(this.value);
      }
      markAsError() {
        this.value.markAsError();
      }
    };
    d();
    p();
    f();
    var An = (e) => e;
    var Tn = { bold: An, red: An, green: An, dim: An, enabled: false };
    var ma = { bold: tt, red: _t, green: on3, dim: nn, enabled: true };
    var Qt = { write(e) {
      e.writeLine(",");
    } };
    d();
    p();
    f();
    var Ue = class {
      constructor(t2) {
        this.contents = t2;
        this.isUnderlined = false;
        this.color = (t3) => t3;
      }
      underline() {
        return this.isUnderlined = true, this;
      }
      setColor(t2) {
        return this.color = t2, this;
      }
      write(t2) {
        let r = t2.getCurrentLineLength();
        t2.write(this.color(this.contents)), this.isUnderlined && t2.afterNextNewline(() => {
          t2.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)));
        });
      }
    };
    d();
    p();
    f();
    var ut = class {
      constructor() {
        this.hasError = false;
      }
      markAsError() {
        return this.hasError = true, this;
      }
    };
    var Wt = class extends ut {
      constructor() {
        super(...arguments);
        this.items = [];
      }
      addItem(r) {
        return this.items.push(new vn(r)), this;
      }
      getField(r) {
        return this.items[r];
      }
      getPrintWidth() {
        return this.items.length === 0 ? 2 : Math.max(...this.items.map((n) => n.value.getPrintWidth())) + 2;
      }
      write(r) {
        if (this.items.length === 0) {
          this.writeEmpty(r);
          return;
        }
        this.writeWithItems(r);
      }
      writeEmpty(r) {
        let n = new Ue("[]");
        this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
      }
      writeWithItems(r) {
        let { colors: n } = r.context;
        r.writeLine("[").withIndent(() => r.writeJoined(Qt, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
          r.writeLine(n.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    d();
    p();
    f();
    var ga = ": ";
    var Cn = class {
      constructor(t2, r) {
        this.name = t2;
        this.value = r;
        this.hasError = false;
      }
      markAsError() {
        this.hasError = true;
      }
      getPrintWidth() {
        return this.name.length + this.value.getPrintWidth() + ga.length;
      }
      write(t2) {
        let r = new Ue(this.name);
        this.hasError && r.underline().setColor(t2.context.colors.red), t2.write(r).write(ga).write(this.value);
      }
    };
    d();
    p();
    f();
    var ne = class e extends ut {
      constructor() {
        super(...arguments);
        this.fields = {};
        this.suggestions = [];
      }
      addField(r) {
        this.fields[r.name] = r;
      }
      addSuggestion(r) {
        this.suggestions.push(r);
      }
      getField(r) {
        return this.fields[r];
      }
      getDeepField(r) {
        let [n, ...o] = r, i = this.getField(n);
        if (!i)
          return;
        let s = i;
        for (let a of o) {
          let u;
          if (s.value instanceof e ? u = s.value.getField(a) : s.value instanceof Wt && (u = s.value.getField(Number(a))), !u)
            return;
          s = u;
        }
        return s;
      }
      getDeepFieldValue(r) {
        var n;
        return r.length === 0 ? this : (n = this.getDeepField(r)) == null ? void 0 : n.value;
      }
      hasField(r) {
        return !!this.getField(r);
      }
      removeAllFields() {
        this.fields = {};
      }
      removeField(r) {
        delete this.fields[r];
      }
      getFields() {
        return this.fields;
      }
      isEmpty() {
        return Object.keys(this.fields).length === 0;
      }
      getFieldValue(r) {
        var n;
        return (n = this.getField(r)) == null ? void 0 : n.value;
      }
      getDeepSubSelectionValue(r) {
        let n = this;
        for (let o of r) {
          if (!(n instanceof e))
            return;
          let i = n.getSubSelectionValue(o);
          if (!i)
            return;
          n = i;
        }
        return n;
      }
      getDeepSelectionParent(r) {
        let n = this.getSelectionParent();
        if (!n)
          return;
        let o = n;
        for (let i of r) {
          let s = o.value.getFieldValue(i);
          if (!s || !(s instanceof e))
            return;
          let a = s.getSelectionParent();
          if (!a)
            return;
          o = a;
        }
        return o;
      }
      getSelectionParent() {
        let r = this.getField("select");
        if ((r == null ? void 0 : r.value) instanceof e)
          return { kind: "select", value: r.value };
        let n = this.getField("include");
        if ((n == null ? void 0 : n.value) instanceof e)
          return { kind: "include", value: n.value };
      }
      getSubSelectionValue(r) {
        var n;
        return (n = this.getSelectionParent()) == null ? void 0 : n.value.fields[r].value;
      }
      getPrintWidth() {
        let r = Object.values(this.fields);
        return r.length == 0 ? 2 : Math.max(...r.map((o) => o.getPrintWidth())) + 2;
      }
      write(r) {
        let n = Object.values(this.fields);
        if (n.length === 0 && this.suggestions.length === 0) {
          this.writeEmpty(r);
          return;
        }
        this.writeWithContents(r, n);
      }
      writeEmpty(r) {
        let n = new Ue("{}");
        this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
      }
      writeWithContents(r, n) {
        r.writeLine("{").withIndent(() => {
          r.writeJoined(Qt, [...n, ...this.suggestions]).newLine();
        }), r.write("}"), this.hasError && r.afterNextNewline(() => {
          r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    d();
    p();
    f();
    var oe = class extends ut {
      constructor(r) {
        super();
        this.text = r;
      }
      getPrintWidth() {
        return this.text.length;
      }
      write(r) {
        let n = new Ue(this.text);
        this.hasError && n.underline().setColor(r.context.colors.red), r.write(n);
      }
    };
    var Ko = class {
      constructor(t2) {
        this.errorMessages = [];
        this.arguments = t2;
      }
      write(t2) {
        t2.write(this.arguments);
      }
      addErrorMessage(t2) {
        this.errorMessages.push(t2);
      }
      renderAllMessages(t2) {
        return this.errorMessages.map((r) => r(t2)).join(`
`);
      }
    };
    function Mn(e) {
      return new Ko(ya(e));
    }
    function ya(e) {
      let t2 = new ne();
      for (let [r, n] of Object.entries(e)) {
        let o = new Cn(r, ha(n));
        t2.addField(o);
      }
      return t2;
    }
    function ha(e) {
      if (typeof e == "string")
        return new oe(JSON.stringify(e));
      if (typeof e == "number" || typeof e == "boolean")
        return new oe(String(e));
      if (typeof e == "bigint")
        return new oe(`${e}n`);
      if (e === null)
        return new oe("null");
      if (e === void 0)
        return new oe("undefined");
      if (Gt(e))
        return new oe(`new Prisma.Decimal("${e.toFixed()}")`);
      if (e instanceof Uint8Array)
        return x.Buffer.isBuffer(e) ? new oe(`Buffer.alloc(${e.byteLength})`) : new oe(`new Uint8Array(${e.byteLength})`);
      if (e instanceof Date) {
        let t2 = gn(e) ? e.toISOString() : "Invalid Date";
        return new oe(`new Date("${t2}")`);
      }
      return e instanceof _e ? new oe(`Prisma.${e._getName()}`) : Jt(e) ? new oe(`prisma.${Zi(e.modelName)}.$fields.${e.name}`) : Array.isArray(e) ? Yp(e) : typeof e == "object" ? ya(e) : new oe(Object.prototype.toString.call(e));
    }
    function Yp(e) {
      let t2 = new Wt();
      for (let r of e)
        t2.addItem(ha(r));
      return t2;
    }
    function xa(e) {
      if (e === void 0)
        return "";
      let t2 = Mn(e);
      return new $t(0, { colors: Tn }).write(t2).toString();
    }
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    var br = "<unknown>";
    function ba(e) {
      var t2 = e.split(`
`);
      return t2.reduce(function(r, n) {
        var o = tf(n) || nf(n) || af(n) || pf(n) || lf(n);
        return o && r.push(o), r;
      }, []);
    }
    var Xp = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var ef = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function tf(e) {
      var t2 = Xp.exec(e);
      if (!t2)
        return null;
      var r = t2[2] && t2[2].indexOf("native") === 0, n = t2[2] && t2[2].indexOf("eval") === 0, o = ef.exec(t2[2]);
      return n && o != null && (t2[2] = o[1], t2[3] = o[2], t2[4] = o[3]), { file: r ? null : t2[2], methodName: t2[1] || br, arguments: r ? [t2[2]] : [], lineNumber: t2[3] ? +t2[3] : null, column: t2[4] ? +t2[4] : null };
    }
    var rf = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function nf(e) {
      var t2 = rf.exec(e);
      return t2 ? { file: t2[2], methodName: t2[1] || br, arguments: [], lineNumber: +t2[3], column: t2[4] ? +t2[4] : null } : null;
    }
    var of = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var sf = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function af(e) {
      var t2 = of.exec(e);
      if (!t2)
        return null;
      var r = t2[3] && t2[3].indexOf(" > eval") > -1, n = sf.exec(t2[3]);
      return r && n != null && (t2[3] = n[1], t2[4] = n[2], t2[5] = null), { file: t2[3], methodName: t2[1] || br, arguments: t2[2] ? t2[2].split(",") : [], lineNumber: t2[4] ? +t2[4] : null, column: t2[5] ? +t2[5] : null };
    }
    var uf = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function lf(e) {
      var t2 = uf.exec(e);
      return t2 ? { file: t2[3], methodName: t2[1] || br, arguments: [], lineNumber: +t2[4], column: t2[5] ? +t2[5] : null } : null;
    }
    var cf = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function pf(e) {
      var t2 = cf.exec(e);
      return t2 ? { file: t2[2], methodName: t2[1] || br, arguments: [], lineNumber: +t2[3], column: t2[4] ? +t2[4] : null } : null;
    }
    var Go = class {
      getLocation() {
        return null;
      }
    };
    var Jo = class {
      constructor() {
        this._error = new Error();
      }
      getLocation() {
        let t2 = this._error.stack;
        if (!t2)
          return null;
        let n = ba(t2).find((o) => {
          if (!o.file)
            return false;
          let i = Mo(o.file);
          return i !== "<anonymous>" && !i.includes("@prisma") && !i.includes("/packages/client/src/runtime/") && !i.endsWith("/runtime/binary.js") && !i.endsWith("/runtime/library.js") && !i.endsWith("/runtime/edge.js") && !i.endsWith("/runtime/edge-esm.js") && !i.startsWith("internal/") && !o.methodName.includes("new ") && !o.methodName.includes("getCallSite") && !o.methodName.includes("Proxy.") && o.methodName.split(".").length < 4;
        });
        return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
      }
    };
    function lt(e) {
      return e === "minimal" ? new Go() : new Jo();
    }
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    var wa = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
    function Ht(e = {}) {
      let t2 = df(e);
      return Object.entries(t2).reduce((n, [o, i]) => (wa[o] !== void 0 ? n.select[o] = { select: i } : n[o] = i, n), { select: {} });
    }
    function df(e = {}) {
      return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
    }
    function Sn(e = {}) {
      return (t2) => (typeof e._count == "boolean" && (t2._count = t2._count._all), t2);
    }
    function Ea(e, t2) {
      let r = Sn(e);
      return t2({ action: "aggregate", unpacker: r, argsMapper: Ht })(e);
    }
    d();
    p();
    f();
    function mf(e = {}) {
      let { select: t2, ...r } = e;
      return typeof t2 == "object" ? Ht({ ...r, _count: t2 }) : Ht({ ...r, _count: { _all: true } });
    }
    function gf(e = {}) {
      return typeof e.select == "object" ? (t2) => Sn(e)(t2)._count : (t2) => Sn(e)(t2)._count._all;
    }
    function Pa(e, t2) {
      return t2({ action: "count", unpacker: gf(e), argsMapper: mf })(e);
    }
    d();
    p();
    f();
    function yf(e = {}) {
      let t2 = Ht(e);
      if (Array.isArray(t2.by))
        for (let r of t2.by)
          typeof r == "string" && (t2.select[r] = true);
      else
        typeof t2.by == "string" && (t2.select[t2.by] = true);
      return t2;
    }
    function hf(e = {}) {
      return (t2) => (typeof (e == null ? void 0 : e._count) == "boolean" && t2.forEach((r) => {
        r._count = r._count._all;
      }), t2);
    }
    function va(e, t2) {
      return t2({ action: "groupBy", unpacker: hf(e), argsMapper: yf })(e);
    }
    function Aa(e, t2, r) {
      if (t2 === "aggregate")
        return (n) => Ea(n, r);
      if (t2 === "count")
        return (n) => Pa(n, r);
      if (t2 === "groupBy")
        return (n) => va(n, r);
    }
    d();
    p();
    f();
    function Ta(e, t2) {
      let r = t2.fields.filter((o) => !o.relationName), n = Fo(r, (o) => o.name);
      return new Proxy({}, { get(o, i) {
        if (i in o || typeof i == "symbol")
          return o[i];
        let s = n[i];
        if (s)
          return new xr(e, i, s.type, s.isList, s.kind === "enum");
      }, ...mn(Object.keys(n)) });
    }
    d();
    p();
    f();
    d();
    p();
    f();
    var Ca = (e) => Array.isArray(e) ? e : e.split(".");
    var Qo = (e, t2) => Ca(t2).reduce((r, n) => r && r[n], e);
    var Ma = (e, t2, r) => Ca(t2).reduceRight((n, o, i, s) => Object.assign({}, Qo(e, s.slice(0, i)), { [o]: n }), r);
    function xf(e, t2) {
      return e === void 0 || t2 === void 0 ? [] : [...t2, "select", e];
    }
    function bf(e, t2, r) {
      return t2 === void 0 ? e != null ? e : {} : Ma(t2, r, e || true);
    }
    function Wo(e, t2, r, n, o, i) {
      let a = e._runtimeDataModel.models[t2].fields.reduce((u, l) => ({ ...u, [l.name]: l }), {});
      return (u) => {
        let l = lt(e._errorFormat), c = xf(n, o), m = bf(u, i, c), g = r({ dataPath: c, callsite: l })(m), w = wf(e, t2);
        return new Proxy(g, { get(E, b) {
          if (!w.includes(b))
            return E[b];
          let S = [a[b].type, r, b], R = [c, m];
          return Wo(e, ...S, ...R);
        }, ...mn([...w, ...Object.getOwnPropertyNames(g)]) });
      };
    }
    function wf(e, t2) {
      return e._runtimeDataModel.models[t2].fields.filter((r) => r.kind === "object").map((r) => r.name);
    }
    d();
    p();
    f();
    d();
    p();
    f();
    var Ia = ve(Bs());
    d();
    p();
    f();
    Ao();
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    var Sa = { keyword: rt, entity: rt, value: (e) => tt(Nt(e)), punctuation: Nt, directive: rt, function: rt, variable: (e) => tt(Nt(e)), string: (e) => tt(on3(e)), boolean: sn, number: rt, comment: an };
    var Ef = (e) => e;
    var Rn = {};
    var Pf = 0;
    var _ = { manual: Rn.Prism && Rn.Prism.manual, disableWorkerMessageHandler: Rn.Prism && Rn.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
      if (e instanceof Fe) {
        let t2 = e;
        return new Fe(t2.type, _.util.encode(t2.content), t2.alias);
      } else
        return Array.isArray(e) ? e.map(_.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
    }, type: function(e) {
      return Object.prototype.toString.call(e).slice(8, -1);
    }, objId: function(e) {
      return e.__id || Object.defineProperty(e, "__id", { value: ++Pf }), e.__id;
    }, clone: function e(t2, r) {
      let n, o, i = _.util.type(t2);
      switch (r = r || {}, i) {
        case "Object":
          if (o = _.util.objId(t2), r[o])
            return r[o];
          n = {}, r[o] = n;
          for (let s in t2)
            t2.hasOwnProperty(s) && (n[s] = e(t2[s], r));
          return n;
        case "Array":
          return o = _.util.objId(t2), r[o] ? r[o] : (n = [], r[o] = n, t2.forEach(function(s, a) {
            n[a] = e(s, r);
          }), n);
        default:
          return t2;
      }
    } }, languages: { extend: function(e, t2) {
      let r = _.util.clone(_.languages[e]);
      for (let n in t2)
        r[n] = t2[n];
      return r;
    }, insertBefore: function(e, t2, r, n) {
      n = n || _.languages;
      let o = n[e], i = {};
      for (let a in o)
        if (o.hasOwnProperty(a)) {
          if (a == t2)
            for (let u in r)
              r.hasOwnProperty(u) && (i[u] = r[u]);
          r.hasOwnProperty(a) || (i[a] = o[a]);
        }
      let s = n[e];
      return n[e] = i, _.languages.DFS(_.languages, function(a, u) {
        u === s && a != e && (this[a] = i);
      }), i;
    }, DFS: function e(t2, r, n, o) {
      o = o || {};
      let i = _.util.objId;
      for (let s in t2)
        if (t2.hasOwnProperty(s)) {
          r.call(t2, s, t2[s], n || s);
          let a = t2[s], u = _.util.type(a);
          u === "Object" && !o[i(a)] ? (o[i(a)] = true, e(a, r, null, o)) : u === "Array" && !o[i(a)] && (o[i(a)] = true, e(a, r, s, o));
        }
    } }, plugins: {}, highlight: function(e, t2, r) {
      let n = { code: e, grammar: t2, language: r };
      return _.hooks.run("before-tokenize", n), n.tokens = _.tokenize(n.code, n.grammar), _.hooks.run("after-tokenize", n), Fe.stringify(_.util.encode(n.tokens), n.language);
    }, matchGrammar: function(e, t2, r, n, o, i, s) {
      for (let b in r) {
        if (!r.hasOwnProperty(b) || !r[b])
          continue;
        if (b == s)
          return;
        let T = r[b];
        T = _.util.type(T) === "Array" ? T : [T];
        for (let S = 0; S < T.length; ++S) {
          let R = T[S], C = R.inside, M = !!R.lookbehind, N = !!R.greedy, L = 0, Te = R.alias;
          if (N && !R.pattern.global) {
            let V = R.pattern.toString().match(/[imuy]*$/)[0];
            R.pattern = RegExp(R.pattern.source, V + "g");
          }
          R = R.pattern || R;
          for (let V = n, H = o; V < t2.length; H += t2[V].length, ++V) {
            let Ee = t2[V];
            if (t2.length > e.length)
              return;
            if (Ee instanceof Fe)
              continue;
            if (N && V != t2.length - 1) {
              R.lastIndex = H;
              var m = R.exec(e);
              if (!m)
                break;
              var c = m.index + (M ? m[1].length : 0), g = m.index + m[0].length, a = V, u = H;
              for (let O = t2.length; a < O && (u < g || !t2[a].type && !t2[a - 1].greedy); ++a)
                u += t2[a].length, c >= u && (++V, H = u);
              if (t2[V] instanceof Fe)
                continue;
              l = a - V, Ee = e.slice(H, u), m.index -= H;
            } else {
              R.lastIndex = 0;
              var m = R.exec(Ee), l = 1;
            }
            if (!m) {
              if (i)
                break;
              continue;
            }
            M && (L = m[1] ? m[1].length : 0);
            var c = m.index + L, m = m[0].slice(L), g = c + m.length, w = Ee.slice(0, c), E = Ee.slice(g);
            let z2 = [V, l];
            w && (++V, H += w.length, z2.push(w));
            let Pe = new Fe(b, C ? _.tokenize(m, C) : m, Te, m, N);
            if (z2.push(Pe), E && z2.push(E), Array.prototype.splice.apply(t2, z2), l != 1 && _.matchGrammar(e, t2, r, V, H, true, b), i)
              break;
          }
        }
      }
    }, tokenize: function(e, t2) {
      let r = [e], n = t2.rest;
      if (n) {
        for (let o in n)
          t2[o] = n[o];
        delete t2.rest;
      }
      return _.matchGrammar(e, r, t2, 0, 0, false), r;
    }, hooks: { all: {}, add: function(e, t2) {
      let r = _.hooks.all;
      r[e] = r[e] || [], r[e].push(t2);
    }, run: function(e, t2) {
      let r = _.hooks.all[e];
      if (!(!r || !r.length))
        for (var n = 0, o; o = r[n++]; )
          o(t2);
    } }, Token: Fe };
    _.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
    _.languages.javascript = _.languages.extend("clike", { "class-name": [_.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
    _.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    _.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: _.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: _.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: _.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: _.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
    _.languages.markup && _.languages.markup.tag.addInlined("script", "javascript");
    _.languages.js = _.languages.javascript;
    _.languages.typescript = _.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
    _.languages.ts = _.languages.typescript;
    function Fe(e, t2, r, n, o) {
      this.type = e, this.content = t2, this.alias = r, this.length = (n || "").length | 0, this.greedy = !!o;
    }
    Fe.stringify = function(e, t2) {
      return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(r) {
        return Fe.stringify(r, t2);
      }).join("") : vf(e.type)(e.content);
    };
    function vf(e) {
      return Sa[e] || Ef;
    }
    function Ra(e) {
      return Af(e, _.languages.javascript);
    }
    function Af(e, t2) {
      return _.tokenize(e, t2).map((n) => Fe.stringify(n)).join("");
    }
    d();
    p();
    f();
    var Oa = ve(Ds());
    function Fa(e) {
      return (0, Oa.default)(e);
    }
    var On = class e {
      static read(t2) {
        let r;
        try {
          r = un.readFileSync(t2, "utf-8");
        } catch (n) {
          return null;
        }
        return e.fromContent(r);
      }
      static fromContent(t2) {
        let r = t2.split(/\r?\n/);
        return new e(1, r);
      }
      constructor(t2, r) {
        this.firstLineNumber = t2, this.lines = r;
      }
      get lastLineNumber() {
        return this.firstLineNumber + this.lines.length - 1;
      }
      mapLineAt(t2, r) {
        if (t2 < this.firstLineNumber || t2 > this.lines.length + this.firstLineNumber)
          return this;
        let n = t2 - this.firstLineNumber, o = [...this.lines];
        return o[n] = r(o[n]), new e(this.firstLineNumber, o);
      }
      mapLines(t2) {
        return new e(this.firstLineNumber, this.lines.map((r, n) => t2(r, this.firstLineNumber + n)));
      }
      lineAt(t2) {
        return this.lines[t2 - this.firstLineNumber];
      }
      prependSymbolAt(t2, r) {
        return this.mapLines((n, o) => o === t2 ? `${r} ${n}` : `  ${n}`);
      }
      slice(t2, r) {
        let n = this.lines.slice(t2 - 1, r).join(`
`);
        return new e(t2, Fa(n).split(`
`));
      }
      highlight() {
        let t2 = Ra(this.toString());
        return new e(this.firstLineNumber, t2.split(`
`));
      }
      toString() {
        return this.lines.join(`
`);
      }
    };
    var Tf = { red: _t, gray: an, dim: nn, bold: tt, underline: Ms, highlightSource: (e) => e.highlight() };
    var Cf = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
    function Mf({ callsite: e, message: t2, originalMethod: r, isPanic: n, callArguments: o }, i) {
      var m;
      let s = { functionName: `prisma.${r}()`, message: t2, isPanic: n != null ? n : false, callArguments: o };
      if (!e || typeof window != "undefined" || y.env.NODE_ENV === "production")
        return s;
      let a = e.getLocation();
      if (!a || !a.lineNumber || !a.columnNumber)
        return s;
      let u = Math.max(1, a.lineNumber - 3), l = (m = On.read(a.fileName)) == null ? void 0 : m.slice(u, a.lineNumber), c = l == null ? void 0 : l.lineAt(a.lineNumber);
      if (l && c) {
        let g = Rf(c), w = Sf(c);
        if (!w)
          return s;
        s.functionName = `${w.code})`, s.location = a, n || (l = l.mapLineAt(a.lineNumber, (b) => b.slice(0, w.openingBraceIndex))), l = i.highlightSource(l);
        let E = String(l.lastLineNumber).length;
        if (s.contextLines = l.mapLines((b, T) => i.gray(String(T).padStart(E)) + " " + b).mapLines((b) => i.dim(b)).prependSymbolAt(a.lineNumber, i.bold(i.red("\u2192"))), o) {
          let b = g + E + 1;
          b += 2, s.callArguments = (0, Ia.default)(o, b).slice(b);
        }
      }
      return s;
    }
    function Sf(e) {
      let t2 = Object.keys(Ce.ModelAction).join("|"), n = new RegExp(String.raw`\.(${t2})\(`).exec(e);
      if (n) {
        let o = n.index + n[0].length, i = e.lastIndexOf(" ", n.index) + 1;
        return { code: e.slice(i, o), openingBraceIndex: o };
      }
      return null;
    }
    function Rf(e) {
      let t2 = 0;
      for (let r = 0; r < e.length; r++) {
        if (e.charAt(r) !== " ")
          return t2;
        t2++;
      }
      return t2;
    }
    function Of({ functionName: e, location: t2, message: r, isPanic: n, contextLines: o, callArguments: i }, s) {
      let a = [""], u = t2 ? " in" : ":";
      if (n ? (a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${u}`))) : a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${u}`)), t2 && a.push(s.underline(Ff(t2))), o) {
        a.push("");
        let l = [o.toString()];
        i && (l.push(i), l.push(s.dim(")"))), a.push(l.join("")), i && a.push("");
      } else
        a.push(""), i && a.push(i), a.push("");
      return a.push(r), a.join(`
`);
    }
    function Ff(e) {
      let t2 = [e.fileName];
      return e.lineNumber && t2.push(String(e.lineNumber)), e.columnNumber && t2.push(String(e.columnNumber)), t2.join(":");
    }
    function zt(e) {
      let t2 = e.showColors ? Tf : Cf, r = Mf(e, t2);
      return Of(r, t2);
    }
    function ka(e, t2, r, n) {
      return e === Ce.ModelAction.findFirstOrThrow || e === Ce.ModelAction.findUniqueOrThrow ? If(t2, r, n) : n;
    }
    function If(e, t2, r) {
      return async (n) => {
        if ("rejectOnNotFound" in n.args) {
          let i = zt({ originalMethod: n.clientMethod, callsite: n.callsite, message: "'rejectOnNotFound' option is not supported" });
          throw new pe(i, { clientVersion: t2 });
        }
        return await r(n).catch((i) => {
          throw i instanceof ce && i.code === "P2025" ? new Ke(`No ${e} found`, t2) : i;
        });
      };
    }
    d();
    p();
    f();
    function $e(e) {
      return e.replace(/^./, (t2) => t2.toLowerCase());
    }
    var kf = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
    var Df = ["aggregate", "count", "groupBy"];
    function Ho(e, t2) {
      var o;
      let r = (o = e._extensions.getAllModelExtensions(t2)) != null ? o : {}, n = [_f(e, t2), Lf(e, t2), gr(r), ge("name", () => t2), ge("$name", () => t2), ge("$parent", () => e._appliedParent)];
      return Le({}, n);
    }
    function _f(e, t2) {
      let r = $e(t2), n = Object.keys(Ce.ModelAction).concat("count");
      return { getKeys() {
        return n;
      }, getPropertyValue(o) {
        let i = o, s = (u) => e._request(u);
        s = ka(i, t2, e._clientVersion, s);
        let a = (u) => (l) => {
          let c = lt(e._errorFormat);
          return e._createPrismaPromise((m) => {
            let g = { args: l, dataPath: [], action: i, model: t2, clientMethod: `${r}.${o}`, jsModelName: r, transaction: m, callsite: c };
            return s({ ...g, ...u });
          });
        };
        return kf.includes(i) ? Wo(e, t2, a) : Nf(o) ? Aa(e, o, a) : a({});
      } };
    }
    function Nf(e) {
      return Df.includes(e);
    }
    function Lf(e, t2) {
      return bt(ge("fields", () => {
        let r = e._runtimeDataModel.models[t2];
        return Ta(t2, r);
      }));
    }
    d();
    p();
    f();
    function Da(e) {
      return e.replace(/^./, (t2) => t2.toUpperCase());
    }
    var zo = Symbol();
    function wr(e) {
      let t2 = [Bf(e), ge(zo, () => e), ge("$parent", () => e._appliedParent)], r = e._extensions.getAllClientExtensions();
      return r && t2.push(gr(r)), Le(e, t2);
    }
    function Bf(e) {
      let t2 = Object.keys(e._runtimeDataModel.models), r = t2.map($e), n = [...new Set(t2.concat(r))];
      return bt({ getKeys() {
        return n;
      }, getPropertyValue(o) {
        let i = Da(o);
        if (e._runtimeDataModel.models[i] !== void 0)
          return Ho(e, i);
        if (e._runtimeDataModel.models[o] !== void 0)
          return Ho(e, o);
      }, getPropertyDescriptor(o) {
        if (!r.includes(o))
          return { enumerable: false };
      } });
    }
    function Fn(e) {
      return e[zo] ? e[zo] : e;
    }
    function _a(e) {
      if (typeof e == "function")
        return e(this);
      let t2 = Fn(this), r = Object.create(t2, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $use: { value: void 0 }, $on: { value: void 0 } });
      return wr(r);
    }
    d();
    p();
    f();
    d();
    p();
    f();
    function Na({ result: e, modelName: t2, select: r, extensions: n }) {
      let o = n.getAllComputedFields(t2);
      if (!o)
        return e;
      let i = [], s = [];
      for (let a of Object.values(o)) {
        if (r) {
          if (!r[a.name])
            continue;
          let u = a.needs.filter((l) => !r[l]);
          u.length > 0 && s.push(yr(u));
        }
        jf(e, a.needs) && i.push(Uf(a, Le(e, i)));
      }
      return i.length > 0 || s.length > 0 ? Le(e, [...i, ...s]) : e;
    }
    function jf(e, t2) {
      return t2.every((r) => Oo(e, r));
    }
    function Uf(e, t2) {
      return bt(ge(e.name, () => e.compute(t2)));
    }
    d();
    p();
    f();
    function In({ visitor: e, result: t2, args: r, runtimeDataModel: n, modelName: o }) {
      var s;
      if (Array.isArray(t2)) {
        for (let a = 0; a < t2.length; a++)
          t2[a] = In({ result: t2[a], args: r, modelName: o, runtimeDataModel: n, visitor: e });
        return t2;
      }
      let i = (s = e(t2, o, r)) != null ? s : t2;
      return r.include && La({ includeOrSelect: r.include, result: i, parentModelName: o, runtimeDataModel: n, visitor: e }), r.select && La({ includeOrSelect: r.select, result: i, parentModelName: o, runtimeDataModel: n, visitor: e }), i;
    }
    function La({ includeOrSelect: e, result: t2, parentModelName: r, runtimeDataModel: n, visitor: o }) {
      for (let [i, s] of Object.entries(e)) {
        if (!s || t2[i] == null)
          continue;
        let u = n.models[r].fields.find((c) => c.name === i);
        if (!u || u.kind !== "object" || !u.relationName)
          continue;
        let l = typeof s == "object" ? s : {};
        t2[i] = In({ visitor: o, result: t2[i], args: l, modelName: u.type, runtimeDataModel: n });
      }
    }
    function Ba({ result: e, modelName: t2, args: r, extensions: n, runtimeDataModel: o }) {
      return n.isEmpty() || e == null || typeof e != "object" || !o.models[t2] ? e : In({ result: e, args: r != null ? r : {}, modelName: t2, runtimeDataModel: o, visitor: (s, a, u) => Na({ result: s, modelName: $e(a), select: u.select, extensions: n }) });
    }
    d();
    p();
    f();
    d();
    p();
    f();
    function ja(e) {
      if (e instanceof xe)
        return $f(e);
      if (Array.isArray(e)) {
        let r = [e[0]];
        for (let n = 1; n < e.length; n++)
          r[n] = Er(e[n]);
        return r;
      }
      let t2 = {};
      for (let r in e)
        t2[r] = Er(e[r]);
      return t2;
    }
    function $f(e) {
      return new xe(e.strings, e.values);
    }
    function Er(e) {
      if (typeof e != "object" || e == null || e instanceof _e || Jt(e))
        return e;
      if (Gt(e))
        return new je(e.toFixed());
      if (qt(e))
        return /* @__PURE__ */ new Date(+e);
      if (ArrayBuffer.isView(e))
        return e.slice(0);
      if (Array.isArray(e)) {
        let t2 = e.length, r;
        for (r = Array(t2); t2--; )
          r[t2] = Er(e[t2]);
        return r;
      }
      if (typeof e == "object") {
        let t2 = {};
        for (let r in e)
          r === "__proto__" ? Object.defineProperty(t2, r, { value: Er(e[r]), configurable: true, enumerable: true, writable: true }) : t2[r] = Er(e[r]);
        return t2;
      }
      xt(e, "Unknown value");
    }
    function $a(e, t2, r, n = 0) {
      return e._createPrismaPromise((o) => {
        var s, a;
        let i = t2.customDataProxyFetch;
        return "transaction" in t2 && o !== void 0 && (((s = t2.transaction) == null ? void 0 : s.kind) === "batch" && t2.transaction.lock.then(), t2.transaction = o), n === r.length ? e._executeRequest(t2) : r[n]({ model: t2.model, operation: t2.model ? t2.action : t2.clientMethod, args: ja((a = t2.args) != null ? a : {}), __internalParams: t2, query: (u, l = t2) => {
          let c = l.customDataProxyFetch;
          return l.customDataProxyFetch = Ga(i, c), l.args = u, $a(e, l, r, n + 1);
        } });
      });
    }
    function qa(e, t2) {
      let { jsModelName: r, action: n, clientMethod: o } = t2, i = r ? n : o;
      if (e._extensions.isEmpty())
        return e._executeRequest(t2);
      let s = e._extensions.getAllQueryCallbacks(r != null ? r : "$none", i);
      return $a(e, t2, s);
    }
    function Va(e) {
      return (t2) => {
        let r = { requests: t2 }, n = t2[0].extensions.getAllBatchQueryCallbacks();
        return n.length ? Ka(r, n, 0, e) : e(r);
      };
    }
    function Ka(e, t2, r, n) {
      if (r === t2.length)
        return n(e);
      let o = e.customDataProxyFetch, i = e.requests[0].transaction;
      return t2[r]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: i ? { isolationLevel: i.kind === "batch" ? i.isolationLevel : void 0 } : void 0 }, __internalParams: e, query(s, a = e) {
        let u = a.customDataProxyFetch;
        return a.customDataProxyFetch = Ga(o, u), Ka(a, t2, r + 1, n);
      } });
    }
    var Ua = (e) => e;
    function Ga(e = Ua, t2 = Ua) {
      return (r) => e(t2(r));
    }
    d();
    p();
    f();
    d();
    p();
    f();
    function Qa(e, t2, r) {
      let n = $e(r);
      return !t2.result || !(t2.result.$allModels || t2.result[n]) ? e : qf({ ...e, ...Ja(t2.name, e, t2.result.$allModels), ...Ja(t2.name, e, t2.result[n]) });
    }
    function qf(e) {
      let t2 = new Ne(), r = (n, o) => t2.getOrCreate(n, () => o.has(n) ? [n] : (o.add(n), e[n] ? e[n].needs.flatMap((i) => r(i, o)) : [n]));
      return jt(e, (n) => ({ ...n, needs: r(n.name, /* @__PURE__ */ new Set()) }));
    }
    function Ja(e, t2, r) {
      return r ? jt(r, ({ needs: n, compute: o }, i) => ({ name: i, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Vf(t2, i, o) })) : {};
    }
    function Vf(e, t2, r) {
      var o;
      let n = (o = e == null ? void 0 : e[t2]) == null ? void 0 : o.compute;
      return n ? (i) => r({ ...i, [t2]: n(i) }) : r;
    }
    function Wa(e, t2) {
      if (!t2)
        return e;
      let r = { ...e };
      for (let n of Object.values(t2))
        if (e[n.name])
          for (let o of n.needs)
            r[o] = true;
      return r;
    }
    var kn = class {
      constructor(t2, r) {
        this.extension = t2;
        this.previous = r;
        this.computedFieldsCache = new Ne();
        this.modelExtensionsCache = new Ne();
        this.queryCallbacksCache = new Ne();
        this.clientExtensions = cr(() => {
          var t3, r2;
          return this.extension.client ? { ...(r2 = this.previous) == null ? void 0 : r2.getAllClientExtensions(), ...this.extension.client } : (t3 = this.previous) == null ? void 0 : t3.getAllClientExtensions();
        });
        this.batchCallbacks = cr(() => {
          var n, o, i;
          let t3 = (o = (n = this.previous) == null ? void 0 : n.getAllBatchQueryCallbacks()) != null ? o : [], r2 = (i = this.extension.query) == null ? void 0 : i.$__internalBatch;
          return r2 ? t3.concat(r2) : t3;
        });
      }
      getAllComputedFields(t2) {
        return this.computedFieldsCache.getOrCreate(t2, () => {
          var r;
          return Qa((r = this.previous) == null ? void 0 : r.getAllComputedFields(t2), this.extension, t2);
        });
      }
      getAllClientExtensions() {
        return this.clientExtensions.get();
      }
      getAllModelExtensions(t2) {
        return this.modelExtensionsCache.getOrCreate(t2, () => {
          var n, o;
          let r = $e(t2);
          return !this.extension.model || !(this.extension.model[r] || this.extension.model.$allModels) ? (n = this.previous) == null ? void 0 : n.getAllModelExtensions(t2) : { ...(o = this.previous) == null ? void 0 : o.getAllModelExtensions(t2), ...this.extension.model.$allModels, ...this.extension.model[r] };
        });
      }
      getAllQueryCallbacks(t2, r) {
        return this.queryCallbacksCache.getOrCreate(`${t2}:${r}`, () => {
          var s, a;
          let n = (a = (s = this.previous) == null ? void 0 : s.getAllQueryCallbacks(t2, r)) != null ? a : [], o = [], i = this.extension.query;
          return !i || !(i[t2] || i.$allModels || i[r] || i.$allOperations) ? n : (i[t2] !== void 0 && (i[t2][r] !== void 0 && o.push(i[t2][r]), i[t2].$allOperations !== void 0 && o.push(i[t2].$allOperations)), t2 !== "$none" && i.$allModels !== void 0 && (i.$allModels[r] !== void 0 && o.push(i.$allModels[r]), i.$allModels.$allOperations !== void 0 && o.push(i.$allModels.$allOperations)), i[r] !== void 0 && o.push(i[r]), i.$allOperations !== void 0 && o.push(i.$allOperations), n.concat(o));
        });
      }
      getAllBatchQueryCallbacks() {
        return this.batchCallbacks.get();
      }
    };
    var Dn = class e {
      constructor(t2) {
        this.head = t2;
      }
      static empty() {
        return new e();
      }
      static single(t2) {
        return new e(new kn(t2));
      }
      isEmpty() {
        return this.head === void 0;
      }
      append(t2) {
        return new e(new kn(t2, this.head));
      }
      getAllComputedFields(t2) {
        var r;
        return (r = this.head) == null ? void 0 : r.getAllComputedFields(t2);
      }
      getAllClientExtensions() {
        var t2;
        return (t2 = this.head) == null ? void 0 : t2.getAllClientExtensions();
      }
      getAllModelExtensions(t2) {
        var r;
        return (r = this.head) == null ? void 0 : r.getAllModelExtensions(t2);
      }
      getAllQueryCallbacks(t2, r) {
        var n, o;
        return (o = (n = this.head) == null ? void 0 : n.getAllQueryCallbacks(t2, r)) != null ? o : [];
      }
      getAllBatchQueryCallbacks() {
        var t2, r;
        return (r = (t2 = this.head) == null ? void 0 : t2.getAllBatchQueryCallbacks()) != null ? r : [];
      }
    };
    d();
    p();
    f();
    var Ha = he("prisma:client");
    var za = { Vercel: "vercel", "Netlify CI": "netlify" };
    function Za({ postinstall: e, ciName: t2, clientVersion: r }) {
      if (Ha("checkPlatformCaching:postinstall", e), Ha("checkPlatformCaching:ciName", t2), e === true && t2 && t2 in za) {
        let n = `Prisma has detected that this project was built on ${t2}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${za[t2]}-build`;
        throw console.error(n), new re(n, r);
      }
    }
    d();
    p();
    f();
    function Ya(e, t2) {
      return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [t2[0]]: { url: e.datasourceUrl } } : {} : {};
    }
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    function Zo({ error: e, user_facing_error: t2 }, r) {
      return t2.error_code ? new ce(t2.message, { code: t2.error_code, clientVersion: r, meta: t2.meta, batchRequestIdx: t2.batch_request_idx }) : new Se(e, { clientVersion: r, batchRequestIdx: t2.batch_request_idx });
    }
    d();
    p();
    f();
    var _n = class {
    };
    d();
    p();
    f();
    function Xa(e, t2) {
      return { batch: e, transaction: (t2 == null ? void 0 : t2.kind) === "batch" ? { isolationLevel: t2.options.isolationLevel } : void 0 };
    }
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    var Kf = "Cloudflare-Workers";
    var Gf = "node";
    function eu() {
      var e, t2, r;
      return typeof Netlify == "object" ? "netlify" : typeof EdgeRuntime == "string" ? "edge-light" : ((e = globalThis.navigator) == null ? void 0 : e.userAgent) === Kf ? "workerd" : globalThis.Deno ? "deno" : globalThis.__lagon__ ? "lagon" : ((r = (t2 = globalThis.process) == null ? void 0 : t2.release) == null ? void 0 : r.name) === Gf ? "node" : globalThis.Bun ? "bun" : globalThis.fastly ? "fastly" : "unknown";
    }
    function Nn({ inlineDatasources: e, overrideDatasources: t2, env: r, clientVersion: n }) {
      var u, l;
      let o, i = Object.keys(e)[0], s = (u = e[i]) == null ? void 0 : u.url, a = (l = t2[i]) == null ? void 0 : l.url;
      if (i === void 0 ? o = void 0 : a ? o = a : s != null && s.value ? o = s.value : s != null && s.fromEnvVar && (o = r[s.fromEnvVar]), (s == null ? void 0 : s.fromEnvVar) !== void 0 && o === void 0)
        throw eu() === "workerd" ? new re(`error: Environment variable not found: ${s.fromEnvVar}.

In Cloudflare module Workers, environment variables are available only in the Worker's \`env\` parameter of \`fetch\`.
To solve this, provide the connection string directly: https://pris.ly/d/cloudflare-datasource-url`, n) : new re(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
      if (o === void 0)
        throw new re("error: Missing URL environment variable, value, or override.", n);
      return o;
    }
    d();
    p();
    f();
    d();
    p();
    f();
    var Ln = class extends Error {
      constructor(r, n) {
        super(r);
        this.clientVersion = n.clientVersion, this.cause = n.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    var we = class extends Ln {
      constructor(r, n) {
        var o;
        super(r, n);
        this.isRetryable = (o = n.isRetryable) != null ? o : true;
      }
    };
    d();
    p();
    f();
    d();
    p();
    f();
    function q(e, t2) {
      return { ...e, isRetryable: t2 };
    }
    var Zt = class extends we {
      constructor(r) {
        super("This request must be retried", q(r, true));
        this.name = "ForcedRetryError";
        this.code = "P5001";
      }
    };
    k(Zt, "ForcedRetryError");
    d();
    p();
    f();
    var Et = class extends we {
      constructor(r, n) {
        super(r, q(n, false));
        this.name = "InvalidDatasourceError";
        this.code = "P5002";
      }
    };
    k(Et, "InvalidDatasourceError");
    d();
    p();
    f();
    var Pt = class extends we {
      constructor(r, n) {
        super(r, q(n, false));
        this.name = "NotImplementedYetError";
        this.code = "P5004";
      }
    };
    k(Pt, "NotImplementedYetError");
    d();
    p();
    f();
    d();
    p();
    f();
    var J = class extends we {
      constructor(r, n) {
        super(r, n);
        this.response = n.response;
        let o = this.response.headers.get("prisma-request-id");
        if (o) {
          let i = `(The request id was: ${o})`;
          this.message = this.message + " " + i;
        }
      }
    };
    var vt = class extends J {
      constructor(r) {
        super("Schema needs to be uploaded", q(r, true));
        this.name = "SchemaMissingError";
        this.code = "P5005";
      }
    };
    k(vt, "SchemaMissingError");
    d();
    p();
    f();
    d();
    p();
    f();
    var Yo = "This request could not be understood by the server";
    var Pr = class extends J {
      constructor(r, n, o) {
        super(n || Yo, q(r, false));
        this.name = "BadRequestError";
        this.code = "P5000";
        o && (this.code = o);
      }
    };
    k(Pr, "BadRequestError");
    d();
    p();
    f();
    var vr = class extends J {
      constructor(r, n) {
        super("Engine not started: healthcheck timeout", q(r, true));
        this.name = "HealthcheckTimeoutError";
        this.code = "P5013";
        this.logs = n;
      }
    };
    k(vr, "HealthcheckTimeoutError");
    d();
    p();
    f();
    var Ar = class extends J {
      constructor(r, n, o) {
        super(n, q(r, true));
        this.name = "EngineStartupError";
        this.code = "P5014";
        this.logs = o;
      }
    };
    k(Ar, "EngineStartupError");
    d();
    p();
    f();
    var Tr = class extends J {
      constructor(r) {
        super("Engine version is not supported", q(r, false));
        this.name = "EngineVersionNotSupportedError";
        this.code = "P5012";
      }
    };
    k(Tr, "EngineVersionNotSupportedError");
    d();
    p();
    f();
    var Xo = "Request timed out";
    var Cr = class extends J {
      constructor(r, n = Xo) {
        super(n, q(r, false));
        this.name = "GatewayTimeoutError";
        this.code = "P5009";
      }
    };
    k(Cr, "GatewayTimeoutError");
    d();
    p();
    f();
    var Jf = "Interactive transaction error";
    var Mr = class extends J {
      constructor(r, n = Jf) {
        super(n, q(r, false));
        this.name = "InteractiveTransactionError";
        this.code = "P5015";
      }
    };
    k(Mr, "InteractiveTransactionError");
    d();
    p();
    f();
    var Qf = "Request parameters are invalid";
    var Sr = class extends J {
      constructor(r, n = Qf) {
        super(n, q(r, false));
        this.name = "InvalidRequestError";
        this.code = "P5011";
      }
    };
    k(Sr, "InvalidRequestError");
    d();
    p();
    f();
    var ei = "Requested resource does not exist";
    var Rr = class extends J {
      constructor(r, n = ei) {
        super(n, q(r, false));
        this.name = "NotFoundError";
        this.code = "P5003";
      }
    };
    k(Rr, "NotFoundError");
    d();
    p();
    f();
    var ti = "Unknown server error";
    var Yt = class extends J {
      constructor(r, n, o) {
        super(n || ti, q(r, true));
        this.name = "ServerError";
        this.code = "P5006";
        this.logs = o;
      }
    };
    k(Yt, "ServerError");
    d();
    p();
    f();
    var ri = "Unauthorized, check your connection string";
    var Or = class extends J {
      constructor(r, n = ri) {
        super(n, q(r, false));
        this.name = "UnauthorizedError";
        this.code = "P5007";
      }
    };
    k(Or, "UnauthorizedError");
    d();
    p();
    f();
    var ni = "Usage exceeded, retry again later";
    var Fr = class extends J {
      constructor(r, n = ni) {
        super(n, q(r, true));
        this.name = "UsageExceededError";
        this.code = "P5008";
      }
    };
    k(Fr, "UsageExceededError");
    async function Wf(e) {
      let t2;
      try {
        t2 = await e.text();
      } catch (r) {
        return { type: "EmptyError" };
      }
      try {
        let r = JSON.parse(t2);
        if (typeof r == "string")
          switch (r) {
            case "InternalDataProxyError":
              return { type: "DataProxyError", body: r };
            default:
              return { type: "UnknownTextError", body: r };
          }
        if (typeof r == "object" && r !== null) {
          if ("is_panic" in r && "message" in r && "error_code" in r)
            return { type: "QueryEngineError", body: r };
          if ("EngineNotStarted" in r || "InteractiveTransactionMisrouted" in r || "InvalidRequestError" in r) {
            let n = Object.values(r)[0].reason;
            return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: r } : { type: "DataProxyError", body: r };
          }
        }
        return { type: "UnknownJsonError", body: r };
      } catch (r) {
        return t2 === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t2 };
      }
    }
    async function Ir(e, t2) {
      if (e.ok)
        return;
      let r = { clientVersion: t2, response: e }, n = await Wf(e);
      if (n.type === "QueryEngineError")
        throw new ce(n.body.message, { code: n.body.error_code, clientVersion: t2 });
      if (n.type === "DataProxyError") {
        if (n.body === "InternalDataProxyError")
          throw new Yt(r, "Internal Data Proxy error");
        if ("EngineNotStarted" in n.body) {
          if (n.body.EngineNotStarted.reason === "SchemaMissing")
            return new vt(r);
          if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported")
            throw new Tr(r);
          if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: o, logs: i } = n.body.EngineNotStarted.reason.EngineStartupError;
            throw new Ar(r, o, i);
          }
          if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: o, error_code: i } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
            throw new re(o, t2, i);
          }
          if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
            let { logs: o } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
            throw new vr(r, o);
          }
        }
        if ("InteractiveTransactionMisrouted" in n.body) {
          let o = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
          throw new Mr(r, o[n.body.InteractiveTransactionMisrouted.reason]);
        }
        if ("InvalidRequestError" in n.body)
          throw new Sr(r, n.body.InvalidRequestError.reason);
      }
      if (e.status === 401 || e.status === 403)
        throw new Or(r, Xt(ri, n));
      if (e.status === 404)
        return new Rr(r, Xt(ei, n));
      if (e.status === 429)
        throw new Fr(r, Xt(ni, n));
      if (e.status === 504)
        throw new Cr(r, Xt(Xo, n));
      if (e.status >= 500)
        throw new Yt(r, Xt(ti, n));
      if (e.status >= 400)
        throw new Pr(r, Xt(Yo, n));
    }
    function Xt(e, t2) {
      return t2.type === "EmptyError" ? e : `${e}: ${JSON.stringify(t2)}`;
    }
    d();
    p();
    f();
    function tu(e) {
      let t2 = Math.pow(2, e) * 50, r = Math.ceil(Math.random() * t2) - Math.ceil(t2 / 2), n = t2 + r;
      return new Promise((o) => setTimeout(() => o(n), n));
    }
    d();
    p();
    f();
    function ru(e) {
      var r;
      if (!!((r = e.generator) != null && r.previewFeatures.some((n) => n.toLowerCase().includes("metrics"))))
        throw new re("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
    }
    d();
    p();
    f();
    var nu = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.5.1-1.aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*", "@swc/core": "1.3.95", "@swc/jest": "0.2.29", "@types/jest": "29.5.5", "@types/node": "18.18.3", execa: "5.1.1", jest: "29.7.0", typescript: "5.2.2" };
    d();
    p();
    f();
    d();
    p();
    f();
    var kr = class extends we {
      constructor(r, n) {
        super(`Cannot fetch data from service:
${r}`, q(n, true));
        this.name = "RequestError";
        this.code = "P5010";
      }
    };
    k(kr, "RequestError");
    async function At(e, t2, r = (n) => n) {
      var o;
      let n = t2.clientVersion;
      try {
        return typeof fetch == "function" ? await r(fetch)(e, t2) : await r(oi)(e, t2);
      } catch (i) {
        console.log(e);
        let s = (o = i.message) != null ? o : "Unknown error";
        throw new kr(s, { clientVersion: n });
      }
    }
    function zf(e) {
      return { ...e.headers, "Content-Type": "application/json" };
    }
    function Zf(e) {
      return { method: e.method, headers: zf(e) };
    }
    function Yf(e, t2) {
      return { text: () => Promise.resolve(x.Buffer.concat(e).toString()), json: () => Promise.resolve().then(() => JSON.parse(x.Buffer.concat(e).toString())), ok: t2.statusCode >= 200 && t2.statusCode <= 299, status: t2.statusCode, url: t2.url, headers: new ii(t2.headers) };
    }
    async function oi(e, t2 = {}) {
      let r = Xf("https"), n = Zf(t2), o = [], { origin: i } = new URL(e);
      return new Promise((s, a) => {
        var l;
        let u = r.request(e, n, (c) => {
          let { statusCode: m, headers: { location: g } } = c;
          m >= 301 && m <= 399 && g && (g.startsWith("http") === false ? s(oi(`${i}${g}`, t2)) : s(oi(g, t2))), c.on("data", (w) => o.push(w)), c.on("end", () => s(Yf(o, c))), c.on("error", a);
        });
        u.on("error", a), u.end((l = t2.body) != null ? l : "");
      });
    }
    var Xf = typeof __require != "undefined" ? __require : () => {
    };
    var ii = class {
      constructor(t2 = {}) {
        this.headers = /* @__PURE__ */ new Map();
        for (let [r, n] of Object.entries(t2))
          if (typeof n == "string")
            this.headers.set(r, n);
          else if (Array.isArray(n))
            for (let o of n)
              this.headers.set(r, o);
      }
      append(t2, r) {
        this.headers.set(t2, r);
      }
      delete(t2) {
        this.headers.delete(t2);
      }
      get(t2) {
        var r;
        return (r = this.headers.get(t2)) != null ? r : null;
      }
      has(t2) {
        return this.headers.has(t2);
      }
      set(t2, r) {
        this.headers.set(t2, r);
      }
      forEach(t2, r) {
        for (let [n, o] of this.headers)
          t2.call(r, o, n, this);
      }
    };
    var ed = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
    var ou = he("prisma:client:dataproxyEngine");
    async function td(e, t2) {
      var s, a, u;
      let r = nu["@prisma/engines-version"], n = (s = t2.clientVersion) != null ? s : "unknown";
      if (y.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
        return y.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
      if (e.includes("accelerate") && n !== "0.0.0" && n !== "in-memory")
        return n;
      let [o, i] = (a = n == null ? void 0 : n.split("-")) != null ? a : [];
      if (i === void 0 && ed.test(o))
        return o;
      if (i !== void 0 || n === "0.0.0" || n === "in-memory") {
        if (e.startsWith("localhost") || e.startsWith("127.0.0.1"))
          return "0.0.0";
        let [l] = (u = r.split("-")) != null ? u : [], [c, m, g] = l.split("."), w = rd(`<=${c}.${m}.${g}`), E = await At(w, { clientVersion: n });
        if (!E.ok)
          throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${E.status} ${E.statusText}, response body: ${await E.text() || "<empty body>"}`);
        let b = await E.text();
        ou("length of body fetched from unpkg.com", b.length);
        let T;
        try {
          T = JSON.parse(b);
        } catch (S) {
          throw console.error("JSON.parse error: body fetched from unpkg.com: ", b), S;
        }
        return T.version;
      }
      throw new Pt("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
    }
    async function iu(e, t2) {
      let r = await td(e, t2);
      return ou("version", r), r;
    }
    function rd(e) {
      return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
    }
    var su = 3;
    var si = he("prisma:client:dataproxyEngine");
    var ai = class {
      constructor({ apiKey: t2, tracingHelper: r, logLevel: n, logQueries: o, engineHash: i }) {
        this.apiKey = t2, this.tracingHelper = r, this.logLevel = n, this.logQueries = o, this.engineHash = i;
      }
      build({ traceparent: t2, interactiveTransaction: r } = {}) {
        let n = { Authorization: `Bearer ${this.apiKey}`, "Prisma-Engine-Hash": this.engineHash };
        this.tracingHelper.isEnabled() && (n.traceparent = t2 != null ? t2 : this.tracingHelper.getTraceParent()), r && (n["X-transaction-id"] = r.id);
        let o = this.buildCaptureSettings();
        return o.length > 0 && (n["X-capture-telemetry"] = o.join(", ")), n;
      }
      buildCaptureSettings() {
        let t2 = [];
        return this.tracingHelper.isEnabled() && t2.push("tracing"), this.logLevel && t2.push(this.logLevel), this.logQueries && t2.push("query"), t2;
      }
    };
    var Dr = class extends _n {
      constructor(r) {
        super();
        ru(r), this.config = r, this.env = { ...this.config.env, ...y.env }, this.inlineSchema = r.inlineSchema, this.inlineDatasources = r.inlineDatasources, this.inlineSchemaHash = r.inlineSchemaHash, this.clientVersion = r.clientVersion, this.engineHash = r.engineVersion, this.logEmitter = r.logEmitter, this.tracingHelper = this.config.tracingHelper;
      }
      apiKey() {
        return this.headerBuilder.apiKey;
      }
      version() {
        return this.engineHash;
      }
      async start() {
        this.startPromise !== void 0 && await this.startPromise, this.startPromise = (async () => {
          let [r, n] = this.extractHostAndApiKey();
          this.host = r, this.headerBuilder = new ai({ apiKey: n, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await iu(r, this.config), si("host", this.host);
        })(), await this.startPromise;
      }
      async stop() {
      }
      propagateResponseExtensions(r) {
        var n, o;
        (n = r == null ? void 0 : r.logs) != null && n.length && r.logs.forEach((i) => {
          switch (i.level) {
            case "debug":
            case "error":
            case "trace":
            case "warn":
            case "info":
              break;
            case "query": {
              let s = typeof i.attributes.query == "string" ? i.attributes.query : "";
              if (!this.tracingHelper.isEnabled()) {
                let [a] = s.split("/* traceparent");
                s = a;
              }
              this.logEmitter.emit("query", { query: s, timestamp: i.timestamp, duration: i.attributes.duration_ms, params: i.attributes.params, target: i.attributes.target });
            }
          }
        }), (o = r == null ? void 0 : r.traces) != null && o.length && this.tracingHelper.createEngineSpan({ span: true, spans: r.traces });
      }
      on(r, n) {
        if (r === "beforeExit")
          throw new Error('"beforeExit" hook is not applicable to the remote query engine');
        this.logEmitter.on(r, n);
      }
      async url(r) {
        return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
      }
      async uploadSchema() {
        let r = { name: "schemaUpload", internal: true };
        return this.tracingHelper.runInChildSpan(r, async () => {
          let n = await At(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
          n.ok || si("schema response status", n.status);
          let o = await Ir(n, this.clientVersion);
          if (o)
            throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${o.message}` }), o;
          this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})` });
        });
      }
      request(r, { traceparent: n, interactiveTransaction: o, customDataProxyFetch: i }) {
        return this.requestInternal({ body: r, traceparent: n, interactiveTransaction: o, customDataProxyFetch: i });
      }
      async requestBatch(r, { traceparent: n, transaction: o, customDataProxyFetch: i }) {
        let s = (o == null ? void 0 : o.kind) === "itx" ? o.options : void 0, a = Xa(r, o), { batchResult: u, elapsed: l } = await this.requestInternal({ body: a, customDataProxyFetch: i, interactiveTransaction: s, traceparent: n });
        return u.map((c) => "errors" in c && c.errors.length > 0 ? Zo(c.errors[0], this.clientVersion) : { data: c, elapsed: l });
      }
      requestInternal({ body: r, traceparent: n, customDataProxyFetch: o, interactiveTransaction: i }) {
        return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: s }) => {
          let a = i ? `${i.payload.endpoint}/graphql` : await this.url("graphql");
          s(a);
          let u = await At(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: n, interactiveTransaction: i }), body: JSON.stringify(r), clientVersion: this.clientVersion }, o);
          u.ok || si("graphql response status", u.status), await this.handleError(await Ir(u, this.clientVersion));
          let l = await u.json(), c = l.extensions;
          if (c && this.propagateResponseExtensions(c), l.errors)
            throw l.errors.length === 1 ? Zo(l.errors[0], this.config.clientVersion) : new Se(l.errors, { clientVersion: this.config.clientVersion });
          return l;
        } });
      }
      async transaction(r, n, o) {
        let i = { start: "starting", commit: "committing", rollback: "rolling back" };
        return this.withRetry({ actionGerund: `${i[r]} transaction`, callback: async ({ logHttpCall: s }) => {
          var a, u;
          if (r === "start") {
            let l = JSON.stringify({ max_wait: (a = o == null ? void 0 : o.maxWait) != null ? a : 2e3, timeout: (u = o == null ? void 0 : o.timeout) != null ? u : 5e3, isolation_level: o == null ? void 0 : o.isolationLevel }), c = await this.url("transaction/start");
            s(c);
            let m = await At(c, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), body: l, clientVersion: this.clientVersion });
            await this.handleError(await Ir(m, this.clientVersion));
            let g = await m.json(), w = g.extensions;
            w && this.propagateResponseExtensions(w);
            let E = g.id, b = g["data-proxy"].endpoint;
            return { id: E, payload: { endpoint: b } };
          } else {
            let l = `${o.payload.endpoint}/${r}`;
            s(l);
            let c = await At(l, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), clientVersion: this.clientVersion });
            await this.handleError(await Ir(c, this.clientVersion));
            let g = (await c.json()).extensions;
            g && this.propagateResponseExtensions(g);
            return;
          }
        } });
      }
      extractHostAndApiKey() {
        let r = { clientVersion: this.clientVersion }, n = Object.keys(this.inlineDatasources)[0], o = Nn({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), i;
        try {
          i = new URL(o);
        } catch (c) {
          throw new Et(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
        }
        let { protocol: s, host: a, searchParams: u } = i;
        if (s !== "prisma:")
          throw new Et(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
        let l = u.get("api_key");
        if (l === null || l.length < 1)
          throw new Et(`Error validating datasource \`${n}\`: the URL must contain a valid API key`, r);
        return [a, l];
      }
      metrics() {
        throw new Pt("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
      }
      async withRetry(r) {
        var n;
        for (let o = 0; ; o++) {
          let i = (s) => {
            this.logEmitter.emit("info", { message: `Calling ${s} (n=${o})` });
          };
          try {
            return await r.callback({ logHttpCall: i });
          } catch (s) {
            if (!(s instanceof we) || !s.isRetryable)
              throw s;
            if (o >= su)
              throw s instanceof Zt ? s.cause : s;
            this.logEmitter.emit("warn", { message: `Attempt ${o + 1}/${su} failed for ${r.actionGerund}: ${(n = s.message) != null ? n : "(unknown)"}` });
            let a = await tu(o);
            this.logEmitter.emit("warn", { message: `Retrying after ${a}ms` });
          }
        }
      }
      async handleError(r) {
        if (r instanceof vt)
          throw await this.uploadSchema(), new Zt({ clientVersion: this.clientVersion, cause: r });
        if (r)
          throw r;
      }
    };
    function au(e, t2) {
      let r;
      try {
        r = Nn({ inlineDatasources: t2.inlineDatasources, overrideDatasources: t2.overrideDatasources, env: { ...t2.env, ...y.env }, clientVersion: t2.clientVersion });
      } catch (o) {
      }
      e.noEngine !== true && (r != null && r.startsWith("prisma://")) && lr("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
      let n = Co(t2.generator);
      return r != null && r.startsWith("prisma://") || e.noEngine, new Dr(t2);
      throw new pe("Invalid client engine type, please use `library` or `binary`", { clientVersion: t2.clientVersion });
    }
    d();
    p();
    f();
    function Bn({ generator: e }) {
      var t2;
      return (t2 = e == null ? void 0 : e.previewFeatures) != null ? t2 : [];
    }
    d();
    p();
    f();
    d();
    p();
    f();
    d();
    p();
    f();
    var du = ve(ui());
    d();
    p();
    f();
    function pu(e, t2) {
      let r = fu(e), n = nd(r), o = id(n);
      o ? jn(o, t2) : t2.addErrorMessage(() => "Unknown error");
    }
    function fu(e) {
      return e.errors.flatMap((t2) => t2.kind === "Union" ? fu(t2) : [t2]);
    }
    function nd(e) {
      let t2 = /* @__PURE__ */ new Map(), r = [];
      for (let n of e) {
        if (n.kind !== "InvalidArgumentType") {
          r.push(n);
          continue;
        }
        let o = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, i = t2.get(o);
        i ? t2.set(o, { ...n, argument: { ...n.argument, typeNames: od(i.argument.typeNames, n.argument.typeNames) } }) : t2.set(o, n);
      }
      return r.push(...t2.values()), r;
    }
    function od(e, t2) {
      return [...new Set(e.concat(t2))];
    }
    function id(e) {
      return Io(e, (t2, r) => {
        let n = lu(t2), o = lu(r);
        return n !== o ? n - o : cu(t2) - cu(r);
      });
    }
    function lu(e) {
      let t2 = 0;
      return Array.isArray(e.selectionPath) && (t2 += e.selectionPath.length), Array.isArray(e.argumentPath) && (t2 += e.argumentPath.length), t2;
    }
    function cu(e) {
      switch (e.kind) {
        case "InvalidArgumentValue":
        case "ValueTooLarge":
          return 20;
        case "InvalidArgumentType":
          return 10;
        case "RequiredArgumentMissing":
          return -10;
        default:
          return 0;
      }
    }
    d();
    p();
    f();
    var Qe = class {
      constructor(t2, r) {
        this.name = t2;
        this.value = r;
        this.isRequired = false;
      }
      makeRequired() {
        return this.isRequired = true, this;
      }
      write(t2) {
        let { colors: { green: r } } = t2.context;
        t2.addMarginSymbol(r(this.isRequired ? "+" : "?")), t2.write(r(this.name)), this.isRequired || t2.write(r("?")), t2.write(r(": ")), typeof this.value == "string" ? t2.write(r(this.value)) : t2.write(this.value);
      }
    };
    d();
    p();
    f();
    var Un = class {
      constructor() {
        this.fields = [];
      }
      addField(t2, r) {
        return this.fields.push({ write(n) {
          let { green: o, dim: i } = n.context.colors;
          n.write(o(i(`${t2}: ${r}`))).addMarginSymbol(o(i("+")));
        } }), this;
      }
      write(t2) {
        let { colors: { green: r } } = t2.context;
        t2.writeLine(r("{")).withIndent(() => {
          t2.writeJoined(Qt, this.fields).newLine();
        }).write(r("}")).addMarginSymbol(r("+"));
      }
    };
    function jn(e, t2) {
      switch (e.kind) {
        case "IncludeAndSelect":
          sd(e, t2);
          break;
        case "IncludeOnScalar":
          ad(e, t2);
          break;
        case "EmptySelection":
          ud(e, t2);
          break;
        case "UnknownSelectionField":
          ld(e, t2);
          break;
        case "UnknownArgument":
          cd(e, t2);
          break;
        case "UnknownInputField":
          pd(e, t2);
          break;
        case "RequiredArgumentMissing":
          fd(e, t2);
          break;
        case "InvalidArgumentType":
          dd(e, t2);
          break;
        case "InvalidArgumentValue":
          md(e, t2);
          break;
        case "ValueTooLarge":
          gd(e, t2);
          break;
        case "SomeFieldsMissing":
          yd(e, t2);
          break;
        case "TooManyFieldsGiven":
          hd(e, t2);
          break;
        case "Union":
          pu(e, t2);
          break;
        default:
          throw new Error("not implemented: " + e.kind);
      }
    }
    function sd(e, t2) {
      var n, o;
      let r = t2.arguments.getDeepSubSelectionValue(e.selectionPath);
      r && r instanceof ne && ((n = r.getField("include")) == null || n.markAsError(), (o = r.getField("select")) == null || o.markAsError()), t2.addErrorMessage((i) => `Please ${i.bold("either")} use ${i.green("`include`")} or ${i.green("`select`")}, but ${i.red("not both")} at the same time.`);
    }
    function ad(e, t2) {
      var s, a;
      let [r, n] = $n(e.selectionPath), o = e.outputType, i = (s = t2.arguments.getDeepSelectionParent(r)) == null ? void 0 : s.value;
      if (i && ((a = i.getField(n)) == null || a.markAsError(), o))
        for (let u of o.fields)
          u.isRelation && i.addSuggestion(new Qe(u.name, "true"));
      t2.addErrorMessage((u) => {
        let l = `Invalid scalar field ${u.red(`\`${n}\``)} for ${u.bold("include")} statement`;
        return o ? l += ` on model ${u.bold(o.name)}. ${_r(u)}` : l += ".", l += `
Note that ${u.bold("include")} statements only accept relation fields.`, l;
      });
    }
    function ud(e, t2) {
      var i, s;
      let r = e.outputType, n = (i = t2.arguments.getDeepSelectionParent(e.selectionPath)) == null ? void 0 : i.value, o = (s = n == null ? void 0 : n.isEmpty()) != null ? s : false;
      n && (n.removeAllFields(), yu(n, r)), t2.addErrorMessage((a) => o ? `The ${a.red("`select`")} statement for type ${a.bold(r.name)} must not be empty. ${_r(a)}` : `The ${a.red("`select`")} statement for type ${a.bold(r.name)} needs ${a.bold("at least one truthy value")}.`);
    }
    function ld(e, t2) {
      var i;
      let [r, n] = $n(e.selectionPath), o = t2.arguments.getDeepSelectionParent(r);
      o && ((i = o.value.getField(n)) == null || i.markAsError(), yu(o.value, e.outputType)), t2.addErrorMessage((s) => {
        let a = [`Unknown field ${s.red(`\`${n}\``)}`];
        return o && a.push(`for ${s.bold(o.kind)} statement`), a.push(`on model ${s.bold(`\`${e.outputType.name}\``)}.`), a.push(_r(s)), a.join(" ");
      });
    }
    function cd(e, t2) {
      var o;
      let r = e.argumentPath[0], n = t2.arguments.getDeepSubSelectionValue(e.selectionPath);
      n instanceof ne && ((o = n.getField(r)) == null || o.markAsError(), xd(n, e.arguments)), t2.addErrorMessage((i) => mu(i, r, e.arguments.map((s) => s.name)));
    }
    function pd(e, t2) {
      var i;
      let [r, n] = $n(e.argumentPath), o = t2.arguments.getDeepSubSelectionValue(e.selectionPath);
      if (o instanceof ne) {
        (i = o.getDeepField(e.argumentPath)) == null || i.markAsError();
        let s = o.getDeepFieldValue(r);
        s instanceof ne && hu(s, e.inputType);
      }
      t2.addErrorMessage((s) => mu(s, n, e.inputType.fields.map((a) => a.name)));
    }
    function mu(e, t2, r) {
      let n = [`Unknown argument \`${e.red(t2)}\`.`], o = wd(t2, r);
      return o && n.push(`Did you mean \`${e.green(o)}\`?`), r.length > 0 && n.push(_r(e)), n.join(" ");
    }
    function fd(e, t2) {
      let r;
      t2.addErrorMessage((u) => (r == null ? void 0 : r.value) instanceof oe && r.value.text === "null" ? `Argument \`${u.green(i)}\` must not be ${u.red("null")}.` : `Argument \`${u.green(i)}\` is missing.`);
      let n = t2.arguments.getDeepSubSelectionValue(e.selectionPath);
      if (!(n instanceof ne))
        return;
      let [o, i] = $n(e.argumentPath), s = new Un(), a = n.getDeepFieldValue(o);
      if (a instanceof ne)
        if (r = a.getField(i), r && a.removeField(i), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
          for (let u of e.inputTypes[0].fields)
            s.addField(u.name, u.typeNames.join(" | "));
          a.addSuggestion(new Qe(i, s).makeRequired());
        } else {
          let u = e.inputTypes.map(gu).join(" | ");
          a.addSuggestion(new Qe(i, u).makeRequired());
        }
    }
    function gu(e) {
      return e.kind === "list" ? `${gu(e.elementType)}[]` : e.name;
    }
    function dd(e, t2) {
      var o;
      let r = e.argument.name, n = t2.arguments.getDeepSubSelectionValue(e.selectionPath);
      n instanceof ne && ((o = n.getDeepFieldValue(e.argumentPath)) == null || o.markAsError()), t2.addErrorMessage((i) => {
        let s = qn("or", e.argument.typeNames.map((a) => i.green(a)));
        return `Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${s}, provided ${i.red(e.inferredType)}.`;
      });
    }
    function md(e, t2) {
      var o;
      let r = e.argument.name, n = t2.arguments.getDeepSubSelectionValue(e.selectionPath);
      n instanceof ne && ((o = n.getDeepFieldValue(e.argumentPath)) == null || o.markAsError()), t2.addErrorMessage((i) => {
        let s = [`Invalid value for argument \`${i.bold(r)}\``];
        if (e.underlyingError && s.push(`: ${e.underlyingError}`), s.push("."), e.argument.typeNames.length > 0) {
          let a = qn("or", e.argument.typeNames.map((u) => i.green(u)));
          s.push(` Expected ${a}.`);
        }
        return s.join("");
      });
    }
    function gd(e, t2) {
      let r = e.argument.name, n = t2.arguments.getDeepSubSelectionValue(e.selectionPath), o;
      if (n instanceof ne) {
        let i = n.getDeepField(e.argumentPath), s = i == null ? void 0 : i.value;
        s == null || s.markAsError(), s instanceof oe && (o = s.text);
      }
      t2.addErrorMessage((i) => {
        let s = ["Unable to fit value"];
        return o && s.push(i.red(o)), s.push(`into a 64-bit signed integer for field \`${i.bold(r)}\``), s.join(" ");
      });
    }
    function yd(e, t2) {
      let r = e.argumentPath[e.argumentPath.length - 1], n = t2.arguments.getDeepSubSelectionValue(e.selectionPath);
      if (n instanceof ne) {
        let o = n.getDeepFieldValue(e.argumentPath);
        o instanceof ne && hu(o, e.inputType);
      }
      t2.addErrorMessage((o) => {
        let i = [`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];
        return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? i.push(`${o.green("at least one of")} ${qn("or", e.constraints.requiredFields.map((s) => `\`${o.bold(s)}\``))} arguments.`) : i.push(`${o.green("at least one")} argument.`) : i.push(`${o.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), i.push(_r(o)), i.join(" ");
      });
    }
    function hd(e, t2) {
      let r = e.argumentPath[e.argumentPath.length - 1], n = t2.arguments.getDeepSubSelectionValue(e.selectionPath), o = [];
      if (n instanceof ne) {
        let i = n.getDeepFieldValue(e.argumentPath);
        i instanceof ne && (i.markAsError(), o = Object.keys(i.getFields()));
      }
      t2.addErrorMessage((i) => {
        let s = [`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];
        return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${i.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${i.green("at most one")} argument,`) : s.push(`${i.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${qn("and", o.map((a) => i.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
      });
    }
    function yu(e, t2) {
      for (let r of t2.fields)
        e.hasField(r.name) || e.addSuggestion(new Qe(r.name, "true"));
    }
    function xd(e, t2) {
      for (let r of t2)
        e.hasField(r.name) || e.addSuggestion(new Qe(r.name, r.typeNames.join(" | ")));
    }
    function hu(e, t2) {
      if (t2.kind === "object")
        for (let r of t2.fields)
          e.hasField(r.name) || e.addSuggestion(new Qe(r.name, r.typeNames.join(" | ")));
    }
    function $n(e) {
      let t2 = [...e], r = t2.pop();
      if (!r)
        throw new Error("unexpected empty path");
      return [t2, r];
    }
    function _r({ green: e, enabled: t2 }) {
      return "Available options are " + (t2 ? `listed in ${e("green")}` : "marked with ?") + ".";
    }
    function qn(e, t2) {
      if (t2.length === 1)
        return t2[0];
      let r = [...t2], n = r.pop();
      return `${r.join(", ")} ${e} ${n}`;
    }
    var bd = 3;
    function wd(e, t2) {
      let r = 1 / 0, n;
      for (let o of t2) {
        let i = (0, du.default)(e, o);
        i > bd || i < r && (r = i, n = o);
      }
      return n;
    }
    function Vn({ args: e, errors: t2, errorFormat: r, callsite: n, originalMethod: o, clientVersion: i }) {
      let s = Mn(e);
      for (let m of t2)
        jn(m, s);
      let a = r === "pretty" ? ma : Tn, u = s.renderAllMessages(a), l = new $t(0, { colors: a }).write(s).toString(), c = zt({ message: u, callsite: n, originalMethod: o, showColors: r === "pretty", callArguments: l });
      throw new pe(c, { clientVersion: i });
    }
    var Ed = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
    function xu({ modelName: e, action: t2, args: r, runtimeDataModel: n, extensions: o, callsite: i, clientMethod: s, errorFormat: a, clientVersion: u }) {
      let l = new li({ runtimeDataModel: n, modelName: e, action: t2, rootArgs: r, callsite: i, extensions: o, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a, clientVersion: u });
      return { modelName: e, action: Ed[t2], query: ci(r, l) };
    }
    function ci({ select: e, include: t2, ...r } = {}, n) {
      return { arguments: wu(r, n), selection: Pd(e, t2, n) };
    }
    function Pd(e, t2, r) {
      return e && t2 && r.throwValidationError({ kind: "IncludeAndSelect", selectionPath: r.getSelectionPath() }), e ? Td(e, r) : vd(r, t2);
    }
    function vd(e, t2) {
      let r = {};
      return e.model && !e.isRawAction() && (r.$composites = true, r.$scalars = true), t2 && Ad(r, t2, e), r;
    }
    function Ad(e, t2, r) {
      for (let [n, o] of Object.entries(t2)) {
        let i = r.findField(n);
        i && (i == null ? void 0 : i.kind) !== "object" && r.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r.getSelectionPath().concat(n), outputType: r.getOutputTypeDescription() }), o === true ? e[n] = true : typeof o == "object" && (e[n] = ci(o, r.nestSelection(n)));
      }
    }
    function Td(e, t2) {
      let r = {}, n = t2.getComputedFields(), o = Wa(e, n);
      for (let [i, s] of Object.entries(o)) {
        let a = t2.findField(i);
        n != null && n[i] && !a || (s === true ? r[i] = true : typeof s == "object" && (r[i] = ci(s, t2.nestSelection(i))));
      }
      return r;
    }
    function bu(e, t2) {
      if (e === null)
        return null;
      if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
        return e;
      if (typeof e == "bigint")
        return { $type: "BigInt", value: String(e) };
      if (qt(e)) {
        if (gn(e))
          return { $type: "DateTime", value: e.toISOString() };
        t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t2.getSelectionPath(), argumentPath: t2.getArgumentPath(), argument: { name: t2.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
      }
      if (Jt(e))
        return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
      if (Array.isArray(e))
        return Cd(e, t2);
      if (ArrayBuffer.isView(e))
        return { $type: "Bytes", value: x.Buffer.from(e).toString("base64") };
      if (Md(e))
        return e.values;
      if (Gt(e))
        return { $type: "Decimal", value: e.toFixed() };
      if (e instanceof _e) {
        if (e !== pn.instances[e._getName()])
          throw new Error("Invalid ObjectEnumValue");
        return { $type: "Enum", value: e._getName() };
      }
      if (Sd(e))
        return e.toJSON();
      if (typeof e == "object")
        return wu(e, t2);
      t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t2.getSelectionPath(), argumentPath: t2.getArgumentPath(), argument: { name: t2.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
    }
    function wu(e, t2) {
      if (e.$type)
        return { $type: "Json", value: JSON.stringify(e) };
      let r = {};
      for (let n in e) {
        let o = e[n];
        o !== void 0 && (r[n] = bu(o, t2.nestArgument(n)));
      }
      return r;
    }
    function Cd(e, t2) {
      let r = [];
      for (let n = 0; n < e.length; n++) {
        let o = t2.nestArgument(String(n)), i = e[n];
        i === void 0 && t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: o.getSelectionPath(), argumentPath: o.getArgumentPath(), argument: { name: `${t2.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), r.push(bu(i, o));
      }
      return r;
    }
    function Md(e) {
      return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
    }
    function Sd(e) {
      return typeof e == "object" && e !== null && typeof e.toJSON == "function";
    }
    var li = class e {
      constructor(t2) {
        this.params = t2;
        this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
      }
      throwValidationError(t2) {
        var r;
        Vn({ errors: [t2], originalMethod: this.params.originalMethod, args: (r = this.params.rootArgs) != null ? r : {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
      }
      getSelectionPath() {
        return this.params.selectionPath;
      }
      getArgumentPath() {
        return this.params.argumentPath;
      }
      getArgumentName() {
        return this.params.argumentPath[this.params.argumentPath.length - 1];
      }
      getOutputTypeDescription() {
        if (!(!this.params.modelName || !this.model))
          return { name: this.params.modelName, fields: this.model.fields.map((t2) => ({ name: t2.name, typeName: "boolean", isRelation: t2.kind === "object" })) };
      }
      isRawAction() {
        return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
      }
      getComputedFields() {
        if (this.params.modelName)
          return this.params.extensions.getAllComputedFields(this.params.modelName);
      }
      findField(t2) {
        var r;
        return (r = this.model) == null ? void 0 : r.fields.find((n) => n.name === t2);
      }
      nestSelection(t2) {
        let r = this.findField(t2), n = (r == null ? void 0 : r.kind) === "object" ? r.type : void 0;
        return new e({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(t2) });
      }
      nestArgument(t2) {
        return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(t2) });
      }
    };
    d();
    p();
    f();
    var Eu = (e) => ({ command: e });
    d();
    p();
    f();
    d();
    p();
    f();
    var Pu = (e) => e.strings.reduce((t2, r, n) => `${t2}@P${n}${r}`);
    d();
    p();
    f();
    function Nr(e) {
      try {
        return vu(e, "fast");
      } catch (t2) {
        return vu(e, "slow");
      }
    }
    function vu(e, t2) {
      return JSON.stringify(e.map((r) => Rd(r, t2)));
    }
    function Rd(e, t2) {
      return typeof e == "bigint" ? { prisma__type: "bigint", prisma__value: e.toString() } : qt(e) ? { prisma__type: "date", prisma__value: e.toJSON() } : je.isDecimal(e) ? { prisma__type: "decimal", prisma__value: e.toJSON() } : x.Buffer.isBuffer(e) ? { prisma__type: "bytes", prisma__value: e.toString("base64") } : Od(e) || ArrayBuffer.isView(e) ? { prisma__type: "bytes", prisma__value: x.Buffer.from(e).toString("base64") } : typeof e == "object" && t2 === "slow" ? Tu(e) : e;
    }
    function Od(e) {
      return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
    }
    function Tu(e) {
      if (typeof e != "object" || e === null)
        return e;
      if (typeof e.toJSON == "function")
        return e.toJSON();
      if (Array.isArray(e))
        return e.map(Au);
      let t2 = {};
      for (let r of Object.keys(e))
        t2[r] = Au(e[r]);
      return t2;
    }
    function Au(e) {
      return typeof e == "bigint" ? e.toString() : Tu(e);
    }
    var Fd = /^(\s*alter\s)/i;
    var Cu = he("prisma:client");
    function pi(e, t2, r, n) {
      if (!(e !== "postgresql" && e !== "cockroachdb") && r.length > 0 && Fd.exec(t2))
        throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
    }
    var fi = ({ clientMethod: e, activeProvider: t2, activeProviderFlavour: r }) => (n) => {
      r !== void 0 && (t2 = r);
      let o = "", i;
      if (Array.isArray(n)) {
        let [s, ...a] = n;
        o = s, i = { values: Nr(a || []), __prismaRawParameters__: true };
      } else
        switch (t2) {
          case "sqlite":
          case "mysql": {
            o = n.sql, i = { values: Nr(n.values), __prismaRawParameters__: true };
            break;
          }
          case "cockroachdb":
          case "postgresql":
          case "postgres": {
            o = n.text, i = { values: Nr(n.values), __prismaRawParameters__: true };
            break;
          }
          case "sqlserver": {
            o = Pu(n), i = { values: Nr(n.values), __prismaRawParameters__: true };
            break;
          }
          default:
            throw new Error(`The ${t2} provider does not support ${e}`);
        }
      return i != null && i.values ? Cu(`prisma.${e}(${o}, ${i.values})`) : Cu(`prisma.${e}(${o})`), { query: o, parameters: i };
    };
    var Mu = { requestArgsToMiddlewareArgs(e) {
      return [e.strings, ...e.values];
    }, middlewareArgsToRequestArgs(e) {
      let [t2, ...r] = e;
      return new xe(t2, r);
    } };
    var Su = { requestArgsToMiddlewareArgs(e) {
      return [e];
    }, middlewareArgsToRequestArgs(e) {
      return e[0];
    } };
    d();
    p();
    f();
    function di(e) {
      return function(r) {
        let n, o = (i = e) => {
          try {
            return i === void 0 || (i == null ? void 0 : i.kind) === "itx" ? n != null ? n : n = Ru(r(i)) : Ru(r(i));
          } catch (s) {
            return Promise.reject(s);
          }
        };
        return { then(i, s) {
          return o().then(i, s);
        }, catch(i) {
          return o().catch(i);
        }, finally(i) {
          return o().finally(i);
        }, requestTransaction(i) {
          let s = o(i);
          return s.requestTransaction ? s.requestTransaction(i) : s;
        }, [Symbol.toStringTag]: "PrismaPromise" };
      };
    }
    function Ru(e) {
      return typeof e.then == "function" ? e : Promise.resolve(e);
    }
    d();
    p();
    f();
    var Ou = { isEnabled() {
      return false;
    }, getTraceParent() {
      return "00-10-10-00";
    }, async createEngineSpan() {
    }, getActiveContext() {
    }, runInChildSpan(e, t2) {
      return t2();
    } };
    var mi = class {
      isEnabled() {
        return this.getGlobalTracingHelper().isEnabled();
      }
      getTraceParent(t2) {
        return this.getGlobalTracingHelper().getTraceParent(t2);
      }
      createEngineSpan(t2) {
        return this.getGlobalTracingHelper().createEngineSpan(t2);
      }
      getActiveContext() {
        return this.getGlobalTracingHelper().getActiveContext();
      }
      runInChildSpan(t2, r) {
        return this.getGlobalTracingHelper().runInChildSpan(t2, r);
      }
      getGlobalTracingHelper() {
        var t2, r;
        return (r = (t2 = globalThis.PRISMA_INSTRUMENTATION) == null ? void 0 : t2.helper) != null ? r : Ou;
      }
    };
    function Fu(e) {
      return e.includes("tracing") ? new mi() : Ou;
    }
    d();
    p();
    f();
    function Iu(e, t2 = () => {
    }) {
      let r, n = new Promise((o) => r = o);
      return { then(o) {
        return --e === 0 && r(t2()), o == null ? void 0 : o(n);
      } };
    }
    d();
    p();
    f();
    var Id = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
    var gi = Id;
    d();
    p();
    f();
    function ku(e) {
      return typeof e == "string" ? e : e.reduce((t2, r) => {
        let n = typeof r == "string" ? r : r.level;
        return n === "query" ? t2 : t2 && (r === "info" || t2 === "info") ? "info" : n;
      }, void 0);
    }
    d();
    p();
    f();
    var Kn = class {
      constructor() {
        this._middlewares = [];
      }
      use(t2) {
        this._middlewares.push(t2);
      }
      get(t2) {
        return this._middlewares[t2];
      }
      has(t2) {
        return !!this._middlewares[t2];
      }
      length() {
        return this._middlewares.length;
      }
    };
    d();
    p();
    f();
    var _u = ve(Vs());
    d();
    p();
    f();
    function Gn(e) {
      return typeof e.batchRequestIdx == "number";
    }
    d();
    p();
    f();
    function Jn(e) {
      return e === null ? e : Array.isArray(e) ? e.map(Jn) : typeof e == "object" ? kd(e) ? Dd(e) : jt(e, Jn) : e;
    }
    function kd(e) {
      return e !== null && typeof e == "object" && typeof e.$type == "string";
    }
    function Dd({ $type: e, value: t2 }) {
      switch (e) {
        case "BigInt":
          return BigInt(t2);
        case "Bytes":
          return x.Buffer.from(t2, "base64");
        case "DateTime":
          return new Date(t2);
        case "Decimal":
          return new je(t2);
        case "Json":
          return JSON.parse(t2);
        default:
          xt(t2, "Unknown tagged value");
      }
    }
    d();
    p();
    f();
    function Du(e) {
      if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow")
        return;
      let t2 = [];
      return e.modelName && t2.push(e.modelName), e.query.arguments && t2.push(yi(e.query.arguments)), t2.push(yi(e.query.selection)), t2.join("");
    }
    function yi(e) {
      return `(${Object.keys(e).sort().map((r) => {
        let n = e[r];
        return typeof n == "object" && n !== null ? `(${r} ${yi(n)})` : r;
      }).join(" ")})`;
    }
    d();
    p();
    f();
    var _d = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
    function hi(e) {
      return _d[e];
    }
    d();
    p();
    f();
    var Qn = class {
      constructor(t2) {
        this.options = t2;
        this.tickActive = false;
        this.batches = {};
      }
      request(t2) {
        let r = this.options.batchBy(t2);
        return r ? (this.batches[r] || (this.batches[r] = [], this.tickActive || (this.tickActive = true, y.nextTick(() => {
          this.dispatchBatches(), this.tickActive = false;
        }))), new Promise((n, o) => {
          this.batches[r].push({ request: t2, resolve: n, reject: o });
        })) : this.options.singleLoader(t2);
      }
      dispatchBatches() {
        for (let t2 in this.batches) {
          let r = this.batches[t2];
          delete this.batches[t2], r.length === 1 ? this.options.singleLoader(r[0].request).then((n) => {
            n instanceof Error ? r[0].reject(n) : r[0].resolve(n);
          }).catch((n) => {
            r[0].reject(n);
          }) : (r.sort((n, o) => this.options.batchOrder(n.request, o.request)), this.options.batchLoader(r.map((n) => n.request)).then((n) => {
            if (n instanceof Error)
              for (let o = 0; o < r.length; o++)
                r[o].reject(n);
            else
              for (let o = 0; o < r.length; o++) {
                let i = n[o];
                i instanceof Error ? r[o].reject(i) : r[o].resolve(i);
              }
          }).catch((n) => {
            for (let o = 0; o < r.length; o++)
              r[o].reject(n);
          }));
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    var Nd = he("prisma:client:request_handler");
    var Wn = class {
      constructor(t2, r) {
        this.logEmitter = r, this.client = t2, this.dataloader = new Qn({ batchLoader: Va(async ({ requests: n, customDataProxyFetch: o }) => {
          let { transaction: i, otelParentCtx: s } = n[0], a = n.map((m) => m.protocolQuery), u = this.client._tracingHelper.getTraceParent(s), l = n.some((m) => hi(m.protocolQuery.action));
          return (await this.client._engine.requestBatch(a, { traceparent: u, transaction: Ld(i), containsWrite: l, customDataProxyFetch: o })).map((m, g) => {
            if (m instanceof Error)
              return m;
            try {
              return this.mapQueryEngineResult(n[g], m);
            } catch (w) {
              return w;
            }
          });
        }), singleLoader: async (n) => {
          var s;
          let o = ((s = n.transaction) == null ? void 0 : s.kind) === "itx" ? Nu(n.transaction) : void 0, i = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: o, isWrite: hi(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
          return this.mapQueryEngineResult(n, i);
        }, batchBy: (n) => {
          var o;
          return (o = n.transaction) != null && o.id ? `transaction-${n.transaction.id}` : Du(n.protocolQuery);
        }, batchOrder(n, o) {
          var i, s;
          return ((i = n.transaction) == null ? void 0 : i.kind) === "batch" && ((s = o.transaction) == null ? void 0 : s.kind) === "batch" ? n.transaction.index - o.transaction.index : 0;
        } });
      }
      async request(t2) {
        try {
          return await this.dataloader.request(t2);
        } catch (r) {
          let { clientMethod: n, callsite: o, transaction: i, args: s } = t2;
          this.handleAndLogRequestError({ error: r, clientMethod: n, callsite: o, transaction: i, args: s });
        }
      }
      mapQueryEngineResult({ dataPath: t2, unpacker: r }, n) {
        let o = n == null ? void 0 : n.data, i = n == null ? void 0 : n.elapsed, s = this.unpack(o, t2, r);
        return y.env.PRISMA_CLIENT_GET_TIME ? { data: s, elapsed: i } : s;
      }
      handleAndLogRequestError(t2) {
        try {
          this.handleRequestError(t2);
        } catch (r) {
          throw this.logEmitter && this.logEmitter.emit("error", { message: r.message, target: t2.clientMethod, timestamp: /* @__PURE__ */ new Date() }), r;
        }
      }
      handleRequestError({ error: t2, clientMethod: r, callsite: n, transaction: o, args: i }) {
        if (Nd(t2), Bd(t2, o) || t2 instanceof Ke)
          throw t2;
        if (t2 instanceof ce && jd(t2)) {
          let a = Lu(t2.meta);
          Vn({ args: i, errors: [a], callsite: n, errorFormat: this.client._errorFormat, originalMethod: r, clientVersion: this.client._clientVersion });
        }
        let s = t2.message;
        throw n && (s = zt({ callsite: n, originalMethod: r, isPanic: t2.isPanic, showColors: this.client._errorFormat === "pretty", message: s })), s = this.sanitizeMessage(s), t2.code ? new ce(s, { code: t2.code, clientVersion: this.client._clientVersion, meta: t2.meta, batchRequestIdx: t2.batchRequestIdx }) : t2.isPanic ? new Ge(s, this.client._clientVersion) : t2 instanceof Se ? new Se(s, { clientVersion: this.client._clientVersion, batchRequestIdx: t2.batchRequestIdx }) : t2 instanceof re ? new re(s, this.client._clientVersion) : t2 instanceof Ge ? new Ge(s, this.client._clientVersion) : (t2.clientVersion = this.client._clientVersion, t2);
      }
      sanitizeMessage(t2) {
        return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, _u.default)(t2) : t2;
      }
      unpack(t2, r, n) {
        if (!t2 || (t2.data && (t2 = t2.data), !t2))
          return t2;
        let o = Object.values(t2)[0], i = r.filter((a) => a !== "select" && a !== "include"), s = Jn(Qo(o, i));
        return n ? n(s) : s;
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    function Ld(e) {
      if (e) {
        if (e.kind === "batch")
          return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
        if (e.kind === "itx")
          return { kind: "itx", options: Nu(e) };
        xt(e, "Unknown transaction kind");
      }
    }
    function Nu(e) {
      return { id: e.id, payload: e.payload };
    }
    function Bd(e, t2) {
      return Gn(e) && (t2 == null ? void 0 : t2.kind) === "batch" && e.batchRequestIdx !== t2.index;
    }
    function jd(e) {
      return e.code === "P2009" || e.code === "P2012";
    }
    function Lu(e) {
      if (e.kind === "Union")
        return { kind: "Union", errors: e.errors.map(Lu) };
      if (Array.isArray(e.selectionPath)) {
        let [, ...t2] = e.selectionPath;
        return { ...e, selectionPath: t2 };
      }
      return e;
    }
    d();
    p();
    f();
    var Bu = "5.5.2";
    var ju = Bu;
    d();
    p();
    f();
    function Uu(e) {
      return e.map((t2) => {
        let r = {};
        for (let n of Object.keys(t2))
          r[n] = $u(t2[n]);
        return r;
      });
    }
    function $u({ prisma__type: e, prisma__value: t2 }) {
      switch (e) {
        case "bigint":
          return BigInt(t2);
        case "bytes":
          return x.Buffer.from(t2, "base64");
        case "decimal":
          return new je(t2);
        case "datetime":
        case "date":
          return new Date(t2);
        case "time":
          return /* @__PURE__ */ new Date(`1970-01-01T${t2}Z`);
        case "array":
          return t2.map($u);
        default:
          return t2;
      }
    }
    d();
    p();
    f();
    var Gu = ve(ui());
    d();
    p();
    f();
    var Q = class extends Error {
      constructor(t2) {
        super(t2 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    k(Q, "PrismaClientConstructorValidationError");
    var qu = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "__internal"];
    var Vu = ["pretty", "colorless", "minimal"];
    var Ku = ["info", "query", "warn", "error"];
    var $d = { datasources: (e, { datasourceNames: t2 }) => {
      if (e) {
        if (typeof e != "object" || Array.isArray(e))
          throw new Q(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
        for (let [r, n] of Object.entries(e)) {
          if (!t2.includes(r)) {
            let o = er(r, t2) || ` Available datasources: ${t2.join(", ")}`;
            throw new Q(`Unknown datasource ${r} provided to PrismaClient constructor.${o}`);
          }
          if (typeof n != "object" || Array.isArray(n))
            throw new Q(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          if (n && typeof n == "object")
            for (let [o, i] of Object.entries(n)) {
              if (o !== "url")
                throw new Q(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
              if (typeof i != "string")
                throw new Q(`Invalid value ${JSON.stringify(i)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            }
        }
      }
    }, adapter: (e, t2) => {
      if (e === null)
        return;
      if (e === void 0)
        throw new Q('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
      if (!Bn(t2).includes("driverAdapters"))
        throw new Q('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
    }, datasourceUrl: (e) => {
      if (typeof e != "undefined" && typeof e != "string")
        throw new Q(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
    }, errorFormat: (e) => {
      if (e) {
        if (typeof e != "string")
          throw new Q(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
        if (!Vu.includes(e)) {
          let t2 = er(e, Vu);
          throw new Q(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t2}`);
        }
      }
    }, log: (e) => {
      if (!e)
        return;
      if (!Array.isArray(e))
        throw new Q(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
      function t2(r) {
        if (typeof r == "string" && !Ku.includes(r)) {
          let n = er(r, Ku);
          throw new Q(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`);
        }
      }
      for (let r of e) {
        t2(r);
        let n = { level: t2, emit: (o) => {
          let i = ["stdout", "event"];
          if (!i.includes(o)) {
            let s = er(o, i);
            throw new Q(`Invalid value ${JSON.stringify(o)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
          }
        } };
        if (r && typeof r == "object")
          for (let [o, i] of Object.entries(r))
            if (n[o])
              n[o](i);
            else
              throw new Q(`Invalid property ${o} for "log" provided to PrismaClient constructor`);
      }
    }, __internal: (e) => {
      if (!e)
        return;
      let t2 = ["debug", "hooks", "engine", "measurePerformance"];
      if (typeof e != "object")
        throw new Q(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
      for (let [r] of Object.entries(e))
        if (!t2.includes(r)) {
          let n = er(r, t2);
          throw new Q(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`);
        }
    } };
    function Ju(e, t2) {
      for (let [r, n] of Object.entries(e)) {
        if (!qu.includes(r)) {
          let o = er(r, qu);
          throw new Q(`Unknown property ${r} provided to PrismaClient constructor.${o}`);
        }
        $d[r](n, t2);
      }
      if (e.datasourceUrl && e.datasources)
        throw new Q('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
    }
    function er(e, t2) {
      if (t2.length === 0 || typeof e != "string")
        return "";
      let r = qd(e, t2);
      return r ? ` Did you mean "${r}"?` : "";
    }
    function qd(e, t2) {
      if (t2.length === 0)
        return null;
      let r = t2.map((o) => ({ value: o, distance: (0, Gu.default)(e, o) }));
      r.sort((o, i) => o.distance < i.distance ? -1 : 1);
      let n = r[0];
      return n.distance < 3 ? n.value : null;
    }
    d();
    p();
    f();
    function Qu(e) {
      return e.length === 0 ? Promise.resolve([]) : new Promise((t2, r) => {
        let n = new Array(e.length), o = null, i = false, s = 0, a = () => {
          i || (s++, s === e.length && (i = true, o ? r(o) : t2(n)));
        }, u = (l) => {
          i || (i = true, r(l));
        };
        for (let l = 0; l < e.length; l++)
          e[l].then((c) => {
            n[l] = c, a();
          }, (c) => {
            if (!Gn(c)) {
              u(c);
              return;
            }
            c.batchRequestIdx === l ? u(c) : (o || (o = c), a());
          });
      });
    }
    var ct = he("prisma:client");
    typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
    var Vd = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
    var Kd = Symbol.for("prisma.client.transaction.id");
    var Gd = { id: 0, nextId() {
      return ++this.id;
    } };
    function zu(e) {
      class t2 {
        constructor(n) {
          this._middlewares = new Kn();
          this._createPrismaPromise = di();
          this.$extends = _a;
          var u, l, c, m, g, w;
          Za(e), n && Ju(n, e);
          let o = n != null && n.adapter ? Qs(n.adapter) : void 0, i = new Hu.EventEmitter().on("error", () => {
          });
          this._extensions = Dn.empty(), this._previewFeatures = Bn(e), this._clientVersion = (u = e.clientVersion) != null ? u : ju, this._activeProvider = e.activeProvider, this._tracingHelper = Fu(this._previewFeatures);
          let s = { rootEnvPath: e.relativeEnvPaths.rootEnvPath && Lr.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && Lr.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, a = (l = e.injectableEdgeEnv) == null ? void 0 : l.call(e);
          try {
            let E = n != null ? n : {}, b = (c = E.__internal) != null ? c : {}, T = b.debug === true;
            T && he.enable("prisma:client");
            let S = Lr.default.resolve(e.dirname, e.relativePath);
            un.existsSync(S) || (S = e.dirname), ct("dirname", e.dirname), ct("relativePath", e.relativePath), ct("cwd", S);
            let R = b.engine || {};
            if (E.errorFormat ? this._errorFormat = E.errorFormat : y.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : y.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: S, dirname: e.dirname, enableDebugLogs: T, allowTriggerPanic: R.allowTriggerPanic, datamodelPath: Lr.default.join(e.dirname, (m = e.filename) != null ? m : "schema.prisma"), prismaPath: (g = R.binaryPath) != null ? g : void 0, engineEndpoint: R.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: E.log && ku(E.log), logQueries: E.log && !!(typeof E.log == "string" ? E.log === "query" : E.log.find((C) => typeof C == "string" ? C === "query" : C.level === "query")), env: (w = a == null ? void 0 : a.parsed) != null ? w : {}, flags: [], clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: Ya(E, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, logEmitter: i, isBundled: e.isBundled, adapter: o }, ct("clientVersion", e.clientVersion), this._engine = au(e, this._engineConfig), this._requestHandler = new Wn(this, i), E.log)
              for (let C of E.log) {
                let M = typeof C == "string" ? C : C.emit === "stdout" ? C.level : null;
                M && this.$on(M, (N) => {
                  var L;
                  Bt.log(`${(L = Bt.tags[M]) != null ? L : ""}`, N.message || N.query);
                });
              }
            this._metrics = new Ut(this._engine);
          } catch (E) {
            throw E.clientVersion = this._clientVersion, E;
          }
          return this._appliedParent = wr(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        $use(n) {
          this._middlewares.use(n);
        }
        $on(n, o) {
          n === "beforeExit" ? this._engine.on("beforeExit", o) : this._engine.on(n, (i) => {
            var a, u, l, c;
            let s = i.fields;
            return o(n === "query" ? { timestamp: i.timestamp, query: (a = s == null ? void 0 : s.query) != null ? a : i.query, params: (u = s == null ? void 0 : s.params) != null ? u : i.params, duration: (l = s == null ? void 0 : s.duration_ms) != null ? l : i.duration, target: i.target } : { timestamp: i.timestamp, message: (c = s == null ? void 0 : s.message) != null ? c : i.message, target: i.target });
          });
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          }
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          } finally {
            Ps();
          }
        }
        $executeRawInternal(n, o, i, s) {
          var l;
          let a = this._activeProvider, u = (l = this._engineConfig.adapter) == null ? void 0 : l.flavour;
          return this._request({ action: "executeRaw", args: i, transaction: n, clientMethod: o, argsMapper: fi({ clientMethod: o, activeProvider: a, activeProviderFlavour: u }), callsite: lt(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $executeRaw(n, ...o) {
          return this._createPrismaPromise((i) => {
            if (n.raw !== void 0 || n.sql !== void 0) {
              let [s, a] = Wu(n, o);
              return pi(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(i, "$executeRaw", s, a);
            }
            throw new pe("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
          });
        }
        $executeRawUnsafe(n, ...o) {
          return this._createPrismaPromise((i) => (pi(this._activeProvider, n, o, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(i, "$executeRawUnsafe", [n, ...o])));
        }
        $runCommandRaw(n) {
          if (e.activeProvider !== "mongodb")
            throw new pe(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
          return this._createPrismaPromise((o) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: Eu, callsite: lt(this._errorFormat), transaction: o }));
        }
        async $queryRawInternal(n, o, i, s) {
          var l;
          let a = this._activeProvider, u = (l = this._engineConfig.adapter) == null ? void 0 : l.flavour;
          return this._request({ action: "queryRaw", args: i, transaction: n, clientMethod: o, argsMapper: fi({ clientMethod: o, activeProvider: a, activeProviderFlavour: u }), callsite: lt(this._errorFormat), dataPath: [], middlewareArgsMapper: s }).then(Uu);
        }
        $queryRaw(n, ...o) {
          return this._createPrismaPromise((i) => {
            if (n.raw !== void 0 || n.sql !== void 0)
              return this.$queryRawInternal(i, "$queryRaw", ...Wu(n, o));
            throw new pe("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
          });
        }
        $queryRawUnsafe(n, ...o) {
          return this._createPrismaPromise((i) => this.$queryRawInternal(i, "$queryRawUnsafe", [n, ...o]));
        }
        _transactionWithArray({ promises: n, options: o }) {
          let i = Gd.nextId(), s = Iu(n.length), a = n.map((u, l) => {
            var g, w;
            if ((u == null ? void 0 : u[Symbol.toStringTag]) !== "PrismaPromise")
              throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
            let c = o == null ? void 0 : o.isolationLevel, m = { kind: "batch", id: i, index: l, isolationLevel: c, lock: s };
            return (w = (g = u.requestTransaction) == null ? void 0 : g.call(u, m)) != null ? w : u;
          });
          return Qu(a);
        }
        async _transactionWithCallback({ callback: n, options: o }) {
          let i = { traceparent: this._tracingHelper.getTraceParent() }, s = await this._engine.transaction("start", i, o), a;
          try {
            let u = { kind: "itx", ...s };
            a = await n(this._createItxClient(u)), await this._engine.transaction("commit", i, s);
          } catch (u) {
            throw await this._engine.transaction("rollback", i, s).catch(() => {
            }), u;
          }
          return a;
        }
        _createItxClient(n) {
          return wr(Le(Fn(this), [ge("_appliedParent", () => this._appliedParent._createItxClient(n)), ge("_createPrismaPromise", () => di(n)), ge(Kd, () => n.id), yr(gi)]));
        }
        $transaction(n, o) {
          let i;
          typeof n == "function" ? i = () => this._transactionWithCallback({ callback: n, options: o }) : i = () => this._transactionWithArray({ promises: n, options: o });
          let s = { name: "transaction", attributes: { method: "$transaction" } };
          return this._tracingHelper.runInChildSpan(s, i);
        }
        _request(n) {
          var l;
          n.otelParentCtx = this._tracingHelper.getActiveContext();
          let o = (l = n.middlewareArgsMapper) != null ? l : Vd, i = { args: o.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: i.action, model: i.model, name: i.model ? `${i.model}.${i.action}` : i.action } } }, a = -1, u = async (c) => {
            let m = this._middlewares.get(++a);
            if (m)
              return this._tracingHelper.runInChildSpan(s.middleware, (S) => m(c, (R) => (S == null || S.end(), u(R))));
            let { runInTransaction: g, args: w, ...E } = c, b = { ...n, ...E };
            w && (b.args = o.middlewareArgsToRequestArgs(w)), n.transaction !== void 0 && g === false && delete b.transaction;
            let T = await qa(this, b);
            return b.model ? Ba({ result: T, modelName: b.model, args: b.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : T;
          };
          return this._tracingHelper.runInChildSpan(s.operation, () => u(i));
        }
        async _executeRequest({ args: n, clientMethod: o, dataPath: i, callsite: s, action: a, model: u, argsMapper: l, transaction: c, unpacker: m, otelParentCtx: g, customDataProxyFetch: w }) {
          try {
            n = l ? l(n) : n;
            let E = { name: "serialize" }, b = this._tracingHelper.runInChildSpan(E, () => xu({ modelName: u, runtimeDataModel: this._runtimeDataModel, action: a, args: n, clientMethod: o, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
            return he.enabled("prisma:client") && (ct("Prisma Client call:"), ct(`prisma.${o}(${xa(n)})`), ct("Generated request:"), ct(JSON.stringify(b, null, 2) + `
`)), (c == null ? void 0 : c.kind) === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: b, modelName: u, action: a, clientMethod: o, dataPath: i, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: m, otelParentCtx: g, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: w });
          } catch (E) {
            throw E.clientVersion = this._clientVersion, E;
          }
        }
        get $metrics() {
          if (!this._hasPreviewFlag("metrics"))
            throw new pe("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
          return this._metrics;
        }
        _hasPreviewFlag(n) {
          var o;
          return !!((o = this._engineConfig.previewFeatures) != null && o.includes(n));
        }
      }
      return t2;
    }
    function Wu(e, t2) {
      return Jd(e) ? [new xe(e, t2), Mu] : [e, Su];
    }
    function Jd(e) {
      return Array.isArray(e) && Array.isArray(e.raw);
    }
    d();
    p();
    f();
    var Qd = /* @__PURE__ */ new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
    function Zu(e) {
      return new Proxy(e, { get(t2, r) {
        if (r in t2)
          return t2[r];
        if (!Qd.has(r))
          throw new TypeError(`Invalid enum value: ${String(r)}`);
      } });
    }
    d();
    p();
    f();
  }
});

// ../node_modules/.prisma/client/edge.js
var require_edge2 = __commonJS({
  "../node_modules/.prisma/client/edge.js"(exports) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      NotFoundError: NotFoundError2,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join3,
      raw: raw2,
      Decimal: Decimal2,
      Debug: Debug2,
      objectEnumValues: objectEnumValues2,
      makeStrictEnum: makeStrictEnum2,
      Extensions: Extensions2,
      warnOnce: warnOnce2,
      defineDmmfProperty: defineDmmfProperty2,
      Public: Public2
    } = require_edge();
    var Prisma = {};
    exports.Prisma = Prisma;
    exports.$Enums = {};
    Prisma.prismaVersion = {
      client: "5.5.2",
      engine: "aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.NotFoundError = NotFoundError2;
    Prisma.Decimal = Decimal2;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join3;
    Prisma.raw = raw2;
    Prisma.validator = Public2.validator;
    Prisma.getExtensionContext = Extensions2.getExtensionContext;
    Prisma.defineExtension = Extensions2.defineExtension;
    Prisma.DbNull = objectEnumValues2.instances.DbNull;
    Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
    Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
    Prisma.NullTypes = {
      DbNull: objectEnumValues2.classes.DbNull,
      JsonNull: objectEnumValues2.classes.JsonNull,
      AnyNull: objectEnumValues2.classes.AnyNull
    };
    exports.Prisma.GeoJSONScalarFieldEnum = {
      id: "id",
      type: "type",
      id_: "id_",
      properties: "properties",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      trip_id: "trip_id"
    };
    exports.Prisma.ItemCategoryScalarFieldEnum = {
      id: "id",
      name: "name",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.ItemScalarFieldEnum = {
      id: "id",
      name: "name",
      weight: "weight",
      quantity: "quantity",
      unit: "unit",
      global: "global",
      pack_ids: "pack_ids",
      itemCategoryId: "itemCategoryId",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.PackScalarFieldEnum = {
      id: "id",
      name: "name",
      owner_id: "owner_id",
      owner_ids: "owner_ids",
      is_public: "is_public",
      type: "type",
      item_ids: "item_ids",
      favourited_by_ids: "favourited_by_ids",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      total_weight: "total_weight",
      total_scores: "total_scores",
      favorites_count: "favorites_count"
    };
    exports.Prisma.TemplateScalarFieldEnum = {
      id: "id",
      type: "type",
      templateId: "templateId",
      isGlobalTemplate: "isGlobalTemplate",
      createdById: "createdById",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.TripScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      duration: "duration",
      weather: "weather",
      start_date: "start_date",
      end_date: "end_date",
      destination: "destination",
      owner_id: "owner_id",
      is_public: "is_public",
      type: "type",
      pack_id: "pack_id",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.UserScalarFieldEnum = {
      id: "id",
      name: "name",
      password: "password",
      email: "email",
      token: "token",
      code: "code",
      googleId: "googleId",
      is_certified_guide: "is_certified_guide",
      passwordResetToken: "passwordResetToken",
      passwordResetTokenExpiration: "passwordResetTokenExpiration",
      role: "role",
      username: "username",
      profileImage: "profileImage",
      preferredWeather: "preferredWeather",
      preferredWeight: "preferredWeight",
      favourite_ids: "favourite_ids",
      pack_ids: "pack_ids",
      item_id: "item_id",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.ConversationScalarFieldEnum = {
      id: "id",
      userId: "userId",
      history: "history",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.WayScalarFieldEnum = {
      id: "id",
      osm_id: "osm_id",
      osm_type: "osm_type",
      tags: "tags",
      geoJSON: "geoJSON",
      createdAt: "createdAt",
      updated_at: "updated_at"
    };
    exports.Prisma.NodeScalarFieldEnum = {
      id: "id",
      osm_id: "osm_id",
      lat: "lat",
      lon: "lon",
      osm_type: "osm_type",
      tags: "tags",
      createdAt: "createdAt",
      updated_at: "updated_at",
      wayId: "wayId"
    };
    exports.Prisma.RelationScalarFieldEnum = {
      id: "id",
      osm_id: "osm_id",
      osm_type: "osm_type",
      tags: "tags",
      geoJSON: "geoJSON",
      createdAt: "createdAt",
      updated_at: "updated_at"
    };
    exports.Prisma.SortOrder = {
      asc: "asc",
      desc: "desc"
    };
    exports.Prisma.QueryMode = {
      default: "default",
      insensitive: "insensitive"
    };
    exports.ItemCategoryName = exports.$Enums.ItemCategoryName = {
      Food: "Food",
      Water: "Water",
      Essentials: "Essentials"
    };
    exports.TemplateType = exports.$Enums.TemplateType = {
      pack: "pack",
      trip: "trip",
      item: "item"
    };
    exports.Role = exports.$Enums.Role = {
      user: "user",
      admin: "admin"
    };
    exports.GeoJSONGeometryType = exports.$Enums.GeoJSONGeometryType = {
      Point: "Point",
      LineString: "LineString",
      Polygon: "Polygon",
      MultiPoint: "MultiPoint",
      MultiPolygon: "MultiPolygon",
      MultiLineString: "MultiLineString"
    };
    exports.MemberType = exports.$Enums.MemberType = {
      way: "way",
      node: "node",
      relation: "relation"
    };
    exports.Prisma.ModelName = {
      GeoJSON: "GeoJSON",
      ItemCategory: "ItemCategory",
      Item: "Item",
      Pack: "Pack",
      Template: "Template",
      Trip: "Trip",
      User: "User",
      Conversation: "Conversation",
      Way: "Way",
      Node: "Node",
      Relation: "Relation"
    };
    var config4 = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "/home/awais/PackRat/node_modules/@prisma/client",
          "fromEnvVar": null
        },
        "config": {
          "engineType": "library"
        },
        "binaryTargets": [
          {
            "fromEnvVar": null,
            "value": "debian-openssl-1.1.x",
            "native": true
          }
        ],
        "previewFeatures": []
      },
      "relativeEnvPaths": {
        "rootEnvPath": null,
        "schemaEnvPath": "../../../server/src/prisma/.env"
      },
      "relativePath": "../../../server/src/prisma",
      "clientVersion": "5.5.2",
      "engineVersion": "aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "mongodb",
      "postinstall": false,
      "inlineDatasources": {
        "db": {
          "url": {
            "fromEnvVar": "MONGODB_URI",
            "value": null
          }
        }
      },
      "inlineSchema": "Z2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgPSAicHJpc21hLWNsaWVudC1qcyIKfQoKZGF0YXNvdXJjZSBkYiB7CiAgcHJvdmlkZXIgPSAibW9uZ29kYiIKICB1cmwgICAgICA9IGVudigiTU9OR09EQl9VUkkiKQp9CgovLyAg4paI4paI4paIICAgIOKWiOKWiOKWiCAg4paI4paI4paI4paI4paI4paIICDilojilojilojilojilojiloggIOKWiOKWiOKWiOKWiOKWiOKWiOKWiCDilojiloggICAgICDilojilojilojilojilojilojilogKLy8gIOKWiOKWiOKWiOKWiCAg4paI4paI4paI4paIIOKWiOKWiCAgICDilojilogg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAgIOKWiOKWiCAgICAgIOKWiOKWiAovLyAg4paI4paIIOKWiOKWiOKWiOKWiCDilojilogg4paI4paIICAgIOKWiOKWiCDilojiloggICDilojilogg4paI4paI4paI4paI4paIICAg4paI4paIICAgICAg4paI4paI4paI4paI4paI4paI4paICi8vICDilojiloggIOKWiOKWiCAg4paI4paIIOKWiOKWiCAgICDilojilogg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAgIOKWiOKWiCAgICAgICAgICAg4paI4paICi8vICDilojiloggICAgICDilojiloggIOKWiOKWiOKWiOKWiOKWiOKWiCAg4paI4paI4paI4paI4paI4paIICDilojilojilojilojilojilojilogg4paI4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAoKbW9kZWwgR2VvSlNPTiB7CiAgaWQgICAgICAgICBTdHJpbmcgICAgICAgICAgQGlkIEBkZWZhdWx0KGF1dG8oKSkgQG1hcCgiX2lkIikgQGRiLk9iamVjdElkCiAgdHlwZSAgICAgICBTdHJpbmcKICBpZF8gICAgICAgIFN0cmluZyAgICAgICAgICBAdW5pcXVlKG1hcDogImlkXzEiKSBAbWFwKCJpZCIpCiAgcHJvcGVydGllcyBKc29uCiAgZ2VvbWV0cnkgICBHZW9KU09OR2VvbWV0cnkKICBjcmVhdGVkQXQgIERhdGVUaW1lPyAgICAgICBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkQXQgIERhdGVUaW1lPyAgICAgICBAdXBkYXRlZEF0CiAgdHJpcF9pZCAgICBTdHJpbmcgICAgICAgICAgQGRiLk9iamVjdElkCiAgVHJpcCAgICAgICBUcmlwPyAgICAgICAgICAgQHJlbGF0aW9uKGZpZWxkczogW3RyaXBfaWRdLCByZWZlcmVuY2VzOiBbaWRdKQoKICBAQG1hcCgiZ2VvanNvbnMiKQp9Cgptb2RlbCBJdGVtQ2F0ZWdvcnkgewogIGlkICAgICAgICBTdHJpbmcgICAgICAgICAgIEBpZCBAZGVmYXVsdChhdXRvKCkpIEBtYXAoIl9pZCIpIEBkYi5PYmplY3RJZAogIG5hbWUgICAgICBJdGVtQ2F0ZWdvcnlOYW1lCiAgY3JlYXRlZEF0IERhdGVUaW1lPyAgICAgICAgQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZEF0IERhdGVUaW1lPyAgICAgICAgQHVwZGF0ZWRBdAogIEl0ZW0gICAgICBJdGVtW10KCiAgQEBpbmRleChbbmFtZV0sIG1hcDogIm5hbWVfMSIpCiAgQEBtYXAoIml0ZW1jYXRlZ29yaWVzIikKfQoKbW9kZWwgSXRlbSB7CiAgaWQgICAgICAgICAgICAgU3RyaW5nICAgICAgICBAaWQgQGRlZmF1bHQoYXV0bygpKSBAbWFwKCJfaWQiKSBAZGIuT2JqZWN0SWQKICBuYW1lICAgICAgICAgICBTdHJpbmc/CiAgd2VpZ2h0ICAgICAgICAgRmxvYXQ/CiAgcXVhbnRpdHkgICAgICAgSW50PwogIHVuaXQgICAgICAgICAgIFN0cmluZz8KICBnbG9iYWwgICAgICAgICBCb29sZWFuPyAgICAgIEBkZWZhdWx0KGZhbHNlKQogIHBhY2tfaWRzICAgICAgIFN0cmluZ1tdICAgICAgQGRiLk9iamVjdElkCiAgaXRlbUNhdGVnb3J5SWQgU3RyaW5nPyAgICAgICBAZGIuT2JqZWN0SWQKICBjcmVhdGVkQXQgICAgICBEYXRlVGltZT8gICAgIEBkZWZhdWx0KG5vdygpKQogIHVwZGF0ZWRBdCAgICAgIERhdGVUaW1lPyAgICAgQHVwZGF0ZWRBdAogIGNhdGVnb3J5ICAgICAgIEl0ZW1DYXRlZ29yeT8gQHJlbGF0aW9uKGZpZWxkczogW2l0ZW1DYXRlZ29yeUlkXSwgcmVmZXJlbmNlczogW2lkXSkKICBvd25lcnMgICAgICAgICBVc2VyW10KICBwYWNrcyAgICAgICAgICBQYWNrW10gICAgICAgIEByZWxhdGlvbihmaWVsZHM6IFtwYWNrX2lkc10sIHJlZmVyZW5jZXM6IFtpZF0pCgogIEBAaW5kZXgoW25hbWVdLCBtYXA6ICJuYW1lXzEiKQogIEBAaW5kZXgoW3dlaWdodF0sIG1hcDogIndlaWdodF8xIikKICBAQGluZGV4KFt1bml0XSwgbWFwOiAidW5pdF8xIikKICBAQG1hcCgiaXRlbXMiKQp9Cgptb2RlbCBQYWNrIHsKICBpZCAgICAgICAgICAgICAgICBTdHJpbmcgICAgICAgQGlkIEBkZWZhdWx0KGF1dG8oKSkgQG1hcCgiX2lkIikgQGRiLk9iamVjdElkCiAgbmFtZSAgICAgICAgICAgICAgU3RyaW5nPwogIG93bmVyX2lkICAgICAgICAgIFN0cmluZz8gICAgICBAZGIuT2JqZWN0SWQKICBvd25lcl9pZHMgICAgICAgICBTdHJpbmdbXSAgICAgQGRiLk9iamVjdElkCiAgaXNfcHVibGljICAgICAgICAgQm9vbGVhbj8KICBncmFkZXMgICAgICAgICAgICBQYWNrc0dyYWRlcz8KICBzY29yZXMgICAgICAgICAgICBQYWNrc1Njb3Jlcz8KICB0eXBlICAgICAgICAgICAgICBTdHJpbmc/ICAgICAgQGRlZmF1bHQoInBhY2siKQogIGl0ZW1faWRzICAgICAgICAgIFN0cmluZ1tdICAgICBAZGIuT2JqZWN0SWQKICBmYXZvdXJpdGVkX2J5X2lkcyBTdHJpbmdbXSAgICAgQGRiLk9iamVjdElkCiAgY3JlYXRlZEF0ICAgICAgICAgU3RyaW5nPwogIHVwZGF0ZWRBdCAgICAgICAgIERhdGVUaW1lPyAgICBAdXBkYXRlZEF0CiAgaXRlbXMgICAgICAgICAgICAgSXRlbVtdICAgICAgIEByZWxhdGlvbihmaWVsZHM6IFtpdGVtX2lkc10sIHJlZmVyZW5jZXM6IFtpZF0pCiAgZmF2b3JpdGVkX2J5ICAgICAgVXNlcltdICAgICAgIEByZWxhdGlvbihuYW1lOiAiRmF2b3VyaXRlcyIsIGZpZWxkczogW2Zhdm91cml0ZWRfYnlfaWRzXSwgcmVmZXJlbmNlczogW2lkXSkKICBvd25lcnMgICAgICAgICAgICBVc2VyW10gICAgICAgQHJlbGF0aW9uKG5hbWU6ICJPd25lcnMiLCBmaWVsZHM6IFtvd25lcl9pZHNdLCByZWZlcmVuY2VzOiBbaWRdKQogIG93bmVyICAgICAgICAgICAgIFVzZXI/ICAgICAgICBAcmVsYXRpb24oZmllbGRzOiBbb3duZXJfaWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIHRyaXBzICAgICAgICAgICAgIFRyaXBbXQoKICAvLyBWaXJ0dWFscwogIHRvdGFsX3dlaWdodCAgICBGbG9hdD8KICB0b3RhbF9zY29yZXMgICAgSW50PwogIGZhdm9yaXRlc19jb3VudCBJbnQ/CgogIEBAaW5kZXgoW25hbWVdLCBtYXA6ICJuYW1lXzEiKQogIEBAaW5kZXgoW2lzX3B1YmxpY10sIG1hcDogImlzX3B1YmxpY18xIikKICBAQG1hcCgicGFja3MiKQp9Cgptb2RlbCBUZW1wbGF0ZSB7CiAgaWQgICAgICAgICAgICAgICBTdHJpbmcgICAgICAgQGlkIEBkZWZhdWx0KGF1dG8oKSkgQG1hcCgiX2lkIikgQGRiLk9iamVjdElkCiAgdHlwZSAgICAgICAgICAgICBUZW1wbGF0ZVR5cGUKICB0ZW1wbGF0ZUlkICAgICAgIFN0cmluZz8gICAgICBAZGIuT2JqZWN0SWQKICBpc0dsb2JhbFRlbXBsYXRlIEJvb2xlYW4/ICAgICBAZGVmYXVsdChmYWxzZSkKICBjcmVhdGVkQnlJZCAgICAgIFN0cmluZz8gICAgICBAZGIuT2JqZWN0SWQKICBjcmVhdGVkQXQgICAgICAgIERhdGVUaW1lPyAgICBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkQXQgICAgICAgIERhdGVUaW1lPyAgICBAdXBkYXRlZEF0CiAgY3JlYXRlZEJ5ICAgICAgICBVc2VyPyAgICAgICAgQHJlbGF0aW9uKGZpZWxkczogW2NyZWF0ZWRCeUlkXSwgcmVmZXJlbmNlczogW2lkXSkKCiAgQEBpbmRleChbdHlwZV0sIG1hcDogInR5cGVfMSIpCiAgQEBpbmRleChbdGVtcGxhdGVJZF0sIG1hcDogInRlbXBsYXRlSWRfMSIpCiAgQEBpbmRleChbY3JlYXRlZEJ5SWRdLCBtYXA6ICJjcmVhdGVkQnlfMSIpCiAgQEBtYXAoInRlbXBsYXRlcyIpCn0KCm1vZGVsIFRyaXAgewogIGlkICAgICAgICAgIFN0cmluZyAgICBAaWQgQGRlZmF1bHQoYXV0bygpKSBAbWFwKCJfaWQiKSBAZGIuT2JqZWN0SWQKICBuYW1lICAgICAgICBTdHJpbmcKICBkZXNjcmlwdGlvbiBTdHJpbmcKICBkdXJhdGlvbiAgICBTdHJpbmcKICB3ZWF0aGVyICAgICBTdHJpbmcKICBzdGFydF9kYXRlICBEYXRlVGltZQogIGVuZF9kYXRlICAgIERhdGVUaW1lCiAgZGVzdGluYXRpb24gU3RyaW5nCiAgb3duZXJfaWQgICAgU3RyaW5nICAgIEBkYi5PYmplY3RJZAogIGlzX3B1YmxpYyAgIEJvb2xlYW4/CiAgdHlwZSAgICAgICAgU3RyaW5nICAgIEBkZWZhdWx0KCJ0cmlwIikKICBwYWNrX2lkICAgICBTdHJpbmc/ICAgQGRiLk9iamVjdElkCiAgY3JlYXRlZEF0ICAgRGF0ZVRpbWU/IEBkZWZhdWx0KG5vdygpKQogIHVwZGF0ZWRBdCAgIERhdGVUaW1lPyBAdXBkYXRlZEF0CiAgb3duZXIgICAgICAgVXNlciAgICAgIEByZWxhdGlvbihmaWVsZHM6IFtvd25lcl9pZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgcGFja3MgICAgICAgUGFjaz8gICAgIEByZWxhdGlvbihmaWVsZHM6IFtwYWNrX2lkXSwgcmVmZXJlbmNlczogW2lkXSkKICBnZW9qc29uICAgICBHZW9KU09OW10KCiAgQEBpbmRleChbZGVzdGluYXRpb25dLCBtYXA6ICJkZXN0aW5hdGlvbl8xIikKICBAQGluZGV4KFtzdGFydF9kYXRlXSwgbWFwOiAic3RhcnRfZGF0ZV8xIikKICBAQGluZGV4KFtlbmRfZGF0ZV0sIG1hcDogImVuZF9kYXRlXzEiKQogIEBAaW5kZXgoW2lzX3B1YmxpY10sIG1hcDogImlzX3B1YmxpY18xIikKICBAQGluZGV4KFt0eXBlXSwgbWFwOiAidHlwZV8xIikKICBAQG1hcCgidHJpcHMiKQp9Cgptb2RlbCBVc2VyIHsKICBpZCAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZyAgICAgQGlkIEBkZWZhdWx0KGF1dG8oKSkgQG1hcCgiX2lkIikgQGRiLk9iamVjdElkCiAgbmFtZSAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcKICBwYXNzd29yZCAgICAgICAgICAgICAgICAgICAgIFN0cmluZwogIGVtYWlsICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nICAgICBAdW5pcXVlCiAgdG9rZW4gICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmc/CiAgY29kZSAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmc/CiAgZ29vZ2xlSWQgICAgICAgICAgICAgICAgICAgICBTdHJpbmc/CiAgaXNfY2VydGlmaWVkX2d1aWRlICAgICAgICAgICBCb29sZWFuPwogIHBhc3N3b3JkUmVzZXRUb2tlbiAgICAgICAgICAgU3RyaW5nPwogIHBhc3N3b3JkUmVzZXRUb2tlbkV4cGlyYXRpb24gRGF0ZVRpbWU/ICBAZGIuRGF0ZQogIHJvbGUgICAgICAgICAgICAgICAgICAgICAgICAgUm9sZSAgICAgICBAZGVmYXVsdCh1c2VyKQogIHVzZXJuYW1lICAgICAgICAgICAgICAgICAgICAgU3RyaW5nPyAgICBAdW5pcXVlKG1hcDogInVzZXJuYW1lXzEiKQogIHByb2ZpbGVJbWFnZSAgICAgICAgICAgICAgICAgU3RyaW5nPwogIHByZWZlcnJlZFdlYXRoZXIgICAgICAgICAgICAgU3RyaW5nPwogIHByZWZlcnJlZFdlaWdodCAgICAgICAgICAgICAgU3RyaW5nPwogIGZhdm91cml0ZV9pZHMgICAgICAgICAgICAgICAgU3RyaW5nW10gICBAZGIuT2JqZWN0SWQKICBwYWNrX2lkcyAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1tdICAgQGRiLk9iamVjdElkCiAgaXRlbV9pZCAgICAgICAgICAgICAgICAgICAgICBTdHJpbmc/ICAgIEBkYi5PYmplY3RJZAogIGNyZWF0ZWRBdCAgICAgICAgICAgICAgICAgICAgRGF0ZVRpbWU/ICBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkQXQgICAgICAgICAgICAgICAgICAgIERhdGVUaW1lPyAgQHVwZGF0ZWRBdAogIGZhdm9yaXRlcyAgICAgICAgICAgICAgICAgICAgUGFja1tdICAgICBAcmVsYXRpb24obmFtZTogIkZhdm91cml0ZXMiLCBmaWVsZHM6IFtmYXZvdXJpdGVfaWRzXSwgcmVmZXJlbmNlczogW2lkXSkKICBwYWNrcyAgICAgICAgICAgICAgICAgICAgICAgIFBhY2tbXSAgICAgQHJlbGF0aW9uKG5hbWU6ICJPd25lcnMiLCBmaWVsZHM6IFtwYWNrX2lkc10sIHJlZmVyZW5jZXM6IFtpZF0pCiAgaXRlbSAgICAgICAgICAgICAgICAgICAgICAgICBJdGVtPyAgICAgIEByZWxhdGlvbihmaWVsZHM6IFtpdGVtX2lkXSwgcmVmZXJlbmNlczogW2lkXSkKICB0ZW1wbGF0ZXMgICAgICAgICAgICAgICAgICAgIFRlbXBsYXRlW10KICB0cmlwcyAgICAgICAgICAgICAgICAgICAgICAgIFRyaXBbXQogIFBhY2sgICAgICAgICAgICAgICAgICAgICAgICAgUGFja1tdCgogIEBAaW5kZXgoW3JvbGVdLCBtYXA6ICJyb2xlXzEiKQogIEBAaW5kZXgoW2NvZGVdLCBtYXA6ICJjb2RlXzEiKQogIEBAbWFwKCJ1c2VycyIpCn0KCm1vZGVsIENvbnZlcnNhdGlvbiB7CiAgaWQgICAgICAgIFN0cmluZyAgICBAaWQgQGRlZmF1bHQoYXV0bygpKSBAbWFwKCJfaWQiKSBAZGIuT2JqZWN0SWQKICB1c2VySWQgICAgU3RyaW5nCiAgaGlzdG9yeSAgIFN0cmluZwogIGNyZWF0ZWRBdCBEYXRlVGltZT8gQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZEF0IERhdGVUaW1lPyBAdXBkYXRlZEF0CgogIEBAbWFwKCJjb252ZXJzYXRpb25zIikKfQoKbW9kZWwgV2F5IHsKICBpZCAgICAgICAgIFN0cmluZyAgICBAaWQgQGRlZmF1bHQoYXV0bygpKSBAbWFwKCJfaWQiKSBAZGIuT2JqZWN0SWQKICBvc21faWQgICAgIEludD8KICBvc21fdHlwZSAgIFN0cmluZz8gICBAZGVmYXVsdCgid2F5IikKICB0YWdzICAgICAgIEpzb24/CiAgbm9kZXMgICAgICBOb2RlW10KICBnZW9KU09OICAgIEpzb24/CiAgY3JlYXRlZEF0ICBEYXRlVGltZT8gQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZF9hdCBEYXRlVGltZT8gQHVwZGF0ZWRBdAoKICBAQG1hcCgid2F5cyIpCn0KCm1vZGVsIE5vZGUgewogIGlkICAgICAgICAgU3RyaW5nICAgIEBpZCBAZGVmYXVsdChhdXRvKCkpIEBtYXAoIl9pZCIpIEBkYi5PYmplY3RJZAogIG9zbV9pZCAgICAgSW50PyAgICAgIEBtYXAoImlkIikKICBsYXQgICAgICAgIEZsb2F0PwogIGxvbiAgICAgICAgRmxvYXQ/CiAgb3NtX3R5cGUgICBTdHJpbmcgICAgQGRlZmF1bHQoIm5vZGUiKQogIHRhZ3MgICAgICAgSnNvbj8KICBjcmVhdGVkQXQgIERhdGVUaW1lPyBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkX2F0IERhdGVUaW1lPyBAdXBkYXRlZEF0CiAgV2F5ICAgICAgICBXYXk/ICAgICAgQHJlbGF0aW9uKGZpZWxkczogW3dheUlkXSwgcmVmZXJlbmNlczogW2lkXSkKICB3YXlJZCAgICAgIFN0cmluZz8gICBAZGIuT2JqZWN0SWQKCiAgQEBtYXAoIm5vZGVzIikKfQoKbW9kZWwgUmVsYXRpb24gewogIGlkICAgICAgICAgU3RyaW5nICAgIEBpZCBAZGVmYXVsdChhdXRvKCkpIEBtYXAoIl9pZCIpIEBkYi5PYmplY3RJZAogIG9zbV9pZCAgICAgSW50PwogIG9zbV90eXBlICAgU3RyaW5nPyAgIEBkZWZhdWx0KCJyZWxhdGlvbiIpCiAgdGFncyAgICAgICBKc29uPwogIG1lbWJlcnMgICAgTWVtYmVyW10KICBnZW9KU09OICAgIEpzb24/CiAgY3JlYXRlZEF0ICBEYXRlVGltZT8gQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZF9hdCBEYXRlVGltZT8gQHVwZGF0ZWRBdAoKICBAQG1hcCgicmVsYXRpb25zIikKfQoKLy8gIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiCDilojiloggICAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCAg4paI4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAovLyAgICAg4paI4paIICAgICDilojiloggIOKWiOKWiCAg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAgIOKWiOKWiAovLyAgICAg4paI4paIICAgICAg4paI4paI4paI4paIICAg4paI4paI4paI4paI4paI4paIICDilojilojilojilojiloggICDilojilojilojilojilojilojilogKLy8gICAgIOKWiOKWiCAgICAgICDilojiloggICAg4paI4paIICAgICAg4paI4paIICAgICAgICAgICDilojilogKLy8gICAgIOKWiOKWiCAgICAgICDilojiloggICAg4paI4paIICAgICAg4paI4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAoKdHlwZSBNZW1iZXIgewogIHR5cGUgIE1lbWJlclR5cGUKICByZWZJZCBTdHJpbmcgICAgIEBkYi5PYmplY3RJZAogIHJvbGUgIFN0cmluZwp9Cgp0eXBlIEdlb0pTT05HZW9tZXRyeSB7CiAgY29vcmRpbmF0ZXMgSnNvbgogIHR5cGUgICAgICAgIEdlb0pTT05HZW9tZXRyeVR5cGUKfQoKdHlwZSBQYWNrc0dyYWRlcyB7CiAgZXNzZW50aWFsSXRlbXMgICAgICAgICAgIFN0cmluZz8gQGRlZmF1bHQoIiIpCiAgcmVkdW5kYW5jeUFuZFZlcnNhdGlsaXR5IFN0cmluZz8gQGRlZmF1bHQoIiIpCiAgd2VpZ2h0ICAgICAgICAgICAgICAgICAgIFN0cmluZz8gQGRlZmF1bHQoIiIpCn0KCnR5cGUgUGFja3NTY29yZXMgewogIGVzc2VudGlhbEl0ZW1zU2NvcmUgICAgICAgICAgIEludD8gQGRlZmF1bHQoMCkKICByZWR1bmRhbmN5QW5kVmVyc2F0aWxpdHlTY29yZSBJbnQ/IEBkZWZhdWx0KDApCiAgd2VpZ2h0U2NvcmUgICAgICAgICAgICAgICAgICAgSW50PyBAZGVmYXVsdCgwKQp9CgovLyAg4paI4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiCAgICDilojilogg4paI4paIICAgIOKWiOKWiCDilojilojiloggICAg4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAovLyAg4paI4paIICAgICAg4paI4paI4paI4paIICAg4paI4paIIOKWiOKWiCAgICDilojilogg4paI4paI4paI4paIICDilojilojilojilogg4paI4paICi8vICDilojilojilojilojiloggICDilojilogg4paI4paIICDilojilogg4paI4paIICAgIOKWiOKWiCDilojilogg4paI4paI4paI4paIIOKWiOKWiCDilojilojilojilojilojilojilogKLy8gIOKWiOKWiCAgICAgIOKWiOKWiCAg4paI4paIIOKWiOKWiCDilojiloggICAg4paI4paIIOKWiOKWiCAg4paI4paIICDilojiloggICAgICDilojilogKLy8gIOKWiOKWiOKWiOKWiOKWiOKWiOKWiCDilojiloggICDilojilojilojiloggIOKWiOKWiOKWiOKWiOKWiOKWiCAg4paI4paIICAgICAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAoKZW51bSBNZW1iZXJUeXBlIHsKICB3YXkKICBub2RlCiAgcmVsYXRpb24KfQoKZW51bSBSb2xlIHsKICB1c2VyCiAgYWRtaW4KfQoKZW51bSBJdGVtQ2F0ZWdvcnlOYW1lIHsKICBGb29kCiAgV2F0ZXIKICBFc3NlbnRpYWxzCn0KCmVudW0gVGVtcGxhdGVUeXBlIHsKICBwYWNrCiAgdHJpcAogIGl0ZW0KfQoKZW51bSBHZW9KU09OR2VvbWV0cnlUeXBlIHsKICBQb2ludAogIExpbmVTdHJpbmcKICBQb2x5Z29uCiAgTXVsdGlQb2ludAogIE11bHRpUG9seWdvbgogIE11bHRpTGluZVN0cmluZwp9Cg==",
      "inlineSchemaHash": "68736a86926db8013b590479e33b7d2cdd9adc9e78c086b0a446b596c0fb6400",
      "noEngine": true
    };
    config4.dirname = "/";
    config4.runtimeDataModel = JSON.parse('{"models":{"GeoJSON":{"dbName":"geojsons","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"id_","dbName":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"properties","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"geometry","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"GeoJSONGeometry","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"trip_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"Trip","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Trip","relationName":"GeoJSONToTrip","relationFromFields":["trip_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ItemCategory":{"dbName":"itemcategories","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ItemCategoryName","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"Item","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Item","relationName":"ItemToItemCategory","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Item":{"dbName":"items","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"weight","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"unit","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"global","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"pack_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"itemCategoryId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"category","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ItemCategory","relationName":"ItemToItemCategory","relationFromFields":["itemCategoryId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"owners","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"ItemToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"packs","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"ItemToPack","relationFromFields":["pack_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Pack":{"dbName":"packs","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"owner_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"owner_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"is_public","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","isGenerated":false,"isUpdatedAt":false},{"name":"grades","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PacksGrades","isGenerated":false,"isUpdatedAt":false},{"name":"scores","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PacksScores","isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"pack","isGenerated":false,"isUpdatedAt":false},{"name":"item_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"favourited_by_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"items","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Item","relationName":"ItemToPack","relationFromFields":["item_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"favorited_by","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"Favourites","relationFromFields":["favourited_by_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"owners","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"Owners","relationFromFields":["owner_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"owner","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"PackToUser","relationFromFields":["owner_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"trips","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Trip","relationName":"PackToTrip","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"total_weight","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","isGenerated":false,"isUpdatedAt":false},{"name":"total_scores","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"favorites_count","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Template":{"dbName":"templates","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"TemplateType","isGenerated":false,"isUpdatedAt":false},{"name":"templateId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"isGlobalTemplate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"createdById","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"createdBy","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"TemplateToUser","relationFromFields":["createdById"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Trip":{"dbName":"trips","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"duration","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"weather","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"start_date","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"end_date","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"destination","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"owner_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"is_public","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"trip","isGenerated":false,"isUpdatedAt":false},{"name":"pack_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"owner","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"TripToUser","relationFromFields":["owner_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"packs","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"PackToTrip","relationFromFields":["pack_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"geojson","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"GeoJSON","relationName":"GeoJSONToTrip","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"User":{"dbName":"users","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"token","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"code","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"googleId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"is_certified_guide","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","isGenerated":false,"isUpdatedAt":false},{"name":"passwordResetToken","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"passwordResetTokenExpiration","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"role","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Role","default":"user","isGenerated":false,"isUpdatedAt":false},{"name":"username","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"profileImage","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"preferredWeather","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"preferredWeight","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"favourite_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"pack_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"item_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"favorites","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"Favourites","relationFromFields":["favourite_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"packs","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"Owners","relationFromFields":["pack_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"item","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Item","relationName":"ItemToUser","relationFromFields":["item_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"templates","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Template","relationName":"TemplateToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"trips","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Trip","relationName":"TripToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"Pack","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"PackToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Conversation":{"dbName":"conversations","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"history","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Way":{"dbName":"ways","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"osm_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"osm_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"way","isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"nodes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Node","relationName":"NodeToWay","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"geoJSON","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Node":{"dbName":"nodes","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"osm_id","dbName":"id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"lat","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","isGenerated":false,"isUpdatedAt":false},{"name":"lon","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","isGenerated":false,"isUpdatedAt":false},{"name":"osm_type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"node","isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"Way","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Way","relationName":"NodeToWay","relationFromFields":["wayId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"wayId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Relation":{"dbName":"relations","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"osm_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"osm_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"relation","isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"members","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Member","isGenerated":false,"isUpdatedAt":false},{"name":"geoJSON","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}},"enums":{"MemberType":{"values":[{"name":"way","dbName":null},{"name":"node","dbName":null},{"name":"relation","dbName":null}],"dbName":null},"Role":{"values":[{"name":"user","dbName":null},{"name":"admin","dbName":null}],"dbName":null},"ItemCategoryName":{"values":[{"name":"Food","dbName":null},{"name":"Water","dbName":null},{"name":"Essentials","dbName":null}],"dbName":null},"TemplateType":{"values":[{"name":"pack","dbName":null},{"name":"trip","dbName":null},{"name":"item","dbName":null}],"dbName":null},"GeoJSONGeometryType":{"values":[{"name":"Point","dbName":null},{"name":"LineString","dbName":null},{"name":"Polygon","dbName":null},{"name":"MultiPoint","dbName":null},{"name":"MultiPolygon","dbName":null},{"name":"MultiLineString","dbName":null}],"dbName":null}},"types":{"Member":{"dbName":null,"fields":[{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MemberType"},{"name":"refId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String"},{"name":"role","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String"}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[]},"GeoJSONGeometry":{"dbName":null,"fields":[{"name":"coordinates","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json"},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"GeoJSONGeometryType"}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[]},"PacksGrades":{"dbName":null,"fields":[{"name":"essentialItems","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":""},{"name":"redundancyAndVersatility","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":""},{"name":"weight","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":""}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[]},"PacksScores":{"dbName":null,"fields":[{"name":"essentialItemsScore","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","default":0},{"name":"redundancyAndVersatilityScore","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","default":0},{"name":"weightScore","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","default":0}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[]}}}');
    defineDmmfProperty2(exports.Prisma, config4.runtimeDataModel);
    config4.injectableEdgeEnv = () => ({
      parsed: {
        MONGODB_URI: typeof globalThis !== "undefined" && globalThis["MONGODB_URI"] || typeof process !== "undefined" && process.env && process.env.MONGODB_URI || void 0
      }
    });
    if (typeof globalThis !== "undefined" && globalThis["DEBUG"] || typeof process !== "undefined" && process.env && process.env.DEBUG || void 0) {
      Debug2.enable(typeof globalThis !== "undefined" && globalThis["DEBUG"] || typeof process !== "undefined" && process.env && process.env.DEBUG || void 0);
    }
    var PrismaClient2 = getPrismaClient2(config4);
    exports.PrismaClient = PrismaClient2;
    Object.assign(exports, Prisma);
  }
});

// ../node_modules/@prisma/client/edge.js
var require_edge3 = __commonJS({
  "../node_modules/@prisma/client/edge.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = {
      ...require_edge2()
    };
  }
});

// node-modules-polyfills:crypto
var crypto_exports = {};
__export(crypto_exports, {
  default: () => crypto_default
});
var crypto_default;
var init_crypto = __esm({
  "node-modules-polyfills:crypto"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    crypto_default = {};
  }
});

// node-modules-polyfills-commonjs:crypto
var require_crypto = __commonJS({
  "node-modules-polyfills-commonjs:crypto"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var polyfill = (init_crypto(), __toCommonJS(crypto_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// ../node_modules/bcryptjs/dist/bcrypt.js
var require_bcrypt = __commonJS({
  "../node_modules/bcryptjs/dist/bcrypt.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    (function(global2, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof __require === "function" && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
      else
        (global2["dcodeIO"] = global2["dcodeIO"] || {})["bcrypt"] = factory();
    })(exports, function() {
      "use strict";
      var bcrypt2 = {};
      var randomFallback = null;
      function random(len) {
        if (typeof module !== "undefined" && module && module["exports"])
          try {
            return require_crypto()["randomBytes"](len);
          } catch (e) {
          }
        try {
          var a;
          (self["crypto"] || self["msCrypto"])["getRandomValues"](a = new Uint32Array(len));
          return Array.prototype.slice.call(a);
        } catch (e) {
        }
        if (!randomFallback)
          throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
        return randomFallback(len);
      }
      var randomAvailable = false;
      try {
        random(1);
        randomAvailable = true;
      } catch (e) {
      }
      randomFallback = null;
      bcrypt2.setRandomFallback = function(random2) {
        randomFallback = random2;
      };
      bcrypt2.genSaltSync = function(rounds, seed_length) {
        rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof rounds !== "number")
          throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
        if (rounds < 4)
          rounds = 4;
        else if (rounds > 31)
          rounds = 31;
        var salt = [];
        salt.push("$2a$");
        if (rounds < 10)
          salt.push("0");
        salt.push(rounds.toString());
        salt.push("$");
        salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
        return salt.join("");
      };
      bcrypt2.genSalt = function(rounds, seed_length, callback) {
        if (typeof seed_length === "function")
          callback = seed_length, seed_length = void 0;
        if (typeof rounds === "function")
          callback = rounds, rounds = void 0;
        if (typeof rounds === "undefined")
          rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
        else if (typeof rounds !== "number")
          throw Error("illegal arguments: " + typeof rounds);
        function _async(callback2) {
          nextTick3(function() {
            try {
              callback2(null, bcrypt2.genSaltSync(rounds));
            } catch (err) {
              callback2(err);
            }
          });
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve2, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve2(res);
            });
          });
      };
      bcrypt2.hashSync = function(s, salt) {
        if (typeof salt === "undefined")
          salt = GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof salt === "number")
          salt = bcrypt2.genSaltSync(salt);
        if (typeof s !== "string" || typeof salt !== "string")
          throw Error("Illegal arguments: " + typeof s + ", " + typeof salt);
        return _hash(s, salt);
      };
      bcrypt2.hash = function(s, salt, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s === "string" && typeof salt === "number")
            bcrypt2.genSalt(salt, function(err, salt2) {
              _hash(s, salt2, callback2, progressCallback);
            });
          else if (typeof s === "string" && typeof salt === "string")
            _hash(s, salt, callback2, progressCallback);
          else
            nextTick3(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof salt)));
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve2, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve2(res);
            });
          });
      };
      function safeStringCompare(known, unknown) {
        var right = 0, wrong = 0;
        for (var i = 0, k = known.length; i < k; ++i) {
          if (known.charCodeAt(i) === unknown.charCodeAt(i))
            ++right;
          else
            ++wrong;
        }
        if (right < 0)
          return false;
        return wrong === 0;
      }
      bcrypt2.compareSync = function(s, hash) {
        if (typeof s !== "string" || typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof s + ", " + typeof hash);
        if (hash.length !== 60)
          return false;
        return safeStringCompare(bcrypt2.hashSync(s, hash.substr(0, hash.length - 31)), hash);
      };
      bcrypt2.compare = function(s, hash, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s !== "string" || typeof hash !== "string") {
            nextTick3(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof hash)));
            return;
          }
          if (hash.length !== 60) {
            nextTick3(callback2.bind(this, null, false));
            return;
          }
          bcrypt2.hash(s, hash.substr(0, 29), function(err, comp) {
            if (err)
              callback2(err);
            else
              callback2(null, safeStringCompare(comp, hash));
          }, progressCallback);
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve2, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve2(res);
            });
          });
      };
      bcrypt2.getRounds = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        return parseInt(hash.split("$")[2], 10);
      };
      bcrypt2.getSalt = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        if (hash.length !== 60)
          throw Error("Illegal hash length: " + hash.length + " != 60");
        return hash.substring(0, 29);
      };
      var nextTick3 = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
      function stringToBytes(str) {
        var out = [], i = 0;
        utfx.encodeUTF16toUTF8(function() {
          if (i >= str.length)
            return null;
          return str.charCodeAt(i++);
        }, function(b) {
          out.push(b);
        });
        return out;
      }
      var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
      var BASE64_INDEX = [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        -1,
        -1,
        -1,
        -1,
        -1
      ];
      var stringFromCharCode = String.fromCharCode;
      function base64_encode(b, len) {
        var off3 = 0, rs = [], c1, c2;
        if (len <= 0 || len > b.length)
          throw Error("Illegal len: " + len);
        while (off3 < len) {
          c1 = b[off3++] & 255;
          rs.push(BASE64_CODE[c1 >> 2 & 63]);
          c1 = (c1 & 3) << 4;
          if (off3 >= len) {
            rs.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b[off3++] & 255;
          c1 |= c2 >> 4 & 15;
          rs.push(BASE64_CODE[c1 & 63]);
          c1 = (c2 & 15) << 2;
          if (off3 >= len) {
            rs.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b[off3++] & 255;
          c1 |= c2 >> 6 & 3;
          rs.push(BASE64_CODE[c1 & 63]);
          rs.push(BASE64_CODE[c2 & 63]);
        }
        return rs.join("");
      }
      function base64_decode(s, len) {
        var off3 = 0, slen = s.length, olen = 0, rs = [], c1, c2, c3, c4, o, code;
        if (len <= 0)
          throw Error("Illegal len: " + len);
        while (off3 < slen - 1 && olen < len) {
          code = s.charCodeAt(off3++);
          c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          code = s.charCodeAt(off3++);
          c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c1 == -1 || c2 == -1)
            break;
          o = c1 << 2 >>> 0;
          o |= (c2 & 48) >> 4;
          rs.push(stringFromCharCode(o));
          if (++olen >= len || off3 >= slen)
            break;
          code = s.charCodeAt(off3++);
          c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c3 == -1)
            break;
          o = (c2 & 15) << 4 >>> 0;
          o |= (c3 & 60) >> 2;
          rs.push(stringFromCharCode(o));
          if (++olen >= len || off3 >= slen)
            break;
          code = s.charCodeAt(off3++);
          c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          o = (c3 & 3) << 6 >>> 0;
          o |= c4;
          rs.push(stringFromCharCode(o));
          ++olen;
        }
        var res = [];
        for (off3 = 0; off3 < olen; off3++)
          res.push(rs[off3].charCodeAt(0));
        return res;
      }
      var utfx = function() {
        "use strict";
        var utfx2 = {};
        utfx2.MAX_CODEPOINT = 1114111;
        utfx2.encodeUTF8 = function(src, dst) {
          var cp = null;
          if (typeof src === "number")
            cp = src, src = function() {
              return null;
            };
          while (cp !== null || (cp = src()) !== null) {
            if (cp < 128)
              dst(cp & 127);
            else if (cp < 2048)
              dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
            else if (cp < 65536)
              dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            else
              dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            cp = null;
          }
        };
        utfx2.decodeUTF8 = function(src, dst) {
          var a, b, c, d, fail = function(b2) {
            b2 = b2.slice(0, b2.indexOf(null));
            var err = Error(b2.toString());
            err.name = "TruncatedError";
            err["bytes"] = b2;
            throw err;
          };
          while ((a = src()) !== null) {
            if ((a & 128) === 0)
              dst(a);
            else if ((a & 224) === 192)
              (b = src()) === null && fail([a, b]), dst((a & 31) << 6 | b & 63);
            else if ((a & 240) === 224)
              ((b = src()) === null || (c = src()) === null) && fail([a, b, c]), dst((a & 15) << 12 | (b & 63) << 6 | c & 63);
            else if ((a & 248) === 240)
              ((b = src()) === null || (c = src()) === null || (d = src()) === null) && fail([a, b, c, d]), dst((a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63);
            else
              throw RangeError("Illegal starting byte: " + a);
          }
        };
        utfx2.UTF16toUTF8 = function(src, dst) {
          var c1, c2 = null;
          while (true) {
            if ((c1 = c2 !== null ? c2 : src()) === null)
              break;
            if (c1 >= 55296 && c1 <= 57343) {
              if ((c2 = src()) !== null) {
                if (c2 >= 56320 && c2 <= 57343) {
                  dst((c1 - 55296) * 1024 + c2 - 56320 + 65536);
                  c2 = null;
                  continue;
                }
              }
            }
            dst(c1);
          }
          if (c2 !== null)
            dst(c2);
        };
        utfx2.UTF8toUTF16 = function(src, dst) {
          var cp = null;
          if (typeof src === "number")
            cp = src, src = function() {
              return null;
            };
          while (cp !== null || (cp = src()) !== null) {
            if (cp <= 65535)
              dst(cp);
            else
              cp -= 65536, dst((cp >> 10) + 55296), dst(cp % 1024 + 56320);
            cp = null;
          }
        };
        utfx2.encodeUTF16toUTF8 = function(src, dst) {
          utfx2.UTF16toUTF8(src, function(cp) {
            utfx2.encodeUTF8(cp, dst);
          });
        };
        utfx2.decodeUTF8toUTF16 = function(src, dst) {
          utfx2.decodeUTF8(src, function(cp) {
            utfx2.UTF8toUTF16(cp, dst);
          });
        };
        utfx2.calculateCodePoint = function(cp) {
          return cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
        };
        utfx2.calculateUTF8 = function(src) {
          var cp, l = 0;
          while ((cp = src()) !== null)
            l += utfx2.calculateCodePoint(cp);
          return l;
        };
        utfx2.calculateUTF16asUTF8 = function(src) {
          var n = 0, l = 0;
          utfx2.UTF16toUTF8(src, function(cp) {
            ++n;
            l += utfx2.calculateCodePoint(cp);
          });
          return [n, l];
        };
        return utfx2;
      }();
      Date.now = Date.now || function() {
        return +/* @__PURE__ */ new Date();
      };
      var BCRYPT_SALT_LEN = 16;
      var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
      var BLOWFISH_NUM_ROUNDS = 16;
      var MAX_EXECUTION_TIME = 100;
      var P_ORIG = [
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ];
      var S_ORIG = [
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946,
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        290971e4,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055,
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504,
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409e3,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ];
      var C_ORIG = [
        1332899944,
        1700884034,
        1701343084,
        1684370003,
        1668446532,
        1869963892
      ];
      function _encipher(lr, off3, P, S) {
        var n, l = lr[off3], r = lr[off3 + 1];
        l ^= P[0];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[1];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[2];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[3];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[4];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[5];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[6];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[7];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[8];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[9];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[10];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[11];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[12];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[13];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[14];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[15];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[16];
        lr[off3] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
        lr[off3 + 1] = l;
        return lr;
      }
      function _streamtoword(data, offp) {
        for (var i = 0, word = 0; i < 4; ++i)
          word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
        return { key: word, offp };
      }
      function _key(key, P, S) {
        var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
        for (i = 0; i < plen; i += 2)
          lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
          lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
      }
      function _ekskey(data, key, P, S) {
        var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
        offp = 0;
        for (i = 0; i < plen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
      }
      function _crypt(b, salt, rounds, callback, progressCallback) {
        var cdata = C_ORIG.slice(), clen = cdata.length, err;
        if (rounds < 4 || rounds > 31) {
          err = Error("Illegal number of rounds (4-31): " + rounds);
          if (callback) {
            nextTick3(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.length !== BCRYPT_SALT_LEN) {
          err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
          if (callback) {
            nextTick3(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        rounds = 1 << rounds >>> 0;
        var P, S, i = 0, j;
        if (Int32Array) {
          P = new Int32Array(P_ORIG);
          S = new Int32Array(S_ORIG);
        } else {
          P = P_ORIG.slice();
          S = S_ORIG.slice();
        }
        _ekskey(salt, b, P, S);
        function next() {
          if (progressCallback)
            progressCallback(i / rounds);
          if (i < rounds) {
            var start = Date.now();
            for (; i < rounds; ) {
              i = i + 1;
              _key(b, P, S);
              _key(salt, P, S);
              if (Date.now() - start > MAX_EXECUTION_TIME)
                break;
            }
          } else {
            for (i = 0; i < 64; i++)
              for (j = 0; j < clen >> 1; j++)
                _encipher(cdata, j << 1, P, S);
            var ret = [];
            for (i = 0; i < clen; i++)
              ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
            if (callback) {
              callback(null, ret);
              return;
            } else
              return ret;
          }
          if (callback)
            nextTick3(next);
        }
        if (typeof callback !== "undefined") {
          next();
        } else {
          var res;
          while (true)
            if (typeof (res = next()) !== "undefined")
              return res || [];
        }
      }
      function _hash(s, salt, callback, progressCallback) {
        var err;
        if (typeof s !== "string" || typeof salt !== "string") {
          err = Error("Invalid string / salt: Not a string");
          if (callback) {
            nextTick3(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var minor, offset;
        if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
          err = Error("Invalid salt version: " + salt.substring(0, 2));
          if (callback) {
            nextTick3(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.charAt(2) === "$")
          minor = String.fromCharCode(0), offset = 3;
        else {
          minor = salt.charAt(2);
          if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
            err = Error("Invalid salt revision: " + salt.substring(2, 4));
            if (callback) {
              nextTick3(callback.bind(this, err));
              return;
            } else
              throw err;
          }
          offset = 4;
        }
        if (salt.charAt(offset + 2) > "$") {
          err = Error("Missing salt rounds");
          if (callback) {
            nextTick3(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
        s += minor >= "a" ? "\0" : "";
        var passwordb = stringToBytes(s), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
        function finish(bytes) {
          var res = [];
          res.push("$2");
          if (minor >= "a")
            res.push(minor);
          res.push("$");
          if (rounds < 10)
            res.push("0");
          res.push(rounds.toString());
          res.push("$");
          res.push(base64_encode(saltb, saltb.length));
          res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
          return res.join("");
        }
        if (typeof callback == "undefined")
          return finish(_crypt(passwordb, saltb, rounds));
        else {
          _crypt(passwordb, saltb, rounds, function(err2, bytes) {
            if (err2)
              callback(err2, null);
            else
              callback(null, finish(bytes));
          }, progressCallback);
        }
      }
      bcrypt2.encodeBase64 = base64_encode;
      bcrypt2.decodeBase64 = base64_decode;
      return bcrypt2;
    });
  }
});

// node-modules-polyfills:fs
var fs_exports = {};
__export(fs_exports, {
  default: () => fs_default
});
var fs_default;
var init_fs = __esm({
  "node-modules-polyfills:fs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    fs_default = {};
  }
});

// node-modules-polyfills-commonjs:fs
var require_fs = __commonJS({
  "node-modules-polyfills-commonjs:fs"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var polyfill = (init_fs(), __toCommonJS(fs_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills:path
var path_exports = {};
__export(path_exports, {
  basename: () => basename,
  default: () => path_default,
  delimiter: () => delimiter,
  dirname: () => dirname,
  extname: () => extname,
  isAbsolute: () => isAbsolute,
  join: () => join2,
  normalize: () => normalize,
  relative: () => relative,
  resolve: () => resolve,
  sep: () => sep
});
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === ".") {
      parts.splice(i, 1);
    } else if (last === "..") {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : "/";
    if (typeof path !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter2(resolvedPath.split("/"), function(p) {
    return !!p;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function normalize(path) {
  var isPathAbsolute = isAbsolute(path), trailingSlash = substr(path, -1) === "/";
  path = normalizeArray(filter2(path.split("/"), function(p) {
    return !!p;
  }), !isPathAbsolute).join("/");
  if (!path && !isPathAbsolute) {
    path = ".";
  }
  if (path && trailingSlash) {
    path += "/";
  }
  return (isPathAbsolute ? "/" : "") + path;
}
function isAbsolute(path) {
  return path.charAt(0) === "/";
}
function join2() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter2(paths, function(p, index) {
    if (typeof p !== "string") {
      throw new TypeError("Arguments to path.join must be strings");
    }
    return p;
  }).join("/"));
}
function relative(from3, to) {
  from3 = resolve(from3).substr(1);
  to = resolve(to).substr(1);
  function trim2(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== "")
        break;
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== "")
        break;
    }
    if (start > end)
      return [];
    return arr.slice(start, end - start + 1);
  }
  var fromParts = trim2(from3.split("/"));
  var toParts = trim2(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
}
function dirname(path) {
  var result = splitPath(path), root = result[0], dir = result[1];
  if (!root && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
}
function basename(path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}
function extname(path) {
  return splitPath(path)[3];
}
function filter2(xs, f) {
  if (xs.filter)
    return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs))
      res.push(xs[i]);
  }
  return res;
}
var splitPathRe, splitPath, sep, delimiter, path_default, substr;
var init_path = __esm({
  "node-modules-polyfills:path"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    splitPath = function(filename) {
      return splitPathRe.exec(filename).slice(1);
    };
    sep = "/";
    delimiter = ":";
    path_default = {
      extname,
      basename,
      dirname,
      sep,
      delimiter,
      relative,
      join: join2,
      isAbsolute,
      normalize,
      resolve
    };
    substr = "ab".substr(-1) === "b" ? function(str, start, len) {
      return str.substr(start, len);
    } : function(str, start, len) {
      if (start < 0)
        start = str.length + start;
      return str.substr(start, len);
    };
  }
});

// node-modules-polyfills-commonjs:path
var require_path = __commonJS({
  "node-modules-polyfills-commonjs:path"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var polyfill = (init_path(), __toCommonJS(path_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills:os
var os_exports = {};
__export(os_exports, {
  EOL: () => EOL,
  arch: () => arch,
  cpus: () => cpus,
  default: () => os_default,
  endianness: () => endianness,
  freemem: () => freemem,
  getNetworkInterfaces: () => getNetworkInterfaces,
  hostname: () => hostname,
  loadavg: () => loadavg,
  networkInterfaces: () => networkInterfaces,
  platform: () => platform2,
  release: () => release2,
  tmpDir: () => tmpDir,
  tmpdir: () => tmpdir,
  totalmem: () => totalmem,
  type: () => type,
  uptime: () => uptime2
});
function endianness() {
  if (typeof _endianness === "undefined") {
    var a = new ArrayBuffer(2);
    var b = new Uint8Array(a);
    var c = new Uint16Array(a);
    b[0] = 1;
    b[1] = 2;
    if (c[0] === 258) {
      _endianness = "BE";
    } else if (c[0] === 513) {
      _endianness = "LE";
    } else {
      throw new Error("unable to figure out endianess");
    }
  }
  return _endianness;
}
function hostname() {
  if (typeof globalThis.location !== "undefined") {
    return globalThis.location.hostname;
  } else
    return "";
}
function loadavg() {
  return [];
}
function uptime2() {
  return 0;
}
function freemem() {
  return Number.MAX_VALUE;
}
function totalmem() {
  return Number.MAX_VALUE;
}
function cpus() {
  return [];
}
function type() {
  return "Browser";
}
function release2() {
  if (typeof globalThis.navigator !== "undefined") {
    return globalThis.navigator.appVersion;
  }
  return "";
}
function networkInterfaces() {
}
function getNetworkInterfaces() {
}
function arch() {
  return "javascript";
}
function platform2() {
  return "browser";
}
function tmpDir() {
  return "/tmp";
}
var _endianness, tmpdir, EOL, os_default;
var init_os = __esm({
  "node-modules-polyfills:os"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    tmpdir = tmpDir;
    EOL = "\n";
    os_default = {
      EOL,
      tmpdir,
      tmpDir,
      networkInterfaces,
      getNetworkInterfaces,
      release: release2,
      type,
      cpus,
      totalmem,
      freemem,
      uptime: uptime2,
      loadavg,
      hostname,
      endianness
    };
  }
});

// node-modules-polyfills-commonjs:os
var require_os = __commonJS({
  "node-modules-polyfills-commonjs:os"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var polyfill = (init_os(), __toCommonJS(os_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// ../node_modules/dotenv/package.json
var require_package = __commonJS({
  "../node_modules/dotenv/package.json"(exports, module) {
    module.exports = {
      name: "dotenv",
      version: "16.3.1",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://github.com/motdotla/dotenv?sponsor=1",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// ../node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "../node_modules/dotenv/lib/main.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var fs = require_fs();
    var path = require_path();
    var os = require_os();
    var crypto2 = require_crypto();
    var packageJson = require_package();
    var version3 = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        throw new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      }
      const keys2 = _dotenvKey(options).split(",");
      const length = keys2.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys2[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version3}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version3}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version3}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          throw new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        throw new Error("INVALID_DOTENV_KEY: Missing key part");
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        throw new Error("INVALID_DOTENV_KEY: Missing environment part");
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      if (options && options.path && options.path.length > 0) {
        dotenvPath = options.path;
      }
      return dotenvPath.endsWith(".vault") ? dotenvPath : `${dotenvPath}.vault`;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug2 = Boolean(options && options.debug);
      if (options) {
        if (options.path != null) {
          dotenvPath = _resolveHome(options.path);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
      }
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
        let processEnv = process.env;
        if (options && options.processEnv != null) {
          processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsed, options);
        return { parsed };
      } catch (e) {
        if (debug2) {
          _debug(`Failed to load ${dotenvPath} ${e.message}`);
        }
        return { error: e };
      }
    }
    function config4(options) {
      const vaultPath = _vaultPath(options);
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      if (!fs.existsSync(vaultPath)) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer2.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer2.from(encrypted, "base64");
      const nonce = ciphertext.slice(0, 12);
      const authTag = ciphertext.slice(-16);
      ciphertext = ciphertext.slice(12, -16);
      try {
        const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const msg = "INVALID_DOTENV_KEY: It must be 64 characters long (or more)";
          throw new Error(msg);
        } else if (decryptionFailed) {
          const msg = "DECRYPTION_FAILED: Please check your DOTENV_KEY";
          throw new Error(msg);
        } else {
          console.error("Error: ", error.code);
          console.error("Error: ", error.message);
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug2 = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        throw new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug2) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config: config4,
      decrypt,
      parse,
      populate
    };
    module.exports.configDotenv = DotenvModule.configDotenv;
    module.exports._configVault = DotenvModule._configVault;
    module.exports._parseVault = DotenvModule._parseVault;
    module.exports.config = DotenvModule.config;
    module.exports.decrypt = DotenvModule.decrypt;
    module.exports.parse = DotenvModule.parse;
    module.exports.populate = DotenvModule.populate;
    module.exports = DotenvModule;
  }
});

// node-modules-polyfills:buffer
var buffer_exports = {};
__export(buffer_exports, {
  Buffer: () => Buffer3,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  SlowBuffer: () => SlowBuffer,
  isBuffer: () => isBuffer3,
  kMaxLength: () => _kMaxLength
});
function init2() {
  inited2 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup2[i] = code[i];
    revLookup2[code.charCodeAt(i)] = i;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited2) {
    init2();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr2(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup2[b64.charCodeAt(i)] << 18 | revLookup2[b64.charCodeAt(i + 1)] << 12 | revLookup2[b64.charCodeAt(i + 2)] << 6 | revLookup2[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i)] << 2 | revLookup2[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i)] << 10 | revLookup2[b64.charCodeAt(i + 1)] << 4 | revLookup2[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk2(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk2(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup2[tmp >> 2];
    output += lookup2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup2[tmp >> 10];
    output += lookup2[tmp >> 4 & 63];
    output += lookup2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write2(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength2() {
  return Buffer3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer2(that, length) {
  if (kMaxLength2() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer3.prototype;
  } else {
    if (that === null) {
      that = new Buffer3(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer3(arg, encodingOrOffset, length) {
  if (!Buffer3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer3)) {
    return new Buffer3(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from2(this, arg, encodingOrOffset, length);
}
function from2(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString2(that, value, encodingOrOffset);
  }
  return fromObject2(that, value);
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc2(that, size, fill3, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill3, encoding) : createBuffer2(that, size).fill(fill3);
  }
  return createBuffer2(that, size);
}
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer3.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength2(string, encoding) | 0;
  that = createBuffer2(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike2(that, array) {
  var length = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer2(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer3.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked2(length) {
  if (length >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    length = 0;
  }
  return Buffer3.alloc(+length);
}
function internalIsBuffer2(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength2(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString2(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start, end);
      case "ascii":
        return asciiSlice2(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start, end);
      case "base64":
        return base64Slice2(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap2(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer3.from(val, encoding);
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer3.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite2(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write2(buf, string, offset, length) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
}
function asciiWrite2(buf, string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), buf, offset, length);
}
function latin1Write2(buf, string, offset, length) {
  return asciiWrite2(buf, string, offset, length);
}
function base64Write2(buf, string, offset, length) {
  return blitBuffer2(base64ToBytes2(string), buf, offset, length);
}
function ucs2Write2(buf, string, offset, length) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset), buf, offset, length);
}
function base64Slice2(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice2(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
function asciiSlice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice2(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex2(buf[i]);
  }
  return out;
}
function utf16leSlice2(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset2(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt2(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer2(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt162(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt322(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE7542(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 4);
  }
  write2(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 8);
  }
  write2(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim2(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex2(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes2(string, units2) {
  units2 = units2 || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units2 -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units2 -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units2 -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units2 -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units2 -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units2 -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units2 -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units2 -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes2(str, units2) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units2 -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes2(str) {
  return toByteArray(base64clean2(str));
}
function blitBuffer2(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan2(val) {
  return val !== val;
}
function isBuffer3(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
var lookup2, revLookup2, Arr2, inited2, toString4, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH2, INVALID_BASE64_RE2;
var init_buffer2 = __esm({
  "node-modules-polyfills:buffer"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    lookup2 = [];
    revLookup2 = [];
    Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited2 = false;
    toString4 = {}.toString;
    isArray2 = Array.isArray || function(arr) {
      return toString4.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer3.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength2();
    Buffer3.poolSize = 8192;
    Buffer3._augment = function(arr) {
      arr.__proto__ = Buffer3.prototype;
      return arr;
    };
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from2(null, value, encodingOrOffset, length);
    };
    if (Buffer3.TYPED_ARRAY_SUPPORT) {
      Buffer3.prototype.__proto__ = Uint8Array.prototype;
      Buffer3.__proto__ = Uint8Array;
    }
    Buffer3.alloc = function(size, fill3, encoding) {
      return alloc2(null, size, fill3, encoding);
    };
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer3.isBuffer = isBuffer3;
    Buffer3.compare = function compare3(a, b) {
      if (!internalIsBuffer2(a) || !internalIsBuffer2(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding2(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat2(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer2(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer3.byteLength = byteLength2;
    Buffer3.prototype._isBuffer = true;
    Buffer3.prototype.swap16 = function swap162() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap2(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap322() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap2(this, i, i + 3);
        swap2(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap642() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap2(this, i, i + 7);
        swap2(this, i + 1, i + 6);
        swap2(this, i + 2, i + 5);
        swap2(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString5() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length);
      return slowToString2.apply(this, arguments);
    };
    Buffer3.prototype.equals = function equals2(b) {
      if (!internalIsBuffer2(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer3.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer2(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
    };
    Buffer3.prototype.write = function write3(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite2(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write2(this, string, offset, length);
          case "ascii":
            return asciiWrite2(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write2(this, string, offset, length);
          case "base64":
            return base64Write2(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write2(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON3() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH2 = 4096;
    Buffer3.prototype.slice = function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer3.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer3(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer3.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUIntBE = function readUIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset2(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUInt8 = function readUInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUInt16LE = function readUInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUInt16BE = function readUInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUInt32BE = function readUInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var i = byteLength3;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer3.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 255, 0);
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUInt16LE = function writeUInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeUInt16BE = function writeUInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeUInt32LE = function writeUInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 127, -128);
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer3.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill2(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer3(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node-modules-polyfills-commonjs:buffer
var require_buffer = __commonJS({
  "node-modules-polyfills-commonjs:buffer"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var polyfill = (init_buffer2(), __toCommonJS(buffer_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// ../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../node_modules/safe-buffer/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var buffer = require_buffer();
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer4.prototype);
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill3, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill3 !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill3, encoding);
        } else {
          buf.fill(fill3);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type2, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events = target._events;
    }
    existing = events[type2];
  }
  if (!existing) {
    existing = events[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type2;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type2, listener) {
  var fired = false;
  function g() {
    target.removeListener(type2, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type2) {
  var events = this._events;
  if (events) {
    var evlistener = events[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy3 = new Array(i);
  while (i--)
    copy3[i] = arr[i];
  return copy3;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit2(type2) {
      var er, handler, len, args, i, events, domain2;
      var needDomainExit = false;
      var doError = type2 === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type2];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain2.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener2(type2, listener) {
      return _addListener(this, type2, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
      return _addListener(this, type2, listener, true);
    };
    EventEmitter.prototype.once = function once2(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener2(type2, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type2];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type2];
          if (events.removeListener)
            this.emit("removeListener", type2, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type2];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type2, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type2) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type2]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type2];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type2];
      if (typeof listeners2 === "function") {
        this.removeListener(type2, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type2, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type2) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type2];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2);
      } else {
        return listenerCount.call(emitter, type2);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop4() {
}
function binding2(name) {
  throw new Error("process.binding is not supported");
}
function cwd2() {
  return "/";
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported");
}
function umask2() {
  return 0;
}
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime3() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
var cachedSetTimeout2, cachedClearTimeout2, queue2, draining2, currentQueue2, queueIndex2, title2, platform3, browser2, env2, argv2, version2, versions2, release3, config3, on2, addListener3, once3, off2, removeListener3, removeAllListeners3, emit3, performance2, performanceNow2, startTime2, browser$1, process_default;
var init_process2 = __esm({
  "node-modules-polyfills:process"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    cachedSetTimeout2 = defaultSetTimout2;
    cachedClearTimeout2 = defaultClearTimeout2;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout2 = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout2 = clearTimeout;
    }
    queue2 = [];
    draining2 = false;
    queueIndex2 = -1;
    Item2.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title2 = "browser";
    platform3 = "browser";
    browser2 = true;
    env2 = {};
    argv2 = [];
    version2 = "";
    versions2 = {};
    release3 = {};
    config3 = {};
    on2 = noop4;
    addListener3 = noop4;
    once3 = noop4;
    off2 = noop4;
    removeListener3 = noop4;
    removeAllListeners3 = noop4;
    emit3 = noop4;
    performance2 = globalThis.performance || {};
    performanceNow2 = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    startTime2 = /* @__PURE__ */ new Date();
    browser$1 = {
      nextTick: nextTick2,
      title: title2,
      browser: browser2,
      env: env2,
      argv: argv2,
      version: version2,
      versions: versions2,
      on: on2,
      addListener: addListener3,
      once: once3,
      off: off2,
      removeListener: removeListener3,
      removeAllListeners: removeAllListeners3,
      emit: emit3,
      binding: binding2,
      cwd: cwd2,
      chdir: chdir2,
      umask: umask2,
      hrtime: hrtime2,
      platform: platform3,
      release: release3,
      config: config3,
      uptime: uptime3
    };
    process_default = browser$1;
  }
});

// ../node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits2, inherits_default;
var init_inherits = __esm({
  "../node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    if (typeof Object.create === "function") {
      inherits2 = function inherits3(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits2 = function inherits3(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits2;
  }
});

// node-modules-polyfills:util
var util_exports = {};
__export(util_exports, {
  _extend: () => _extend,
  debuglog: () => debuglog,
  default: () => util_default,
  deprecate: () => deprecate,
  format: () => format,
  inherits: () => inherits_default,
  inspect: () => inspect2,
  isArray: () => isArray3,
  isBoolean: () => isBoolean2,
  isBuffer: () => isBuffer4,
  isDate: () => isDate2,
  isError: () => isError,
  isFunction: () => isFunction2,
  isNull: () => isNull,
  isNullOrUndefined: () => isNullOrUndefined,
  isNumber: () => isNumber2,
  isObject: () => isObject3,
  isPrimitive: () => isPrimitive,
  isRegExp: () => isRegExp2,
  isString: () => isString2,
  isSymbol: () => isSymbol,
  isUndefined: () => isUndefined2,
  log: () => log
});
function format(f) {
  if (!isString2(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect2(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject3(x)) {
      str += " " + x;
    } else {
      str += " " + inspect2(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined2(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined2(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect2(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean2(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined2(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined2(ctx.depth))
    ctx.depth = 2;
  if (isUndefined2(ctx.colors))
    ctx.colors = false;
  if (isUndefined2(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect2.styles[styleType];
  if (style) {
    return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect2 && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString2(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction2(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp2(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate2(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray3(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction2(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp2(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate2(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp2(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined2(value))
    return ctx.stylize("undefined", "undefined");
  if (isString2(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber2(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean2(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty2(value, String(i))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty2(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined2(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray3(ar) {
  return Array.isArray(ar);
}
function isBoolean2(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber2(arg) {
  return typeof arg === "number";
}
function isString2(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined2(arg) {
  return arg === void 0;
}
function isRegExp2(re) {
  return isObject3(re) && objectToString(re) === "[object RegExp]";
}
function isObject3(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate2(d) {
  return isObject3(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject3(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction2(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer4(maybeBuf) {
  return Buffer2.isBuffer(maybeBuf);
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
function timestamp() {
  var d = /* @__PURE__ */ new Date();
  var time = [
    pad(d.getHours()),
    pad(d.getMinutes()),
    pad(d.getSeconds())
  ].join(":");
  return [d.getDate(), months[d.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function _extend(origin, add) {
  if (!add || !isObject3(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron, months, util_default;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    init_process2();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect2.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect2.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    util_default = {
      inherits: inherits_default,
      _extend,
      log,
      isBuffer: isBuffer4,
      isPrimitive,
      isFunction: isFunction2,
      isError,
      isDate: isDate2,
      isObject: isObject3,
      isRegExp: isRegExp2,
      isUndefined: isUndefined2,
      isSymbol,
      isString: isString2,
      isNumber: isNumber2,
      isNullOrUndefined,
      isNull,
      isBoolean: isBoolean2,
      isArray: isArray3,
      inspect: inspect2,
      deprecate,
      format,
      debuglog
    };
  }
});

// ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    init_buffer2();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer3.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer3.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer3(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    init_buffer2();
    isBufferEncoding = Buffer3.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type2) {
  return emitter.listeners(type2).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick2(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick2(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick2(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer2.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick2(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach2(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf3(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process2();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick2(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf3(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick2(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach2(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick2(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer3.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick2(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer3.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick2(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick2(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick2(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    init_util();
    init_buffer2();
    init_events();
    init_duplex();
    init_process2();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer3.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick2(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    init_util();
    init_process2();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills-commonjs:util
var require_util = __commonJS({
  "node-modules-polyfills-commonjs:util"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var polyfill = (init_util(), __toCommonJS(util_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// ../node_modules/jsonwebtoken/node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "../node_modules/jsonwebtoken/node_modules/jws/lib/data-stream.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var Stream2 = require_stream();
    var util2 = require_util();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer4.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer4.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util2.inherits(DataStream, Stream2);
    DataStream.prototype.write = function write4(data) {
      this.buffer = Buffer4.concat([this.buffer, Buffer4.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module.exports = DataStream;
  }
});

// ../node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "../node_modules/buffer-equal-constant-time/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Buffer4 = require_buffer().Buffer;
    var SlowBuffer2 = require_buffer().SlowBuffer;
    module.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer4.prototype.equal = SlowBuffer2.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer4.prototype.equal;
    var origSlowBufEqual = SlowBuffer2.prototype.equal;
    bufferEq.restore = function() {
      Buffer4.prototype.equal = origBufEqual;
      SlowBuffer2.prototype.equal = origSlowBufEqual;
    };
  }
});

// ../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module.exports = getParamBytesForAlg;
  }
});

// ../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer4.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer4.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer4.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer4.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module.exports = {
      derToJose,
      joseToDer
    };
  }
});

// ../node_modules/jsonwebtoken/node_modules/jwa/index.js
var require_jwa = __commonJS({
  "../node_modules/jsonwebtoken/node_modules/jwa/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer4 = require_safe_buffer().Buffer;
    var crypto2 = require_crypto();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util2 = require_util();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer4.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer4.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer4.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util2.format.bind(util2, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer4.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto2.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer4.from(signature), Buffer4.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// ../node_modules/jsonwebtoken/node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "../node_modules/jsonwebtoken/node_modules/jws/lib/tostring.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Buffer4 = require_buffer().Buffer;
    module.exports = function toString6(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer4.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// ../node_modules/jsonwebtoken/node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "../node_modules/jsonwebtoken/node_modules/jws/lib/sign-stream.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream2 = require_stream();
    var toString6 = require_tostring();
    var util2 = require_util();
    function base64url(string, encoding) {
      return Buffer4.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString6(header), "binary");
      var encodedPayload = base64url(toString6(payload), encoding);
      return util2.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util2.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util2.inherits(SignStream, Stream2);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module.exports = SignStream;
  }
});

// ../node_modules/jsonwebtoken/node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "../node_modules/jsonwebtoken/node_modules/jws/lib/verify-stream.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream2 = require_stream();
    var toString6 = require_tostring();
    var util2 = require_util();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject4(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject4(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer4.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer4.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString6(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString6(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util2.inherits(VerifyStream, Stream2);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module.exports = VerifyStream;
  }
});

// ../node_modules/jsonwebtoken/node_modules/jws/index.js
var require_jws = __commonJS({
  "../node_modules/jsonwebtoken/node_modules/jws/index.js"(exports) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// ../node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "../node_modules/jsonwebtoken/decode.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var jws = require_jws();
    module.exports = function(jwt3, options) {
      options = options || {};
      var decoded = jws.decode(jwt3, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// ../node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "../node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module.exports = JsonWebTokenError;
  }
});

// ../node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "../node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module.exports = NotBeforeError;
  }
});

// ../node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "../node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module.exports = TokenExpiredError;
  }
});

// ../node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/ms/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "../node_modules/jsonwebtoken/lib/timespan.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var ms = require_ms();
    module.exports = function(time, iat) {
      var timestamp2 = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp2 + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp2 + time;
      } else {
        return;
      }
    };
  }
});

// ../node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "../node_modules/semver/internal/constants.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// ../node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "../node_modules/semver/internal/debug.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug2;
  }
});

// ../node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../node_modules/semver/internal/re.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug2 = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t2 = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug2(name, index, value);
      t2[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
    createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
    createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t2.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// ../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../node_modules/semver/internal/parse-options.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// ../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../node_modules/semver/internal/identifiers.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../node_modules/semver/classes/semver.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var debug2 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t: t2 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug2("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version3.trim().match(options.loose ? re[t2.LOOSE] : re[t2.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug2("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release4, identifier, identifierBase) {
        switch (release4) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release4}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// ../node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "../node_modules/semver/functions/parse.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var parse = (version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse;
  }
});

// ../node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../node_modules/semver/functions/valid.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var parse = require_parse();
    var valid = (version3, options) => {
      const v = parse(version3, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});

// ../node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../node_modules/semver/functions/clean.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var parse = require_parse();
    var clean = (version3, options) => {
      const s = parse(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// ../node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../node_modules/semver/functions/inc.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var inc = (version3, release4, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release4, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// ../node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../node_modules/semver/functions/diff.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var parse = require_parse();
    var diff = (version1, version22) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// ../node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../node_modules/semver/functions/major.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});

// ../node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../node_modules/semver/functions/minor.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});

// ../node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../node_modules/semver/functions/patch.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});

// ../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../node_modules/semver/functions/prerelease.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var parse = require_parse();
    var prerelease = (version3, options) => {
      const parsed = parse(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// ../node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../node_modules/semver/functions/compare.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var compare5 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare5;
  }
});

// ../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../node_modules/semver/functions/rcompare.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compare5 = require_compare();
    var rcompare = (a, b, loose) => compare5(b, a, loose);
    module.exports = rcompare;
  }
});

// ../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../node_modules/semver/functions/compare-loose.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compare5 = require_compare();
    var compareLoose = (a, b) => compare5(a, b, true);
    module.exports = compareLoose;
  }
});

// ../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../node_modules/semver/functions/compare-build.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// ../node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../node_modules/semver/functions/sort.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  }
});

// ../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../node_modules/semver/functions/rsort.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  }
});

// ../node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../node_modules/semver/functions/gt.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compare5 = require_compare();
    var gt = (a, b, loose) => compare5(a, b, loose) > 0;
    module.exports = gt;
  }
});

// ../node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../node_modules/semver/functions/lt.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compare5 = require_compare();
    var lt = (a, b, loose) => compare5(a, b, loose) < 0;
    module.exports = lt;
  }
});

// ../node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../node_modules/semver/functions/eq.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compare5 = require_compare();
    var eq = (a, b, loose) => compare5(a, b, loose) === 0;
    module.exports = eq;
  }
});

// ../node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../node_modules/semver/functions/neq.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compare5 = require_compare();
    var neq = (a, b, loose) => compare5(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// ../node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../node_modules/semver/functions/gte.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compare5 = require_compare();
    var gte = (a, b, loose) => compare5(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// ../node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../node_modules/semver/functions/lte.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var compare5 = require_compare();
    var lte = (a, b, loose) => compare5(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// ../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../node_modules/semver/functions/cmp.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// ../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../node_modules/semver/functions/coerce.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t: t2 } = require_re();
    var coerce2 = (version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version3.match(re[t2.COERCE]);
      } else {
        let next;
        while ((next = re[t2.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t2.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module.exports = coerce2;
  }
});

// ../node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// ../node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from3, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from3 = from3 || 0;
      if (from3 < 0) {
        from3 += this.length;
      }
      var ret = new Yallist();
      if (to < from3 || to < 0) {
        return ret;
      }
      if (from3 < 0) {
        from3 = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from3; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from3, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from3 = from3 || 0;
      if (from3 < 0) {
        from3 += this.length;
      }
      var ret = new Yallist();
      if (to < from3 || to < 0) {
        return ret;
      }
      if (from3 < 0) {
        from3 = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from3; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// ../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim2(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim2(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim2(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim2(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim2(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim2 = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  }
});

// ../node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../node_modules/semver/classes/range.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t2.HYPHENRANGELOOSE] : re[t2.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug2("hyphen replace", range);
        range = range.replace(re[t2.COMPARATORTRIM], comparatorTrimReplace);
        debug2("comparator trim", range);
        range = range.replace(re[t2.TILDETRIM], tildeTrimReplace);
        debug2("tilde trim", range);
        range = range.replace(re[t2.CARETTRIM], caretTrimReplace);
        debug2("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug2("loose invalid filter", comp, this.options);
            return !!comp.match(re[t2.COMPARATORLOOSE]);
          });
        }
        debug2("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug2 = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t: t2,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t2.TILDELOOSE] : re[t2.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug2("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug2("caret", comp, options);
      const r = options.loose ? re[t2.CARETLOOSE] : re[t2.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t2.XRANGELOOSE] : re[t2.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug2("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(re[t2.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug2("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from3, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from3 = "";
      } else if (isX(fm)) {
        from3 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from3 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from3 = `>=${from3}`;
      } else {
        from3 = `>=${from3}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from3} ${to}`.trim();
    };
    var testSet = (set, version3, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug2(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../node_modules/semver/classes/comparator.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug2("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug2("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t2.COMPARATORLOOSE] : re[t2.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug2("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t: t2 } = require_re();
    var cmp = require_cmp();
    var debug2 = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../node_modules/semver/functions/satisfies.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Range = require_range();
    var satisfies = (version3, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    };
    module.exports = satisfies;
  }
});

// ../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../node_modules/semver/ranges/to-comparators.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// ../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions3, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions3.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// ../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions3, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions3.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// ../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../node_modules/semver/ranges/min-version.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// ../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../node_modules/semver/ranges/valid.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// ../node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../node_modules/semver/ranges/outside.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version3, range, hilo, options) => {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// ../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../node_modules/semver/ranges/gtr.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var outside = require_outside();
    var gtr = (version3, range, options) => outside(version3, range, ">", options);
    module.exports = gtr;
  }
});

// ../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../node_modules/semver/ranges/ltr.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var outside = require_outside();
    var ltr = (version3, range, options) => outside(version3, range, "<", options);
    module.exports = ltr;
  }
});

// ../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../node_modules/semver/ranges/intersects.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});

// ../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../node_modules/semver/ranges/simplify.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var satisfies = require_satisfies();
    var compare5 = require_compare();
    module.exports = (versions3, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions3.sort((a, b) => compare5(a, b, options));
      for (const version3 of v) {
        const included = satisfies(version3, range, options);
        if (included) {
          prev = version3;
          if (!first) {
            first = version3;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// ../node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../node_modules/semver/ranges/subset.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare5 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare5(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare5(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare5(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module.exports = subset;
  }
});

// ../node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../node_modules/semver/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare5 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce2 = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare5,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce: coerce2,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// ../node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "../node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// ../node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "../node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// ../node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "../node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module.exports = function(algorithm, key) {
      if (!algorithm || !key)
        return;
      const keyType = key.asymmetricKeyType;
      if (!keyType)
        return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// ../node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "../node_modules/jsonwebtoken/lib/psSupported.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// ../node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "../node_modules/jsonwebtoken/verify.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = require_crypto();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done2;
      if (callback) {
        done2 = callback;
      } else {
        done2 = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done2(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done2(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done2(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done2(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done2(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done2(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done2(err);
      }
      if (!decodedToken) {
        return done2(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done2(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done2(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done2(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done2(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done2(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer2.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done2(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done2(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done2(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done2(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done2(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done2(e);
        }
        if (!valid) {
          return done2(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done2(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done2(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done2(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done2(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done2(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done2(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done2(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done2(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done2(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done2(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done2(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done2(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done2(null, {
            header,
            payload,
            signature
          });
        }
        return done2(null, payload);
      });
    };
  }
});

// ../node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "../node_modules/lodash.includes/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var objectToString2 = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray4(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty3.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes3(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty3.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
    }
    var isArray4 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction3(value) {
      var tag = isObject4(value) ? objectToString2.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject4(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString3(value) {
      return typeof value == "string" || !isArray4(value) && isObjectLike(value) && objectToString2.call(value) == stringTag;
    }
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys2(object)) : [];
    }
    module.exports = includes3;
  }
});

// ../node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "../node_modules/lodash.isboolean/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString2 = objectProto.toString;
    function isBoolean3(value) {
      return value === true || value === false || isObjectLike(value) && objectToString2.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module.exports = isBoolean3;
  }
});

// ../node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "../node_modules/lodash.isinteger/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString2 = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject4(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = isInteger;
  }
});

// ../node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "../node_modules/lodash.isnumber/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString2 = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber3(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString2.call(value) == numberTag;
    }
    module.exports = isNumber3;
  }
});

// ../node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "../node_modules/lodash.isplainobject/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString2 = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject3(value) {
      if (!isObjectLike(value) || objectToString2.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject3;
  }
});

// ../node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "../node_modules/lodash.isstring/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString2 = objectProto.toString;
    var isArray4 = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString3(value) {
      return typeof value == "string" || !isArray4(value) && isObjectLike(value) && objectToString2.call(value) == stringTag;
    }
    module.exports = isString3;
  }
});

// ../node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "../node_modules/lodash.once/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString2 = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once4(func) {
      return before(2, func);
    }
    function isObject4(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = once4;
  }
});

// ../node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "../node_modules/jsonwebtoken/sign.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes3 = require_lodash();
    var isBoolean3 = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber3 = require_lodash4();
    var isPlainObject3 = require_lodash5();
    var isString3 = require_lodash6();
    var once4 = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey } = require_crypto();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString3(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString3(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString3(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes3.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject3, message: '"header" must be an object' },
      encoding: { isValid: isString3, message: '"encoding" must be a string' },
      issuer: { isValid: isString3, message: '"issuer" must be a string' },
      subject: { isValid: isString3, message: '"subject" must be a string' },
      jwtid: { isValid: isString3, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean3, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString3, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean3, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean3, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean3, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber3, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber3, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber3, message: '"nbf" should be a number of seconds' }
    };
    function validate(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject3(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer2.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer2.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
          return failure(error);
        }
      }
      const timestamp2 = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp2;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp2);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp2);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once4(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// ../node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "../node_modules/jsonwebtoken/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// ../node_modules/zod/lib/helpers/util.js
var require_util2 = __commonJS({
  "../node_modules/zod/lib/helpers/util.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
    var util2;
    (function(util3) {
      util3.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util3.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util3.assertNever = assertNever;
      util3.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util3.getValidEnumValues = (obj) => {
        const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util3.objectValues(filtered);
      };
      util3.objectValues = (obj) => {
        return util3.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys2 = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys2.push(key);
          }
        }
        return keys2;
      };
      util3.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util3.joinValues = joinValues;
      util3.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util2 = exports.util || (exports.util = {}));
    var objectUtil2;
    (function(objectUtil3) {
      objectUtil3.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil2 = exports.objectUtil || (exports.objectUtil = {}));
    exports.ZodParsedType = util2.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType2 = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return exports.ZodParsedType.undefined;
        case "string":
          return exports.ZodParsedType.string;
        case "number":
          return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
          return exports.ZodParsedType.boolean;
        case "function":
          return exports.ZodParsedType.function;
        case "bigint":
          return exports.ZodParsedType.bigint;
        case "symbol":
          return exports.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports.ZodParsedType.array;
          }
          if (data === null) {
            return exports.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports.ZodParsedType.date;
          }
          return exports.ZodParsedType.object;
        default:
          return exports.ZodParsedType.unknown;
      }
    };
    exports.getParsedType = getParsedType2;
  }
});

// ../node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS({
  "../node_modules/zod/lib/ZodError.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
    var util_1 = require_util2();
    exports.ZodIssueCode = util_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson2 = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    exports.quotelessJson = quotelessJson2;
    var ZodError2 = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    exports.ZodError = ZodError2;
    ZodError2.create = (issues) => {
      const error = new ZodError2(issues);
      return error;
    };
  }
});

// ../node_modules/zod/lib/locales/en.js
var require_en = __commonJS({
  "../node_modules/zod/lib/locales/en.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util2();
    var ZodError_1 = require_ZodError();
    var errorMap2 = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
          if (issue.received === util_1.ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_1.ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodError_1.ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodError_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodError_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_1.ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util_1.util.assertNever(issue);
      }
      return { message };
    };
    exports.default = errorMap2;
  }
});

// ../node_modules/zod/lib/errors.js
var require_errors = __commonJS({
  "../node_modules/zod/lib/errors.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
    var en_1 = __importDefault(require_en());
    exports.defaultErrorMap = en_1.default;
    var overrideErrorMap2 = en_1.default;
    function setErrorMap2(map) {
      overrideErrorMap2 = map;
    }
    exports.setErrorMap = setErrorMap2;
    function getErrorMap2() {
      return overrideErrorMap2;
    }
    exports.getErrorMap = getErrorMap2;
  }
});

// ../node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS({
  "../node_modules/zod/lib/helpers/parseUtil.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
    var errors_1 = require_errors();
    var en_1 = __importDefault(require_en());
    var makeIssue2 = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    exports.makeIssue = makeIssue2;
    exports.EMPTY_PATH = [];
    function addIssueToContext2(ctx, issueData) {
      const issue = (0, exports.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          (0, errors_1.getErrorMap)(),
          en_1.default
          // then global default map
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    exports.addIssueToContext = addIssueToContext2;
    var ParseStatus2 = class {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return exports.INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return ParseStatus2.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return exports.INVALID;
          if (value.status === "aborted")
            return exports.INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    exports.ParseStatus = ParseStatus2;
    exports.INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY2 = (value) => ({ status: "dirty", value });
    exports.DIRTY = DIRTY2;
    var OK2 = (value) => ({ status: "valid", value });
    exports.OK = OK2;
    var isAborted2 = (x) => x.status === "aborted";
    exports.isAborted = isAborted2;
    var isDirty2 = (x) => x.status === "dirty";
    exports.isDirty = isDirty2;
    var isValid2 = (x) => x.status === "valid";
    exports.isValid = isValid2;
    var isAsync2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    exports.isAsync = isAsync2;
  }
});

// ../node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS({
  "../node_modules/zod/lib/helpers/typeAliases.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS({
  "../node_modules/zod/lib/helpers/errorUtil.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorUtil = void 0;
    var errorUtil2;
    (function(errorUtil3) {
      errorUtil3.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil3.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil2 = exports.errorUtil || (exports.errorUtil = {}));
  }
});

// ../node_modules/zod/lib/types.js
var require_types = __commonJS({
  "../node_modules/zod/lib/types.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
    exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = void 0;
    var errors_1 = require_errors();
    var errorUtil_1 = require_errorUtil();
    var parseUtil_1 = require_parseUtil();
    var util_1 = require_util2();
    var ZodError_1 = require_ZodError();
    var ParseInputLazyPath2 = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    var handleResult2 = (ctx, result) => {
      if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError_1.ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams2(params) {
      if (!params)
        return {};
      const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
      if (errorMap2 && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap2)
        return { errorMap: errorMap2, description };
      const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
          return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    var ZodType2 = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult2(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult2(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodError_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects2({
          schema: this,
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional2.create(this, this._def);
      }
      nullable() {
        return ZodNullable2.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray2.create(this, this._def);
      }
      promise() {
        return ZodPromise2.create(this, this._def);
      }
      or(option) {
        return ZodUnion2.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection2.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects2({
          ...processCreateParams2(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault2({
          ...processCreateParams2(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind2.ZodDefault
        });
      }
      brand() {
        return new ZodBranded2({
          typeName: ZodFirstPartyTypeKind2.ZodBranded,
          type: this,
          ...processCreateParams2(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch2({
          ...processCreateParams2(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind2.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline2.create(this, target);
      }
      readonly() {
        return ZodReadonly2.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    exports.ZodType = ZodType2;
    exports.Schema = ZodType2;
    exports.ZodSchema = ZodType2;
    var cuidRegex2 = /^c[^\s-]{8,}$/i;
    var cuid2Regex2 = /^[a-z][a-z0-9]*$/;
    var ulidRegex2 = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    var uuidRegex2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    var emailRegex2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    var _emojiRegex2 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    var emojiRegex2;
    var ipv4Regex2 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    var ipv6Regex2 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    var datetimeRegex2 = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    function isValidIP2(ip, version3) {
      if ((version3 === "v4" || !version3) && ipv4Regex2.test(ip)) {
        return true;
      }
      if ((version3 === "v6" || !version3) && ipv6Regex2.test(ip)) {
        return true;
      }
      return false;
    }
    var ZodString2 = class extends ZodType2 {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(
            ctx2,
            {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.string,
              received: ctx2.parsedType
            }
            //
          );
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex2) {
              emojiRegex2 = new RegExp(_emojiRegex2, "u");
            }
            if (!emojiRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "emoji",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid2",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ulid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex2(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP2(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ip",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodError_1.ZodIssueCode.invalid_string,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new ZodString2({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      /**
       * @deprecated Use z.string().min(1) instead.
       * @see {@link ZodString.min}
       */
      nonempty(message) {
        return this.min(1, errorUtil_1.errorUtil.errToObj(message));
      }
      trim() {
        return new ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports.ZodString = ZodString2;
    ZodString2.create = (params) => {
      var _a;
      return new ZodString2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams2(params)
      });
    };
    function floatSafeRemainder2(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    var ZodNumber2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder2(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodNumber2({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new ZodNumber2({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    exports.ZodNumber = ZodNumber2;
    ZodNumber2.create = (params) => {
      return new ZodNumber2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams2(params)
      });
    };
    var ZodBigInt2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodBigInt2({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new ZodBigInt2({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports.ZodBigInt = ZodBigInt2;
    ZodBigInt2.create = (params) => {
      var _a;
      return new ZodBigInt2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams2(params)
      });
    };
    var ZodBoolean2 = class extends ZodType2 {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodBoolean = ZodBoolean2;
    ZodBoolean2.create = (params) => {
      return new ZodBoolean2({
        typeName: ZodFirstPartyTypeKind2.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams2(params)
      });
    };
    var ZodDate2 = class extends ZodType2 {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_date
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new ZodDate2({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    exports.ZodDate = ZodDate2;
    ZodDate2.create = (params) => {
      return new ZodDate2({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind2.ZodDate,
        ...processCreateParams2(params)
      });
    };
    var ZodSymbol2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodSymbol = ZodSymbol2;
    ZodSymbol2.create = (params) => {
      return new ZodSymbol2({
        typeName: ZodFirstPartyTypeKind2.ZodSymbol,
        ...processCreateParams2(params)
      });
    };
    var ZodUndefined2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodUndefined = ZodUndefined2;
    ZodUndefined2.create = (params) => {
      return new ZodUndefined2({
        typeName: ZodFirstPartyTypeKind2.ZodUndefined,
        ...processCreateParams2(params)
      });
    };
    var ZodNull2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodNull = ZodNull2;
    ZodNull2.create = (params) => {
      return new ZodNull2({
        typeName: ZodFirstPartyTypeKind2.ZodNull,
        ...processCreateParams2(params)
      });
    };
    var ZodAny2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodAny = ZodAny2;
    ZodAny2.create = (params) => {
      return new ZodAny2({
        typeName: ZodFirstPartyTypeKind2.ZodAny,
        ...processCreateParams2(params)
      });
    };
    var ZodUnknown2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodUnknown = ZodUnknown2;
    ZodUnknown2.create = (params) => {
      return new ZodUnknown2({
        typeName: ZodFirstPartyTypeKind2.ZodUnknown,
        ...processCreateParams2(params)
      });
    };
    var ZodNever2 = class extends ZodType2 {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
    };
    exports.ZodNever = ZodNever2;
    ZodNever2.create = (params) => {
      return new ZodNever2({
        typeName: ZodFirstPartyTypeKind2.ZodNever,
        ...processCreateParams2(params)
      });
    };
    var ZodVoid2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodVoid = ZodVoid2;
    ZodVoid2.create = (params) => {
      return new ZodVoid2({
        typeName: ZodFirstPartyTypeKind2.ZodVoid,
        ...processCreateParams2(params)
      });
    };
    var ZodArray2 = class extends ZodType2 {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
          })).then((result2) => {
            return parseUtil_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new ZodArray2({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new ZodArray2({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new ZodArray2({
          ...this._def,
          exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodArray = ZodArray2;
    ZodArray2.create = (schema, params) => {
      return new ZodArray2({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind2.ZodArray,
        ...processCreateParams2(params)
      });
    };
    function deepPartialify2(schema) {
      if (schema instanceof ZodObject2) {
        const newShape = {};
        for (const key in schema.shape) {
          const fieldSchema = schema.shape[key];
          newShape[key] = ZodOptional2.create(deepPartialify2(fieldSchema));
        }
        return new ZodObject2({
          ...schema._def,
          shape: () => newShape
        });
      } else if (schema instanceof ZodArray2) {
        return new ZodArray2({
          ...schema._def,
          type: deepPartialify2(schema.element)
        });
      } else if (schema instanceof ZodOptional2) {
        return ZodOptional2.create(deepPartialify2(schema.unwrap()));
      } else if (schema instanceof ZodNullable2) {
        return ZodNullable2.create(deepPartialify2(schema.unwrap()));
      } else if (schema instanceof ZodTuple2) {
        return ZodTuple2.create(schema.items.map((item) => deepPartialify2(item)));
      } else {
        return schema;
      }
    }
    var ZodObject2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys2 = util_1.util.objectKeys(shape);
        return this._cached = { shape, keys: keys2 };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever2) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath2(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new ZodObject2({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new ZodObject2({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new ZodObject2({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new ZodObject2({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new ZodObject2({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind2.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new ZodObject2({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject2({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject2({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify2(this);
      }
      partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new ZodObject2({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional2) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new ZodObject2({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum2(util_1.util.objectKeys(this.shape));
      }
    };
    exports.ZodObject = ZodObject2;
    ZodObject2.create = (shape, params) => {
      return new ZodObject2({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams2(params)
      });
    };
    ZodObject2.strictCreate = (shape, params) => {
      return new ZodObject2({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams2(params)
      });
    };
    ZodObject2.lazycreate = (shape, params) => {
      return new ZodObject2({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams2(params)
      });
    };
    var ZodUnion2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    exports.ZodUnion = ZodUnion2;
    ZodUnion2.create = (types, params) => {
      return new ZodUnion2({
        options: types,
        typeName: ZodFirstPartyTypeKind2.ZodUnion,
        ...processCreateParams2(params)
      });
    };
    var getDiscriminator2 = (type2) => {
      if (type2 instanceof ZodLazy2) {
        return getDiscriminator2(type2.schema);
      } else if (type2 instanceof ZodEffects2) {
        return getDiscriminator2(type2.innerType());
      } else if (type2 instanceof ZodLiteral2) {
        return [type2.value];
      } else if (type2 instanceof ZodEnum2) {
        return type2.options;
      } else if (type2 instanceof ZodNativeEnum2) {
        return Object.keys(type2.enum);
      } else if (type2 instanceof ZodDefault2) {
        return getDiscriminator2(type2._def.innerType);
      } else if (type2 instanceof ZodUndefined2) {
        return [void 0];
      } else if (type2 instanceof ZodNull2) {
        return [null];
      } else {
        return null;
      }
    };
    var ZodDiscriminatedUnion2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type2 of options) {
          const discriminatorValues = getDiscriminator2(type2.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type2);
          }
        }
        return new ZodDiscriminatedUnion2({
          typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams2(params)
        });
      }
    };
    exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion2;
    function mergeValues2(a, b) {
      const aType = (0, util_1.getParsedType)(a);
      const bType = (0, util_1.getParsedType)(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues2(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues2(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    var ZodIntersection2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
            return parseUtil_1.INVALID;
          }
          const merged = mergeValues2(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_1.INVALID;
          }
          if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    exports.ZodIntersection = ZodIntersection2;
    ZodIntersection2.create = (left, right, params) => {
      return new ZodIntersection2({
        left,
        right,
        typeName: ZodFirstPartyTypeKind2.ZodIntersection,
        ...processCreateParams2(params)
      });
    };
    var ZodTuple2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath2(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new ZodTuple2({
          ...this._def,
          rest
        });
      }
    };
    exports.ZodTuple = ZodTuple2;
    ZodTuple2.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple2({
        items: schemas,
        typeName: ZodFirstPartyTypeKind2.ZodTuple,
        rest: null,
        ...processCreateParams2(params)
      });
    };
    var ZodRecord2 = class extends ZodType2 {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath2(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType2) {
          return new ZodRecord2({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind2.ZodRecord,
            ...processCreateParams2(third)
          });
        }
        return new ZodRecord2({
          keyType: ZodString2.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind2.ZodRecord,
          ...processCreateParams2(second)
        });
      }
    };
    exports.ZodRecord = ZodRecord2;
    var ZodMap2 = class extends ZodType2 {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath2(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    exports.ZodMap = ZodMap2;
    ZodMap2.create = (keyType, valueType, params) => {
      return new ZodMap2({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind2.ZodMap,
        ...processCreateParams2(params)
      });
    };
    var ZodSet2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath2(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new ZodSet2({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new ZodSet2({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodSet = ZodSet2;
    ZodSet2.create = (valueType, params) => {
      return new ZodSet2({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind2.ZodSet,
        ...processCreateParams2(params)
      });
    };
    var ZodFunction2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
          return (0, parseUtil_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise2) {
          const me = this;
          return (0, parseUtil_1.OK)(async function(...args) {
            const error = new ZodError_1.ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return (0, parseUtil_1.OK)(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new ZodFunction2({
          ...this._def,
          args: ZodTuple2.create(items).rest(ZodUnknown2.create())
        });
      }
      returns(returnType) {
        return new ZodFunction2({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new ZodFunction2({
          args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
          returns: returns || ZodUnknown2.create(),
          typeName: ZodFirstPartyTypeKind2.ZodFunction,
          ...processCreateParams2(params)
        });
      }
    };
    exports.ZodFunction = ZodFunction2;
    var ZodLazy2 = class extends ZodType2 {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    exports.ZodLazy = ZodLazy2;
    ZodLazy2.create = (getter, params) => {
      return new ZodLazy2({
        getter,
        typeName: ZodFirstPartyTypeKind2.ZodLazy,
        ...processCreateParams2(params)
      });
    };
    var ZodLiteral2 = class extends ZodType2 {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    exports.ZodLiteral = ZodLiteral2;
    ZodLiteral2.create = (value, params) => {
      return new ZodLiteral2({
        value,
        typeName: ZodFirstPartyTypeKind2.ZodLiteral,
        ...processCreateParams2(params)
      });
    };
    function createZodEnum2(values, params) {
      return new ZodEnum2({
        values,
        typeName: ZodFirstPartyTypeKind2.ZodEnum,
        ...processCreateParams2(params)
      });
    }
    var ZodEnum2 = class extends ZodType2 {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values) {
        return ZodEnum2.create(values);
      }
      exclude(values) {
        return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)));
      }
    };
    exports.ZodEnum = ZodEnum2;
    ZodEnum2.create = createZodEnum2;
    var ZodNativeEnum2 = class extends ZodType2 {
      _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    exports.ZodNativeEnum = ZodNativeEnum2;
    ZodNativeEnum2.create = (values, params) => {
      return new ZodNativeEnum2({
        values,
        typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
        ...processCreateParams2(params)
      });
    };
    var ZodPromise2 = class extends ZodType2 {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    exports.ZodPromise = ZodPromise2;
    ZodPromise2.create = (schema, params) => {
      return new ZodPromise2({
        type: schema,
        typeName: ZodFirstPartyTypeKind2.ZodPromise,
        ...processCreateParams2(params)
      });
    };
    var ZodEffects2 = class extends ZodType2 {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.issues.length) {
            return {
              status: "dirty",
              value: ctx.data
            };
          }
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_1.isValid)(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!(0, parseUtil_1.isValid)(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util_1.util.assertNever(effect);
      }
    };
    exports.ZodEffects = ZodEffects2;
    exports.ZodTransformer = ZodEffects2;
    ZodEffects2.create = (schema, effect, params) => {
      return new ZodEffects2({
        schema,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect,
        ...processCreateParams2(params)
      });
    };
    ZodEffects2.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects2({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        ...processCreateParams2(params)
      });
    };
    var ZodOptional2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
          return (0, parseUtil_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodOptional = ZodOptional2;
    ZodOptional2.create = (type2, params) => {
      return new ZodOptional2({
        innerType: type2,
        typeName: ZodFirstPartyTypeKind2.ZodOptional,
        ...processCreateParams2(params)
      });
    };
    var ZodNullable2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
          return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodNullable = ZodNullable2;
    ZodNullable2.create = (type2, params) => {
      return new ZodNullable2({
        innerType: type2,
        typeName: ZodFirstPartyTypeKind2.ZodNullable,
        ...processCreateParams2(params)
      });
    };
    var ZodDefault2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports.ZodDefault = ZodDefault2;
    ZodDefault2.create = (type2, params) => {
      return new ZodDefault2({
        innerType: type2,
        typeName: ZodFirstPartyTypeKind2.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams2(params)
      });
    };
    var ZodCatch2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if ((0, parseUtil_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    exports.ZodCatch = ZodCatch2;
    ZodCatch2.create = (type2, params) => {
      return new ZodCatch2({
        innerType: type2,
        typeName: ZodFirstPartyTypeKind2.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams2(params)
      });
    };
    var ZodNaN2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    exports.ZodNaN = ZodNaN2;
    ZodNaN2.create = (params) => {
      return new ZodNaN2({
        typeName: ZodFirstPartyTypeKind2.ZodNaN,
        ...processCreateParams2(params)
      });
    };
    exports.BRAND = Symbol("zod_brand");
    var ZodBranded2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    exports.ZodBranded = ZodBranded2;
    var ZodPipeline2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new ZodPipeline2({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind2.ZodPipeline
        });
      }
    };
    exports.ZodPipeline = ZodPipeline2;
    var ZodReadonly2 = class extends ZodType2 {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        if ((0, parseUtil_1.isValid)(result)) {
          result.value = Object.freeze(result.value);
        }
        return result;
      }
    };
    exports.ZodReadonly = ZodReadonly2;
    ZodReadonly2.create = (type2, params) => {
      return new ZodReadonly2({
        innerType: type2,
        typeName: ZodFirstPartyTypeKind2.ZodReadonly,
        ...processCreateParams2(params)
      });
    };
    var custom2 = (check, params = {}, fatal) => {
      if (check)
        return ZodAny2.create().superRefine((data, ctx) => {
          var _a, _b;
          if (!check(data)) {
            const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            const p2 = typeof p === "string" ? { message: p } : p;
            ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
          }
        });
      return ZodAny2.create();
    };
    exports.custom = custom2;
    exports.late = {
      object: ZodObject2.lazycreate
    };
    var ZodFirstPartyTypeKind2;
    (function(ZodFirstPartyTypeKind3) {
      ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind2 = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
    var instanceOfType2 = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => (0, exports.custom)((data) => data instanceof cls, params);
    exports.instanceof = instanceOfType2;
    var stringType2 = ZodString2.create;
    exports.string = stringType2;
    var numberType2 = ZodNumber2.create;
    exports.number = numberType2;
    var nanType2 = ZodNaN2.create;
    exports.nan = nanType2;
    var bigIntType2 = ZodBigInt2.create;
    exports.bigint = bigIntType2;
    var booleanType2 = ZodBoolean2.create;
    exports.boolean = booleanType2;
    var dateType2 = ZodDate2.create;
    exports.date = dateType2;
    var symbolType2 = ZodSymbol2.create;
    exports.symbol = symbolType2;
    var undefinedType2 = ZodUndefined2.create;
    exports.undefined = undefinedType2;
    var nullType2 = ZodNull2.create;
    exports.null = nullType2;
    var anyType2 = ZodAny2.create;
    exports.any = anyType2;
    var unknownType2 = ZodUnknown2.create;
    exports.unknown = unknownType2;
    var neverType2 = ZodNever2.create;
    exports.never = neverType2;
    var voidType2 = ZodVoid2.create;
    exports.void = voidType2;
    var arrayType2 = ZodArray2.create;
    exports.array = arrayType2;
    var objectType2 = ZodObject2.create;
    exports.object = objectType2;
    var strictObjectType2 = ZodObject2.strictCreate;
    exports.strictObject = strictObjectType2;
    var unionType2 = ZodUnion2.create;
    exports.union = unionType2;
    var discriminatedUnionType2 = ZodDiscriminatedUnion2.create;
    exports.discriminatedUnion = discriminatedUnionType2;
    var intersectionType2 = ZodIntersection2.create;
    exports.intersection = intersectionType2;
    var tupleType2 = ZodTuple2.create;
    exports.tuple = tupleType2;
    var recordType2 = ZodRecord2.create;
    exports.record = recordType2;
    var mapType2 = ZodMap2.create;
    exports.map = mapType2;
    var setType2 = ZodSet2.create;
    exports.set = setType2;
    var functionType2 = ZodFunction2.create;
    exports.function = functionType2;
    var lazyType2 = ZodLazy2.create;
    exports.lazy = lazyType2;
    var literalType2 = ZodLiteral2.create;
    exports.literal = literalType2;
    var enumType2 = ZodEnum2.create;
    exports.enum = enumType2;
    var nativeEnumType2 = ZodNativeEnum2.create;
    exports.nativeEnum = nativeEnumType2;
    var promiseType2 = ZodPromise2.create;
    exports.promise = promiseType2;
    var effectsType2 = ZodEffects2.create;
    exports.effect = effectsType2;
    exports.transformer = effectsType2;
    var optionalType2 = ZodOptional2.create;
    exports.optional = optionalType2;
    var nullableType2 = ZodNullable2.create;
    exports.nullable = nullableType2;
    var preprocessType2 = ZodEffects2.createWithPreprocess;
    exports.preprocess = preprocessType2;
    var pipelineType2 = ZodPipeline2.create;
    exports.pipeline = pipelineType2;
    var ostring2 = () => stringType2().optional();
    exports.ostring = ostring2;
    var onumber2 = () => numberType2().optional();
    exports.onumber = onumber2;
    var oboolean2 = () => booleanType2().optional();
    exports.oboolean = oboolean2;
    exports.coerce = {
      string: (arg) => ZodString2.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber2.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean2.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt2.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate2.create({ ...arg, coerce: true })
    };
    exports.NEVER = parseUtil_1.INVALID;
  }
});

// ../node_modules/zod/lib/external.js
var require_external = __commonJS({
  "../node_modules/zod/lib/external.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors(), exports);
    __exportStar(require_parseUtil(), exports);
    __exportStar(require_typeAliases(), exports);
    __exportStar(require_util2(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_ZodError(), exports);
  }
});

// ../node_modules/zod/lib/index.js
var require_lib = __commonJS({
  "../node_modules/zod/lib/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.z = void 0;
    var z2 = __importStar(require_external());
    exports.z = z2;
    __exportStar(require_external(), exports);
    exports.default = z2;
  }
});

// ../packages/validations/dist/validations/userRoutesValidator.js
var require_userRoutesValidator = __commonJS({
  "../packages/validations/dist/validations/userRoutesValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updatePassword = exports.emailExists = exports.checkCode = exports.login = exports.getFirebaseUserByEmail = exports.createMongoDBUser = exports.linkFirebaseAuth = exports.deleteUser = exports.editUser = exports.addToFavorite = exports.resetPassword = exports.sentEmail = exports.getUserById = exports.userSignIn = exports.userSignUp = void 0;
    var zod_1 = require_lib();
    var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
    exports.userSignUp = zod_1.z.object({
      name: zod_1.z.string().min(1).nonempty(),
      email: zod_1.z.string().email().nonempty(),
      password: zod_1.z.string().nonempty(),
      username: zod_1.z.string().nonempty()
    });
    exports.userSignIn = zod_1.z.object({
      email: zod_1.z.string().email().nonempty(),
      password: zod_1.z.string().nonempty()
    });
    exports.getUserById = zod_1.z.object({
      userId: JoiObjectId6.nonempty()
    });
    exports.sentEmail = zod_1.z.object({
      email: zod_1.z.string().email().nonempty()
    });
    exports.resetPassword = zod_1.z.object({
      resetToken: zod_1.z.string().nonempty(),
      password: zod_1.z.string().nonempty()
    });
    exports.addToFavorite = zod_1.z.object({
      packId: JoiObjectId6.nonempty(),
      userId: JoiObjectId6.nonempty()
    });
    exports.editUser = zod_1.z.object({
      userId: JoiObjectId6.nonempty()
    });
    exports.deleteUser = zod_1.z.object({
      userId: JoiObjectId6.nonempty()
    });
    exports.linkFirebaseAuth = zod_1.z.object({
      firebaseAuthToken: zod_1.z.string().nonempty()
    });
    exports.createMongoDBUser = zod_1.z.object({
      email: zod_1.z.string().email().nonempty(),
      name: zod_1.z.string().min(1).nonempty(),
      password: zod_1.z.string().nonempty()
    });
    exports.getFirebaseUserByEmail = zod_1.z.object({
      email: zod_1.z.string().email().nonempty()
    });
    exports.login = zod_1.z.object({
      email: zod_1.z.string().email().nonempty(),
      password: zod_1.z.string().nonempty()
    });
    exports.checkCode = zod_1.z.object({
      email: zod_1.z.string().email().nonempty(),
      code: zod_1.z.string().nonempty()
    });
    exports.emailExists = zod_1.z.object({
      email: zod_1.z.string().email().nonempty()
    });
    exports.updatePassword = zod_1.z.object({
      email: zod_1.z.string().email().nonempty(),
      password: zod_1.z.string().nonempty()
    });
  }
});

// ../packages/validations/dist/validations/tripRoutesValidator.js
var require_tripRoutesValidator = __commonJS({
  "../packages/validations/dist/validations/tripRoutesValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queryTrip = exports.deleteTrip = exports.editTrip = exports.addTrip = exports.getTripById = exports.getTrips = exports.JoiObjectId = void 0;
    var zod_1 = require_lib();
    var JoiObjectId6 = (message = "valid id") => zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g, { message });
    exports.JoiObjectId = JoiObjectId6;
    exports.getTrips = zod_1.z.object({
      owner_id: (0, exports.JoiObjectId)().nonempty()
    });
    exports.getTripById = zod_1.z.object({
      tripId: (0, exports.JoiObjectId)().nonempty()
    });
    exports.addTrip = zod_1.z.object({
      name: zod_1.z.string().nonempty(),
      description: zod_1.z.string().nonempty(),
      duration: zod_1.z.string().nonempty(),
      weather: zod_1.z.string().nonempty(),
      start_date: zod_1.z.string().nonempty(),
      end_date: zod_1.z.string().nonempty(),
      destination: zod_1.z.string().nonempty(),
      geoJSON: zod_1.z.object({}),
      owner_id: (0, exports.JoiObjectId)().nonempty(),
      packs: zod_1.z.string().nonempty(),
      is_public: zod_1.z.boolean()
    });
    exports.editTrip = zod_1.z.object({
      _id: (0, exports.JoiObjectId)().nonempty(),
      name: zod_1.z.string().nonempty(),
      duration: zod_1.z.string().nonempty(),
      weather: zod_1.z.string().nonempty(),
      start_date: zod_1.z.string().nonempty(),
      end_date: zod_1.z.string().nonempty(),
      destination: zod_1.z.string().nonempty(),
      is_public: zod_1.z.boolean()
    });
    exports.deleteTrip = zod_1.z.object({
      tripId: (0, exports.JoiObjectId)().nonempty()
    });
    exports.queryTrip = zod_1.z.object({
      queryBy: zod_1.z.string()
    });
  }
});

// ../packages/validations/dist/validations/objectIdValidator.js
var require_objectIdValidator = __commonJS({
  "../packages/validations/dist/validations/objectIdValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var zod_1 = __importDefault(require_lib());
    var objectId = (message = "valid id") => zod_1.default.string().regex(/^[0-9a-fA-F]{24}$/, { message });
    exports.default = objectId;
  }
});

// ../packages/validations/dist/validations/packRoutesValidator.js
var require_packRoutesValidator = __commonJS({
  "../packages/validations/dist/validations/packRoutesValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPublicPacks = exports.duplicatePublicPack = exports.deletePack = exports.editPack = exports.addPack = exports.getPackById = exports.getPacks = void 0;
    var zod_1 = require_lib();
    var objectIdValidator_1 = __importDefault(require_objectIdValidator());
    exports.getPacks = zod_1.z.object({
      ownerId: (0, objectIdValidator_1.default)(),
      queryBy: zod_1.z.string().optional()
    });
    exports.getPackById = zod_1.z.object({
      packId: (0, objectIdValidator_1.default)()
    });
    exports.addPack = zod_1.z.object({
      name: zod_1.z.string().nonempty(),
      owner_id: (0, objectIdValidator_1.default)(),
      is_public: zod_1.z.boolean()
    });
    exports.editPack = zod_1.z.object({
      _id: (0, objectIdValidator_1.default)(),
      name: zod_1.z.string().nonempty(),
      is_public: zod_1.z.boolean()
    });
    exports.deletePack = zod_1.z.object({
      packId: (0, objectIdValidator_1.default)()
    });
    exports.duplicatePublicPack = zod_1.z.object({
      packId: (0, objectIdValidator_1.default)(),
      ownerId: (0, objectIdValidator_1.default)(),
      items: zod_1.z.array(zod_1.z.object({}))
    });
    exports.getPublicPacks = zod_1.z.object({
      queryBy: zod_1.z.string()
    });
  }
});

// ../packages/validations/dist/validations/itemRoutesValidator.js
var require_itemRoutesValidator = __commonJS({
  "../packages/validations/dist/validations/itemRoutesValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getItemsGlobally = exports.editGlobalItemAsDuplicate = exports.deleteGlobalItem = exports.addGlobalItemToPack = exports.addItemGlobal = exports.deleteItem = exports.editItem = exports.addItem = exports.getItemByName = exports.getItemById = exports.getItems = void 0;
    var zod_1 = require_lib();
    var objectIdValidator_1 = __importDefault(require_objectIdValidator());
    exports.getItems = zod_1.z.object({
      packId: (0, objectIdValidator_1.default)()
    });
    exports.getItemById = zod_1.z.object({
      _id: (0, objectIdValidator_1.default)()
    });
    exports.getItemByName = zod_1.z.object({
      name: zod_1.z.string()
    });
    exports.addItem = zod_1.z.object({
      name: zod_1.z.string().nonempty(),
      weight: zod_1.z.string().nonempty(),
      quantity: zod_1.z.string().nonempty(),
      unit: zod_1.z.string().nonempty(),
      packId: (0, objectIdValidator_1.default)(),
      type: zod_1.z.string().optional(),
      ownerId: zod_1.z.string().optional()
    });
    exports.editItem = zod_1.z.object({
      _id: (0, objectIdValidator_1.default)(),
      name: zod_1.z.string().nonempty(),
      weight: zod_1.z.string().nonempty(),
      quantity: zod_1.z.string().nonempty(),
      unit: zod_1.z.string().nonempty(),
      type: zod_1.z.string()
    });
    exports.deleteItem = zod_1.z.object({
      itemId: (0, objectIdValidator_1.default)().nonempty(),
      packId: (0, objectIdValidator_1.default)().nonempty()
    });
    exports.addItemGlobal = zod_1.z.object({
      name: zod_1.z.string().nonempty(),
      weight: zod_1.z.string().nonempty(),
      quantity: zod_1.z.string().nonempty(),
      unit: zod_1.z.string().nonempty(),
      type: zod_1.z.string().optional()
    });
    exports.addGlobalItemToPack = zod_1.z.object({
      packId: zod_1.z.string(),
      itemId: zod_1.z.string(),
      ownerId: zod_1.z.string()
    });
    exports.deleteGlobalItem = zod_1.z.object({
      itemId: zod_1.z.string()
    });
    exports.editGlobalItemAsDuplicate = zod_1.z.object({
      itemId: zod_1.z.string(),
      packId: zod_1.z.string(),
      name: zod_1.z.string(),
      weight: zod_1.z.number(),
      quantity: zod_1.z.number(),
      unit: zod_1.z.string(),
      type: zod_1.z.string()
    });
    exports.getItemsGlobally = zod_1.z.object({
      limit: zod_1.z.number(),
      page: zod_1.z.number()
    });
  }
});

// ../packages/validations/dist/validations/destinationValidator.js
var require_destinationValidator = __commonJS({
  "../packages/validations/dist/validations/destinationValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDestinationByid = void 0;
    var zod_1 = require_lib();
    var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
    exports.getDestinationByid = zod_1.z.object({
      id: zod_1.z.string()
    });
  }
});

// ../packages/validations/dist/validations/osmValidators.js
var require_osmValidators = __commonJS({
  "../packages/validations/dist/validations/osmValidators.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.postSingleGeoJSON = exports.getTrailsOSM = exports.getPhotonResults = exports.getPhotonDetails = exports.getParksOSM = exports.getOsm = void 0;
    var zod_1 = require_lib();
    var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
    exports.getOsm = zod_1.z.object({
      activityType: zod_1.z.string(),
      startPoint: zod_1.z.object({ latitude: zod_1.z.number(), longitude: zod_1.z.number() }),
      endPoint: zod_1.z.object({ latitude: zod_1.z.number(), longitude: zod_1.z.number() })
    });
    exports.getParksOSM = zod_1.z.object({
      lat: zod_1.z.number(),
      lon: zod_1.z.number(),
      radius: zod_1.z.number().optional()
    });
    exports.getPhotonDetails = zod_1.z.object({
      id: zod_1.z.union([zod_1.z.string(), zod_1.z.number()]),
      type: zod_1.z.string()
    });
    exports.getPhotonResults = zod_1.z.object({
      searchString: zod_1.z.string()
    });
    exports.getTrailsOSM = zod_1.z.object({
      lat: zod_1.z.number(),
      lon: zod_1.z.number(),
      radius: zod_1.z.number().optional()
    });
    exports.postSingleGeoJSON = zod_1.z.object({
      geojson: zod_1.z.any()
    });
  }
});

// ../packages/validations/dist/validations/parksRouteValidator.js
var require_parksRouteValidator = __commonJS({
  "../packages/validations/dist/validations/parksRouteValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getParks = void 0;
    var zod_1 = require_lib();
    var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
    exports.getParks = zod_1.z.object({
      abbrState: zod_1.z.string()
    });
  }
});

// ../packages/validations/dist/validations/trailsRouteValidator.js
var require_trailsRouteValidator = __commonJS({
  "../packages/validations/dist/validations/trailsRouteValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTrails = void 0;
    var zod_1 = require_lib();
    var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
    exports.getTrails = zod_1.z.object({
      administrative_area_level_1: zod_1.z.string(),
      country: zod_1.z.string(),
      locality: zod_1.z.string(),
      latitude: zod_1.z.number(),
      longitude: zod_1.z.number()
    });
  }
});

// ../packages/validations/dist/validations/openAIRoutesValidator.js
var require_openAIRoutesValidator = __commonJS({
  "../packages/validations/dist/validations/openAIRoutesValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUserChats = exports.getAIResponse = void 0;
    var zod_1 = require_lib();
    exports.getAIResponse = zod_1.z.object({
      userId: zod_1.z.string(),
      conversationId: zod_1.z.string(),
      userInput: zod_1.z.string()
    });
    exports.getUserChats = zod_1.z.object({
      userId: zod_1.z.string()
    });
  }
});

// ../packages/validations/dist/validations/extrasValidator.js
var require_extrasValidator = __commonJS({
  "../packages/validations/dist/validations/extrasValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handlePasswordReset = exports.AddressArray = void 0;
    var zod_1 = require_lib();
    var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
    exports.AddressArray = zod_1.z.object({
      addressArray: zod_1.z.string()
    });
    exports.handlePasswordReset = zod_1.z.object({
      token: zod_1.z.string()
    });
  }
});

// ../packages/validations/dist/validations/templateRouteValidator.js
var require_templateRouteValidator = __commonJS({
  "../packages/validations/dist/validations/templateRouteValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTemplateById = exports.deleteTemplate = exports.editTemplate = exports.addTemplate = void 0;
    var zod_1 = require_lib();
    exports.addTemplate = zod_1.z.object({
      type: zod_1.z.string(),
      templateId: zod_1.z.string(),
      isGlobalTemplate: zod_1.z.boolean(),
      createdBy: zod_1.z.string()
    });
    exports.editTemplate = zod_1.z.object({
      templateId: zod_1.z.string(),
      type: zod_1.z.string(),
      isGlobalTemplate: zod_1.z.boolean()
    });
    exports.deleteTemplate = zod_1.z.object({
      templateId: zod_1.z.string()
    });
    exports.getTemplateById = zod_1.z.object({
      templateId: zod_1.z.string()
    });
  }
});

// ../packages/validations/dist/validations/weatherRoutesValidator.js
var require_weatherRoutesValidator = __commonJS({
  "../packages/validations/dist/validations/weatherRoutesValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWeather = exports.getWeatherWeek = void 0;
    var zod_1 = require_lib();
    exports.getWeatherWeek = zod_1.z.object({
      lat: zod_1.z.number(),
      lon: zod_1.z.number()
    });
    exports.getWeather = zod_1.z.object({
      lat: zod_1.z.number(),
      lon: zod_1.z.number()
    });
  }
});

// ../packages/validations/dist/validations/zodParser.js
var require_zodParser = __commonJS({
  "../packages/validations/dist/validations/zodParser.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zodParser = void 0;
    var zodParser = (schema, input, next) => {
      schema.parse(input);
      next();
    };
    exports.zodParser = zodParser;
  }
});

// ../packages/validations/dist/validations/roleValidator.js
var require_roleValidator = __commonJS({
  "../packages/validations/dist/validations/roleValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RoleSchema = void 0;
    var zod_1 = require_lib();
    exports.RoleSchema = zod_1.z.union([zod_1.z.literal("user"), zod_1.z.literal("admin")]);
  }
});

// ../packages/validations/dist/validations/authTokenValidator.js
var require_authTokenValidator = __commonJS({
  "../packages/validations/dist/validations/authTokenValidator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.googleSignin = exports.TokenSchema = void 0;
    var zod_1 = require_lib();
    exports.TokenSchema = zod_1.z.object({
      _id: zod_1.z.string()
    });
    exports.googleSignin = zod_1.z.object({
      idToken: zod_1.z.string().nonempty()
    });
  }
});

// ../packages/validations/dist/validations/index.js
var require_validations = __commonJS({
  "../packages/validations/dist/validations/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_userRoutesValidator(), exports);
    __exportStar(require_tripRoutesValidator(), exports);
    __exportStar(require_packRoutesValidator(), exports);
    __exportStar(require_itemRoutesValidator(), exports);
    __exportStar(require_destinationValidator(), exports);
    __exportStar(require_osmValidators(), exports);
    __exportStar(require_parksRouteValidator(), exports);
    __exportStar(require_trailsRouteValidator(), exports);
    __exportStar(require_openAIRoutesValidator(), exports);
    __exportStar(require_extrasValidator(), exports);
    __exportStar(require_templateRouteValidator(), exports);
    __exportStar(require_weatherRoutesValidator(), exports);
    __exportStar(require_zodParser(), exports);
    __exportStar(require_roleValidator(), exports);
    __exportStar(require_authTokenValidator(), exports);
    __exportStar(require_objectIdValidator(), exports);
  }
});

// ../packages/validations/dist/index.js
var require_dist = __commonJS({
  "../packages/validations/dist/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_validations(), exports);
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = function bind2(fn, thisArg) {
      return function wrap2() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var bind2 = require_bind();
    var toString6 = Object.prototype.toString;
    function isArray4(val) {
      return Array.isArray(val);
    }
    function isUndefined3(val) {
      return typeof val === "undefined";
    }
    function isBuffer5(val) {
      return val !== null && !isUndefined3(val) && val.constructor !== null && !isUndefined3(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer2(val) {
      return toString6.call(val) === "[object ArrayBuffer]";
    }
    function isFormData2(val) {
      return toString6.call(val) === "[object FormData]";
    }
    function isArrayBufferView2(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer2(val.buffer);
      }
      return result;
    }
    function isString3(val) {
      return typeof val === "string";
    }
    function isNumber3(val) {
      return typeof val === "number";
    }
    function isObject4(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject3(val) {
      if (toString6.call(val) !== "[object Object]") {
        return false;
      }
      var prototype3 = Object.getPrototypeOf(val);
      return prototype3 === null || prototype3 === Object.prototype;
    }
    function isDate3(val) {
      return toString6.call(val) === "[object Date]";
    }
    function isFile2(val) {
      return toString6.call(val) === "[object File]";
    }
    function isBlob2(val) {
      return toString6.call(val) === "[object Blob]";
    }
    function isFunction3(val) {
      return toString6.call(val) === "[object Function]";
    }
    function isStream2(val) {
      return isObject4(val) && isFunction3(val.pipe);
    }
    function isURLSearchParams2(val) {
      return toString6.call(val) === "[object URLSearchParams]";
    }
    function trim2(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv2() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach3(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray4(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge2() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject3(result[key]) && isPlainObject3(val)) {
          result[key] = merge2(result[key], val);
        } else if (isPlainObject3(val)) {
          result[key] = merge2({}, val);
        } else if (isArray4(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach3(arguments[i], assignValue);
      }
      return result;
    }
    function extend2(a, b, thisArg) {
      forEach3(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind2(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM2(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray: isArray4,
      isArrayBuffer: isArrayBuffer2,
      isBuffer: isBuffer5,
      isFormData: isFormData2,
      isArrayBufferView: isArrayBufferView2,
      isString: isString3,
      isNumber: isNumber3,
      isObject: isObject4,
      isPlainObject: isPlainObject3,
      isUndefined: isUndefined3,
      isDate: isDate3,
      isFile: isFile2,
      isBlob: isBlob2,
      isFunction: isFunction3,
      isStream: isStream2,
      isURLSearchParams: isURLSearchParams2,
      isStandardBrowserEnv: isStandardBrowserEnv2,
      forEach: forEach3,
      merge: merge2,
      extend: extend2,
      trim: trim2,
      stripBOM: stripBOM2
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    function encode3(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL2(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode3(key) + "=" + encode3(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    function InterceptorManager2() {
      this.handlers = [];
    }
    InterceptorManager2.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager2.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager2.prototype.forEach = function forEach3(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager2;
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = function enhanceError(error, config4, code, request, response) {
      error.config = config4;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON4() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/defaults/transitional.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config4, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config4, code, request, response);
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var createError = require_createError();
    module.exports = function settle2(resolve2, reject, response) {
      var validateStatus2 = response.config.validateStatus;
      if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
        resolve2(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv3() {
        return {
          write: function write4(name, value, expires, path, domain2, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain2)) {
              cookie.push("domain=" + domain2);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read2(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv3() {
        return {
          write: function write4() {
          },
          read: function read2() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = function isAbsoluteURL2(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = function combineURLs2(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var isAbsoluteURL2 = require_isAbsoluteURL();
    var combineURLs2 = require_combineURLs();
    module.exports = function buildFullPath2(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL2(requestedURL)) {
        return combineURLs2(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    var ignoreDuplicateOf2 = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf2.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv3() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv3() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// ../node_modules/openai/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    function Cancel2(message) {
      this.message = message;
    }
    Cancel2.prototype.toString = function toString6() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel2.prototype.__CANCEL__ = true;
    module.exports = Cancel2;
  }
});

// ../node_modules/openai/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    var settle2 = require_settle();
    var cookies = require_cookies();
    var buildURL2 = require_buildURL();
    var buildFullPath2 = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var transitionalDefaults = require_transitional();
    var Cancel2 = require_Cancel();
    module.exports = function xhrAdapter(config4) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        var requestData = config4.data;
        var requestHeaders = config4.headers;
        var responseType = config4.responseType;
        var onCanceled;
        function done2() {
          if (config4.cancelToken) {
            config4.cancelToken.unsubscribe(onCanceled);
          }
          if (config4.signal) {
            config4.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config4.auth) {
          var username = config4.auth.username || "";
          var password = config4.auth.password ? unescape(encodeURIComponent(config4.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath2(config4.baseURL, config4.url);
        request.open(config4.method.toUpperCase(), buildURL2(fullPath, config4.params, config4.paramsSerializer), true);
        request.timeout = config4.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config4,
            request
          };
          settle2(function _resolve(value) {
            resolve2(value);
            done2();
          }, function _reject(err) {
            reject(err);
            done2();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config4, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config4, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config4.timeout ? "timeout of " + config4.timeout + "ms exceeded" : "timeout exceeded";
          var transitional2 = config4.transitional || transitionalDefaults;
          if (config4.timeoutErrorMessage) {
            timeoutErrorMessage = config4.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config4,
            transitional2.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config4.withCredentials || isURLSameOrigin(fullPath)) && config4.xsrfCookieName ? cookies.read(config4.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config4.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config4.withCredentials)) {
          request.withCredentials = !!config4.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config4.responseType;
        }
        if (typeof config4.onDownloadProgress === "function") {
          request.addEventListener("progress", config4.onDownloadProgress);
        }
        if (typeof config4.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config4.onUploadProgress);
        }
        if (config4.cancelToken || config4.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel2("canceled") : cancel);
            request.abort();
            request = null;
          };
          config4.cancelToken && config4.cancelToken.subscribe(onCanceled);
          if (config4.signal) {
            config4.signal.aborted ? onCanceled() : config4.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/defaults/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var transitionalDefaults = require_transitional();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely2(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults2 = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest2(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely2(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse2(data) {
        var transitional2 = this.transitional || defaults2.transitional;
        var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
        var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus2(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData2(method) {
      defaults2.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
      defaults2.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults2;
  }
});

// ../node_modules/openai/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    var defaults2 = require_defaults();
    module.exports = function transformData2(data, headers, fns) {
      var context = this || defaults2;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = function isCancel3(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    var transformData2 = require_transformData();
    var isCancel3 = require_isCancel();
    var defaults2 = require_defaults();
    var Cancel2 = require_Cancel();
    function throwIfCancellationRequested2(config4) {
      if (config4.cancelToken) {
        config4.cancelToken.throwIfRequested();
      }
      if (config4.signal && config4.signal.aborted) {
        throw new Cancel2("canceled");
      }
    }
    module.exports = function dispatchRequest2(config4) {
      throwIfCancellationRequested2(config4);
      config4.headers = config4.headers || {};
      config4.data = transformData2.call(
        config4,
        config4.data,
        config4.headers,
        config4.transformRequest
      );
      config4.headers = utils.merge(
        config4.headers.common || {},
        config4.headers[config4.method] || {},
        config4.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config4.headers[method];
        }
      );
      var adapter = config4.adapter || defaults2.adapter;
      return adapter(config4).then(function onAdapterResolution(response) {
        throwIfCancellationRequested2(config4);
        response.data = transformData2.call(
          config4,
          response.data,
          response.headers,
          config4.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel3(reason)) {
          throwIfCancellationRequested2(config4);
          if (reason && reason.response) {
            reason.response.data = transformData2.call(
              config4,
              reason.response.data,
              reason.response.headers,
              config4.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    module.exports = function mergeConfig3(config1, config22) {
      config22 = config22 || {};
      var config4 = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(config1[prop], config22[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(void 0, config22[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(void 0, config22[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config22) {
          return getMergedValue(config1[prop], config22[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config22)), function computeConfigValue(prop) {
        var merge2 = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge2(prop);
        utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config4[prop] = configValue);
      });
      return config4;
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/env/data.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = {
      "version": "0.26.1"
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var VERSION3 = require_data().version;
    var validators8 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i) {
      validators8[type2] = function validator(thing) {
        return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
      };
    });
    var deprecatedWarnings2 = {};
    validators8.transitional = function transitional2(validator, version3, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION3 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")));
        }
        if (version3 && !deprecatedWarnings2[opt]) {
          deprecatedWarnings2[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version3 + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions2(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys2 = Object.keys(options);
      var i = keys2.length;
      while (i-- > 0) {
        var opt = keys2[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions: assertOptions2,
      validators: validators8
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    var buildURL2 = require_buildURL();
    var InterceptorManager2 = require_InterceptorManager();
    var dispatchRequest2 = require_dispatchRequest();
    var mergeConfig3 = require_mergeConfig();
    var validator = require_validator();
    var validators8 = validator.validators;
    function Axios3(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager2(),
        response: new InterceptorManager2()
      };
    }
    Axios3.prototype.request = function request(configOrUrl, config4) {
      if (typeof configOrUrl === "string") {
        config4 = config4 || {};
        config4.url = configOrUrl;
      } else {
        config4 = configOrUrl || {};
      }
      config4 = mergeConfig3(this.defaults, config4);
      if (config4.method) {
        config4.method = config4.method.toLowerCase();
      } else if (this.defaults.method) {
        config4.method = this.defaults.method.toLowerCase();
      } else {
        config4.method = "get";
      }
      var transitional2 = config4.transitional;
      if (transitional2 !== void 0) {
        validator.assertOptions(transitional2, {
          silentJSONParsing: validators8.transitional(validators8.boolean),
          forcedJSONParsing: validators8.transitional(validators8.boolean),
          clarifyTimeoutError: validators8.transitional(validators8.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config4) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest2, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config4);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config4;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest2(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios3.prototype.getUri = function getUri(config4) {
      config4 = mergeConfig3(this.defaults, config4);
      return buildURL2(config4.url, config4.params, config4.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
      Axios3.prototype[method] = function(url, config4) {
        return this.request(mergeConfig3(config4 || {}, {
          method,
          url,
          data: (config4 || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
      Axios3.prototype[method] = function(url, data, config4) {
        return this.request(mergeConfig3(config4 || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios3;
  }
});

// ../node_modules/openai/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var Cancel2 = require_Cancel();
    function CancelToken3(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve2) {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel2(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken3.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken3.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken3.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken3.source = function source() {
      var cancel;
      var token = new CancelToken3(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken3;
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = function spread3(callback) {
      return function wrap2(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    module.exports = function isAxiosError3(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// ../node_modules/openai/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "../node_modules/openai/node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var utils = require_utils();
    var bind2 = require_bind();
    var Axios3 = require_Axios();
    var mergeConfig3 = require_mergeConfig();
    var defaults2 = require_defaults();
    function createInstance2(defaultConfig) {
      var context = new Axios3(defaultConfig);
      var instance = bind2(Axios3.prototype.request, context);
      utils.extend(instance, Axios3.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance2(mergeConfig3(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance2(defaults2);
    axios2.Axios = Axios3;
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.all = function all3(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module.exports = axios2;
    module.exports.default = axios2;
  }
});

// ../node_modules/openai/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "../node_modules/openai/node_modules/axios/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = require_axios();
  }
});

// ../node_modules/openai/dist/base.js
var require_base = __commonJS({
  "../node_modules/openai/dist/base.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;
    var axios_1 = require_axios2();
    exports.BASE_PATH = "https://api.openai.com/v1".replace(/\/+$/, "");
    exports.COLLECTION_FORMATS = {
      csv: ",",
      ssv: " ",
      tsv: "	",
      pipes: "|"
    };
    var BaseAPI = class {
      constructor(configuration, basePath = exports.BASE_PATH, axios2 = axios_1.default) {
        this.basePath = basePath;
        this.axios = axios2;
        if (configuration) {
          this.configuration = configuration;
          this.basePath = configuration.basePath || this.basePath;
        }
      }
    };
    exports.BaseAPI = BaseAPI;
    var RequiredError = class extends Error {
      constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
      }
    };
    exports.RequiredError = RequiredError;
  }
});

// ../node_modules/openai/dist/common.js
var require_common = __commonJS({
  "../node_modules/openai/dist/common.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;
    var base_1 = require_base();
    exports.DUMMY_BASE_URL = "https://example.com";
    exports.assertParamExists = function(functionName, paramName, paramValue) {
      if (paramValue === null || paramValue === void 0) {
        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
      }
    };
    exports.setApiKeyToObject = function(object, keyParamName, configuration) {
      return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.apiKey) {
          const localVarApiKeyValue = typeof configuration.apiKey === "function" ? yield configuration.apiKey(keyParamName) : yield configuration.apiKey;
          object[keyParamName] = localVarApiKeyValue;
        }
      });
    };
    exports.setBasicAuthToObject = function(object, configuration) {
      if (configuration && (configuration.username || configuration.password)) {
        object["auth"] = { username: configuration.username, password: configuration.password };
      }
    };
    exports.setBearerAuthToObject = function(object, configuration) {
      return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
          const accessToken = typeof configuration.accessToken === "function" ? yield configuration.accessToken() : yield configuration.accessToken;
          object["Authorization"] = "Bearer " + accessToken;
        }
      });
    };
    exports.setOAuthToObject = function(object, name, scopes, configuration) {
      return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
          const localVarAccessTokenValue = typeof configuration.accessToken === "function" ? yield configuration.accessToken(name, scopes) : yield configuration.accessToken;
          object["Authorization"] = "Bearer " + localVarAccessTokenValue;
        }
      });
    };
    function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
      if (parameter == null)
        return;
      if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
          parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
        } else {
          Object.keys(parameter).forEach((currentKey) => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== "" ? "." : ""}${currentKey}`));
        }
      } else {
        if (urlSearchParams.has(key)) {
          urlSearchParams.append(key, parameter);
        } else {
          urlSearchParams.set(key, parameter);
        }
      }
    }
    exports.setSearchParams = function(url, ...objects) {
      const searchParams = new URLSearchParams(url.search);
      setFlattenedQueryParams(searchParams, objects);
      url.search = searchParams.toString();
    };
    exports.serializeDataIfNeeded = function(value, requestOptions, configuration) {
      const nonString = typeof value !== "string";
      const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
      return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
    };
    exports.toPathString = function(url) {
      return url.pathname + url.search + url.hash;
    };
    exports.createRequestFunction = function(axiosArgs, globalAxios, BASE_PATH, configuration) {
      return (axios2 = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });
        return axios2.request(axiosRequestArgs);
      };
    };
  }
});

// ../node_modules/openai/dist/api.js
var require_api = __commonJS({
  "../node_modules/openai/dist/api.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenAIApi = exports.OpenAIApiFactory = exports.OpenAIApiFp = exports.OpenAIApiAxiosParamCreator = exports.CreateImageRequestResponseFormatEnum = exports.CreateImageRequestSizeEnum = exports.ChatCompletionResponseMessageRoleEnum = exports.ChatCompletionRequestMessageRoleEnum = void 0;
    var axios_1 = require_axios2();
    var common_1 = require_common();
    var base_1 = require_base();
    exports.ChatCompletionRequestMessageRoleEnum = {
      System: "system",
      User: "user",
      Assistant: "assistant",
      Function: "function"
    };
    exports.ChatCompletionResponseMessageRoleEnum = {
      System: "system",
      User: "user",
      Assistant: "assistant",
      Function: "function"
    };
    exports.CreateImageRequestSizeEnum = {
      _256x256: "256x256",
      _512x512: "512x512",
      _1024x1024: "1024x1024"
    };
    exports.CreateImageRequestResponseFormatEnum = {
      Url: "url",
      B64Json: "b64_json"
    };
    exports.OpenAIApiAxiosParamCreator = function(configuration) {
      return {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFineTune: (fineTuneId, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("cancelFineTune", "fineTuneId", fineTuneId);
          const localVarPath = `/fine-tunes/{fine_tune_id}/cancel`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAnswer: (createAnswerRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createAnswer", "createAnswerRequest", createAnswerRequest);
          const localVarPath = `/answers`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createAnswerRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Creates a model response for the given chat conversation.
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatCompletion: (createChatCompletionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createChatCompletion", "createChatCompletionRequest", createChatCompletionRequest);
          const localVarPath = `/chat/completions`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createChatCompletionRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createClassification: (createClassificationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createClassification", "createClassificationRequest", createClassificationRequest);
          const localVarPath = `/classifications`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createClassificationRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion: (createCompletionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createCompletion", "createCompletionRequest", createCompletionRequest);
          const localVarPath = `/completions`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createCompletionRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdit: (createEditRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createEdit", "createEditRequest", createEditRequest);
          const localVarPath = `/edits`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createEditRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding: (createEmbeddingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createEmbedding", "createEmbeddingRequest", createEmbeddingRequest);
          const localVarPath = `/embeddings`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createEmbeddingRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: (file, purpose, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createFile", "file", file);
          common_1.assertParamExists("createFile", "purpose", purpose);
          const localVarPath = `/files`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
          if (file !== void 0) {
            localVarFormParams.append("file", file);
          }
          if (purpose !== void 0) {
            localVarFormParams.append("purpose", purpose);
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = localVarFormParams;
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFineTune: (createFineTuneRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createFineTune", "createFineTuneRequest", createFineTuneRequest);
          const localVarPath = `/fine-tunes`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createFineTuneRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage: (createImageRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createImage", "createImageRequest", createImageRequest);
          const localVarPath = `/images/generations`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createImageRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageEdit: (image, prompt, mask, n, size, responseFormat, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createImageEdit", "image", image);
          common_1.assertParamExists("createImageEdit", "prompt", prompt);
          const localVarPath = `/images/edits`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
          if (image !== void 0) {
            localVarFormParams.append("image", image);
          }
          if (mask !== void 0) {
            localVarFormParams.append("mask", mask);
          }
          if (prompt !== void 0) {
            localVarFormParams.append("prompt", prompt);
          }
          if (n !== void 0) {
            localVarFormParams.append("n", n);
          }
          if (size !== void 0) {
            localVarFormParams.append("size", size);
          }
          if (responseFormat !== void 0) {
            localVarFormParams.append("response_format", responseFormat);
          }
          if (user !== void 0) {
            localVarFormParams.append("user", user);
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = localVarFormParams;
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageVariation: (image, n, size, responseFormat, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createImageVariation", "image", image);
          const localVarPath = `/images/variations`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
          if (image !== void 0) {
            localVarFormParams.append("image", image);
          }
          if (n !== void 0) {
            localVarFormParams.append("n", n);
          }
          if (size !== void 0) {
            localVarFormParams.append("size", size);
          }
          if (responseFormat !== void 0) {
            localVarFormParams.append("response_format", responseFormat);
          }
          if (user !== void 0) {
            localVarFormParams.append("user", user);
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = localVarFormParams;
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModeration: (createModerationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createModeration", "createModerationRequest", createModerationRequest);
          const localVarPath = `/moderations`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createModerationRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createSearch: (engineId, createSearchRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createSearch", "engineId", engineId);
          common_1.assertParamExists("createSearch", "createSearchRequest", createSearchRequest);
          const localVarPath = `/engines/{engine_id}/search`.replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          localVarHeaderParameter["Content-Type"] = "application/json";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = common_1.serializeDataIfNeeded(createSearchRequest, localVarRequestOptions, configuration);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranscription: (file, model, prompt, responseFormat, temperature, language, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createTranscription", "file", file);
          common_1.assertParamExists("createTranscription", "model", model);
          const localVarPath = `/audio/transcriptions`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
          if (file !== void 0) {
            localVarFormParams.append("file", file);
          }
          if (model !== void 0) {
            localVarFormParams.append("model", model);
          }
          if (prompt !== void 0) {
            localVarFormParams.append("prompt", prompt);
          }
          if (responseFormat !== void 0) {
            localVarFormParams.append("response_format", responseFormat);
          }
          if (temperature !== void 0) {
            localVarFormParams.append("temperature", temperature);
          }
          if (language !== void 0) {
            localVarFormParams.append("language", language);
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = localVarFormParams;
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranslation: (file, model, prompt, responseFormat, temperature, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("createTranslation", "file", file);
          common_1.assertParamExists("createTranslation", "model", model);
          const localVarPath = `/audio/translations`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
          if (file !== void 0) {
            localVarFormParams.append("file", file);
          }
          if (model !== void 0) {
            localVarFormParams.append("model", model);
          }
          if (prompt !== void 0) {
            localVarFormParams.append("prompt", prompt);
          }
          if (responseFormat !== void 0) {
            localVarFormParams.append("response_format", responseFormat);
          }
          if (temperature !== void 0) {
            localVarFormParams.append("temperature", temperature);
          }
          localVarHeaderParameter["Content-Type"] = "multipart/form-data";
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
          localVarRequestOptions.data = localVarFormParams;
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("deleteFile", "fileId", fileId);
          const localVarPath = `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: (model, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("deleteModel", "model", model);
          const localVarPath = `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(model)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("downloadFile", "fileId", fileId);
          const localVarPath = `/files/{file_id}/content`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listEngines: (options = {}) => __awaiter(this, void 0, void 0, function* () {
          const localVarPath = `/engines`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: (options = {}) => __awaiter(this, void 0, void 0, function* () {
          const localVarPath = `/files`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuneEvents: (fineTuneId, stream, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("listFineTuneEvents", "fineTuneId", fineTuneId);
          const localVarPath = `/fine-tunes/{fine_tune_id}/events`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          if (stream !== void 0) {
            localVarQueryParameter["stream"] = stream;
          }
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTunes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
          const localVarPath = `/fine-tunes`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: (options = {}) => __awaiter(this, void 0, void 0, function* () {
          const localVarPath = `/models`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        retrieveEngine: (engineId, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("retrieveEngine", "engineId", engineId);
          const localVarPath = `/engines/{engine_id}`.replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("retrieveFile", "fileId", fileId);
          const localVarPath = `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFineTune: (fineTuneId, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("retrieveFineTune", "fineTuneId", fineTuneId);
          const localVarPath = `/fine-tunes/{fine_tune_id}`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        }),
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModel: (model, options = {}) => __awaiter(this, void 0, void 0, function* () {
          common_1.assertParamExists("retrieveModel", "model", model);
          const localVarPath = `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(model)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
          return {
            url: common_1.toPathString(localVarUrlObj),
            options: localVarRequestOptions
          };
        })
      };
    };
    exports.OpenAIApiFp = function(configuration) {
      const localVarAxiosParamCreator = exports.OpenAIApiAxiosParamCreator(configuration);
      return {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFineTune(fineTuneId, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelFineTune(fineTuneId, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAnswer(createAnswerRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createAnswer(createAnswerRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Creates a model response for the given chat conversation.
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatCompletion(createChatCompletionRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createChatCompletion(createChatCompletionRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createClassification(createClassificationRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createClassification(createClassificationRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion(createCompletionRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createCompletion(createCompletionRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdit(createEditRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createEdit(createEditRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding(createEmbeddingRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createEmbedding(createEmbeddingRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(file, purpose, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createFile(file, purpose, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFineTune(createFineTuneRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createFineTune(createFineTuneRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createImage(createImageRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageEdit(image, prompt, mask, n, size, responseFormat, user, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createImageEdit(image, prompt, mask, n, size, responseFormat, user, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageVariation(image, n, size, responseFormat, user, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createImageVariation(image, n, size, responseFormat, user, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModeration(createModerationRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createModeration(createModerationRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createSearch(engineId, createSearchRequest, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createSearch(engineId, createSearchRequest, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranscription(file, model, prompt, responseFormat, temperature, language, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createTranscription(file, model, prompt, responseFormat, temperature, language, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranslation(file, model, prompt, responseFormat, temperature, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.createTranslation(file, model, prompt, responseFormat, temperature, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFile(fileId, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(model, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteModel(model, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(fileId, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadFile(fileId, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listEngines(options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listEngines(options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listFiles(options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuneEvents(fineTuneId, stream, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listFineTuneEvents(fineTuneId, stream, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTunes(options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listFineTunes(options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.listModels(options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        retrieveEngine(engineId, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveEngine(engineId, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile(fileId, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveFile(fileId, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFineTune(fineTuneId, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveFineTune(fineTuneId, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModel(model, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveModel(model, options);
            return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
          });
        }
      };
    };
    exports.OpenAIApiFactory = function(configuration, basePath, axios2) {
      const localVarFp = exports.OpenAIApiFp(configuration);
      return {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFineTune(fineTuneId, options) {
          return localVarFp.cancelFineTune(fineTuneId, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAnswer(createAnswerRequest, options) {
          return localVarFp.createAnswer(createAnswerRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Creates a model response for the given chat conversation.
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatCompletion(createChatCompletionRequest, options) {
          return localVarFp.createChatCompletion(createChatCompletionRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createClassification(createClassificationRequest, options) {
          return localVarFp.createClassification(createClassificationRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion(createCompletionRequest, options) {
          return localVarFp.createCompletion(createCompletionRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdit(createEditRequest, options) {
          return localVarFp.createEdit(createEditRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding(createEmbeddingRequest, options) {
          return localVarFp.createEmbedding(createEmbeddingRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(file, purpose, options) {
          return localVarFp.createFile(file, purpose, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFineTune(createFineTuneRequest, options) {
          return localVarFp.createFineTune(createFineTuneRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageRequest, options) {
          return localVarFp.createImage(createImageRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageEdit(image, prompt, mask, n, size, responseFormat, user, options) {
          return localVarFp.createImageEdit(image, prompt, mask, n, size, responseFormat, user, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageVariation(image, n, size, responseFormat, user, options) {
          return localVarFp.createImageVariation(image, n, size, responseFormat, user, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModeration(createModerationRequest, options) {
          return localVarFp.createModeration(createModerationRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createSearch(engineId, createSearchRequest, options) {
          return localVarFp.createSearch(engineId, createSearchRequest, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranscription(file, model, prompt, responseFormat, temperature, language, options) {
          return localVarFp.createTranscription(file, model, prompt, responseFormat, temperature, language, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranslation(file, model, prompt, responseFormat, temperature, options) {
          return localVarFp.createTranslation(file, model, prompt, responseFormat, temperature, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId, options) {
          return localVarFp.deleteFile(fileId, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(model, options) {
          return localVarFp.deleteModel(model, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(fileId, options) {
          return localVarFp.downloadFile(fileId, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listEngines(options) {
          return localVarFp.listEngines(options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(options) {
          return localVarFp.listFiles(options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuneEvents(fineTuneId, stream, options) {
          return localVarFp.listFineTuneEvents(fineTuneId, stream, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTunes(options) {
          return localVarFp.listFineTunes(options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(options) {
          return localVarFp.listModels(options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        retrieveEngine(engineId, options) {
          return localVarFp.retrieveEngine(engineId, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile(fileId, options) {
          return localVarFp.retrieveFile(fileId, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFineTune(fineTuneId, options) {
          return localVarFp.retrieveFineTune(fineTuneId, options).then((request) => request(axios2, basePath));
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModel(model, options) {
          return localVarFp.retrieveModel(model, options).then((request) => request(axios2, basePath));
        }
      };
    };
    var OpenAIApi2 = class extends base_1.BaseAPI {
      /**
       *
       * @summary Immediately cancel a fine-tune job.
       * @param {string} fineTuneId The ID of the fine-tune job to cancel
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      cancelFineTune(fineTuneId, options) {
        return exports.OpenAIApiFp(this.configuration).cancelFineTune(fineTuneId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
       * @param {CreateAnswerRequest} createAnswerRequest
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createAnswer(createAnswerRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createAnswer(createAnswerRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Creates a model response for the given chat conversation.
       * @param {CreateChatCompletionRequest} createChatCompletionRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createChatCompletion(createChatCompletionRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createChatCompletion(createChatCompletionRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
       * @param {CreateClassificationRequest} createClassificationRequest
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createClassification(createClassificationRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createClassification(createClassificationRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Creates a completion for the provided prompt and parameters.
       * @param {CreateCompletionRequest} createCompletionRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createCompletion(createCompletionRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createCompletion(createCompletionRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Creates a new edit for the provided input, instruction, and parameters.
       * @param {CreateEditRequest} createEditRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createEdit(createEditRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createEdit(createEditRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Creates an embedding vector representing the input text.
       * @param {CreateEmbeddingRequest} createEmbeddingRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createEmbedding(createEmbeddingRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createEmbedding(createEmbeddingRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
       * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
       * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createFile(file, purpose, options) {
        return exports.OpenAIApiFp(this.configuration).createFile(file, purpose, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
       * @param {CreateFineTuneRequest} createFineTuneRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createFineTune(createFineTuneRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createFineTune(createFineTuneRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Creates an image given a prompt.
       * @param {CreateImageRequest} createImageRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createImage(createImageRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createImage(createImageRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Creates an edited or extended image given an original image and a prompt.
       * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
       * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
       * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
       * @param {number} [n] The number of images to generate. Must be between 1 and 10.
       * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
       * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
       * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createImageEdit(image, prompt, mask, n, size, responseFormat, user, options) {
        return exports.OpenAIApiFp(this.configuration).createImageEdit(image, prompt, mask, n, size, responseFormat, user, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Creates a variation of a given image.
       * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
       * @param {number} [n] The number of images to generate. Must be between 1 and 10.
       * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
       * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
       * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createImageVariation(image, n, size, responseFormat, user, options) {
        return exports.OpenAIApiFp(this.configuration).createImageVariation(image, n, size, responseFormat, user, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Classifies if text violates OpenAI\'s Content Policy
       * @param {CreateModerationRequest} createModerationRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createModeration(createModerationRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createModeration(createModerationRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
       * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
       * @param {CreateSearchRequest} createSearchRequest
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createSearch(engineId, createSearchRequest, options) {
        return exports.OpenAIApiFp(this.configuration).createSearch(engineId, createSearchRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Transcribes audio into the input language.
       * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
       * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
       * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
       * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
       * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
       * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createTranscription(file, model, prompt, responseFormat, temperature, language, options) {
        return exports.OpenAIApiFp(this.configuration).createTranscription(file, model, prompt, responseFormat, temperature, language, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Translates audio into into English.
       * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
       * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
       * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
       * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
       * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      createTranslation(file, model, prompt, responseFormat, temperature, options) {
        return exports.OpenAIApiFp(this.configuration).createTranslation(file, model, prompt, responseFormat, temperature, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Delete a file.
       * @param {string} fileId The ID of the file to use for this request
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      deleteFile(fileId, options) {
        return exports.OpenAIApiFp(this.configuration).deleteFile(fileId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
       * @param {string} model The model to delete
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      deleteModel(model, options) {
        return exports.OpenAIApiFp(this.configuration).deleteModel(model, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Returns the contents of the specified file
       * @param {string} fileId The ID of the file to use for this request
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      downloadFile(fileId, options) {
        return exports.OpenAIApiFp(this.configuration).downloadFile(fileId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listEngines(options) {
        return exports.OpenAIApiFp(this.configuration).listEngines(options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Returns a list of files that belong to the user\'s organization.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listFiles(options) {
        return exports.OpenAIApiFp(this.configuration).listFiles(options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Get fine-grained status updates for a fine-tune job.
       * @param {string} fineTuneId The ID of the fine-tune job to get events for.
       * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listFineTuneEvents(fineTuneId, stream, options) {
        return exports.OpenAIApiFp(this.configuration).listFineTuneEvents(fineTuneId, stream, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary List your organization\'s fine-tuning jobs
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listFineTunes(options) {
        return exports.OpenAIApiFp(this.configuration).listFineTunes(options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      listModels(options) {
        return exports.OpenAIApiFp(this.configuration).listModels(options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
       * @param {string} engineId The ID of the engine to use for this request
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      retrieveEngine(engineId, options) {
        return exports.OpenAIApiFp(this.configuration).retrieveEngine(engineId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Returns information about a specific file.
       * @param {string} fileId The ID of the file to use for this request
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      retrieveFile(fileId, options) {
        return exports.OpenAIApiFp(this.configuration).retrieveFile(fileId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
       * @param {string} fineTuneId The ID of the fine-tune job
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      retrieveFineTune(fineTuneId, options) {
        return exports.OpenAIApiFp(this.configuration).retrieveFineTune(fineTuneId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
       * @param {string} model The ID of the model to use for this request
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof OpenAIApi
       */
      retrieveModel(model, options) {
        return exports.OpenAIApiFp(this.configuration).retrieveModel(model, options).then((request) => request(this.axios, this.basePath));
      }
    };
    exports.OpenAIApi = OpenAIApi2;
  }
});

// ../node_modules/openai/package.json
var require_package2 = __commonJS({
  "../node_modules/openai/package.json"(exports, module) {
    module.exports = {
      name: "openai",
      version: "3.3.0",
      description: "Node.js library for the OpenAI API",
      repository: {
        type: "git",
        url: "git@github.com:openai/openai-node.git"
      },
      keywords: [
        "openai",
        "open",
        "ai",
        "gpt-3",
        "gpt3"
      ],
      author: "OpenAI",
      license: "MIT",
      main: "./dist/index.js",
      types: "./dist/index.d.ts",
      scripts: {
        build: "tsc --outDir dist/"
      },
      dependencies: {
        axios: "^0.26.0",
        "form-data": "^4.0.0"
      },
      devDependencies: {
        "@types/node": "^12.11.5",
        typescript: "^3.6.4"
      }
    };
  }
});

// ../node_modules/form-data/lib/browser.js
var require_browser = __commonJS({
  "../node_modules/form-data/lib/browser.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// ../node_modules/openai/dist/configuration.js
var require_configuration = __commonJS({
  "../node_modules/openai/dist/configuration.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Configuration = void 0;
    var packageJson = require_package2();
    var Configuration2 = class {
      constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.organization = param.organization;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
        if (!this.baseOptions) {
          this.baseOptions = {};
        }
        this.baseOptions.headers = Object.assign({ "User-Agent": `OpenAI/NodeJS/${packageJson.version}`, "Authorization": `Bearer ${this.apiKey}` }, this.baseOptions.headers);
        if (this.organization) {
          this.baseOptions.headers["OpenAI-Organization"] = this.organization;
        }
        if (!this.formDataCtor) {
          this.formDataCtor = require_browser();
        }
      }
      /**
       * Check if the given MIME is a JSON MIME.
       * JSON MIME examples:
       *   application/json
       *   application/json; charset=UTF8
       *   APPLICATION/JSON
       *   application/vnd.company+json
       * @param mime - MIME (Multipurpose Internet Mail Extensions)
       * @return True if the given MIME is JSON, false otherwise.
       */
      isJsonMime(mime) {
        const jsonMime = new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$", "i");
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
      }
    };
    exports.Configuration = Configuration2;
  }
});

// ../node_modules/openai/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/openai/dist/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_api(), exports);
    __exportStar(require_configuration(), exports);
  }
});

// src/.wrangler/tmp/bundle-QkSCc7/middleware-loader.entry.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/wrangler/templates/middleware/common.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
function __facade_invokeChain__(request, env3, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env3, ctx, middlewareCtx);
}
function __facade_invoke__(request, env3, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env3, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}

// src/.wrangler/tmp/bundle-QkSCc7/middleware-insertion-facade.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/routes/trpcRouter.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/getOsm/getPhotonDetails.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/helpers/errors.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var UserNotFoundError = { statusCode: 404, message: "User not found" };
var ErrorFetchingGeoCodeError = {
  statusCode: 500,
  message: "Error fetching GeoCode"
};
var ErrorProcessingOverpassError = {
  statusCode: 500,
  message: "Error processing Overpass Data"
};
var ErrorRetrievingOverpassError = {
  statusCode: 500,
  message: "Error retrieving Overpass Data"
};
var RetrievingParksDataError = {
  statusCode: 500,
  message: "Error retrieving Parks Data"
};
var RetrievingTrailsDataError = {
  statusCode: 500,
  message: "Error retrieving Trails Data"
};
var TemplateNotFoundError = {
  statusCode: 404,
  message: "Template not found"
};

// src/helpers/responseHandler.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/zod/lib/index.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return Object.keys(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type2);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/trpc.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/@trpc/server/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/@trpc/server/dist/config-00ffd309.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/@trpc/server/dist/TRPCError-689e79f1.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function getTRPCErrorFromUnknown(cause) {
  if (cause instanceof TRPCError) {
    return cause;
  }
  if (cause instanceof Error && cause.name === "TRPCError") {
    return cause;
  }
  const trpcError = new TRPCError({
    code: "INTERNAL_SERVER_ERROR",
    cause
  });
  if (cause instanceof Error && cause.stack) {
    trpcError.stack = cause.stack;
  }
  return trpcError;
}
var UnknownCauseError = class extends Error {
};
function getCauseFromUnknown(cause) {
  if (cause instanceof Error) {
    return cause;
  }
  const type2 = typeof cause;
  if (type2 === "undefined" || type2 === "function" || cause === null) {
    return void 0;
  }
  if (type2 !== "object") {
    return new Error(String(cause));
  }
  if (isObject(cause)) {
    const err = new UnknownCauseError();
    for (const key in cause) {
      err[key] = cause[key];
    }
    return err;
  }
  return void 0;
}
var TRPCError = class extends Error {
  constructor(opts) {
    const cause = getCauseFromUnknown(opts.cause);
    const message = opts.message ?? cause?.message ?? opts.code;
    super(message, {
      cause
    });
    this.code = opts.code;
    this.name = "TRPCError";
    if (!this.cause) {
      this.cause = cause;
    }
  }
};

// ../node_modules/@trpc/server/dist/index-f91d720c.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/@trpc/server/dist/codes-c924c3db.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function invert(obj) {
  const newObj = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    const v = obj[key];
    newObj[v] = key;
  }
  return newObj;
}
var TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
var TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);

// ../node_modules/@trpc/server/dist/index-f91d720c.mjs
var TRPC_ERROR_CODES_BY_NUMBER2 = invert(TRPC_ERROR_CODES_BY_KEY);
var JSONRPC2_TO_HTTP_CODE = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  METHOD_NOT_SUPPORTED: 405,
  TIMEOUT: 408,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  CLIENT_CLOSED_REQUEST: 499,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501
};
function getStatusCodeFromKey(code) {
  return JSONRPC2_TO_HTTP_CODE[code] ?? 500;
}
function getHTTPStatusCode(json) {
  const arr = Array.isArray(json) ? json : [
    json
  ];
  const httpStatuses = new Set(arr.map((res) => {
    if ("error" in res) {
      const data = res.error.data;
      if (typeof data.httpStatus === "number") {
        return data.httpStatus;
      }
      const code = TRPC_ERROR_CODES_BY_NUMBER2[res.error.code];
      return getStatusCodeFromKey(code);
    }
    return 200;
  }));
  if (httpStatuses.size !== 1) {
    return 207;
  }
  const httpStatus = httpStatuses.values().next().value;
  return httpStatus;
}
function getHTTPStatusCodeFromError(error) {
  return getStatusCodeFromKey(error.code);
}
var noop2 = () => {
};
function createInnerProxy(callback, path) {
  const proxy = new Proxy(noop2, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path,
        key
      ]);
    },
    apply(_1, _2, args) {
      const isApply = path[path.length - 1] === "apply";
      return callback({
        args: isApply ? args.length >= 2 ? args[1] : [] : args,
        path: isApply ? path.slice(0, -1) : path
      });
    }
  });
  return proxy;
}
var createRecursiveProxy = (callback) => createInnerProxy(callback, []);
var createFlatProxy = (callback) => {
  return new Proxy(noop2, {
    get(_obj, name) {
      if (typeof name !== "string" || name === "then") {
        return void 0;
      }
      return callback(name);
    }
  });
};

// ../node_modules/@trpc/server/dist/config-00ffd309.mjs
function getDataTransformer(transformer) {
  if ("input" in transformer) {
    return transformer;
  }
  return {
    input: transformer,
    output: transformer
  };
}
var defaultTransformer = {
  _default: true,
  input: {
    serialize: (obj) => obj,
    deserialize: (obj) => obj
  },
  output: {
    serialize: (obj) => obj,
    deserialize: (obj) => obj
  }
};
var defaultFormatter = ({ shape }) => {
  return shape;
};
function omitPrototype(obj) {
  return Object.assign(/* @__PURE__ */ Object.create(null), obj);
}
var procedureTypes = [
  "query",
  "mutation",
  "subscription"
];
function isRouter(procedureOrRouter) {
  return "router" in procedureOrRouter._def;
}
var emptyRouter = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: defaultFormatter,
  transformer: defaultTransformer
};
var reservedWords = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function createRouterFactory(config4) {
  return function createRouterInner(procedures) {
    const reservedWordsUsed = new Set(Object.keys(procedures).filter((v) => reservedWords.includes(v)));
    if (reservedWordsUsed.size > 0) {
      throw new Error("Reserved words used in `router({})` call: " + Array.from(reservedWordsUsed).join(", "));
    }
    const routerProcedures = omitPrototype({});
    function recursiveGetPaths(procedures2, path = "") {
      for (const [key, procedureOrRouter] of Object.entries(procedures2 ?? {})) {
        const newPath = `${path}${key}`;
        if (isRouter(procedureOrRouter)) {
          recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);
          continue;
        }
        if (routerProcedures[newPath]) {
          throw new Error(`Duplicate key: ${newPath}`);
        }
        routerProcedures[newPath] = procedureOrRouter;
      }
    }
    recursiveGetPaths(procedures);
    const _def = {
      _config: config4,
      router: true,
      procedures: routerProcedures,
      ...emptyRouter,
      record: procedures,
      queries: Object.entries(routerProcedures).filter((pair) => pair[1]._def.query).reduce((acc, [key, val]) => ({
        ...acc,
        [key]: val
      }), {}),
      mutations: Object.entries(routerProcedures).filter((pair) => pair[1]._def.mutation).reduce((acc, [key, val]) => ({
        ...acc,
        [key]: val
      }), {}),
      subscriptions: Object.entries(routerProcedures).filter((pair) => pair[1]._def.subscription).reduce((acc, [key, val]) => ({
        ...acc,
        [key]: val
      }), {})
    };
    const router2 = {
      ...procedures,
      _def,
      createCaller(ctx) {
        const proxy = createRecursiveProxy(({ path, args }) => {
          if (path.length === 1 && procedureTypes.includes(path[0])) {
            return callProcedure({
              procedures: _def.procedures,
              path: args[0],
              rawInput: args[1],
              ctx,
              type: path[0]
            });
          }
          const fullPath = path.join(".");
          const procedure = _def.procedures[fullPath];
          let type2 = "query";
          if (procedure._def.mutation) {
            type2 = "mutation";
          } else if (procedure._def.subscription) {
            type2 = "subscription";
          }
          return procedure({
            path: fullPath,
            rawInput: args[0],
            ctx,
            type: type2
          });
        });
        return proxy;
      },
      getErrorShape(opts) {
        const { path, error } = opts;
        const { code } = opts.error;
        const shape = {
          message: error.message,
          code: TRPC_ERROR_CODES_BY_KEY[code],
          data: {
            code,
            httpStatus: getHTTPStatusCodeFromError(error)
          }
        };
        if (config4.isDev && typeof opts.error.stack === "string") {
          shape.data.stack = opts.error.stack;
        }
        if (typeof path === "string") {
          shape.data.path = path;
        }
        return this._def._config.errorFormatter({
          ...opts,
          shape
        });
      }
    };
    return router2;
  };
}
function callProcedure(opts) {
  const { type: type2, path } = opts;
  if (!(path in opts.procedures) || !opts.procedures[path]?._def[type2]) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: `No "${type2}"-procedure on path "${path}"`
    });
  }
  const procedure = opts.procedures[path];
  return procedure(opts);
}
var isServerDefault = typeof window === "undefined" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;

// ../node_modules/@trpc/server/dist/index.mjs
function getParseFn(procedureParser) {
  const parser = procedureParser;
  if (typeof parser === "function") {
    return parser;
  }
  if (typeof parser.parseAsync === "function") {
    return parser.parseAsync.bind(parser);
  }
  if (typeof parser.parse === "function") {
    return parser.parse.bind(parser);
  }
  if (typeof parser.validateSync === "function") {
    return parser.validateSync.bind(parser);
  }
  if (typeof parser.create === "function") {
    return parser.create.bind(parser);
  }
  if (typeof parser.assert === "function") {
    return (value) => {
      parser.assert(value);
      return value;
    };
  }
  throw new Error("Could not find a validator fn");
}
function mergeWithoutOverrides(obj1, ...objs) {
  const newObj = Object.assign(/* @__PURE__ */ Object.create(null), obj1);
  for (const overrides of objs) {
    for (const key in overrides) {
      if (key in newObj && newObj[key] !== overrides[key]) {
        throw new Error(`Duplicate key ${key}`);
      }
      newObj[key] = overrides[key];
    }
  }
  return newObj;
}
function createMiddlewareFactory() {
  function createMiddlewareInner(middlewares) {
    return {
      _middlewares: middlewares,
      unstable_pipe(middlewareBuilderOrFn) {
        const pipedMiddleware = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
          middlewareBuilderOrFn
        ];
        return createMiddlewareInner([
          ...middlewares,
          ...pipedMiddleware
        ]);
      }
    };
  }
  function createMiddleware(fn) {
    return createMiddlewareInner([
      fn
    ]);
  }
  return createMiddleware;
}
function isPlainObject(obj) {
  return obj && typeof obj === "object" && !Array.isArray(obj);
}
function createInputMiddleware(parse) {
  const inputMiddleware = async ({ next, rawInput, input }) => {
    let parsedInput;
    try {
      parsedInput = await parse(rawInput);
    } catch (cause) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        cause
      });
    }
    const combinedInput = isPlainObject(input) && isPlainObject(parsedInput) ? {
      ...input,
      ...parsedInput
    } : parsedInput;
    return next({
      input: combinedInput
    });
  };
  inputMiddleware._type = "input";
  return inputMiddleware;
}
function createOutputMiddleware(parse) {
  const outputMiddleware = async ({ next }) => {
    const result = await next();
    if (!result.ok) {
      return result;
    }
    try {
      const data = await parse(result.data);
      return {
        ...result,
        data
      };
    } catch (cause) {
      throw new TRPCError({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause
      });
    }
  };
  outputMiddleware._type = "output";
  return outputMiddleware;
}
var middlewareMarker = "middlewareMarker";
function createNewBuilder(def1, def2) {
  const { middlewares = [], inputs, meta, ...rest } = def2;
  return createBuilder({
    ...mergeWithoutOverrides(def1, rest),
    inputs: [
      ...def1.inputs,
      ...inputs ?? []
    ],
    middlewares: [
      ...def1.middlewares,
      ...middlewares
    ],
    meta: def1.meta && meta ? {
      ...def1.meta,
      ...meta
    } : meta ?? def1.meta
  });
}
function createBuilder(initDef = {}) {
  const _def = {
    inputs: [],
    middlewares: [],
    ...initDef
  };
  return {
    _def,
    input(input) {
      const parser = getParseFn(input);
      return createNewBuilder(_def, {
        inputs: [
          input
        ],
        middlewares: [
          createInputMiddleware(parser)
        ]
      });
    },
    output(output) {
      const parseOutput = getParseFn(output);
      return createNewBuilder(_def, {
        output,
        middlewares: [
          createOutputMiddleware(parseOutput)
        ]
      });
    },
    meta(meta) {
      return createNewBuilder(_def, {
        meta
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(builder) {
      return createNewBuilder(_def, builder._def);
    },
    use(middlewareBuilderOrFn) {
      const middlewares = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
        middlewareBuilderOrFn
      ];
      return createNewBuilder(_def, {
        middlewares
      });
    },
    query(resolver) {
      return createResolver({
        ..._def,
        query: true
      }, resolver);
    },
    mutation(resolver) {
      return createResolver({
        ..._def,
        mutation: true
      }, resolver);
    },
    subscription(resolver) {
      return createResolver({
        ..._def,
        subscription: true
      }, resolver);
    }
  };
}
function createResolver(_def, resolver) {
  const finalBuilder = createNewBuilder(_def, {
    resolver,
    middlewares: [
      async function resolveMiddleware(opts) {
        const data = await resolver(opts);
        return {
          marker: middlewareMarker,
          ok: true,
          data,
          ctx: opts.ctx
        };
      }
    ]
  });
  return createProcedureCaller(finalBuilder._def);
}
var codeblock = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
function createProcedureCaller(_def) {
  const procedure = async function resolve2(opts) {
    if (!opts || !("rawInput" in opts)) {
      throw new Error(codeblock);
    }
    const callRecursive = async (callOpts = {
      index: 0,
      ctx: opts.ctx
    }) => {
      try {
        const middleware2 = _def.middlewares[callOpts.index];
        const result2 = await middleware2({
          ctx: callOpts.ctx,
          type: opts.type,
          path: opts.path,
          rawInput: callOpts.rawInput ?? opts.rawInput,
          meta: _def.meta,
          input: callOpts.input,
          next(_nextOpts) {
            const nextOpts = _nextOpts;
            return callRecursive({
              index: callOpts.index + 1,
              ctx: nextOpts && "ctx" in nextOpts ? {
                ...callOpts.ctx,
                ...nextOpts.ctx
              } : callOpts.ctx,
              input: nextOpts && "input" in nextOpts ? nextOpts.input : callOpts.input,
              rawInput: nextOpts && "rawInput" in nextOpts ? nextOpts.rawInput : callOpts.rawInput
            });
          }
        });
        return result2;
      } catch (cause) {
        return {
          ok: false,
          error: getTRPCErrorFromUnknown(cause),
          marker: middlewareMarker
        };
      }
    };
    const result = await callRecursive();
    if (!result) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    }
    if (!result.ok) {
      throw result.error;
    }
    return result.data;
  };
  procedure._def = _def;
  procedure.meta = _def.meta;
  return procedure;
}
function mergeRouters(...routerList) {
  const record = mergeWithoutOverrides({}, ...routerList.map((r) => r._def.record));
  const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {
    if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {
      if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {
        throw new Error("You seem to have several error formatters");
      }
      return nextRouter._def._config.errorFormatter;
    }
    return currentErrorFormatter;
  }, defaultFormatter);
  const transformer = routerList.reduce((prev, current) => {
    if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {
      if (prev !== defaultTransformer && prev !== current._def._config.transformer) {
        throw new Error("You seem to have several transformers");
      }
      return current._def._config.transformer;
    }
    return prev;
  }, defaultTransformer);
  const router2 = createRouterFactory({
    errorFormatter,
    transformer,
    isDev: routerList.some((r) => r._def._config.isDev),
    allowOutsideOfServer: routerList.some((r) => r._def._config.allowOutsideOfServer),
    isServer: routerList.some((r) => r._def._config.isServer),
    $types: routerList[0]?._def._config.$types
  })(record);
  return router2;
}
var TRPCBuilder = class {
  context() {
    return new TRPCBuilder();
  }
  meta() {
    return new TRPCBuilder();
  }
  create(options) {
    return createTRPCInner()(options);
  }
};
var initTRPC = new TRPCBuilder();
function createTRPCInner() {
  return function initTRPCInner(runtime) {
    const errorFormatter = runtime?.errorFormatter ?? defaultFormatter;
    const transformer = getDataTransformer(runtime?.transformer ?? defaultTransformer);
    const config4 = {
      transformer,
      isDev: runtime?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
      allowOutsideOfServer: runtime?.allowOutsideOfServer ?? false,
      errorFormatter,
      isServer: runtime?.isServer ?? isServerDefault,
      /**
      * @internal
      */
      $types: createFlatProxy((key) => {
        throw new Error(`Tried to access "$types.${key}" which is not available at runtime`);
      })
    };
    {
      const isServer = runtime?.isServer ?? isServerDefault;
      if (!isServer && runtime?.allowOutsideOfServer !== true) {
        throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);
      }
    }
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: config4,
      /**
      * Builder object for creating procedures
      */
      procedure: createBuilder({
        meta: runtime?.defaultMeta
      }),
      /**
      * Create reusable middlewares
      */
      middleware: createMiddlewareFactory(),
      /**
      * Create a router
      */
      router: createRouterFactory(config4),
      /**
      * Merge Routers
      */
      mergeRouters
    };
  };
}

// src/trpc.ts
var t = initTRPC.create();
var router = t.router;
var middleware = t.middleware;
var publicProcedure = t.procedure;

// src/services/osm/getPhotonDetailsService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_osmtogeojson = __toESM(require_osmtogeojson());

// ../node_modules/axios/index.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/axios.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/utils.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/helpers/bind.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function bind(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}

// ../node_modules/axios/lib/utils.js
var { toString: toString2 } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
var typeOfTest = (type2) => (thing) => typeof thing === type2;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer2(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject2 = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject2 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject2(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : globalThis;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject2(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
  return obj;
};
var noop3 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer: isBuffer2,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject2,
  isPlainObject: isPlainObject2,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop3,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// ../node_modules/axios/lib/core/Axios.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/helpers/buildURL.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/helpers/AxiosURLSearchParams.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/helpers/toFormData.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/core/AxiosError.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function AxiosError(message, code, config4, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config4 && (this.config = config4);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config4, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config4, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// ../node_modules/axios/lib/helpers/null.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var null_default = null;

// ../node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer2.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// ../node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString3(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// ../node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// ../node_modules/axios/lib/core/InterceptorManager.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// ../node_modules/axios/lib/core/dispatchRequest.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/core/transformData.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/defaults/index.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/defaults/transitional.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// ../node_modules/axios/lib/helpers/toURLEncodedForm.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/platform/index.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/platform/browser/index.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// ../node_modules/axios/lib/platform/browser/classes/FormData.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// ../node_modules/axios/lib/platform/browser/classes/Blob.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// ../node_modules/axios/lib/platform/browser/index.js
var isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
var isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// ../node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new browser_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (browser_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// ../node_modules/axios/lib/helpers/formDataToJSON.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// ../node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: browser_default.classes.FormData,
    Blob: browser_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// ../node_modules/axios/lib/core/AxiosHeaders.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/helpers/parseHeaders.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// ../node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils_default.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils_default.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i = keys2.length;
    let deleted = false;
    while (i--) {
      const key = keys2[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// ../node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config4 = this || defaults_default;
  const context = response || config4;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config4, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// ../node_modules/axios/lib/cancel/isCancel.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// ../node_modules/axios/lib/cancel/CanceledError.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function CanceledError(message, config4, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config4, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// ../node_modules/axios/lib/adapters/adapters.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/adapters/xhr.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/core/settle.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// ../node_modules/axios/lib/helpers/cookies.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var cookies_default = browser_default.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write4(name, value, expires, path, domain2, secure) {
        const cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils_default.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils_default.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils_default.isString(domain2)) {
          cookie.push("domain=" + domain2);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write4() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);

// ../node_modules/axios/lib/core/buildFullPath.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/helpers/isAbsoluteURL.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// ../node_modules/axios/lib/helpers/combineURLs.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// ../node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// ../node_modules/axios/lib/helpers/isURLSameOrigin.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var isURLSameOrigin_default = browser_default.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// ../node_modules/axios/lib/helpers/parseProtocol.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// ../node_modules/axios/lib/helpers/speedometer.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// ../node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config4) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    let requestData = config4.data;
    const requestHeaders = AxiosHeaders_default.from(config4.headers).normalize();
    const responseType = config4.responseType;
    let onCanceled;
    function done2() {
      if (config4.cancelToken) {
        config4.cancelToken.unsubscribe(onCanceled);
      }
      if (config4.signal) {
        config4.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (browser_default.isStandardBrowserEnv || browser_default.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if (!requestHeaders.getContentType(/^\s*multipart\/form-data/)) {
        requestHeaders.setContentType("multipart/form-data");
      } else if (utils_default.isString(contentType = requestHeaders.getContentType())) {
        requestHeaders.setContentType(contentType.replace(/^\s*(multipart\/form-data);+/, "$1"));
      }
    }
    let request = new XMLHttpRequest();
    if (config4.auth) {
      const username = config4.auth.username || "";
      const password = config4.auth.password ? unescape(encodeURIComponent(config4.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config4.baseURL, config4.url);
    request.open(config4.method.toUpperCase(), buildURL(fullPath, config4.params, config4.paramsSerializer), true);
    request.timeout = config4.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config4,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done2();
      }, function _reject(err) {
        reject(err);
        done2();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config4, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config4, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config4.timeout ? "timeout of " + config4.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config4.transitional || transitional_default;
      if (config4.timeoutErrorMessage) {
        timeoutErrorMessage = config4.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config4,
        request
      ));
      request = null;
    };
    if (browser_default.isStandardBrowserEnv) {
      const xsrfValue = isURLSameOrigin_default(fullPath) && config4.xsrfCookieName && cookies_default.read(config4.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config4.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config4.withCredentials)) {
      request.withCredentials = !!config4.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config4.responseType;
    }
    if (typeof config4.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config4.onDownloadProgress, true));
    }
    if (typeof config4.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config4.onUploadProgress));
    }
    if (config4.cancelToken || config4.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config4, request) : cancel);
        request.abort();
        request = null;
      };
      config4.cancelToken && config4.cancelToken.subscribe(onCanceled);
      if (config4.signal) {
        config4.signal.aborted ? onCanceled() : config4.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && browser_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config4));
      return;
    }
    request.send(requestData || null);
  });
};

// ../node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// ../node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config4) {
  if (config4.cancelToken) {
    config4.cancelToken.throwIfRequested();
  }
  if (config4.signal && config4.signal.aborted) {
    throw new CanceledError_default(null, config4);
  }
}
function dispatchRequest(config4) {
  throwIfCancellationRequested(config4);
  config4.headers = AxiosHeaders_default.from(config4.headers);
  config4.data = transformData.call(
    config4,
    config4.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config4.method) !== -1) {
    config4.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config4.adapter || defaults_default.adapter);
  return adapter(config4).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config4);
    response.data = transformData.call(
      config4,
      config4.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config4);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config4,
          config4.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// ../node_modules/axios/lib/core/mergeConfig.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config22) {
  config22 = config22 || {};
  const config4 = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config22) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config22)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config22[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config4[prop] = configValue);
  });
  return config4;
}

// ../node_modules/axios/lib/helpers/validator.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/axios/lib/env/data.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var VERSION = "1.6.0";

// ../node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators[type2] = function validator(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version3, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version3 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version3 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// ../node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config4) {
    if (typeof configOrUrl === "string") {
      config4 = config4 || {};
      config4.url = configOrUrl;
    } else {
      config4 = configOrUrl || {};
    }
    config4 = mergeConfig(this.defaults, config4);
    const { transitional: transitional2, paramsSerializer, headers } = config4;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config4.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config4.method = (config4.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config4.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config4.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config4) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config4);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config4;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config4) {
    config4 = mergeConfig(this.defaults, config4);
    const fullPath = buildFullPath(config4.baseURL, config4.url);
    return buildURL(fullPath, config4.params, config4.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config4) {
    return this.request(mergeConfig(config4 || {}, {
      method,
      url,
      data: (config4 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config4) {
      return this.request(mergeConfig(config4 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// ../node_modules/axios/lib/cancel/CancelToken.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config4, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config4, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// ../node_modules/axios/lib/helpers/spread.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}

// ../node_modules/axios/lib/helpers/isAxiosError.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// ../node_modules/axios/lib/helpers/HttpStatusCode.js
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// ../node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// ../node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// src/services/osm/getPhotonDetailsService.ts
async function getPhotonDetailsService(id, type2) {
  type2 = type2.toLowerCase();
  switch (type2) {
    case "way":
    case "w":
      type2 = "way";
      break;
    case "node":
    case "n":
      type2 = "node";
      break;
    case "relation":
    case "r":
      type2 = "relation";
      break;
    default:
      break;
  }
  const overpassUrl = process.env.OSM_URI;
  const overpassQuery = `[out:json][timeout:25];${type2}(${id});(._;>;);out body;`;
  console.log("overpassQuery", overpassQuery);
  const response = await axios_default.post(overpassUrl, overpassQuery, {
    headers: { "Content-Type": "text/plain" }
  });
  const geojsonData = (0, import_osmtogeojson.default)(response.data);
  return geojsonData;
}

// src/controllers/getOsm/getPhotonDetails.ts
function getPhotonDetailsRoute() {
  return publicProcedure.input(
    z.object({ id: z.union([z.string(), z.number()]), type: z.string() })
  ).query(async (opts) => {
    const { id, type: type2 } = opts.input;
    return await getPhotonDetailsService(id, type2);
  });
}

// src/controllers/weather/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/weather/getWeather.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/weather/getWeatherService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
async function getWeatherService(lat, lon) {
  const root = process.env.WEATHER_URL;
  const OPENWEATHER_KEY = process.env.OPENWEATHER_KEY;
  const latParams = lat;
  const lonParams = lon;
  const unitParams = "imperial";
  const apiParams = true;
  let params = "?";
  if (latParams)
    params += `lat=${latParams}`;
  if (lonParams)
    params += `&lon=${lonParams}`;
  if (unitParams)
    params += `&units=${unitParams}`;
  if (apiParams)
    params += `&appid=${OPENWEATHER_KEY}`;
  const url = root + params;
  const response = await axios_default.get(url);
  return response;
}

// src/controllers/weather/getWeather.ts
function getWeatherRoute() {
  return publicProcedure.input(z.object({ lat: z.number(), lon: z.number() })).query(async (opts) => {
    const { lat, lon } = opts.input;
    const response = await getWeatherService(lat, lon);
    return response.data;
  });
}

// src/controllers/weather/getWeatherWeek.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/weather/getWeatherWeekService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
async function getWeatherWeekService(lat, lon) {
  const root = process.env.WEATHER_WEEK_URL;
  const OPENWEATHER_KEY = process.env.OPENWEATHER_KEY;
  const latParams = lat;
  const lonParams = lon;
  const unitParams = "imperial";
  const apiParams = true;
  let params = "?";
  if (latParams)
    params += `lat=${latParams}`;
  if (lonParams)
    params += `&lon=${lonParams}`;
  if (unitParams)
    params += `&units=${unitParams}`;
  if (apiParams)
    params += `&appid=${OPENWEATHER_KEY}`;
  const url = root + params;
  const response = await axios_default.get(url);
  return response;
}

// src/controllers/weather/getWeatherWeek.ts
function getWeatherWeekRoute() {
  return publicProcedure.input(z.object({ lat: z.number(), lon: z.number() })).query(async (opts) => {
    const { lat, lon } = opts.input;
    const response = await getWeatherWeekService(lat, lon);
    return response.data;
  });
}

// src/controllers/trip/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/trip/addTrip.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/trip/addTripService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/prisma/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/prisma/extension.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/prisma/client.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_edge = __toESM(require_edge3());
var prisma = new import_edge.PrismaClient();
var client_default = prisma;

// src/prisma/statics/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/prisma/statics/user.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_bcryptjs = __toESM(require_bcrypt());

// src/config.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_dotenv = __toESM(require_main());
(0, import_dotenv.config)();
var MONGODB_URI = process.env.MONGODB_URI;
var SERVICE_ACCOUNT_KEY = {
  type: process.env.SERVICE_ACCOUNT_KEY_TYPE,
  project_id: process.env.SERVICE_ACCOUNT_KEY_PROJECT_ID,
  private_key_id: process.env.SERVICE_ACCOUNT_KEY_PRIVATE_KEY_ID,
  private_key: process.env.SERVICE_ACCOUNT_KEY_PRIVATE_KEY,
  client_email: process.env.SERVICE_ACCOUNT_KEY_CLIENT_EMAIL,
  client_id: process.env.SERVICE_ACCOUNT_KEY_CLIENT_ID,
  auth_uri: process.env.SERVICE_ACCOUNT_KEY_AUTH_URI,
  token_uri: process.env.SERVICE_ACCOUNT_KEY_TOKEN_URI,
  auth_provider_x509_cert_url: process.env.SERVICE_ACCOUNT_KEY_AUTH_PROVIDER_X509_CERT_URL,
  client_x509_cert_url: process.env.SERVICE_ACCOUNT_KEY_CLIENT_X509_CERT_URL
};
var GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
var GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
var STMP_EMAIL = process.env.STMP_EMAIL;
var STMP_PASSWORD = process.env.STMP_PASSWORD;
var CLIENT_URL = process.env.CLIENT_URL;
var JWT_SECRET = process.env.JWT_SECRET;
var SEND_GRID_API_KEY = process.env.SEND_GRID_API_KEY;
var SERVER_ROOT_URI = process.env.SERVER_ROOT_URI;
var UI_ROOT_URI = process.env.CLIENT_URL;
var CORS_ORIGIN = process.env.CORS_ORIGIN;

// src/prisma/statics/user.ts
var import_jsonwebtoken = __toESM(require_jsonwebtoken());
async function findByCredentials({
  email,
  password
}) {
  const user = await client_default.user.findFirst({ where: { email } });
  if (!user)
    throw new Error("Unable to login");
  const isMatch = await import_bcryptjs.default.compare(password, user.password);
  if (!isMatch)
    throw new Error("Unable to login");
  return user;
}
async function alreadyLogin(email) {
  const user = client_default.user.findFirst({
    where: { email }
  });
  if (user)
    throw new Error("Already email registered");
}
async function validateResetToken(token) {
  if (!JWT_SECRET)
    throw new Error("JWT_SECRET is not defined");
  const decoded = import_jsonwebtoken.default.verify(token, JWT_SECRET);
  const user = await client_default.user.findFirst({
    where: { id: decoded.id, passwordResetToken: token }
  });
  if (!user)
    throw new Error("User not Found");
  return user;
}
var user_default = {
  alreadyLogin,
  findByCredentials,
  validateResetToken
};

// src/prisma/statics/geojson.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
async function saveOne(feature) {
  return client_default.geoJSON.upsert({
    where: { id: feature.id },
    update: feature,
    create: feature
  });
}
async function saveMany(features) {
  return client_default.$transaction(
    features.map((feature) => client_default.geoJSON.create({ data: feature }))
  );
}
var geojson_default = { saveOne, saveMany };

// src/prisma/statics/node.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var findOrCreateMany = async (ids, nodes) => {
  const existingNodes = await client_default.node.findMany({
    where: {
      id: {
        in: ids
      }
    }
  });
  const existingIds = existingNodes.map((node) => node.id);
  const filteredNodes = nodes.filter(
    (node) => !existingIds.includes(node.id)
  );
  if (filteredNodes.length > 0) {
    await client_default.node.createMany({
      data: filteredNodes
    });
  }
  return client_default.node.findMany({ where: { id: { in: ids } } });
};
var node_default = { findOrCreateMany };

// src/prisma/extension.ts
var prisma2 = client_default.$extends({
  // Model level extensions
  model: {
    geoJSON: {
      ...geojson_default
    },
    user: {
      ...user_default
    },
    node: {
      ...node_default
    }
  }
});

// src/prisma/methods/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/prisma/methods/user.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_jsonwebtoken2 = __toESM(require_jsonwebtoken());
var User = (prismaUser) => {
  if (!prismaUser)
    return;
  return Object.assign(prismaUser, {
    async save() {
      const user = this;
      if (user.username)
        return User(user);
      let generatedUsername = user.email ? user.email.split("@")[0] : "packratuser";
      let counter = 1;
      let exists = await client_default.user.findFirst({
        where: { username: generatedUsername }
      });
      while (!!exists) {
        generatedUsername = `${user.email.split("@")[0]}${counter}`;
        counter++;
        exists = await client_default.user.findFirst({
          where: { username: generatedUsername }
        });
      }
      const {
        save,
        toJSON: toJSON4,
        generateAuthToken,
        generateResetToken,
        ...userObject
      } = user;
      const updatedUser = await client_default.user.upsert({
        where: {
          username: generatedUsername
        },
        update: {
          username: generatedUsername
        },
        create: { ...userObject, username: generatedUsername }
      });
      return User(updatedUser);
    },
    toJSON() {
      const {
        password,
        passwordResetToken,
        // Remove function properties
        generateAuthToken,
        generateResetToken,
        save,
        toJSON: toJSON4,
        ...userObject
      } = this;
      return userObject;
    },
    async generateAuthToken() {
      if (!JWT_SECRET)
        throw new Error("JWT_SECRET is not defined");
      const token = await import_jsonwebtoken2.default.sign({ id: this.id.toString() }, JWT_SECRET, {
        expiresIn: "7 days"
      });
      this.token = token;
      await client_default.user.update({
        where: { id: this.id },
        data: { token }
      });
      return token;
    },
    async generateResetToken() {
      if (this.passwordResetToken) {
        if (!JWT_SECRET)
          throw new Error("JWT_SECRET is not defined");
        const decoded = import_jsonwebtoken2.default.verify(this.passwordResetToken, JWT_SECRET);
        if (decoded.id)
          return this.passwordResetToken;
      }
      if (!JWT_SECRET)
        throw new Error("JWT_SECRET is not defined");
      const resetToken = await import_jsonwebtoken2.default.sign(
        { id: this.id.toString() },
        JWT_SECRET,
        {
          expiresIn: "12h"
        }
      );
      this.passwordResetToken = resetToken;
      await client_default.user.update({
        where: { id: this.id },
        data: { passwordResetToken: resetToken }
      });
      return `${CLIENT_URL}/password-reset?token=${resetToken}`;
    }
  });
};

// src/prisma/methods/trip.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var Trip = (prismaTrip) => {
  if (!prismaTrip)
    return;
  return Object.assign(prismaTrip, {
    toJSON() {
      const {
        // destructure methods
        toJSON: toJSON4,
        ...trip
      } = this;
      const { ...tripObject } = trip;
      if (!trip.geojson)
        return tripObject;
      tripObject.geojson = {
        type: "FeatureCollection",
        features: tripObject.geojson
      };
      return tripObject;
    }
  });
};

// src/prisma/methods/way.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var Way = (prismaWay) => {
  if (!prismaWay)
    return;
  return Object.assign(prismaWay, {
    toJSON() {
      const {
        id,
        // destructure methods
        toJSON: toJSON4,
        save,
        ...wayObject
      } = this;
      return wayObject;
    },
    async save() {
      if (this.osm_type !== "way") {
        console.log(
          'ERROR in WaySchema.pre("save"): this.osm_type !== "way"',
          this.osm_type
        );
        throw new Error("This is not a way");
      }
      const {
        id,
        // destructure methods
        toJSON: toJSON4,
        save,
        ...wayObject
      } = this;
      await client_default.way.upsert({
        where: {
          id
        },
        update: wayObject,
        create: wayObject
      });
    }
  });
};

// src/prisma/methods/node.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/prisma/methods/relation.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/trip/addTripService.ts
var addTripService = async (tripDetails) => {
  try {
    const {
      name,
      description,
      duration,
      weather,
      start_date,
      end_date,
      destination,
      geoJSON,
      owner_id,
      packs,
      is_public
    } = tripDetails;
    const savedGeoJSONs = await prisma2.geoJSON.saveMany(geoJSON.features);
    const geojsonIds = savedGeoJSONs.map((feature) => feature.id);
    const newTrip = await prisma2.trip.create({
      data: {
        name,
        description,
        duration,
        weather,
        start_date,
        end_date,
        destination,
        geojson: {
          connect: geojsonIds.map((id) => ({ id }))
        },
        packs: {
          connect: packs.map((packId) => ({ id: packId }))
        },
        is_public,
        owner: {
          connect: { id: owner_id }
        }
      }
    });
    return {
      message: "Trip added successfully",
      trip: Trip(newTrip)?.toJSON()
    };
  } catch (error) {
    console.error(error);
    throw new Error("Unable to add trip");
  }
};

// src/middleware/validators/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/middleware/validators/userRoutesValidator.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_edge2 = __toESM(require_edge3());
var JoiObjectId = z.string().regex(/^[0-9a-fA-F]{24}$/g);
var userSignUp = z.object({
  name: z.string().min(1).nonempty(),
  email: z.string().email().nonempty(),
  password: z.string().nonempty(),
  username: z.string().nonempty()
});
var userSignIn = z.object({
  email: z.string().email().nonempty(),
  password: z.string().nonempty()
});
var getUserById = z.object({
  userId: JoiObjectId.nonempty()
});
var sentEmail = z.object({
  email: z.string().email().nonempty()
});
var resetPassword = z.object({
  resetToken: z.string().nonempty(),
  password: z.string().nonempty()
});
var addToFavorite = z.object({
  packId: JoiObjectId.nonempty(),
  userId: JoiObjectId.nonempty()
});
var editUser = z.object({
  userId: JoiObjectId.nonempty(),
  name: z.string(),
  password: z.string(),
  email: z.string(),
  token: z.string().optional(),
  code: z.string().optional(),
  googleId: z.string().optional(),
  is_certified_guide: z.boolean().optional(),
  passwordResetToken: z.string().optional(),
  passwordResetTokenExpiration: z.date().nullable().optional(),
  role: z.nativeEnum(import_edge2.Role).optional(),
  username: z.string().refine((value) => value.length > 0).optional(),
  profileImage: z.string().optional(),
  preferredWeather: z.string().optional(),
  preferredWeight: z.string().optional(),
  favourite_ids: z.array(JoiObjectId.nonempty()).optional(),
  pack_ids: z.array(JoiObjectId.nonempty()).optional(),
  item_id: JoiObjectId.nonempty().nullable().optional(),
  template_ids: z.array(JoiObjectId.nonempty()).optional(),
  trip_ids: z.array(JoiObjectId.nonempty()).optional()
});
var deleteUser = z.object({
  userId: JoiObjectId.nonempty()
});
var linkFirebaseAuth = z.object({
  firebaseAuthToken: z.string().nonempty()
});
var createMongoDBUser = z.object({
  email: z.string().email().nonempty(),
  name: z.string().min(1).nonempty(),
  password: z.string().nonempty()
});
var getFirebaseUserByEmail = z.object({
  email: z.string().email().nonempty()
});
var login = z.object({
  email: z.string().email().nonempty(),
  password: z.string().nonempty()
});
var checkCode = z.object({
  email: z.string().email().nonempty(),
  code: z.string().nonempty()
});
var emailExists = z.object({
  email: z.string().email().nonempty()
});
var updatePassword = z.object({
  email: z.string().email().nonempty(),
  password: z.string().nonempty()
});

// src/middleware/validators/tripRoutesValidator.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var JoiObjectId2 = (message = "valid id") => z.string().regex(/^[0-9a-fA-F]{24}$/g, { message });
var getTrips = z.object({
  owner_id: JoiObjectId2().nonempty()
});
var getTripById = z.object({
  tripId: JoiObjectId2().nonempty()
});
var addTrip = z.object({
  name: z.string().nonempty(),
  description: z.string().nonempty(),
  duration: z.string().nonempty(),
  weather: z.string().nonempty(),
  start_date: z.string().nonempty(),
  end_date: z.string().nonempty(),
  destination: z.string().nonempty(),
  geoJSON: z.object({}),
  owner_id: JoiObjectId2().nonempty(),
  packs: z.string().nonempty(),
  is_public: z.boolean()
});
var editTrip = z.object({
  id: JoiObjectId2().nonempty(),
  name: z.string().nonempty(),
  duration: z.string().nonempty(),
  weather: z.string().nonempty(),
  start_date: z.string().nonempty(),
  end_date: z.string().nonempty(),
  destination: z.string().nonempty(),
  is_public: z.boolean()
});
var deleteTrip = z.object({
  tripId: JoiObjectId2().nonempty()
});

// src/middleware/validators/packRoutesValidator.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var JoiObjectId3 = (message = "valid id") => z.string().regex(/^[0-9a-fA-F]{24}$/, { message });
var getPacks = z.object({
  ownerId: JoiObjectId3(),
  queryBy: z.string().optional()
});
var getPackById = z.object({
  packId: JoiObjectId3()
});
var addPack = z.object({
  name: z.string().nonempty(),
  owner_id: JoiObjectId3(),
  is_public: z.boolean()
});
var editPack = z.object({
  id: JoiObjectId3(),
  name: z.string().nonempty(),
  is_public: z.boolean()
});
var deletePack = z.object({
  packId: JoiObjectId3()
});
var duplicatePublicPack = z.object({
  packId: JoiObjectId3(),
  ownerId: JoiObjectId3(),
  items: z.array(z.object({}))
});

// src/middleware/validators/itemRoutesValidator.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var JoiObjectId4 = (message = "valid id") => z.string().regex(/^[0-9a-fA-F]{24}$/, { message });
var getItems = z.object({
  packId: JoiObjectId4()
});
var getItemById = z.object({
  id: JoiObjectId4()
});
var addItem = z.object({
  name: z.string().nonempty(),
  weight: z.number(),
  quantity: z.number(),
  unit: z.string().nonempty(),
  packId: JoiObjectId4(),
  type: z.string().optional(),
  ownerId: z.string().optional()
});
var editItem = z.object({
  id: JoiObjectId4(),
  name: z.string().nonempty(),
  weight: z.number(),
  quantity: z.number(),
  unit: z.string().nonempty(),
  type: z.string()
});
var deleteItem = z.object({
  itemId: JoiObjectId4().nonempty(),
  packId: JoiObjectId4().nonempty()
});
var addItemGlobal = z.object({
  name: z.string().nonempty(),
  weight: z.number(),
  quantity: z.number(),
  unit: z.string().nonempty(),
  type: z.string().optional()
});

// src/controllers/trip/addTrip.ts
function addTripRoute() {
  return publicProcedure.input(addTrip).mutation(async (opts) => {
    const {
      name,
      description,
      duration,
      weather,
      start_date,
      end_date,
      destination,
      geoJSON,
      owner_id,
      packs,
      is_public
    } = opts.input;
    const tripDetails = {
      name,
      description,
      duration,
      weather,
      start_date,
      end_date,
      destination,
      geoJSON,
      owner_id,
      packs,
      is_public
    };
    return await addTripService(tripDetails);
  });
}

// src/controllers/trip/deleteTrip.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function deleteTripRoute() {
  return publicProcedure.input(deleteTrip).mutation(async (opts) => {
    const { tripId } = opts.input;
    await prisma2.trip.delete({
      where: { id: tripId }
      // Assuming tripId is the ID of the trip to delete
    });
    return "trip was deleted successfully";
  });
}

// src/controllers/trip/editTrip.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function editTripRoute() {
  return publicProcedure.input(editTrip).mutation(async (opts) => {
    const { id } = opts.input;
    return await prisma2.trip.update({
      where: { id },
      // Assuming id is the ID of the trip to update
      data: opts.input,
      include: {
        packs: true
        // Fetch associated packs
      }
    });
  });
}

// src/controllers/trip/getPublicTrips.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/trip/getPublicTripService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getPublicTripsService = async (queryBy) => {
  try {
    const publicTrips = await prisma2.trip.findMany({
      where: { is_public: true },
      select: {
        id: true,
        name: true,
        description: true,
        duration: true,
        weather: true,
        start_date: true,
        end_date: true,
        destination: true,
        owner: {
          select: {
            id: true,
            username: true
          }
        },
        packs: {
          select: {
            id: true
          }
        },
        createdAt: true,
        updatedAt: true
      },
      orderBy: queryBy === "Favorite" ? { id: "desc" } : { id: "asc" }
    });
    const trips = publicTrips.map((trip) => {
      const owner = Array.isArray(trip.owner) ? trip.owner[0] : trip.owner;
      return {
        ...trip,
        owner
      };
    });
    return trips;
  } catch (error) {
    console.error(error);
    throw new Error("Trips cannot be found");
  }
};

// src/controllers/trip/getPublicTrips.ts
function getPublicTripsRoute() {
  return publicProcedure.input(z.object({ queryBy: z.string() })).query(async (opts) => {
    const { queryBy } = opts.input;
    return await getPublicTripsService(queryBy);
  });
}

// src/controllers/trip/getTrip.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/trip/getTripsService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getTripsService = async (ownerId) => {
  try {
    const trips = await prisma2.trip.findMany({
      where: { owner_id: ownerId },
      include: {
        packs: true
      }
    });
    return trips;
  } catch (error) {
    console.error(error);
    throw new Error("Trips cannot be found");
  }
};

// src/controllers/trip/getTrip.ts
function getTripsRoute() {
  return publicProcedure.input(getTrips).query(async (opts) => {
    const { owner_id } = opts.input;
    return await getTripsService(owner_id);
  });
}

// src/controllers/trip/getTripById.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/trip/getTripByIdService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getTripByIdService = async (tripId) => {
  try {
    const trip = await prisma2.trip.findUnique({
      where: { id: tripId },
      include: { owner: true, geojson: true }
      // Assuming 'owner_id' is a foreign key to the 'User' model
    });
    if (!trip) {
      throw new Error("Trip cannot be found");
    }
    const tripObject = {
      id: trip.id,
      name: trip.name,
      // Replace with the actual fields you have
      // Add more fields as needed
      geojson: {
        type: "FeatureCollection",
        features: trip.geojson
      },
      owner: trip.owner
      // This will have the owner details if included
    };
    return tripObject;
  } catch (error) {
    console.error(error);
    throw new Error("Trip cannot be found");
  }
};

// src/controllers/trip/getTripById.ts
function getTripByIdRoute() {
  return publicProcedure.input(getTripById).query(async (opts) => {
    const { tripId } = opts.input;
    return await getTripByIdService(tripId);
  });
}

// src/controllers/template/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/template/addTemplate.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/template/template.service.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/template/addTemplateService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var addTemplateService = async (type2, templateId, isGlobalTemplate, createdBy) => {
  try {
    const user = await prisma2.user.findUnique({
      where: {
        id: createdBy
      }
    });
    if (!user) {
      throw new Error("User not found");
    }
    await prisma2.template.create({
      data: {
        type: type2,
        templateId,
        isGlobalTemplate,
        createdBy: {
          connect: { id: createdBy }
        }
      }
    });
  } catch (error) {
    throw new Error(error.toString());
  }
};

// src/services/template/editTemplateService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var editTemplateService = async (templateId, type2, isGlobalTemplate) => {
  try {
    const template = await prisma2.template.findUnique({
      where: {
        id: templateId
      }
    });
    if (!template) {
      throw new Error("Template not found");
    }
    const updatedTemplate = await prisma2.template.update({
      where: {
        id: templateId
      },
      data: {
        type: type2 || template.type,
        isGlobalTemplate: isGlobalTemplate !== void 0 ? isGlobalTemplate : template.isGlobalTemplate
      }
    });
    return updatedTemplate;
  } catch (error) {
    throw new Error(error.toString());
  }
};

// src/controllers/template/addTemplate.ts
var import_edge3 = __toESM(require_edge3());
function addTemplateRoute() {
  return publicProcedure.input(
    z.object({
      type: z.nativeEnum(import_edge3.TemplateType),
      templateId: z.string(),
      isGlobalTemplate: z.boolean(),
      createdBy: z.string()
    })
  ).mutation(async (opts) => {
    const { type: type2, templateId, isGlobalTemplate, createdBy } = opts.input;
    const user = await prisma2.user.findUnique({
      where: {
        id: createdBy
      }
    });
    if (!user) {
      throw new Error(UserNotFoundError.message);
    }
    await addTemplateService(type2, templateId, isGlobalTemplate, createdBy);
    return { message: "Template added successfully" };
  });
}

// src/controllers/template/deleteTemplate.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function deleteTemplateRoute() {
  return publicProcedure.input(z.object({ templateId: z.string() })).mutation(async (opts) => {
    const { templateId } = opts.input;
    const template = await prisma2.template.findUnique({
      where: {
        id: templateId
      }
    });
    if (template) {
      await prisma2.template.delete({
        where: {
          id: templateId
        }
      });
      return { message: "Template removed" };
    } else {
      throw new Error(TemplateNotFoundError.message);
    }
  });
}

// src/controllers/template/editTemplate.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_edge4 = __toESM(require_edge3());
function editTemplateRoute() {
  return publicProcedure.input(
    z.object({
      templateId: z.string(),
      type: z.nativeEnum(import_edge4.TemplateType),
      isGlobalTemplate: z.boolean()
    })
  ).mutation(async (opts) => {
    const { templateId, type: type2, isGlobalTemplate } = opts.input;
    const updatedTemplate = await editTemplateService(
      templateId,
      type2,
      isGlobalTemplate
    );
    return updatedTemplate;
  });
}

// src/controllers/template/getTemplateById.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getTemplateByIdRoute() {
  return publicProcedure.input(z.object({ templateId: z.string() })).query(async (opts) => {
    const { templateId } = opts.input;
    const template = await prisma2.template.findUnique({
      where: {
        id: templateId
      },
      include: {
        createdBy: {
          select: {
            username: true
          }
        }
      }
    });
    return template;
  });
}

// src/controllers/template/getTemplates.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getTemplatesRoute() {
  return publicProcedure.query(async (opts) => {
    const templates = await prisma2.template.findMany({
      include: {
        createdBy: {
          select: {
            username: true
          }
        }
      }
    });
    return templates;
  });
}

// src/controllers/pack/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/pack/addPack.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/pack/pack.service.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/pack/addPackService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var addPackService = async (name, owner_id) => {
  const newPack = {
    name,
    owner_id,
    is_public: false,
    createdAt: (/* @__PURE__ */ new Date()).toDateString()
  };
  const existingPack = await prisma2.pack.findFirst({
    where: {
      name
    }
  });
  if (existingPack) {
    throw new Error("A pack with the same name already exists");
  }
  const createdPack = await prisma2.pack.create({
    data: {
      ...newPack,
      owners: {
        connect: { id: owner_id }
      }
    }
  });
  return { createdPack };
};

// src/services/pack/deletePackService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var deletePackService = async (packId) => {
  const pack = await prisma2.pack.delete({
    where: {
      id: packId
      // Replace 'id' with the actual primary key field in your model
    }
  });
  return { message: "pack was deleted successfully" };
};

// src/services/pack/duplicatePublicPackService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var duplicatePublicPackService = async (packId, ownerId, items) => {
  const existingPack = await prisma2.pack.findUnique({
    where: {
      id: packId
      // Replace 'id' with the actual primary key field in your model
    },
    include: {
      owners: true
    }
  });
  if (!existingPack) {
    throw new Error("Pack not found");
  }
  const newPack = await prisma2.pack.create({
    data: {
      name: existingPack.name,
      is_public: false,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      grades: {
        set: { ...existingPack.grades }
      },
      scores: {
        set: { ...existingPack.scores }
      },
      owners: {
        connect: existingPack.owners.map((owner) => ({ id: owner.id }))
      },
      owner: {
        connect: ownerId
      },
      items: {
        connect: items
      },
      type: existingPack.type
    }
  });
  return { pack: newPack };
};

// src/services/pack/editPackService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var editPackService = async (packId, packData) => {
  const updatedPack = await prisma2.pack.update({
    where: { id: packId },
    data: packData
  });
  return updatedPack;
};

// src/services/pack/getPackByIdService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getPackByIdService = async (packId) => {
  try {
    const pack = await prisma2.pack.findFirst({
      where: { id: packId },
      include: {
        favorited_by: true,
        items: true,
        owner: true,
        owners: true,
        trips: true
      }
    });
    const owner = User(pack.owner)?.toJSON();
    const favorited_by = pack.favorited_by.map((user) => User(user)?.toJSON());
    const owners = pack.owners.map((user) => User(user)?.toJSON());
    const trips = pack.trips.map((trip) => Trip(trip)?.toJSON());
    return {
      ...pack,
      owner,
      owners,
      favorited_by,
      trips
    };
  } catch (error) {
    console.error(error);
    throw error;
  }
};

// src/services/pack/getPackService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var SORT_OPTIONS = {
  Favorite: { favoritesCount: "desc" },
  Lightest: { totalWeight: "asc" },
  Heaviest: { totalWeight: "desc" },
  "Most Items": { itemsCount: "desc" },
  "Fewest Items": { itemsCount: "asc" },
  Oldest: { createdAt: "asc" },
  "Most Recent": { updatedAt: "desc" },
  "Highest Score": { scores: { totalScore: "desc" } },
  "Lowest Score": { scores: { totalScore: "asc" } },
  "A-Z": { name: "asc" },
  "Z-A": { name: "desc" },
  "Most Owners": { owners: "desc" }
};
var DEFAULT_SORT = { createdAt: "desc" };
var getPacksService = async (ownerId, queryBy = null) => {
  try {
    const packs = await prisma2.pack.findMany({
      where: {
        owners: { some: { id: ownerId } }
      },
      include: {
        items: {
          select: {
            category: {
              select: {
                name: true
              }
            }
          }
        },
        owners: true
      },
      orderBy: SORT_OPTIONS[queryBy] || DEFAULT_SORT
    });
    return packs;
  } catch (error) {
    throw new Error("Packs cannot be found: " + error.message);
  }
};

// src/services/pack/scorePackService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/utils/scorePack.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function checkEssentialItems(packItems) {
  const essentialItems = {
    water: ["water", "hydration"],
    food: ["food", "nutrition"],
    map: ["map", "navigation"],
    compass: ["compass"],
    firstAidKit: ["first aid kit", "medical kit"],
    clothing: ["clothing", "apparel"],
    shelter: ["shelter", "tent"],
    firestarter: ["firestarter", "firelighter"],
    navigationTools: ["navigation tools"],
    lightSource: ["light source", "flashlight"],
    communicationDevice: ["communication device", "phone"]
  };
  const totalItems = Object.keys(essentialItems).length;
  let presentItems = 0;
  for (const item in essentialItems) {
    const matchingItem = packItems.find(
      (packItem) => essentialItems[item].some(
        (itemName) => packItem.name.toLowerCase().includes(itemName.toLowerCase())
      )
    );
    if (matchingItem) {
      presentItems++;
    }
  }
  const essentialItemsScore = presentItems / totalItems * 10;
  return essentialItemsScore;
}
function checkRedundancy(packItems) {
  const redundantItems = {
    tools: ["multi-tool", "hammer"],
    lightSources: ["flashlight", "extra flashlight"],
    powerSources: ["batteries", "extra batteries"],
    clothing: ["socks", "extra socks"],
    food: ["food", "extra food"],
    waterContainers: ["water container", "backup water container"]
  };
  const totalRedundantItems = Object.keys(redundantItems).length;
  let presentRedundantItems = 0;
  const uniquePackItems = new Set(
    packItems.map((item) => item.name.toLowerCase())
  );
  for (const item in redundantItems) {
    const matchingItems = packItems.filter(
      (packItem) => redundantItems[item].some(
        (itemName) => packItem.name.toLowerCase().includes(itemName.toLowerCase())
      )
    );
    if (matchingItems.length > 1) {
      presentRedundantItems++;
    }
  }
  const excludedItems = ["extra socks", "extra food", "backup water container"];
  const effectiveTotalRedundantItems = totalRedundantItems - excludedItems.length;
  const redundancyScore = (effectiveTotalRedundantItems - presentRedundantItems) / effectiveTotalRedundantItems * 10;
  return redundancyScore;
}
function calculatePackScore(packData) {
  console.log("Calculating pack score...");
  console.log("packData: ", packData);
  const { items } = packData;
  const totalWeight = packData.items.reduce((total, item) => {
    if (item.unit === "lb") {
      return total + item.weight * 16 * item.quantity;
    } else {
      return total + item.weight * item.quantity;
    }
  }, 0);
  const weightThreshold = 7;
  const essentialItemsThreshold = 8;
  const redundancyAndVersatilityThreshold = 8;
  const weightScore = Math.max(11 - Math.floor(totalWeight / 10), 1);
  const essentialItemsScore = checkEssentialItems(items);
  const redundancyAndVersatilityScore = checkRedundancy(items);
  const weightGrade = weightScore >= weightThreshold ? "Good" : "Needs Improvement";
  const essentialItemsGrade = essentialItemsScore >= essentialItemsThreshold ? "Good" : "Needs Improvement";
  const redundancyAndVersatilityGrade = redundancyAndVersatilityScore >= redundancyAndVersatilityThreshold ? "Good" : "Needs Improvement";
  const totalScore = (weightScore + essentialItemsScore + redundancyAndVersatilityScore) / 3;
  const roundedScore = Math.round(totalScore * 100) / 100;
  return {
    totalScore: roundedScore,
    grades: {
      weight: weightGrade,
      essentialItems: essentialItemsGrade,
      redundancyAndVersatility: redundancyAndVersatilityGrade
    },
    scores: {
      weightScore,
      essentialItemsScore,
      redundancyAndVersatilityScore
    }
  };
}

// src/services/pack/scorePackService.ts
async function scorePackService(packId) {
  try {
    const packData = await prisma2.pack.findUnique({
      where: { id: packId },
      include: { items: true }
      // Assuming you have a relationship defined in your Prisma schema
    });
    if (!packData) {
      throw new Error("Pack not found");
    }
    const packScore = calculatePackScore(packData);
    const updatedPack = await prisma2.pack.update({
      where: { id: packId },
      data: {
        scores: packScore.scores,
        grades: packScore.grades
      }
    });
    return updatedPack;
  } catch (error) {
    throw new Error("Unable to score pack: " + error.message);
  }
}

// src/services/pack/getPublicPacksService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/prisma/virtuals/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/prisma/virtuals/pack.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/utils/convertWeight.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var units = {
  g: 1,
  kg: 1e3,
  oz: 28.3495,
  lb: 453.592,
  lbs: 453.592
};
var convertWeight = (weight, fromUnit, toUnit) => {
  if (typeof weight !== "number" || !fromUnit || !toUnit) {
    return 0;
  }
  const weightInGrams = weight * units[fromUnit];
  const convertedWeight = weightInGrams / units[toUnit];
  return convertedWeight;
};

// src/prisma/virtuals/pack.ts
var computeTotalWeight = (pack) => {
  if (pack.items && pack.items.length > 0) {
    const totalWeight = pack.items.reduce((total, item) => {
      const weightInGrams = convertWeight(item.weight, item.unit, "g");
      return total + weightInGrams * item.quantity;
    }, 0);
    return {
      ...pack,
      total_weight: totalWeight
    };
  } else {
    return {
      ...pack,
      total_weight: 0
    };
  }
};
var computeFavouritesCount = (pack) => ({ ...pack, favorites_count: pack.favorited_by.length });
var computeTotalScores = (pack) => {
  if (!pack.scores)
    return { ...pack, total_score: 0 };
  const scoresArray = Object.values(pack.scores);
  const sum = scoresArray.reduce(
    (total, score) => total + score,
    0
  );
  const average = scoresArray.length > 0 ? sum / scoresArray.length : 0;
  return { ...pack, total_score: Math.round(average * 100) / 100 };
};

// src/services/pack/getPublicPacksService.ts
var SORT_OPTIONS2 = {
  Favorite: { favorites_count: -1 },
  Lightest: { total_weight: 1 },
  Heaviest: { total_weight: -1 },
  "Most Items": { items_count: -1 },
  "Fewest Items": { items_count: 1 },
  Oldest: { createdAt: 1 },
  "Most Recent": { updatedAt: -1 },
  "Highest Score": { total_score: -1 },
  "Lowest Score": { total_score: 1 },
  "A-Z": { name: 1 },
  "Z-A": { name: -1 },
  "Most Owners": { "owners.length": -1 }
};
var sortPacks = (propertyName, sortOrder) => (packA, packB) => {
  const valueA = propertyName !== "owners.length" ? packA[propertyName] : packA.owners.length;
  const valueB = propertyName !== "owners.length" ? packB[propertyName] : packB.owners.length;
  if (valueA < valueB) {
    return -1 * Number(sortOrder);
  } else if (valueA > valueB) {
    return 1 * Number(sortOrder);
  }
  return 0;
};
var computeVirtualFields = (pack) => {
  const packWithTotalWeight = computeTotalWeight(pack);
  const packWithTotalScore = computeTotalScores(packWithTotalWeight);
  const packWithFavoritesCount = computeFavouritesCount(packWithTotalScore);
  return {
    ...packWithFavoritesCount,
    favorited_by: pack.favorited_by.map((user) => User(user)?.toJSON()),
    owners: pack.owners.map((owner) => User(owner)?.toJSON()),
    owner: User(pack.owner)?.toJSON(),
    items_count: pack.items.length
  };
};
var DEFAULT_SORT2 = { createdAt: -1 };
async function getPublicPacksService(queryBy = null) {
  try {
    const sortOption = SORT_OPTIONS2[queryBy] || DEFAULT_SORT2;
    const [[propertyName, sortOrder]] = Object.entries(sortOption);
    const publicPacks = await prisma2.pack.findMany({
      where: {
        is_public: true
      },
      include: {
        favorited_by: true,
        items: true,
        owner: true,
        owners: true
      }
    });
    console.log(publicPacks);
    return publicPacks.map(computeVirtualFields).sort(sortPacks(propertyName, sortOrder));
  } catch (error) {
    throw new Error("Packs cannot be found: " + error.message);
  }
}

// src/controllers/pack/addPack.ts
function addPackRoute() {
  return publicProcedure.input(addPack).mutation(async (opts) => {
    const { name, owner_id } = opts.input;
    return addPackService(name, owner_id);
  });
}

// src/controllers/pack/deletePack.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function deletePackRoute() {
  return publicProcedure.input(deletePack).mutation(async (opts) => {
    const { packId } = opts.input;
    await deletePackService(packId);
    return { msg: "pack was deleted successfully" };
  });
}

// src/controllers/pack/getPacks.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getPacksRoute() {
  return publicProcedure.input(getPacks).query(async (opts) => {
    const { ownerId, queryBy } = opts.input;
    const packs = await getPacksService(ownerId, queryBy);
    return { packs, message: "Packs retrieved successfully" };
  });
}

// src/controllers/pack/editPack.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function editPackRoute() {
  return publicProcedure.input(editPack).mutation(async (opts) => {
    const { id } = opts.input;
    return await editPackService(id, opts.input);
  });
}

// src/controllers/pack/duplicatePublicPack.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function duplicatePublicPackRoute() {
  return publicProcedure.input(duplicatePublicPack).mutation(async (opts) => {
    const { packId, ownerId, items } = opts.input;
    const result = await duplicatePublicPackService(packId, ownerId, items);
    return result.pack;
  });
}

// src/controllers/pack/getPackById.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getPackByIdRoute() {
  return publicProcedure.input(getPackById).query(async (opts) => {
    const { packId } = opts.input;
    return await getPackByIdService(packId);
  });
}

// src/controllers/pack/getPublicPacks.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getPublicPacksRoute() {
  return publicProcedure.input(z.object({ queryBy: z.string() })).query(async (opts) => {
    const { queryBy } = opts.input;
    return await getPublicPacksService(queryBy);
  });
}

// src/controllers/pack/scorePack.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function scorePackRoute() {
  return publicProcedure.input(getPackById).mutation(async (opts) => {
    const { packId } = opts.input;
    return await scorePackService(packId);
  });
}

// src/controllers/getOsm/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/getOsm/getOsm.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/osm/getOsmService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_osmtogeojson2 = __toESM(require_osmtogeojson());
var getOsmService = async ({ activityType, startPoint, endPoint }) => {
  const overpassUrl = process.env.OSM_URI;
  try {
    const overpassQuery = await formatOverpassQuery(
      activityType,
      startPoint,
      endPoint
    );
    const response = await axios_default.post(overpassUrl, overpassQuery, {
      headers: { "Content-Type": "text/plain" }
    });
    if (response.status === 200) {
      const responseFormat = response.data;
      const geojsonData = (0, import_osmtogeojson2.default)(responseFormat);
      return geojsonData;
    } else {
      return ErrorProcessingOverpassError;
    }
  } catch (error) {
    return ErrorRetrievingOverpassError;
  }
};
async function formatOverpassQuery(activityType, startPoint, endPoint) {
  const activityTypeTags = {
    hiking: '["highway"~"path|footway"]',
    skiing: '["piste:type"~"downhill|nordic"]',
    climbing: '["sport"="climbing"]',
    cycling: '["highway"~"cycleway(:left|:right)?"]',
    canoeing: '["waterway"~"riverbank|canal|stream"]',
    horseback_riding: '["highway"="bridleway"]',
    kayaking: '["waterway"~"riverbank|canal|stream|rapids|waterfall"]',
    rock_climbing: '["natural"="cliff"]',
    sailing: '["waterway"~"riverbank|canal|harbour|basin"]'
  };
  const tagString = activityTypeTags[activityType];
  const overpassQuery = `[out:json][timeout:25];
        (
          way${tagString}(${startPoint.latitude},${startPoint.longitude},${endPoint.latitude},${endPoint.longitude});
        );
        (._;>;);
        out skel qt;`;
  return overpassQuery;
}

// src/controllers/getOsm/getOsm.ts
function getOsmRoute() {
  return publicProcedure.input(
    z.object({
      activityType: z.string(),
      startPoint: z.object({ latitude: z.number(), longitude: z.number() }),
      endPoint: z.object({ latitude: z.number(), longitude: z.number() })
    })
  ).mutation(async (opts) => {
    try {
      const { activityType, startPoint, endPoint } = opts.input;
      return await getOsmService({ activityType, startPoint, endPoint });
    } catch (error) {
      return ErrorRetrievingOverpassError;
    }
  });
}

// src/controllers/getOsm/getDestination.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/osm/osm.service.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/osm/getDestinationService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getDestinationService = async (id) => {
  const way = await prisma2.way.findUnique({ where: { id } });
  if (way) {
    return Way(way).toJSON();
  }
  const node = await prisma2.node.findUnique({ where: { id } });
  return node;
};

// src/services/osm/postCollectionGeoJSONService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/utils/osmFunctions/modelHandlers.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/utils/osmFunctions/coordinateHandlers.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
async function createInstanceFromCoordinates(Model, [lon, lat]) {
  if (typeof lon !== "number" || typeof lat !== "number") {
    console.error("Invalid coordinate format");
    return null;
  }
  const instance = await Model.create({
    data: {
      lon,
      lat
    }
  });
  return instance.id;
}
async function coordinatesToInstances(Model, coordinates) {
  if (!Array.isArray(coordinates)) {
    console.error("Coordinates is not an array");
    return [];
  }
  if (coordinates.length === 0) {
    return [];
  }
  const isNestedArray = Array.isArray(coordinates[0]);
  if (!isNestedArray) {
    if (typeof coordinates[0] === "number") {
      return [
        await createInstanceFromCoordinates(
          Model,
          coordinates
        )
      ];
    } else {
      return coordinates;
    }
  }
  if (typeof coordinates[0][0] === "number") {
    return await Promise.all(
      coordinates.map(
        async (coordinate) => await createInstanceFromCoordinates(Model, coordinate)
      )
    );
  } else {
    return coordinates;
  }
}
function handleGeoJSONGeometry(geometry) {
  if (!geometry || !Array.isArray(geometry.coordinates)) {
    console.error("geometry is undefined or not an array");
    return [];
  }
  const nodes = [];
  if (geometry.type === "Point") {
    nodes.push(geometry.coordinates);
  } else {
    for (const coords of geometry.coordinates) {
      nodes.push(coords);
    }
  }
  return nodes;
}

// src/utils/osmFunctions/dataFormatters.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var extractIdAndType = (string) => {
  if (string.includes("/")) {
    const [type2, idString] = string.split("/");
    const idNumber = Number(idString);
    return { type: type2, id: idNumber };
  } else {
    return { type: "node", id: string };
  }
};
function isOSMFormat(data) {
  return data?.type && data.id && data.tags && data.nodes;
}
function isGeoJSONFormat(data) {
  return data && data.type === "Feature" && data.geometry && data.properties;
}
function propertiesToTags(properties) {
  if (!properties) {
    console.error("properties is undefined or null");
    return {};
  }
  if (typeof properties !== "object" || properties === null) {
    throw new Error("Properties should be an object");
  }
  const tags = {};
  for (const [k, v] of Object.entries(properties)) {
    tags[k] = v;
  }
  return tags;
}

// src/utils/osmFunctions/modelHandlers.ts
var modelMappingFunc = (type2) => {
  switch (type2) {
    case "node":
    case "n":
    case "N":
      return prisma2.node;
    case "way":
    case "w":
    case "W":
      return prisma2.way;
    case "relation":
    case "r":
    case "R":
      return prisma2.relation;
    default:
      return null;
  }
};
async function fromOSM(Model, data) {
  const { type: type2, id } = extractIdAndType(data.id);
  const instanceData = {
    osm_id: id,
    osm_type: type2,
    tags: propertiesToTags(data.tags),
    updated_at: data.timestamp
  };
  const ids = data.nodes.map((node) => node.id);
  const instances = await prisma2.node.findOrCreateMany(ids, data.nodes);
  instanceData.nodes = instances.map((instance) => instance._id);
  const newInstance = await Model.create({ data: instanceData });
  return newInstance;
}
async function fromGeoJSON(Model, geoJSON) {
  let osm_type;
  let osm_id;
  if (geoJSON.id) {
    const extractedObj = extractIdAndType(geoJSON.id);
    osm_type = extractedObj.type;
    osm_id = extractedObj.id;
  }
  const tags = propertiesToTags(geoJSON.properties || {});
  const nodes = await coordinatesToInstances(
    prisma2.node,
    handleGeoJSONGeometry(geoJSON.geometry)
  );
  let instanceGeoJSON;
  if (isGeoJSONFormat(geoJSON)) {
    instanceGeoJSON = geoJSON;
  } else {
    console.error("geoJSON is not in GeoJSON format");
  }
  const instance = await Model.create({
    data: {
      osm_id,
      osm_type,
      geoJSON: instanceGeoJSON,
      nodes: {
        connect: nodes.map((node) => ({ id: node.id }))
      },
      tags
    }
  });
  return instance;
}
function findExisting(Model, id, type2) {
  return Model.findFirst({ where: { osm_id: id, osm_type: type2 } });
}
async function updateInstanceFromGeoJSON(instance, geoJSON) {
  instance.updated_at = geoJSON.properties.timestamp;
  instance.tags = propertiesToTags(geoJSON.properties);
  instance.nodes = await coordinatesToInstances(
    prisma2.node,
    handleGeoJSONGeometry(geoJSON.geometry)
  );
  instance.geoJSON = geoJSON;
  return instance;
}
async function createNewInstance(Model, element) {
  if (isOSMFormat(element)) {
    return await fromOSM(Model, element);
  } else if (isGeoJSONFormat(element)) {
    return await fromGeoJSON(Model, element);
  }
  throw new Error("Element is neither in OSM or GeoJSON format.");
}
function ensureIdProperty(element) {
  if (!element.id && element.properties?.osm_id) {
    let { osm_type, osm_id } = element.properties;
    if (osm_type === "N") {
      osm_type = "node";
    } else if (osm_type === "W") {
      osm_type = "way";
    } else if (osm_type === "R") {
      osm_type = "relation";
    }
    element.id = `${osm_type}/${osm_id}`;
  }
  if (!element.type && element.properties?.osm_type) {
    element.type = element.properties.osm_type;
  }
  return element;
}
async function processElement(element) {
  const id = element.id ? Number(element.id.split("/")[1]) : Number(element.properties.osm_id);
  const type2 = element.id ? element.id.split("/")[0] : element.properties.osm_type;
  const ModelForElement = modelMappingFunc(type2);
  if (!ModelForElement) {
    console.error(`Invalid type: ${type2}`);
    return;
  }
  let instance = await findExisting(ModelForElement, id, type2);
  if (instance) {
    if (isGeoJSONFormat(element)) {
      instance = await updateInstanceFromGeoJSON(instance, element);
      await instance.save();
    }
  } else {
    instance = await createNewInstance(ModelForElement, element);
  }
  return instance;
}

// src/services/osm/postSingleGeoJSONService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var postSingleGeoJSONService = async (geojson) => {
  if (!geojson || !isGeoJSONFormat(geojson)) {
    throw new Error("Invalid or missing geoJSON");
  }
  const processedElement = ensureIdProperty(geojson);
  const newInstance = await processElement(processedElement);
  return newInstance;
};

// src/controllers/getOsm/getDestination.ts
function getDestinationRoute() {
  return publicProcedure.input(z.object({ id: z.string() })).query(async (opts) => {
    const { id } = opts.input;
    return await getDestinationService(id);
  });
}

// src/controllers/getOsm/postSingleGeoJSON.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function postSingleGeoJSONRoute() {
  return publicProcedure.input(z.object({ geojson: z.any() })).mutation(async (opts) => {
    const { geojson } = opts.input;
    return await postSingleGeoJSONService(geojson);
  });
}

// src/controllers/getOsm/postCollectionGeoJSON.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/getOsm/updateDatabaseWithGeoJSONDataFromOverpass.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var updateDatabaseWithGeoJSONDataFromOverpass = async (data) => {
  if (!data) {
    throw new Error("No data provided");
  }
};

// src/controllers/getOsm/getPhotonResults.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/osm/getPhotonResultsService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
async function getPhotonResultsService(searchString) {
  const params = {
    q: searchString,
    osm_tag: ["highway:footway", "highway:cycleway", "place"]
    // osm_tag: "highway:footway",
    // osm_tag: "highway:cycleway",
    // osm_tag: "place",
  };
  const queryString = Object.entries(params).flatMap(
    ([key, values]) => Array.isArray(values) ? values.map((val) => `${key}=${val}`) : `${key}=${values}`
  ).join("&");
  const response = await axios_default.get(
    `https://photon.komoot.io/api/?${queryString}`
  );
  return response;
}

// src/controllers/getOsm/getPhotonResults.ts
var validators3 = __toESM(require_dist());
function getPhotonResultsRoute() {
  return publicProcedure.input(validators3.getPhotonResults).query(async (opts) => {
    const response = await getPhotonResultsService(opts.input.searchString);
    return response.data.features;
  });
}

// src/controllers/getOsm/getEnhancedPhotonDetails.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_osmtogeojson3 = __toESM(require_osmtogeojson());

// src/controllers/getOsm/getParksOSM.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/osm/getParksOSMService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_osmtogeojson4 = __toESM(require_osmtogeojson());
async function getParksOSMService(lat, lon, radius) {
  const overpassUrl = process.env.OSM_URI;
  const overpassQuery = `
        [out:json][timeout:25];
        (
          way["leisure"~"park|nature_reserve|garden|recreation_ground"](around:${radius},${lat},${lon});
        );
        (._;>;);
        out tags geom qt;
        `;
  const response = await axios_default.post(overpassUrl, overpassQuery, {
    headers: { "Content-Type": "text/plain" }
  });
  const geojsonData = (0, import_osmtogeojson4.default)(response.data);
  console.log("geojsonData==============", geojsonData);
  updateDatabaseWithGeoJSONDataFromOverpass(geojsonData);
  return geojsonData;
}

// src/controllers/getOsm/getParksOSM.ts
var validators4 = __toESM(require_dist());
function getParksOSMRoute() {
  return publicProcedure.input(validators4.getParksOSM).query(async (opts) => {
    const { lat = 45.5231, lon = -122.6765, radius = 5e4 } = opts.input;
    return await getParksOSMService(lat, lon, radius);
  });
}

// src/controllers/getOsm/getNominatimDetails.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/getOsm/getTrailsOSM.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/osm/getTrailsOSMService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_osmtogeojson5 = __toESM(require_osmtogeojson());
async function getTrailsOsmService(lat, lon, radius) {
  const overpassUrl = process.env.OSM_URI;
  const overpassQuery = `
       [out:json][timeout:25];
       (
         way["highway"~"footway"]["name"](around:${radius},${lat},${lon});
       );
       out tags geom qt;
       `;
  const response = await axios_default.post(overpassUrl, overpassQuery, {
    headers: { "Content-Type": "text/plain" }
  });
  const geojsonData = (0, import_osmtogeojson5.default)(response.data);
  updateDatabaseWithGeoJSONDataFromOverpass(geojsonData);
  return geojsonData;
}

// src/controllers/getOsm/getTrailsOSM.ts
var validators5 = __toESM(require_dist());
function getTrailsOSMRoute() {
  return publicProcedure.input(validators5.getTrailsOSM).query(async (opts) => {
    const { lat = 45.5231, lon = -122.6765, radius = 5e4 } = opts.input;
    return await getTrailsOsmService(lat, lon, radius);
  });
}

// src/controllers/openAi/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/openAi/getAIResponse.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/openAi/openAi.service.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/openAi/getAIResponseService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_openai = __toESM(require_dist2());
var getAIResponseService = async (userId, conversationId, userInput) => {
  if (!process.env.OPENAI_API_KEY) {
    throw new Error(
      "Failed to get response from AI. OPENAI_API_KEY is not set."
    );
  }
  const configuration = new import_openai.Configuration({
    apiKey: process.env.OPENAI_API_KEY
  });
  const openai = new import_openai.OpenAIApi(configuration);
  const user = await prisma2.user.findUnique({
    where: { id: userId }
  });
  if (!user) {
    throw new Error("User not found");
  }
  let conversation = await prisma2.conversation.findFirst({
    where: { userId, id: conversationId }
  });
  console.log("conversation after find ---->", conversation);
  let conversationHistory = conversation ? conversation.history : "";
  const messages = conversationHistory ? conversationHistory.split("\n").map((message, i) => ({
    role: i % 2 === 0 ? "user" : "assistant",
    content: message
  })) : [
    {
      role: "system",
      content: "You are a helpful Outdoor Adventure Planning assistant for PackRat. Please assist the user with planning their trip using the following information:"
    }
  ];
  messages.push({ role: "user", content: userInput });
  const response = await openai.createChatCompletion({
    model: "gpt-3.5-turbo",
    messages
  });
  const aiResponse = response.data.choices[0].message.content.trim();
  conversationHistory += `
${userInput}
AI: ${aiResponse}`;
  if (conversation) {
    await prisma2.conversation.update({
      where: { id: conversationId },
      data: { history: conversationHistory }
    });
  } else {
    conversation = await prisma2.conversation.create({
      data: {
        userId,
        history: conversationHistory
      }
    });
  }
  return {
    aiResponse,
    conversation
  };
};

// src/services/openAi/getUserChatsService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getUserChatsService = async (userId) => {
  const user = await prisma2.user.findUnique({
    where: { id: userId }
  });
  if (!user) {
    throw new Error("User not found");
  }
  const conversations = await prisma2.conversation.findMany({
    where: { userId }
  });
  return { conversations };
};

// src/controllers/openAi/getAIResponse.ts
function getAIResponseRoute() {
  return publicProcedure.input(
    z.object({
      userId: z.string(),
      conversationId: z.string(),
      userInput: z.string()
    })
  ).query(async (opts) => {
    const { userId, conversationId, userInput } = opts.input;
    return getAIResponseService(userId, conversationId, userInput);
  });
}

// src/controllers/openAi/getUserChats.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getUserChatsRoute() {
  return publicProcedure.input(z.object({ userId: z.string() })).query(async (opts) => {
    const { userId } = opts.input;
    return getUserChatsService(userId);
  });
}

// src/controllers/item/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/item/addGlobalItemToPack.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/item/item.service.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/item/addGlobalItemToPackService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var addGlobalItemToPackService = async (packId, itemId, ownerId) => {
  const item = await prisma2.item.findUnique({
    where: { id: itemId },
    include: { category: { select: { name: true } } }
  });
  await prisma2.pack.update({
    where: { id: packId },
    data: {
      items: {
        connect: { id: item.id }
      }
    }
  });
  const updatedItem = await prisma2.item.update({
    where: { id: item.id },
    data: {
      owners: {
        connect: { id: ownerId }
      }
    }
  });
  return item;
};

// src/services/item/editGlobalItemAsDuplicateService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var editGlobalItemAsDuplicateService = async (itemId, packId, name, weight, quantity, unit, type2) => {
  const category = await prisma2.itemCategory.findFirst({
    where: {
      name: type2
    }
  });
  let newItem = await prisma2.item.create({
    data: {
      name,
      weight,
      unit,
      quantity,
      global: false,
      category: {
        connect: { id: category.id }
      },
      packs: {
        connect: { id: packId }
      }
    }
  });
  newItem = await prisma2.item.findUnique({
    where: {
      id: newItem.id
    },
    include: {
      category: true
    }
  });
  await prisma2.pack.update({
    where: {
      id: packId
    },
    data: {
      items: {
        connect: { id: newItem.id },
        disconnect: [{ id: itemId }, { id: packId }]
      }
    }
  });
  return newItem;
};

// src/services/item/deleteGlobalItemService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var deleteGlobalItemService = async (itemId) => {
  const itemDeleted = await prisma2.item.delete({
    where: {
      id: itemId
    }
  });
  return itemDeleted;
};

// src/services/item/addItemGlobalService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/utils/itemCategory.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var ItemCategoryEnum = {
  FOOD: "Food",
  WATER: "Water",
  ESSENTIALS: "Essentials"
};

// src/services/item/addItemGlobalService.ts
var import_edge5 = __toESM(require_edge3());
var addItemGlobalService = async (name, weight, quantity, unit, type2) => {
  let category = null;
  let newItem = null;
  switch (type2) {
    case ItemCategoryEnum.FOOD: {
      const category2 = await prisma2.itemCategory.findFirst({
        where: {
          name: import_edge5.ItemCategoryName.Food
        }
      });
      let newItem2 = await prisma2.item.create({
        data: {
          name,
          weight,
          quantity,
          unit,
          category: {
            connect: { id: category2.id }
          },
          global: true
        }
      });
      newItem2 = await prisma2.item.findUnique({
        where: {
          id: newItem2.id
        },
        include: {
          category: {
            select: {
              name: true
            }
          }
        }
      });
      break;
    }
    case ItemCategoryEnum.WATER: {
      const category2 = await prisma2.itemCategory.findFirst({
        where: {
          name: import_edge5.ItemCategoryName.Water
        }
      });
      newItem = await prisma2.item.create({
        data: {
          name,
          weight,
          quantity: 1,
          unit,
          category: {
            connect: { id: category2.id }
          },
          global: true
        }
      });
      newItem = await prisma2.item.findUnique({
        where: {
          id: newItem.id
        },
        include: {
          category: {
            select: {
              name: true
            }
          }
        }
      });
      break;
    }
    default: {
      category = await prisma2.itemCategory.findFirst({
        where: {
          name: import_edge5.ItemCategoryName.Essentials
        }
      });
      newItem = await prisma2.item.create({
        data: {
          name,
          weight,
          quantity,
          unit,
          category: {
            connect: {
              id: category.id
            }
          },
          global: true
        }
      });
      newItem = await prisma2.item.findUnique({
        where: {
          id: newItem.id
        },
        include: {
          category: {
            select: {
              name: true
            }
          }
        }
      });
      break;
    }
  }
  return newItem;
};

// src/services/item/addItemService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var import_edge6 = __toESM(require_edge3());
var addItemService = async (name, weight, quantity, unit, packId, type2, ownerId) => {
  let category = null;
  let newItem = null;
  switch (type2) {
    case ItemCategoryEnum.FOOD: {
      category = await prisma2.itemCategory.findFirst({
        where: {
          name: import_edge6.ItemCategoryName.Food
        }
      });
      newItem = await prisma2.item.create({
        data: {
          name,
          weight,
          quantity,
          unit,
          packs: {
            connect: { id: packId }
          },
          category: {
            connect: { id: category.id }
          }
        }
      });
      break;
    }
    case ItemCategoryEnum.WATER: {
      category = await prisma2.itemCategory.findFirst({
        where: {
          name: "Water"
        }
      });
      const existingWaterItem = await prisma2.item.findFirst({
        where: {
          category: { id: category.id },
          packs: { some: { id: packId } }
        },
        select: {
          weight: true,
          id: true
        }
      });
      if (existingWaterItem) {
        existingWaterItem.weight += Number(weight);
        newItem = await prisma2.item.update({
          where: { id: existingWaterItem.id },
          data: {
            weight: existingWaterItem.weight
          }
        });
      } else {
        newItem = await prisma2.item.create({
          data: {
            name,
            weight,
            quantity: 1,
            unit,
            packs: {
              connect: { id: packId }
            },
            category: {
              connect: { id: category.id }
            }
          }
        });
      }
      break;
    }
    default: {
      category = await prisma2.itemCategory.findFirst({
        where: {
          name: ItemCategoryEnum.ESSENTIALS
        }
      });
      newItem = await prisma2.item.create({
        data: {
          name,
          weight,
          quantity,
          unit,
          packs: {
            connect: { id: packId }
          },
          category: {
            connect: { id: category.id }
          }
        }
      });
      break;
    }
  }
  const pack = await prisma2.pack.update({
    where: { id: packId },
    data: {
      items: {
        connect: { id: newItem.id }
      }
    },
    include: {
      owners: true
    }
  });
  const updatedItem = await prisma2.item.update({
    where: { id: newItem.id },
    data: {
      owners: {
        connect: pack.owners.map((owner) => ({ id: owner.id }))
      }
    },
    include: {
      category: true
    }
  });
  return { newItem: updatedItem, packId };
};

// src/services/item/deleteItemService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var deleteItemService = async (itemId, packId) => {
  let itemDeleted;
  const item = await prisma2.item.findUnique({
    where: {
      id: itemId
    }
  });
  if (item.global) {
    await prisma2.pack.update({
      where: {
        id: packId
      },
      data: {
        items: {
          disconnect: { id: itemId }
        }
      }
    });
    await prisma2.item.update({
      where: {
        id: itemId
      },
      data: {
        packs: {
          disconnect: { id: packId }
        }
      }
    });
    itemDeleted = await prisma2.item.findUnique({
      where: {
        id: itemId
      }
    });
  } else {
    itemDeleted = await prisma2.item.delete({
      where: {
        id: itemId
      }
    });
  }
  return itemDeleted;
};

// src/services/item/editItemService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var editItemService = async (id, name, weight, unit, quantity, type2) => {
  const category = await prisma2.itemCategory.findFirst({
    where: {
      name: type2
    }
  });
  const newItem = await prisma2.item.update({
    where: {
      id
    },
    data: {
      name,
      weight,
      unit,
      quantity,
      category: {
        connect: { id: category.id }
      }
    },
    include: {
      category: true
    }
  });
  return newItem;
};

// src/services/item/getItemByIdService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getItemByIdService = async (id) => {
  const item = await prisma2.item.findUnique({
    where: {
      id
    }
  });
  return item;
};

// src/services/item/getItemsGloballyService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getItemsGloballyService = async (reqlimit, reqpage) => {
  const totalItems = await prisma2.item.count({
    where: {
      global: true
    }
  });
  const limit = Number(reqlimit) || totalItems;
  const totalPages = Math.ceil(totalItems / limit);
  const page = Number(reqpage) || 1;
  const startIndex = (page - 1) * limit;
  const items = await prisma2.item.findMany({
    where: {
      global: true
    },
    include: {
      category: {
        select: {
          name: true
        }
      }
    },
    skip: startIndex,
    take: limit,
    orderBy: {
      createdAt: "desc"
    }
  });
  return {
    items,
    page,
    totalPages
  };
};

// src/services/item/searchItemsByNameService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var searchItemsByNameService = async (name, packId) => {
  const items = await prisma2.item.findMany({
    where: {
      ...packId && {
        pack_ids: {
          has: packId
        }
      },
      name: {
        contains: name
        // Case-insensitive search for name
      }
    }
  });
  return items;
};

// src/services/item/getItemsService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getItemsService = async (packId) => {
  const items = await prisma2.item.findMany({
    where: {
      packs: {
        some: {
          id: packId
        }
      }
    }
  });
  return items;
};

// src/controllers/item/addGlobalItemToPack.ts
function addGlobalItemToPackRoute() {
  return publicProcedure.input(
    z.object({
      packId: z.string(),
      itemId: z.string(),
      ownerId: z.string()
    })
  ).query(async (opts) => {
    const { packId, itemId, ownerId } = opts.input;
    return await addGlobalItemToPackService(packId, itemId, ownerId);
  });
}

// src/controllers/item/addItem.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function addItemRoute() {
  return publicProcedure.input(addItem).mutation(async (opts) => {
    const { name, weight, quantity, unit, packId, type: type2, ownerId } = opts.input;
    const result = await addItemService(
      name,
      weight,
      quantity,
      unit,
      packId,
      type2,
      ownerId
    );
    return { newItem: result.newItem, packId: result.packId };
  });
}

// src/controllers/item/addItemGlobal.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function addItemGlobalRoute() {
  return publicProcedure.input(addItemGlobal).mutation(async (opts) => {
    const { name, weight, quantity, unit, type: type2 } = opts.input;
    return await addItemGlobalService(name, weight, quantity, unit, type2);
  });
}

// src/controllers/item/deleteGlobalItem.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function deleteGlobalItemRoute() {
  return publicProcedure.input(
    z.object({
      itemId: z.string()
    })
  ).mutation(async (opts) => {
    const { itemId } = opts.input;
    return await deleteGlobalItemService(itemId);
  });
}

// src/controllers/item/deleteItem.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function deleteItemRoute() {
  return publicProcedure.input(deleteItem).mutation(async (opts) => {
    const { itemId, packId } = opts.input;
    return await deleteItemService(itemId, packId);
  });
}

// src/controllers/item/editItem.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function editItemRoute() {
  return publicProcedure.input(editItem).mutation(async (opts) => {
    const { id, name, weight, unit, quantity, type: type2 } = opts.input;
    return await editItemService(id, name, weight, unit, quantity, type2);
  });
}

// src/controllers/item/getItems.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getItemsRoute() {
  return publicProcedure.input(getItems).query(async (opts) => {
    const { packId } = opts.input;
    return await getItemsService(packId);
  });
}

// src/controllers/item/getItemById.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getItemByIdRoute() {
  return publicProcedure.input(getItemById).query(async (opts) => {
    const { id } = opts.input;
    return getItemByIdService(id);
  });
}

// src/controllers/item/editGlobalItemAsDuplicate.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function editGlobalItemAsDuplicateRoute() {
  return publicProcedure.input(
    z.object({
      itemId: z.string(),
      packId: z.string(),
      name: z.string(),
      weight: z.number(),
      quantity: z.number(),
      unit: z.string(),
      type: z.string()
    })
  ).mutation(async (opts) => {
    const { itemId, packId, name, weight, quantity, unit, type: type2 } = opts.input;
    return await editGlobalItemAsDuplicateService(
      itemId,
      packId,
      name,
      weight,
      quantity,
      unit,
      type2
    );
  });
}

// src/controllers/item/getItemsGlobally.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getItemsGloballyRoute() {
  return publicProcedure.input(
    z.object({
      limit: z.number(),
      page: z.number(),
      searchString: z.string().optional()
    })
  ).query(async (opts) => {
    return await getItemsGloballyService(opts.input.limit, opts.input.page);
  });
}

// src/controllers/item/searchItemsByName.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var JoiObjectId5 = (message = "valid id") => z.string().regex(/^[0-9a-fA-F]{24}$/, { message });
function searchItemsByNameRoute() {
  return publicProcedure.input(z.object({ name: z.string(), packId: JoiObjectId5().optional() })).query(async (opts) => {
    const { name, packId } = opts.input;
    return searchItemsByNameService(name, packId);
  });
}

// src/controllers/getTrail/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/getTrail/getTrails.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/trails/getTrailsService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
async function getTrailsService(administrative_area_level_1, country, locality, latitude, longitude, radiusParams, activityParams) {
  const state = administrative_area_level_1;
  const city = locality;
  let paramsConditional = "";
  const root = process.env.GET_TRAIL_ROOT_URL;
  if (latitude)
    paramsConditional += `lat=${latitude}`;
  if (longitude)
    paramsConditional += `&lon=${longitude}`;
  if (city)
    paramsConditional += `&q-city_cont=${city.replace(/\s/g, "")}`;
  if (radiusParams)
    paramsConditional += `&radius=${radiusParams}`;
  if (activityParams) {
    paramsConditional += "&q-activities_activity_type_name_eq=hiking";
  }
  const url1 = root + paramsConditional;
  const url = "https://trailapi-trailapi.p.rapidapi.com/activity/?lat=34.1&lon=-105.2&q-city_cont=Denver&radius=25&q-activities_activity_type_name_eq=hiking";
  const X_RAPIDAPI_KEY = process.env.X_RAPIDAPI_KEY;
  const options = {
    method: "GET",
    headers: {
      "X-RapidAPI-Key": `${X_RAPIDAPI_KEY}`,
      "X-RapidAPI-Host": "trailapi-trailapi.p.rapidapi.com"
    }
  };
  return await fetch(url1, options).then(async (res) => await res.json()).then((json) => {
    return json;
  }).catch((_err) => {
    return RetrievingTrailsDataError;
  });
}

// src/controllers/getTrail/getTrails.ts
function getTrailsRoute() {
  return publicProcedure.input(
    z.object({
      administrative_area_level_1: z.string(),
      country: z.string(),
      locality: z.string(),
      latitude: z.number(),
      longitude: z.number()
    })
  ).mutation(async (opts) => {
    const radiusParams = 25;
    const activityParams = true;
    const {
      administrative_area_level_1,
      country,
      locality,
      latitude,
      longitude
    } = opts.input;
    return await getTrailsService(
      administrative_area_level_1,
      country,
      locality,
      latitude,
      longitude,
      radiusParams,
      activityParams
    );
  });
}

// src/controllers/getParks/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/getParks/getParks.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var validators6 = __toESM(require_dist());

// src/services/parks/getParksService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/utils/oneEntity.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var oneEntity = async (val) => {
  if (!val) {
    throw new Error("Required");
  }
  return val;
};

// src/services/parks/getParksService.ts
async function getParksService(abbrStates) {
  const abbrState = await oneEntity(abbrStates);
  const X_RAPIDAPI_KEY = process.env.X_RAPIDAPI_KEY;
  const NPS_API = process.env.NPS_API;
  const PARKS_HOST = process.env.PARKS_HOST;
  const host = `${PARKS_HOST}?stateCode=${abbrState}`;
  const options = {
    method: "GET",
    headers: {
      "X-Api-Key": `${NPS_API}`,
      "X-RapidAPI-Key": `${X_RAPIDAPI_KEY}`,
      "X-RapidAPI-Host": "jonahtaylor-national-park-service-v1.p.rapidapi.com",
      "User-Agent": "PackRat"
    }
  };
  return await fetch(host, options).then(async (res) => await res.json()).then((json) => {
    return json;
  }).catch(() => {
    return RetrievingParksDataError;
  });
}

// src/controllers/getParks/getParks.ts
function getParksRoute() {
  return publicProcedure.input(validators6.getParks).query(async (opts) => {
    return await getParksService(opts.input.abbrState);
  });
}

// src/controllers/geoCode/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/geoCode/getGeoCode.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var validators7 = __toESM(require_dist());

// src/services/geocode/geoCodeService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
async function geoCodeService({ addressArray }) {
  const address = await oneEntity(addressArray);
  const transform = address.split(", ").join("%20").split(" ").join("%20");
  const GEO_CODE_URL = process.env.GEO_CODE_URL;
  const GEOAPIFY_KEY = process.env.GEOAPIFY_KEY;
  let params = "?";
  if (address)
    params += `text=${transform}`;
  const api_key = `&apiKey=${GEOAPIFY_KEY}`;
  params += api_key;
  const url = GEO_CODE_URL + params;
  return await fetch(url).then(async (response) => response.json()).then((result) => {
    return { message: "ok", result };
  }).catch(() => {
    return ErrorFetchingGeoCodeError;
  });
}

// src/controllers/geoCode/getGeoCode.ts
function getGeoCodeRoute() {
  return publicProcedure.input(validators7.AddressArray).query(async (opts) => {
    const result = await geoCodeService(opts.input);
    return result.message === "ok" ? result.result : ErrorFetchingGeoCodeError;
  });
}

// src/controllers/favorite/index.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/favorite/addToFavorite.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/favorite/favorite.service.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/services/favorite/addToFavoriteService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var addToFavoriteService = async (packId, userId) => {
  const user = await prisma2.user.findUnique({
    where: {
      id: userId
    },
    include: {
      favorites: true
    }
  });
  if (user.favorites.includes(packId)) {
    await prisma2.user.update({
      where: {
        id: userId
      },
      data: {
        favorites: {
          disconnect: {
            id: packId
          }
        }
      }
    });
    await prisma2.pack.update({
      where: {
        id: packId
      },
      data: {
        favorited_by: {
          disconnect: {
            id: userId
          }
        }
      }
    });
  } else {
    await prisma2.user.update({
      where: {
        id: userId
      },
      data: {
        favorites: {
          connect: {
            id: packId
          }
        }
      }
    });
    await prisma2.pack.update({
      where: {
        id: packId
      },
      data: {
        favorited_by: {
          connect: {
            id: userId
          }
        }
      }
    });
  }
};

// src/services/favorite/getFavoritePacksByUserService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
var getFavoritePacksByUserService = async (userId) => {
  const packs = await prisma2.pack.findMany({
    where: {
      favorited_by: {
        some: {
          id: userId
        }
      }
    }
  });
  return packs;
};

// src/services/favorite/getUserFavoritesService.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// src/controllers/favorite/addToFavorite.ts
function addToFavoriteRoute() {
  return publicProcedure.input(addToFavorite).mutation(async (opts) => {
    const { packId, userId } = opts.input;
    await addToFavoriteService(packId, userId);
    const user = await prisma2.user.findUnique({
      where: {
        id: userId
        // Assuming userId is the user's ID
      },
      select: {
        // Exclude the 'password' field
        id: true,
        email: true,
        name: true
        // Include other fields you want
      }
    });
    if (!user)
      return UserNotFoundError;
    return user;
  });
}

// src/controllers/favorite/getFavoritePacksByUser.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getFavoritePacksByUserRoute() {
  return publicProcedure.input(z.object({ userId: z.string() })).query(async (opts) => {
    const { userId } = opts.input;
    const packs = await getFavoritePacksByUserService(userId);
    return packs;
  });
}

// src/controllers/favorite/getUserFavorites.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getUserFavoritesRoute() {
  return publicProcedure.input(z.object({ userId: z.string() })).query(async (opts) => {
    const { userId } = opts.input;
    const user = await prisma2.user.findUnique({
      where: {
        id: userId
        // Assuming userId is the user's ID
      },
      include: {
        favorites: true
      }
    });
    return user.favorites;
  });
}

// src/routes/trpcRouter.ts
var helloRouter = router({
  world: publicProcedure.input(z.string()).query(async ({ input }) => {
    console.log("input", input);
    return `Hello ${input}!`;
  })
});
var helloRouter2 = () => {
  return publicProcedure.query(async ({ input }) => {
    console.log("input", input);
    return `Hello ${input}!`;
  });
};
var appRouter = router({
  hello1: router({
    world: publicProcedure.query(() => {
      return "Hello World";
    })
  }),
  hello2: helloRouter,
  hello3: publicProcedure.query(() => {
    return "Hello World";
  }),
  helloRouter2: helloRouter2(),
  // user routes
  // getUserById: getUserByIdRoute(),
  // signIn: userSignInRoute(),
  // signUp: signUpRoute(),
  // resetPassword: resetPasswordRoute(),
  // getGoogleAuthURL: getGoogleAuthURLRoute(),
  // googleSignin: googleSigninRoute(),
  // editUser: editUserRoute(),
  // deleteUser: deleteUserRoute(),
  // getMe: getMeRoute(),
  // emaileExists: emailExistsRoute(),
  // checkCode: checkCodeRoute(),
  // getUsers: getUsersRoute(),
  // resetPasswordEmail: sentEmailRoute(),
  // updatePassword: updatePasswordRoute(),
  // weather routes
  getWeather: getWeatherRoute(),
  getWeatherWeek: getWeatherWeekRoute(),
  // trips routes
  getPublicTripsRoute: getPublicTripsRoute(),
  getTrips: getTripsRoute(),
  getTripById: getTripByIdRoute(),
  addTrip: addTripRoute(),
  editTrip: editTripRoute(),
  deleteTrip: deleteTripRoute(),
  // templates routes
  getTemplates: getTemplatesRoute(),
  getTemplateById: getTemplateByIdRoute(),
  addTemplate: addTemplateRoute(),
  editTemplate: editTemplateRoute(),
  deleteTemplate: deleteTemplateRoute(),
  // password reset routes
  // requestPasswordResetEmailAndToken: requestPasswordResetEmailAndTokenRoute(),
  // handlePasswordReset: handlePasswordResetRoute(),
  // packs routes
  getPublicPacks: getPublicPacksRoute(),
  getPacks: getPacksRoute(),
  getPackById: getPackByIdRoute(),
  addPack: addPackRoute(),
  editPack: editPackRoute(),
  deletePack: deletePackRoute(),
  scorePack: scorePackRoute(),
  duplicatePublicPack: duplicatePublicPackRoute(),
  // osm routes
  getPhotonResults: getPhotonResultsRoute(),
  getTrailsOSM: getTrailsOSMRoute(),
  getParksOSM: getParksOSMRoute(),
  getOsm: getOsmRoute(),
  postSingleGeoJSON: postSingleGeoJSONRoute(),
  getDestination: getDestinationRoute(),
  getPhotonDetails: getPhotonDetailsRoute(),
  // open ai routes
  getAIResponse: getAIResponseRoute(),
  getUserChats: getUserChatsRoute(),
  // item routes
  getItems: getItemsRoute(),
  getItemById: getItemByIdRoute(),
  searchItemsByName: searchItemsByNameRoute(),
  addItem: addItemRoute(),
  editItem: editItemRoute(),
  deleteItem: deleteItemRoute(),
  addItemGlobal: addItemGlobalRoute(),
  getItemsGlobally: getItemsGloballyRoute(),
  addGlobalItemToPack: addGlobalItemToPackRoute(),
  editGlobalItemAsDuplicate: editGlobalItemAsDuplicateRoute(),
  deleteGlobalItem: deleteGlobalItemRoute(),
  // trails routes
  getTrails: getTrailsRoute(),
  // parks route
  getParks: getParksRoute(),
  // geo code routes
  getGeoCode: getGeoCodeRoute(),
  // favorite routes
  addToFavorite: addToFavoriteRoute(),
  getUserFavorites: getUserFavoritesRoute(),
  getFavoritePacksByUser: getFavoritePacksByUserRoute()
});

// ../node_modules/@trpc/server/dist/adapters/fetch/index.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/@trpc/server/dist/resolveHTTPResponse-cd1a9112.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();

// ../node_modules/@trpc/server/dist/transformTRPCResponse-1153b421.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getErrorShape(opts) {
  const { path, error, config: config4 } = opts;
  const { code } = opts.error;
  const shape = {
    message: error.message,
    code: TRPC_ERROR_CODES_BY_KEY[code],
    data: {
      code,
      httpStatus: getHTTPStatusCodeFromError(error)
    }
  };
  if (config4.isDev && typeof opts.error.stack === "string") {
    shape.data.stack = opts.error.stack;
  }
  if (typeof path === "string") {
    shape.data.path = path;
  }
  return config4.errorFormatter({
    ...opts,
    shape
  });
}
function transformTRPCResponseItem(config4, item) {
  if ("error" in item) {
    return {
      ...item,
      error: config4.transformer.output.serialize(item.error)
    };
  }
  if ("data" in item.result) {
    return {
      ...item,
      result: {
        ...item.result,
        data: config4.transformer.output.serialize(item.result.data)
      }
    };
  }
  return item;
}
function transformTRPCResponse(config4, itemOrItems) {
  return Array.isArray(itemOrItems) ? itemOrItems.map((item) => transformTRPCResponseItem(config4, item)) : transformTRPCResponseItem(config4, itemOrItems);
}

// ../node_modules/@trpc/server/dist/contentType-778b33c3.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getRawProcedureInputOrThrow(opts) {
  const { req } = opts;
  try {
    if (req.method === "GET") {
      if (!req.query.has("input")) {
        return void 0;
      }
      const raw2 = req.query.get("input");
      return JSON.parse(raw2);
    }
    if (!opts.preprocessedBody && typeof req.body === "string") {
      return req.body.length === 0 ? void 0 : JSON.parse(req.body);
    }
    return req.body;
  } catch (cause) {
    throw new TRPCError({
      code: "PARSE_ERROR",
      cause
    });
  }
}
var deserializeInputValue = (rawValue, transformer) => {
  return typeof rawValue !== "undefined" ? transformer.input.deserialize(rawValue) : rawValue;
};
var getJsonContentTypeInputs = (opts) => {
  const rawInput = getRawProcedureInputOrThrow(opts);
  const transformer = opts.router._def._config.transformer;
  if (!opts.isBatchCall) {
    return {
      0: deserializeInputValue(rawInput, transformer)
    };
  }
  if (rawInput == null || typeof rawInput !== "object" || Array.isArray(rawInput)) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: '"input" needs to be an object when doing a batch call'
    });
  }
  const input = {};
  for (const key in rawInput) {
    const k = key;
    const rawValue = rawInput[k];
    const value = deserializeInputValue(rawValue, transformer);
    input[k] = value;
  }
  return input;
};

// ../node_modules/@trpc/server/dist/resolveHTTPResponse-cd1a9112.mjs
var HTTP_METHOD_PROCEDURE_TYPE_MAP = {
  GET: "query",
  POST: "mutation"
};
var fallbackContentTypeHandler = {
  getInputs: getJsonContentTypeInputs
};
function initResponse(initOpts) {
  const { ctx, paths, type: type2, responseMeta, untransformedJSON, errors = [] } = initOpts;
  let status = untransformedJSON ? getHTTPStatusCode(untransformedJSON) : 200;
  const headers = {
    "Content-Type": "application/json"
  };
  const eagerGeneration = !untransformedJSON;
  const data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [
    untransformedJSON
  ];
  const meta = responseMeta?.({
    ctx,
    paths,
    type: type2,
    data,
    errors,
    eagerGeneration
  }) ?? {};
  for (const [key, value] of Object.entries(meta.headers ?? {})) {
    headers[key] = value;
  }
  if (meta.status) {
    status = meta.status;
  }
  return {
    status,
    headers
  };
}
async function inputToProcedureCall(procedureOpts) {
  const { opts, ctx, type: type2, input, path } = procedureOpts;
  try {
    const data = await callProcedure({
      procedures: opts.router._def.procedures,
      path,
      rawInput: input,
      ctx,
      type: type2
    });
    return {
      result: {
        data
      }
    };
  } catch (cause) {
    const error = getTRPCErrorFromUnknown(cause);
    opts.onError?.({
      error,
      path,
      input,
      ctx,
      type: type2,
      req: opts.req
    });
    return {
      error: getErrorShape({
        config: opts.router._def._config,
        error,
        type: type2,
        path,
        input,
        ctx
      })
    };
  }
}
function caughtErrorToData(cause, errorOpts) {
  const { router: router2, req, onError } = errorOpts.opts;
  const error = getTRPCErrorFromUnknown(cause);
  onError?.({
    error,
    path: errorOpts.path,
    input: errorOpts.input,
    ctx: errorOpts.ctx,
    type: errorOpts.type,
    req
  });
  const untransformedJSON = {
    error: getErrorShape({
      config: router2._def._config,
      error,
      type: errorOpts.type,
      path: errorOpts.path,
      input: errorOpts.input,
      ctx: errorOpts.ctx
    })
  };
  const transformedJSON = transformTRPCResponse(router2._def._config, untransformedJSON);
  const body = JSON.stringify(transformedJSON);
  return {
    error,
    untransformedJSON,
    body
  };
}
async function resolveHTTPResponse(opts) {
  const { router: router2, req, unstable_onHead, unstable_onChunk } = opts;
  if (req.method === "HEAD") {
    const headResponse = {
      status: 204
    };
    unstable_onHead?.(headResponse, false);
    unstable_onChunk?.([
      -1,
      ""
    ]);
    return headResponse;
  }
  const contentTypeHandler = opts.contentTypeHandler ?? fallbackContentTypeHandler;
  const batchingEnabled = opts.batching?.enabled ?? true;
  const type2 = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method] ?? "unknown";
  let ctx = void 0;
  let paths;
  const isBatchCall = !!req.query.get("batch");
  const isStreamCall = isBatchCall && unstable_onHead && unstable_onChunk && req.headers["trpc-batch-mode"] === "stream";
  try {
    ctx = await opts.createContext();
    if (opts.error) {
      throw opts.error;
    }
    if (isBatchCall && !batchingEnabled) {
      throw new Error(`Batching is not enabled on the server`);
    }
    if (type2 === "subscription") {
      throw new TRPCError({
        message: "Subscriptions should use wsLink",
        code: "METHOD_NOT_SUPPORTED"
      });
    }
    if (type2 === "unknown") {
      throw new TRPCError({
        message: `Unexpected request method ${req.method}`,
        code: "METHOD_NOT_SUPPORTED"
      });
    }
    const inputs = await contentTypeHandler.getInputs({
      isBatchCall,
      req,
      router: router2,
      preprocessedBody: opts.preprocessedBody ?? false
    });
    paths = isBatchCall ? decodeURIComponent(opts.path).split(",") : [
      opts.path
    ];
    const promises = paths.map((path, index) => inputToProcedureCall({
      opts,
      ctx,
      type: type2,
      input: inputs[index],
      path
    }));
    if (!isStreamCall) {
      const untransformedJSON = await Promise.all(promises);
      const errors = untransformedJSON.flatMap((response) => "error" in response ? [
        response.error
      ] : []);
      const headResponse1 = initResponse({
        ctx,
        paths,
        type: type2,
        responseMeta: opts.responseMeta,
        untransformedJSON,
        errors
      });
      unstable_onHead?.(headResponse1, false);
      const result = isBatchCall ? untransformedJSON : untransformedJSON[0];
      const transformedJSON = transformTRPCResponse(router2._def._config, result);
      const body = JSON.stringify(transformedJSON);
      unstable_onChunk?.([
        -1,
        body
      ]);
      return {
        status: headResponse1.status,
        headers: headResponse1.headers,
        body
      };
    }
    const headResponse2 = initResponse({
      ctx,
      paths,
      type: type2,
      responseMeta: opts.responseMeta
    });
    unstable_onHead(headResponse2, true);
    const indexedPromises = new Map(promises.map((promise, index) => [
      index,
      promise.then((r) => [
        index,
        r
      ])
    ]));
    for (const _ of paths) {
      const [index, untransformedJSON1] = await Promise.race(indexedPromises.values());
      indexedPromises.delete(index);
      try {
        const transformedJSON1 = transformTRPCResponse(router2._def._config, untransformedJSON1);
        const body1 = JSON.stringify(transformedJSON1);
        unstable_onChunk([
          index,
          body1
        ]);
      } catch (cause) {
        const path = paths[index];
        const input = inputs[index];
        const { body: body2 } = caughtErrorToData(cause, {
          opts,
          ctx,
          type: type2,
          path,
          input
        });
        unstable_onChunk([
          index,
          body2
        ]);
      }
    }
    return;
  } catch (cause1) {
    const { error, untransformedJSON: untransformedJSON2, body: body3 } = caughtErrorToData(cause1, {
      opts,
      ctx,
      type: type2
    });
    const headResponse3 = initResponse({
      ctx,
      paths,
      type: type2,
      responseMeta: opts.responseMeta,
      untransformedJSON: untransformedJSON2,
      errors: [
        error
      ]
    });
    unstable_onHead?.(headResponse3, false);
    unstable_onChunk?.([
      -1,
      body3
    ]);
    return {
      status: headResponse3.status,
      headers: headResponse3.headers,
      body: body3
    };
  }
}

// ../node_modules/@trpc/server/dist/batchStreamFormatter-fc1ffb26.mjs
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function getBatchStreamFormatter() {
  let first = true;
  function format2(index, string) {
    const prefix = first ? "{" : ",";
    first = false;
    return `${prefix}"${index}":${string}
`;
  }
  format2.end = () => "}";
  return format2;
}

// ../node_modules/@trpc/server/dist/adapters/fetch/index.mjs
async function fetchRequestHandler(opts) {
  const resHeaders = new Headers();
  const createContext = async () => {
    return opts.createContext?.({
      req: opts.req,
      resHeaders
    });
  };
  const url = new URL(opts.req.url);
  const path = url.pathname.slice(opts.endpoint.length + 1);
  const req = {
    query: url.searchParams,
    method: opts.req.method,
    headers: Object.fromEntries(opts.req.headers),
    body: opts.req.headers.get("content-type")?.startsWith("application/json") ? await opts.req.text() : ""
  };
  let resolve2;
  const promise = new Promise((r) => resolve2 = r);
  let status = 200;
  let isStream2 = false;
  let controller;
  let encoder;
  let formatter;
  const unstable_onHead = (head, isStreaming) => {
    for (const [key, value] of Object.entries(head.headers ?? {})) {
      if (typeof value === "undefined") {
        continue;
      }
      if (typeof value === "string") {
        resHeaders.set(key, value);
        continue;
      }
      for (const v of value) {
        resHeaders.append(key, v);
      }
    }
    status = head.status;
    if (isStreaming) {
      resHeaders.set("Transfer-Encoding", "chunked");
      resHeaders.append("Vary", "trpc-batch-mode");
      const stream = new ReadableStream({
        start(c) {
          controller = c;
        }
      });
      const response = new Response(stream, {
        status,
        headers: resHeaders
      });
      resolve2(response);
      encoder = new TextEncoder();
      formatter = getBatchStreamFormatter();
      isStream2 = true;
    }
  };
  const unstable_onChunk = ([index, string]) => {
    if (index === -1) {
      const response = new Response(string || null, {
        status,
        headers: resHeaders
      });
      resolve2(response);
    } else {
      controller.enqueue(encoder.encode(formatter(index, string)));
    }
  };
  resolveHTTPResponse({
    req,
    createContext,
    path,
    router: opts.router,
    batching: opts.batching,
    responseMeta: opts.responseMeta,
    onError(o) {
      opts?.onError?.({
        ...o,
        req: opts.req
      });
    },
    unstable_onHead,
    unstable_onChunk
  }).then(() => {
    if (isStream2) {
      controller.enqueue(encoder.encode(formatter.end()));
      controller.close();
    }
  }).catch(() => {
    if (isStream2) {
      controller.close();
    }
  });
  return promise;
}

// src/index.ts
var src_default = {
  async fetch(request) {
    return fetchRequestHandler({
      endpoint: "/trpc",
      req: request,
      router: appRouter,
      createContext: async (arg) => arg
    });
  }
};

// ../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_checked_fetch();
init_modules_watch_stub();
init_process();
init_buffer();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
var jsonError = async (request, env3, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env3);
  } catch (e) {
    const error = reduceError(e);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
};
var middleware_miniflare3_json_error_default = jsonError;
var wrap = void 0;

// src/.wrangler/tmp/bundle-QkSCc7/middleware-insertion-facade.js
var envWrappers = [wrap].filter(Boolean);
var facade = {
  ...src_default,
  envWrappers,
  middleware: [
    middleware_miniflare3_json_error_default,
    ...src_default.middleware ? src_default.middleware : []
  ].filter(Boolean)
};
var middleware_insertion_facade_default = facade;

// src/.wrangler/tmp/bundle-QkSCc7/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
var __facade_modules_fetch__ = function(request, env3, ctx) {
  if (middleware_insertion_facade_default.fetch === void 0)
    throw new Error("Handler does not export a fetch() function.");
  return middleware_insertion_facade_default.fetch(request, env3, ctx);
};
function getMaskedEnv(rawEnv) {
  let env3 = rawEnv;
  if (middleware_insertion_facade_default.envWrappers && middleware_insertion_facade_default.envWrappers.length > 0) {
    for (const wrapFn of middleware_insertion_facade_default.envWrappers) {
      env3 = wrapFn(env3);
    }
  }
  return env3;
}
var registeredMiddleware = false;
var facade2 = {
  ...middleware_insertion_facade_default.tail && {
    tail: maskHandlerEnv(middleware_insertion_facade_default.tail)
  },
  ...middleware_insertion_facade_default.trace && {
    trace: maskHandlerEnv(middleware_insertion_facade_default.trace)
  },
  ...middleware_insertion_facade_default.scheduled && {
    scheduled: maskHandlerEnv(middleware_insertion_facade_default.scheduled)
  },
  ...middleware_insertion_facade_default.queue && {
    queue: maskHandlerEnv(middleware_insertion_facade_default.queue)
  },
  ...middleware_insertion_facade_default.test && {
    test: maskHandlerEnv(middleware_insertion_facade_default.test)
  },
  ...middleware_insertion_facade_default.email && {
    email: maskHandlerEnv(middleware_insertion_facade_default.email)
  },
  fetch(request, rawEnv, ctx) {
    const env3 = getMaskedEnv(rawEnv);
    if (middleware_insertion_facade_default.middleware && middleware_insertion_facade_default.middleware.length > 0) {
      if (!registeredMiddleware) {
        registeredMiddleware = true;
        for (const middleware2 of middleware_insertion_facade_default.middleware) {
          __facade_register__(middleware2);
        }
      }
      const __facade_modules_dispatch__ = function(type2, init3) {
        if (type2 === "scheduled" && middleware_insertion_facade_default.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init3.cron ?? "",
            () => {
            }
          );
          return middleware_insertion_facade_default.scheduled(controller, env3, ctx);
        }
      };
      return __facade_invoke__(
        request,
        env3,
        ctx,
        __facade_modules_dispatch__,
        __facade_modules_fetch__
      );
    } else {
      return __facade_modules_fetch__(request, env3, ctx);
    }
  }
};
function maskHandlerEnv(handler) {
  return (data, env3, ctx) => handler(data, getMaskedEnv(env3), ctx);
}
var middleware_loader_entry_default = facade2;
export {
  middleware_loader_entry_default as default
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! Bundled license information:

@esbuild-plugins/node-globals-polyfill/Buffer.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

osmtogeojson/lodash.custom.js:
  (**
   * @license
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash exports="node" include="clone,merge,isEmpty,isArray,compact,each" -d`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

bcryptjs/dist/bcrypt.js:
  (**
   * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/bcrypt.js for details
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@trpc/server/dist/resolveHTTPResponse-cd1a9112.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/server/dist/adapters/fetch/index.mjs:
  (* istanbul ignore if -- @preserve *)
*/
//# sourceMappingURL=index.js.map
