(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a4, b2) => (typeof require !== "undefined" ? require : a4)[b2]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all3) => {
    for (var name in all3)
      __defProp(target, name, { get: all3[name], enumerable: true });
  };
  var __copyProps = (to, from3, except, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/.wrangler/tmp/bundle-1lsW9v/checked-fetch.js
  function checkURL(request, init3) {
    const url = request instanceof URL ? request : new URL(
      (typeof request === "string" ? new Request(request, init3) : request).url
    );
    if (url.port && url.port !== "443" && url.protocol === "https:") {
      if (!urls.has(url.toString())) {
        urls.add(url.toString());
        console.warn(
          `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
        );
      }
    }
  }
  var urls;
  var init_checked_fetch = __esm({
    "src/.wrangler/tmp/bundle-1lsW9v/checked-fetch.js"() {
      urls = /* @__PURE__ */ new Set();
      globalThis.fetch = new Proxy(globalThis.fetch, {
        apply(target, thisArg, argArray) {
          const [request, init3] = argArray;
          checkURL(request, init3);
          return Reflect.apply(target, thisArg, argArray);
        }
      });
    }
  });

  // ../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/process.js
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e8) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e9) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e8) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e9) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        args[i2 - 1] = arguments[i2];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function binding(name) {
    throw new Error("process.binding is not supported");
  }
  function cwd() {
    return "/";
  }
  function chdir(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask() {
    return 0;
  }
  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance2) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  function uptime() {
    var currentTime = /* @__PURE__ */ new Date();
    var dif = currentTime - startTime;
    return dif / 1e3;
  }
  var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance2, performanceNow, startTime, process, defines;
  var init_process = __esm({
    "../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/process.js"() {
      cachedSetTimeout = defaultSetTimout;
      cachedClearTimeout = defaultClearTimeout;
      if (typeof globalThis.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof globalThis.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      platform = "browser";
      browser = true;
      env = {};
      argv = [];
      version = "";
      versions = {};
      release = {};
      config = {};
      on = noop;
      addListener = noop;
      once = noop;
      off = noop;
      removeListener = noop;
      removeAllListeners = noop;
      emit = noop;
      performance2 = globalThis.performance || {};
      performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      startTime = /* @__PURE__ */ new Date();
      process = {
        nextTick,
        title,
        browser,
        env,
        argv,
        version,
        versions,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        binding,
        cwd,
        chdir,
        umask,
        hrtime,
        platform,
        release,
        config,
        uptime
      };
      defines = {};
      Object.keys(defines).forEach((key) => {
        const segs = key.split(".");
        let target = process;
        for (let i2 = 0; i2 < segs.length; i2++) {
          const seg = segs[i2];
          if (i2 === segs.length - 1) {
            target[seg] = defines[key];
          } else {
            target = target[seg] || (target[seg] = {});
          }
        }
      });
    }
  });

  // ../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js
  function init() {
    inited = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  function base64toByteArray(b64) {
    if (!inited) {
      init();
    }
    var i2, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i2 = 0, j = 0; i2 < l; i2 += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function base64fromByteArray(uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
      parts.push(
        encodeChunk(
          uint8,
          i2,
          i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength
        )
      );
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 63];
      output += lookup[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  function kMaxLength() {
    return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer2.prototype;
    } else {
      if (that === null) {
        that = new Buffer2(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
      return new Buffer2(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
  }
  function from(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill3, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill3 !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill3, encoding) : createBuffer(that, size).fill(fill3);
    }
    return createBuffer(that, size);
  }
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) {
      for (var i2 = 0; i2 < size; ++i2) {
        that[i2] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i2 = 0; i2 < length; i2 += 1) {
      that[i2] = array[i2] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array = new Uint8Array(array);
    } else if (length === void 0) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer2.prototype;
    } else {
      that = fromArrayLike(that, array);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError(
      "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
    );
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes"
      );
    }
    return length | 0;
  }
  function internalIsBuffer(b2) {
    return !!(b2 != null && b2._isBuffer);
  }
  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  function swap(b2, n3, m2) {
    var i2 = b2[n3];
    b2[n3] = b2[m2];
    b2[m2] = i2;
  }
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(
            buffer,
            val,
            byteOffset
          );
        } else {
          return Uint8Array.prototype.lastIndexOf.call(
            buffer,
            val,
            byteOffset
          );
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (isNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(
      utf8ToBytes(string, buf.length - offset),
      buf,
      offset,
      length
    );
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(
      utf16leToBytes(string, buf.length - offset),
      buf,
      offset,
      length
    );
  }
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64fromByteArray(buf);
    } else {
      return base64fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += toHex(buf[i2]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes.length; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 2); i2 < j; ++i2) {
      buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
    }
  }
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 4); i2 < j; ++i2) {
      buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
    }
  }
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(
        buf,
        value,
        offset,
        4,
        34028234663852886e22,
        -34028234663852886e22
      );
    }
    ieee754write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(
        buf,
        value,
        offset,
        8,
        17976931348623157e292,
        -17976931348623157e292
      );
    }
    ieee754write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex(n3) {
    if (n3 < 16)
      return "0" + n3.toString(16);
    return n3.toString(16);
  }
  function utf8ToBytes(string, units2) {
    units2 = units2 || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units2 -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units2 -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units2 -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units2 -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units2 -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units2 -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units2 -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units2 -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units2) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units2 -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  function ieee754read(buffer, offset, isLE, mLen, nBytes) {
    var e8, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d2 = isLE ? -1 : 1;
    var s3 = buffer[offset + i2];
    i2 += d2;
    e8 = s3 & (1 << -nBits) - 1;
    s3 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e8 = e8 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
    }
    m2 = e8 & (1 << -nBits) - 1;
    e8 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
    }
    if (e8 === 0) {
      e8 = 1 - eBias;
    } else if (e8 === eMax) {
      return m2 ? NaN : (s3 ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e8 = e8 - eBias;
    }
    return (s3 ? -1 : 1) * m2 * Math.pow(2, e8 - mLen);
  }
  function ieee754write(buffer, value, offset, isLE, mLen, nBytes) {
    var e8, m2, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d2 = isLE ? 1 : -1;
    var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e8 = eMax;
    } else {
      e8 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e8)) < 1) {
        e8--;
        c2 *= 2;
      }
      if (e8 + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e8++;
        c2 /= 2;
      }
      if (e8 + eBias >= eMax) {
        m2 = 0;
        e8 = eMax;
      } else if (e8 + eBias >= 1) {
        m2 = (value * c2 - 1) * Math.pow(2, mLen);
        e8 = e8 + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e8 = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
    }
    e8 = e8 << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e8 & 255, i2 += d2, e8 /= 256, eLen -= 8) {
    }
    buffer[offset + i2 - d2] |= s3 * 128;
  }
  var lookup, revLookup, Arr, inited, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
  var init_Buffer = __esm({
    "../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      lookup = [];
      revLookup = [];
      Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      inited = false;
      Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
      Buffer2.poolSize = 8192;
      Buffer2._augment = function(arr) {
        arr.__proto__ = Buffer2.prototype;
        return arr;
      };
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      Buffer2.kMaxLength = kMaxLength();
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
        if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
        }
      }
      Buffer2.alloc = function(size, fill3, encoding) {
        return alloc(null, size, fill3, encoding);
      };
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.isBuffer = isBuffer;
      Buffer2.compare = function compare(a4, b2) {
        if (!internalIsBuffer(a4) || !internalIsBuffer(b2)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a4 === b2)
          return 0;
        var x2 = a4.length;
        var y2 = b2.length;
        for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
          if (a4[i2] !== b2[i2]) {
            x2 = a4[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i2;
        if (length === void 0) {
          length = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length += list[i2].length;
          }
        }
        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          var buf = list[i2];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      Buffer2.byteLength = byteLength;
      Buffer2.prototype._isBuffer = true;
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        var length = this.length | 0;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.equals = function equals(b2) {
        if (!internalIsBuffer(b2))
          throw new TypeError("Argument must be a Buffer");
        if (this === b2)
          return true;
        return Buffer2.compare(this, b2) === 0;
      };
      Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x2 = thisEnd - thisStart;
        var y2 = end - start;
        var len = Math.min(x2, y2);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i2 = 0; i2 < len; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x2 = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
              return asciiWrite(this, string, offset, length);
            case "latin1":
            case "binary":
              return latin1Write(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      MAX_ARGUMENTS_LENGTH = 4096;
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i2 = 0; i2 < sliceLen; ++i2) {
            newBuf[i2] = this[i2 + start];
          }
        }
        return newBuf;
      };
      Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength3, this.length);
        }
        var val = this[offset + --byteLength3];
        var mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength3] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        var i2 = byteLength3;
        var mul = 1;
        var val = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754read(this, offset, false, 52, 8);
      };
      Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        var mul = 1;
        var i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        var i2 = byteLength3 - 1;
        var mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i2 = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i2 = byteLength3 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i2;
        if (this === target && start < targetStart && targetStart < end) {
          for (i2 = len - 1; i2 >= 0; --i2) {
            target[i2 + targetStart] = this[i2 + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i2 = 0; i2 < len; ++i2) {
            target[i2 + targetStart] = this[i2 + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i2;
        if (typeof val === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
          var len = bytes.length;
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes[i2 % len];
          }
        }
        return this;
      };
      INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
    }
  });

  // ../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js
  var init_buffer = __esm({
    "../node_modules/wrangler/node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js"() {
      init_Buffer();
    }
  });

  // wrangler-modules-watch:wrangler:modules-watch
  var init_wrangler_modules_watch = __esm({
    "wrangler-modules-watch:wrangler:modules-watch"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
    }
  });

  // ../node_modules/wrangler/templates/modules-watch-stub.js
  var init_modules_watch_stub = __esm({
    "../node_modules/wrangler/templates/modules-watch-stub.js"() {
      init_wrangler_modules_watch();
    }
  });

  // ../node_modules/wrangler/templates/middleware/common.ts
  function __facade_register__(...args) {
    __facade_middleware__.push(...args.flat());
  }
  function __facade_registerInternal__(...args) {
    __facade_middleware__.unshift(...args.flat());
  }
  function __facade_invokeChain__(request, env3, ctx, dispatch, middlewareChain) {
    const [head, ...tail] = middlewareChain;
    const middlewareCtx = {
      dispatch,
      next(newRequest, newEnv) {
        return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
      }
    };
    return head(request, env3, ctx, middlewareCtx);
  }
  function __facade_invoke__(request, env3, ctx, dispatch, finalMiddleware) {
    return __facade_invokeChain__(request, env3, ctx, dispatch, [
      ...__facade_middleware__,
      finalMiddleware
    ]);
  }
  var __facade_middleware__;
  var init_common = __esm({
    "../node_modules/wrangler/templates/middleware/common.ts"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      __facade_middleware__ = [];
    }
  });

  // ../node_modules/wrangler/templates/middleware/loader-sw.ts
  function __facade_isSpecialEvent__(type2) {
    return type2 === "fetch" || type2 === "scheduled";
  }
  var __FACADE_EVENT_TARGET__, __facade__originalAddEventListener__, __facade__originalRemoveEventListener__, __facade__originalDispatchEvent__, __facade_waitUntil__, __facade_response__, __facade_dispatched__, __Facade_ExtendableEvent__, __Facade_FetchEvent__, __Facade_ScheduledEvent__;
  var init_loader_sw = __esm({
    "../node_modules/wrangler/templates/middleware/loader-sw.ts"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_common();
      if (globalThis.MINIFLARE) {
        __FACADE_EVENT_TARGET__ = new (Object.getPrototypeOf(WorkerGlobalScope))();
      } else {
        __FACADE_EVENT_TARGET__ = new EventTarget();
      }
      __facade__originalAddEventListener__ = globalThis.addEventListener;
      __facade__originalRemoveEventListener__ = globalThis.removeEventListener;
      __facade__originalDispatchEvent__ = globalThis.dispatchEvent;
      globalThis.addEventListener = function(type2, listener, options) {
        if (__facade_isSpecialEvent__(type2)) {
          __FACADE_EVENT_TARGET__.addEventListener(
            type2,
            listener,
            options
          );
        } else {
          __facade__originalAddEventListener__(type2, listener, options);
        }
      };
      globalThis.removeEventListener = function(type2, listener, options) {
        if (__facade_isSpecialEvent__(type2)) {
          __FACADE_EVENT_TARGET__.removeEventListener(
            type2,
            listener,
            options
          );
        } else {
          __facade__originalRemoveEventListener__(type2, listener, options);
        }
      };
      globalThis.dispatchEvent = function(event) {
        if (__facade_isSpecialEvent__(event.type)) {
          return __FACADE_EVENT_TARGET__.dispatchEvent(event);
        } else {
          return __facade__originalDispatchEvent__(event);
        }
      };
      globalThis.addMiddleware = __facade_register__;
      globalThis.addMiddlewareInternal = __facade_registerInternal__;
      __facade_waitUntil__ = Symbol("__facade_waitUntil__");
      __facade_response__ = Symbol("__facade_response__");
      __facade_dispatched__ = Symbol("__facade_dispatched__");
      __Facade_ExtendableEvent__ = class extends Event {
        [__facade_waitUntil__] = [];
        waitUntil(promise) {
          if (!(this instanceof __Facade_ExtendableEvent__)) {
            throw new TypeError("Illegal invocation");
          }
          this[__facade_waitUntil__].push(promise);
        }
      };
      __Facade_FetchEvent__ = class extends __Facade_ExtendableEvent__ {
        #request;
        #passThroughOnException;
        [__facade_response__];
        [__facade_dispatched__] = false;
        constructor(type2, init3) {
          super(type2);
          this.#request = init3.request;
          this.#passThroughOnException = init3.passThroughOnException;
        }
        get request() {
          return this.#request;
        }
        respondWith(response) {
          if (!(this instanceof __Facade_FetchEvent__)) {
            throw new TypeError("Illegal invocation");
          }
          if (this[__facade_response__] !== void 0) {
            throw new DOMException(
              "FetchEvent.respondWith() has already been called; it can only be called once.",
              "InvalidStateError"
            );
          }
          if (this[__facade_dispatched__]) {
            throw new DOMException(
              "Too late to call FetchEvent.respondWith(). It must be called synchronously in the event handler.",
              "InvalidStateError"
            );
          }
          this.stopImmediatePropagation();
          this[__facade_response__] = response;
        }
        passThroughOnException() {
          if (!(this instanceof __Facade_FetchEvent__)) {
            throw new TypeError("Illegal invocation");
          }
          this.#passThroughOnException();
        }
      };
      __Facade_ScheduledEvent__ = class extends __Facade_ExtendableEvent__ {
        #scheduledTime;
        #cron;
        #noRetry;
        constructor(type2, init3) {
          super(type2);
          this.#scheduledTime = init3.scheduledTime;
          this.#cron = init3.cron;
          this.#noRetry = init3.noRetry;
        }
        get scheduledTime() {
          return this.#scheduledTime;
        }
        get cron() {
          return this.#cron;
        }
        noRetry() {
          if (!(this instanceof __Facade_ScheduledEvent__)) {
            throw new TypeError("Illegal invocation");
          }
          this.#noRetry();
        }
      };
      __facade__originalAddEventListener__("fetch", (event) => {
        const ctx = {
          waitUntil: event.waitUntil.bind(event),
          passThroughOnException: event.passThroughOnException.bind(event)
        };
        const __facade_sw_dispatch__ = function(type2, init3) {
          if (type2 === "scheduled") {
            const facadeEvent = new __Facade_ScheduledEvent__("scheduled", {
              scheduledTime: Date.now(),
              cron: init3.cron ?? "",
              noRetry() {
              }
            });
            __FACADE_EVENT_TARGET__.dispatchEvent(facadeEvent);
            event.waitUntil(Promise.all(facadeEvent[__facade_waitUntil__]));
          }
        };
        const __facade_sw_fetch__ = function(request, _env, ctx2) {
          const facadeEvent = new __Facade_FetchEvent__("fetch", {
            request,
            passThroughOnException: ctx2.passThroughOnException
          });
          __FACADE_EVENT_TARGET__.dispatchEvent(facadeEvent);
          facadeEvent[__facade_dispatched__] = true;
          event.waitUntil(Promise.all(facadeEvent[__facade_waitUntil__]));
          const response = facadeEvent[__facade_response__];
          if (response === void 0) {
            throw new Error("No response!");
          }
          return response;
        };
        event.respondWith(
          __facade_invoke__(
            event.request,
            globalThis,
            ctx,
            __facade_sw_dispatch__,
            __facade_sw_fetch__
          )
        );
      });
      __facade__originalAddEventListener__("scheduled", (event) => {
        const facadeEvent = new __Facade_ScheduledEvent__("scheduled", {
          scheduledTime: event.scheduledTime,
          cron: event.cron,
          noRetry: event.noRetry.bind(event)
        });
        __FACADE_EVENT_TARGET__.dispatchEvent(facadeEvent);
        event.waitUntil(Promise.all(facadeEvent[__facade_waitUntil__]));
      });
    }
  });

  // ../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
  function reduceError(e8) {
    return {
      name: e8?.name,
      message: e8?.message ?? String(e8),
      stack: e8?.stack,
      cause: e8?.cause === void 0 ? void 0 : reduceError(e8.cause)
    };
  }
  var jsonError, middleware_miniflare3_json_error_default;
  var init_middleware_miniflare3_json_error = __esm({
    "../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      jsonError = async (request, env3, _ctx, middlewareCtx) => {
        try {
          return await middlewareCtx.next(request, env3);
        } catch (e8) {
          const error = reduceError(e8);
          return Response.json(error, {
            status: 500,
            headers: { "MF-Experimental-Error-Stack": "true" }
          });
        }
      };
      middleware_miniflare3_json_error_default = jsonError;
    }
  });

  // src/.wrangler/tmp/bundle-1lsW9v/middleware-insertion-facade.js
  var init_middleware_insertion_facade = __esm({
    "src/.wrangler/tmp/bundle-1lsW9v/middleware-insertion-facade.js"() {
      init_loader_sw();
      init_middleware_miniflare3_json_error();
      __facade_registerInternal__([middleware_miniflare3_json_error_default]);
    }
  });

  // ../node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "../node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once4) {
        this.fn = fn;
        this.context = context;
        this.once = once4 || false;
      }
      function addListener4(emitter, event, fn, context, once4) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once4), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter3() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter3.prototype.eventNames = function eventNames2() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter3.prototype.listeners = function listeners2(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l = handlers.length, ee = new Array(l); i2 < l; i2++) {
          ee[i2] = handlers[i2].fn;
        }
        return ee;
      };
      EventEmitter3.prototype.listenerCount = function listenerCount3(event) {
        var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
        if (!listeners2)
          return 0;
        if (listeners2.fn)
          return 1;
        return listeners2.length;
      };
      EventEmitter3.prototype.emit = function emit4(event, a1, a22, a32, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners2 = this._events[evt], len = arguments.length, args, i2;
        if (listeners2.fn) {
          if (listeners2.once)
            this.removeListener(event, listeners2.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners2.fn.call(listeners2.context), true;
            case 2:
              return listeners2.fn.call(listeners2.context, a1), true;
            case 3:
              return listeners2.fn.call(listeners2.context, a1, a22), true;
            case 4:
              return listeners2.fn.call(listeners2.context, a1, a22, a32), true;
            case 5:
              return listeners2.fn.call(listeners2.context, a1, a22, a32, a4), true;
            case 6:
              return listeners2.fn.call(listeners2.context, a1, a22, a32, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners2.fn.apply(listeners2.context, args);
        } else {
          var length = listeners2.length, j;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners2[i2].once)
              this.removeListener(event, listeners2[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners2[i2].fn.call(listeners2[i2].context);
                break;
              case 2:
                listeners2[i2].fn.call(listeners2[i2].context, a1);
                break;
              case 3:
                listeners2[i2].fn.call(listeners2[i2].context, a1, a22);
                break;
              case 4:
                listeners2[i2].fn.call(listeners2[i2].context, a1, a22, a32);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners2[i2].fn.apply(listeners2[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter3.prototype.on = function on3(event, fn, context) {
        return addListener4(this, event, fn, context, false);
      };
      EventEmitter3.prototype.once = function once4(event, fn, context) {
        return addListener4(this, event, fn, context, true);
      };
      EventEmitter3.prototype.removeListener = function removeListener4(event, fn, context, once4) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners2 = this._events[evt];
        if (listeners2.fn) {
          if (listeners2.fn === fn && (!once4 || listeners2.once) && (!context || listeners2.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length = listeners2.length; i2 < length; i2++) {
            if (listeners2[i2].fn !== fn || once4 && !listeners2[i2].once || context && listeners2[i2].context !== context) {
              events.push(listeners2[i2]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter3.prototype.removeAllListeners = function removeAllListeners4(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
      EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
      EventEmitter3.prefixed = prefix;
      EventEmitter3.EventEmitter = EventEmitter3;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter3;
      }
    }
  });

  // ../node_modules/@sinclair/typebox/value/guard.js
  var require_guard = __commonJS({
    "../node_modules/@sinclair/typebox/value/guard.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IsValueType = exports.IsSymbol = exports.IsFunction = exports.IsString = exports.IsBigInt = exports.IsInteger = exports.IsNumber = exports.IsBoolean = exports.IsNull = exports.IsUndefined = exports.IsArray = exports.IsObject = exports.IsPlainObject = exports.HasPropertyKey = exports.IsDate = exports.IsUint8Array = exports.IsPromise = exports.IsTypedArray = exports.IsIterator = exports.IsAsyncIterator = void 0;
      function IsAsyncIterator(value) {
        return IsObject(value) && Symbol.asyncIterator in value;
      }
      exports.IsAsyncIterator = IsAsyncIterator;
      function IsIterator(value) {
        return IsObject(value) && Symbol.iterator in value;
      }
      exports.IsIterator = IsIterator;
      function IsTypedArray(value) {
        return ArrayBuffer.isView(value);
      }
      exports.IsTypedArray = IsTypedArray;
      function IsPromise(value) {
        return value instanceof Promise;
      }
      exports.IsPromise = IsPromise;
      function IsUint8Array(value) {
        return value instanceof Uint8Array;
      }
      exports.IsUint8Array = IsUint8Array;
      function IsDate(value) {
        return value instanceof Date && Number.isFinite(value.getTime());
      }
      exports.IsDate = IsDate;
      function HasPropertyKey(value, key) {
        return key in value;
      }
      exports.HasPropertyKey = HasPropertyKey;
      function IsPlainObject(value) {
        return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
      }
      exports.IsPlainObject = IsPlainObject;
      function IsObject(value) {
        return value !== null && typeof value === "object";
      }
      exports.IsObject = IsObject;
      function IsArray(value) {
        return Array.isArray(value) && !ArrayBuffer.isView(value);
      }
      exports.IsArray = IsArray;
      function IsUndefined(value) {
        return value === void 0;
      }
      exports.IsUndefined = IsUndefined;
      function IsNull(value) {
        return value === null;
      }
      exports.IsNull = IsNull;
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      exports.IsBoolean = IsBoolean;
      function IsNumber(value) {
        return typeof value === "number";
      }
      exports.IsNumber = IsNumber;
      function IsInteger(value) {
        return IsNumber(value) && Number.isInteger(value);
      }
      exports.IsInteger = IsInteger;
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      exports.IsBigInt = IsBigInt;
      function IsString(value) {
        return typeof value === "string";
      }
      exports.IsString = IsString;
      function IsFunction(value) {
        return typeof value === "function";
      }
      exports.IsFunction = IsFunction;
      function IsSymbol(value) {
        return typeof value === "symbol";
      }
      exports.IsSymbol = IsSymbol;
      function IsValueType(value) {
        return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
      }
      exports.IsValueType = IsValueType;
    }
  });

  // ../node_modules/@sinclair/typebox/typebox.js
  var require_typebox = __commonJS({
    "../node_modules/@sinclair/typebox/typebox.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = void 0;
      exports.Transform = Symbol.for("TypeBox.Transform");
      exports.Readonly = Symbol.for("TypeBox.Readonly");
      exports.Optional = Symbol.for("TypeBox.Optional");
      exports.Hint = Symbol.for("TypeBox.Hint");
      exports.Kind = Symbol.for("TypeBox.Kind");
      exports.PatternBoolean = "(true|false)";
      exports.PatternNumber = "(0|[1-9][0-9]*)";
      exports.PatternString = "(.*)";
      exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
      exports.PatternNumberExact = `^${exports.PatternNumber}$`;
      exports.PatternStringExact = `^${exports.PatternString}$`;
      var TypeRegistry;
      (function(TypeRegistry2) {
        const map = /* @__PURE__ */ new Map();
        function Entries() {
          return new Map(map);
        }
        TypeRegistry2.Entries = Entries;
        function Clear() {
          return map.clear();
        }
        TypeRegistry2.Clear = Clear;
        function Delete(kind) {
          return map.delete(kind);
        }
        TypeRegistry2.Delete = Delete;
        function Has(kind) {
          return map.has(kind);
        }
        TypeRegistry2.Has = Has;
        function Set2(kind, func) {
          map.set(kind, func);
        }
        TypeRegistry2.Set = Set2;
        function Get(kind) {
          return map.get(kind);
        }
        TypeRegistry2.Get = Get;
      })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
      var TypeBoxError = class extends Error {
        constructor(message) {
          super(message);
        }
      };
      exports.TypeBoxError = TypeBoxError;
      var FormatRegistry;
      (function(FormatRegistry2) {
        const map = /* @__PURE__ */ new Map();
        function Entries() {
          return new Map(map);
        }
        FormatRegistry2.Entries = Entries;
        function Clear() {
          return map.clear();
        }
        FormatRegistry2.Clear = Clear;
        function Delete(format2) {
          return map.delete(format2);
        }
        FormatRegistry2.Delete = Delete;
        function Has(format2) {
          return map.has(format2);
        }
        FormatRegistry2.Has = Has;
        function Set2(format2, func) {
          map.set(format2, func);
        }
        FormatRegistry2.Set = Set2;
        function Get(format2) {
          return map.get(format2);
        }
        FormatRegistry2.Get = Get;
      })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
      var ValueGuard;
      (function(ValueGuard2) {
        function IsArray(value) {
          return Array.isArray(value);
        }
        ValueGuard2.IsArray = IsArray;
        function IsBigInt(value) {
          return typeof value === "bigint";
        }
        ValueGuard2.IsBigInt = IsBigInt;
        function IsBoolean(value) {
          return typeof value === "boolean";
        }
        ValueGuard2.IsBoolean = IsBoolean;
        function IsNull(value) {
          return value === null;
        }
        ValueGuard2.IsNull = IsNull;
        function IsNumber(value) {
          return typeof value === "number";
        }
        ValueGuard2.IsNumber = IsNumber;
        function IsObject(value) {
          return typeof value === "object" && value !== null;
        }
        ValueGuard2.IsObject = IsObject;
        function IsString(value) {
          return typeof value === "string";
        }
        ValueGuard2.IsString = IsString;
        function IsUndefined(value) {
          return value === void 0;
        }
        ValueGuard2.IsUndefined = IsUndefined;
      })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));
      var TypeGuardUnknownTypeError = class extends TypeBoxError {
      };
      exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
      var TypeGuard;
      (function(TypeGuard2) {
        function IsPattern(value) {
          try {
            new RegExp(value);
            return true;
          } catch {
            return false;
          }
        }
        function IsControlCharacterFree(value) {
          if (!ValueGuard.IsString(value))
            return false;
          for (let i2 = 0; i2 < value.length; i2++) {
            const code = value.charCodeAt(i2);
            if (code >= 7 && code <= 13 || code === 27 || code === 127) {
              return false;
            }
          }
          return true;
        }
        function IsAdditionalProperties(value) {
          return IsOptionalBoolean(value) || TSchema(value);
        }
        function IsOptionalBigInt(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
        }
        function IsOptionalNumber(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
        }
        function IsOptionalBoolean(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
        }
        function IsOptionalString(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
        }
        function IsOptionalPattern(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
        }
        function IsOptionalFormat(value) {
          return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
        }
        function IsOptionalSchema(value) {
          return ValueGuard.IsUndefined(value) || TSchema(value);
        }
        function TAny(schema) {
          return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
        }
        TypeGuard2.TAny = TAny;
        function TArray(schema) {
          return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
        }
        TypeGuard2.TArray = TArray;
        function TAsyncIterator(schema) {
          return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
        }
        TypeGuard2.TAsyncIterator = TAsyncIterator;
        function TBigInt(schema) {
          return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);
        }
        TypeGuard2.TBigInt = TBigInt;
        function TBoolean(schema) {
          return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TBoolean = TBoolean;
        function TConstructor(schema) {
          return TKindOf(schema, "Constructor") && schema.type === "Constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
        }
        TypeGuard2.TConstructor = TConstructor;
        function TDate(schema) {
          return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);
        }
        TypeGuard2.TDate = TDate;
        function TFunction(schema) {
          return TKindOf(schema, "Function") && schema.type === "Function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
        }
        TypeGuard2.TFunction = TFunction;
        function TInteger(schema) {
          return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
        }
        TypeGuard2.TInteger = TInteger;
        function TIntersect(schema) {
          return TKindOf(schema, "Intersect") && (ValueGuard.IsString(schema.type) && schema.type !== "object" ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every((schema2) => TSchema(schema2) && !TTransform(schema2)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);
        }
        TypeGuard2.TIntersect = TIntersect;
        function TIterator(schema) {
          return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
        }
        TypeGuard2.TIterator = TIterator;
        function TKindOf(schema, kind) {
          return TKind(schema) && schema[exports.Kind] === kind;
        }
        TypeGuard2.TKindOf = TKindOf;
        function TKind(schema) {
          return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);
        }
        TypeGuard2.TKind = TKind;
        function TLiteralString(schema) {
          return TLiteral(schema) && ValueGuard.IsString(schema.const);
        }
        TypeGuard2.TLiteralString = TLiteralString;
        function TLiteralNumber(schema) {
          return TLiteral(schema) && ValueGuard.IsNumber(schema.const);
        }
        TypeGuard2.TLiteralNumber = TLiteralNumber;
        function TLiteralBoolean(schema) {
          return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);
        }
        TypeGuard2.TLiteralBoolean = TLiteralBoolean;
        function TLiteral(schema) {
          return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
        }
        TypeGuard2.TLiteral = TLiteral;
        function TNever(schema) {
          return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
        }
        TypeGuard2.TNever = TNever;
        function TNot(schema) {
          return TKindOf(schema, "Not") && TSchema(schema.not);
        }
        TypeGuard2.TNot = TNot;
        function TNull(schema) {
          return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TNull = TNull;
        function TNumber(schema) {
          return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
        }
        TypeGuard2.TNumber = TNumber;
        function TObject(schema) {
          return TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema2]) => IsControlCharacterFree(key) && TSchema(schema2));
        }
        TypeGuard2.TObject = TObject;
        function TPromise(schema) {
          return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
        }
        TypeGuard2.TPromise = TPromise;
        function TRecord(schema) {
          return TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && ((schema2) => {
            const keys2 = Object.getOwnPropertyNames(schema2.patternProperties);
            return keys2.length === 1 && IsPattern(keys2[0]) && ValueGuard.IsObject(schema2.patternProperties) && TSchema(schema2.patternProperties[keys2[0]]);
          })(schema);
        }
        TypeGuard2.TRecord = TRecord;
        function TRecursive(schema) {
          return ValueGuard.IsObject(schema) && exports.Hint in schema && schema[exports.Hint] === "Recursive";
        }
        TypeGuard2.TRecursive = TRecursive;
        function TRef(schema) {
          return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
        }
        TypeGuard2.TRef = TRef;
        function TString(schema) {
          return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
        }
        TypeGuard2.TString = TString;
        function TSymbol(schema) {
          return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TSymbol = TSymbol;
        function TTemplateLiteral(schema) {
          return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
        }
        TypeGuard2.TTemplateLiteral = TTemplateLiteral;
        function TThis(schema) {
          return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
        }
        TypeGuard2.TThis = TThis;
        function TTransform(schema) {
          return ValueGuard.IsObject(schema) && exports.Transform in schema;
        }
        TypeGuard2.TTransform = TTransform;
        function TTuple(schema) {
          return TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && // empty
          (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every((schema2) => TSchema(schema2)));
        }
        TypeGuard2.TTuple = TTuple;
        function TUndefined(schema) {
          return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TUndefined = TUndefined;
        function TUnionLiteral(schema) {
          return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
        }
        TypeGuard2.TUnionLiteral = TUnionLiteral;
        function TUnion(schema) {
          return TKindOf(schema, "Union") && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every((schema2) => TSchema(schema2));
        }
        TypeGuard2.TUnion = TUnion;
        function TUint8Array(schema) {
          return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
        }
        TypeGuard2.TUint8Array = TUint8Array;
        function TUnknown(schema) {
          return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
        }
        TypeGuard2.TUnknown = TUnknown;
        function TUnsafe(schema) {
          return TKindOf(schema, "Unsafe");
        }
        TypeGuard2.TUnsafe = TUnsafe;
        function TVoid(schema) {
          return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
        }
        TypeGuard2.TVoid = TVoid;
        function TReadonly(schema) {
          return ValueGuard.IsObject(schema) && schema[exports.Readonly] === "Readonly";
        }
        TypeGuard2.TReadonly = TReadonly;
        function TOptional(schema) {
          return ValueGuard.IsObject(schema) && schema[exports.Optional] === "Optional";
        }
        TypeGuard2.TOptional = TOptional;
        function TSchema(schema) {
          return ValueGuard.IsObject(schema) && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TAsyncIterator(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TIterator(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));
        }
        TypeGuard2.TSchema = TSchema;
      })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
      var ExtendsUndefined;
      (function(ExtendsUndefined2) {
        function Check(schema) {
          return schema[exports.Kind] === "Intersect" ? schema.allOf.every((schema2) => Check(schema2)) : schema[exports.Kind] === "Union" ? schema.anyOf.some((schema2) => Check(schema2)) : schema[exports.Kind] === "Undefined" ? true : schema[exports.Kind] === "Not" ? !Check(schema.not) : false;
        }
        ExtendsUndefined2.Check = Check;
      })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
      var TypeExtendsError = class extends TypeBoxError {
      };
      exports.TypeExtendsError = TypeExtendsError;
      var TypeExtendsResult;
      (function(TypeExtendsResult2) {
        TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
        TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
        TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
      })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
      var TypeExtends;
      (function(TypeExtends2) {
        function IntoBooleanResult(result) {
          return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
        }
        function Throw(message) {
          throw new TypeExtendsError(message);
        }
        function IsStructuralRight(right) {
          return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
        }
        function StructuralRight(left, right) {
          return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : Throw("StructuralRight");
        }
        function TAnyRight(left, right) {
          return TypeExtendsResult.True;
        }
        function TAny(left, right) {
          return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
        }
        function TArrayRight(left, right) {
          return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TArray(left, right) {
          return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
        }
        function TAsyncIterator(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
        }
        function TBigInt(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TBooleanRight(left, right) {
          return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TBoolean(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TConstructor(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
        }
        function TDate(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TFunction(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
        }
        function TIntegerRight(left, right) {
          return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TInteger(left, right) {
          return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
        }
        function TIntersectRight(left, right) {
          return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TIntersect(left, right) {
          return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TIterator(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
        }
        function TLiteral(left, right) {
          return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeExtendsResult.False;
        }
        function TNeverRight(left, right) {
          return TypeExtendsResult.False;
        }
        function TNever(left, right) {
          return TypeExtendsResult.True;
        }
        function UnwrapTNot(schema) {
          let [current, depth] = [schema, 0];
          while (true) {
            if (!TypeGuard.TNot(current))
              break;
            current = current.not;
            depth += 1;
          }
          return depth % 2 === 0 ? current : exports.Type.Unknown();
        }
        function TNot(left, right) {
          return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
        }
        function TNull(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TNumberRight(left, right) {
          return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TNumber(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function IsObjectPropertyCount(schema, count) {
          return Object.getOwnPropertyNames(schema.properties).length === count;
        }
        function IsObjectStringLike(schema) {
          return IsObjectArrayLike(schema);
        }
        function IsObjectSymbolLike(schema) {
          return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
        }
        function IsObjectNumberLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectBooleanLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectBigIntLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectDateLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectUint8ArrayLike(schema) {
          return IsObjectArrayLike(schema);
        }
        function IsObjectFunctionLike(schema) {
          const length = exports.Type.Number();
          return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
        }
        function IsObjectConstructorLike(schema) {
          return IsObjectPropertyCount(schema, 0);
        }
        function IsObjectArrayLike(schema) {
          const length = exports.Type.Number();
          return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
        }
        function IsObjectPromiseLike(schema) {
          const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
          return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
        }
        function Property(left, right) {
          return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
        }
        function TObjectRight(left, right) {
          return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
            return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
          })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
          })() : TypeExtendsResult.False;
        }
        function TObject(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
            for (const key of Object.getOwnPropertyNames(right.properties)) {
              if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {
                return TypeExtendsResult.False;
              }
              if (TypeGuard.TOptional(right.properties[key])) {
                return TypeExtendsResult.True;
              }
              if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
                return TypeExtendsResult.False;
              }
            }
            return TypeExtendsResult.True;
          })();
        }
        function TPromise(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
        }
        function RecordKey(schema) {
          return exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() : exports.PatternStringExact in schema.patternProperties ? exports.Type.String() : Throw("Unknown record key pattern");
        }
        function RecordValue(schema) {
          return exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] : exports.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports.PatternStringExact] : Throw("Unable to get record value schema");
        }
        function TRecordRight(left, right) {
          const [Key, Value] = [RecordKey(right), RecordValue(right)];
          return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TObject(left) ? (() => {
            for (const key of Object.getOwnPropertyNames(left.properties)) {
              if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
                return TypeExtendsResult.False;
              }
            }
            return TypeExtendsResult.True;
          })() : TypeExtendsResult.False;
        }
        function TRecord(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
        }
        function TStringRight(left, right) {
          return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TString(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TSymbol(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TTemplateLiteral(left, right) {
          return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
        }
        function IsArrayOfTuple(left, right) {
          return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
        }
        function TTupleRight(left, right) {
          return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
        }
        function TTuple(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUint8Array(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUndefined(left, right) {
          return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUnionRight(left, right) {
          return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUnion(left, right) {
          return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TUnknownRight(left, right) {
          return TypeExtendsResult.True;
        }
        function TUnknown(left, right) {
          return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function VoidRight(left, right) {
          return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function TVoid(left, right) {
          return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        function Visit(left, right) {
          return (
            // resolvable
            TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) : (
              // standard
              TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever(left, right) : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`)
            )
          );
        }
        function Extends(left, right) {
          return Visit(left, right);
        }
        TypeExtends2.Extends = Extends;
      })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
      var TypeClone;
      (function(TypeClone2) {
        function ObjectType(value) {
          const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
          const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
          return { ...clonedProperties, ...clonedSymbols };
        }
        function ArrayType(value) {
          return value.map((value2) => Visit(value2));
        }
        function Visit(value) {
          return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
        }
        function Rest(schemas) {
          return schemas.map((schema) => Type(schema));
        }
        TypeClone2.Rest = Rest;
        function Type(schema, options = {}) {
          return { ...Visit(schema), ...options };
        }
        TypeClone2.Type = Type;
      })(TypeClone || (exports.TypeClone = TypeClone = {}));
      var IndexedAccessor;
      (function(IndexedAccessor2) {
        function OptionalUnwrap(schema) {
          return schema.map((schema2) => {
            const { [exports.Optional]: _, ...clone } = TypeClone.Type(schema2);
            return clone;
          });
        }
        function IsIntersectOptional(schema) {
          return schema.every((schema2) => TypeGuard.TOptional(schema2));
        }
        function IsUnionOptional(schema) {
          return schema.some((schema2) => TypeGuard.TOptional(schema2));
        }
        function ResolveIntersect(schema) {
          return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
        }
        function ResolveUnion(schema) {
          return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
        }
        function ResolveOptional(schema) {
          return schema[exports.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports.Kind] === "Union" ? ResolveUnion(schema) : schema;
        }
        function TIntersect(schema, key) {
          const resolved = schema.allOf.reduce((acc, schema2) => {
            const indexed = Visit(schema2, key);
            return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
          }, []);
          return ResolveOptional(exports.Type.Intersect(resolved));
        }
        function TUnion(schema, key) {
          const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
          return ResolveOptional(exports.Type.Union(resolved));
        }
        function TObject(schema, key) {
          const property = schema.properties[key];
          return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
        }
        function TTuple(schema, key) {
          const items = schema.items;
          if (ValueGuard.IsUndefined(items))
            return exports.Type.Never();
          const element = items[key];
          if (ValueGuard.IsUndefined(element))
            return exports.Type.Never();
          return element;
        }
        function Visit(schema, key) {
          return schema[exports.Kind] === "Intersect" ? TIntersect(schema, key) : schema[exports.Kind] === "Union" ? TUnion(schema, key) : schema[exports.Kind] === "Object" ? TObject(schema, key) : schema[exports.Kind] === "Tuple" ? TTuple(schema, key) : exports.Type.Never();
        }
        function Resolve(schema, keys2, options = {}) {
          const resolved = keys2.map((key) => Visit(schema, key.toString()));
          return ResolveOptional(exports.Type.Union(resolved, options));
        }
        IndexedAccessor2.Resolve = Resolve;
      })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
      var Intrinsic;
      (function(Intrinsic2) {
        function Uncapitalize(value) {
          const [first, rest] = [value.slice(0, 1), value.slice(1)];
          return `${first.toLowerCase()}${rest}`;
        }
        function Capitalize(value) {
          const [first, rest] = [value.slice(0, 1), value.slice(1)];
          return `${first.toUpperCase()}${rest}`;
        }
        function Uppercase(value) {
          return value.toUpperCase();
        }
        function Lowercase(value) {
          return value.toLowerCase();
        }
        function IntrinsicTemplateLiteral(schema, mode) {
          const expression = TemplateLiteralParser.ParseExact(schema.pattern);
          const finite = TemplateLiteralFinite.Check(expression);
          if (!finite)
            return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
          const strings = [...TemplateLiteralGenerator.Generate(expression)];
          const literals = strings.map((value) => exports.Type.Literal(value));
          const mapped = IntrinsicRest(literals, mode);
          const union = exports.Type.Union(mapped);
          return exports.Type.TemplateLiteral([union]);
        }
        function IntrinsicLiteral(value, mode) {
          return typeof value === "string" ? mode === "Uncapitalize" ? Uncapitalize(value) : mode === "Capitalize" ? Capitalize(value) : mode === "Uppercase" ? Uppercase(value) : mode === "Lowercase" ? Lowercase(value) : value : value.toString();
        }
        function IntrinsicRest(schema, mode) {
          if (schema.length === 0)
            return [];
          const [L, ...R] = schema;
          return [Map2(L, mode), ...IntrinsicRest(R, mode)];
        }
        function Visit(schema, mode) {
          return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;
        }
        function Map2(schema, mode) {
          return Visit(schema, mode);
        }
        Intrinsic2.Map = Map2;
      })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
      var ObjectMap;
      (function(ObjectMap2) {
        function TIntersect(schema, callback) {
          return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
        }
        function TUnion(schema, callback) {
          return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
        }
        function TObject(schema, callback) {
          return callback(schema);
        }
        function Visit(schema, callback) {
          return schema[exports.Kind] === "Intersect" ? TIntersect(schema, callback) : schema[exports.Kind] === "Union" ? TUnion(schema, callback) : schema[exports.Kind] === "Object" ? TObject(schema, callback) : schema;
        }
        function Map2(schema, callback, options) {
          return { ...Visit(TypeClone.Type(schema), callback), ...options };
        }
        ObjectMap2.Map = Map2;
      })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
      var KeyResolver;
      (function(KeyResolver2) {
        function UnwrapPattern(key) {
          return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
        }
        function TIntersect(schema, options) {
          return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
        }
        function TUnion(schema, options) {
          const sets = schema.anyOf.map((inner) => Visit(inner, options));
          return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
        }
        function TObject(schema, options) {
          return Object.getOwnPropertyNames(schema.properties);
        }
        function TRecord(schema, options) {
          return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
        }
        function Visit(schema, options) {
          return TypeGuard.TIntersect(schema) ? TIntersect(schema, options) : TypeGuard.TUnion(schema) ? TUnion(schema, options) : TypeGuard.TObject(schema) ? TObject(schema, options) : TypeGuard.TRecord(schema) ? TRecord(schema, options) : [];
        }
        function ResolveKeys(schema, options) {
          return [...new Set(Visit(schema, options))];
        }
        KeyResolver2.ResolveKeys = ResolveKeys;
        function ResolvePattern(schema) {
          const keys2 = ResolveKeys(schema, { includePatterns: true });
          const pattern = keys2.map((key) => `(${UnwrapPattern(key)})`);
          return `^(${pattern.join("|")})$`;
        }
        KeyResolver2.ResolvePattern = ResolvePattern;
      })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
      var KeyArrayResolverError = class extends TypeBoxError {
      };
      exports.KeyArrayResolverError = KeyArrayResolverError;
      var KeyArrayResolver;
      (function(KeyArrayResolver2) {
        function Resolve(schema) {
          return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema2) => schema2.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {
            const expression = TemplateLiteralParser.ParseExact(schema.pattern);
            if (!TemplateLiteralFinite.Check(expression))
              throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
            return [...TemplateLiteralGenerator.Generate(expression)];
          })() : [];
        }
        KeyArrayResolver2.Resolve = Resolve;
      })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
      var UnionResolver;
      (function(UnionResolver2) {
        function* TUnion(union) {
          for (const schema of union.anyOf) {
            if (schema[exports.Kind] === "Union") {
              yield* TUnion(schema);
            } else {
              yield schema;
            }
          }
        }
        function Resolve(union) {
          return exports.Type.Union([...TUnion(union)], { ...union });
        }
        UnionResolver2.Resolve = Resolve;
      })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
      var TemplateLiteralPatternError = class extends TypeBoxError {
      };
      exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
      var TemplateLiteralPattern;
      (function(TemplateLiteralPattern2) {
        function Throw(message) {
          throw new TemplateLiteralPatternError(message);
        }
        function Escape(value) {
          return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function Visit(schema, acc) {
          return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports.Kind]}'`);
        }
        function Create(kinds) {
          return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
        }
        TemplateLiteralPattern2.Create = Create;
      })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
      var TemplateLiteralResolver;
      (function(TemplateLiteralResolver2) {
        function Resolve(template) {
          const expression = TemplateLiteralParser.ParseExact(template.pattern);
          if (!TemplateLiteralFinite.Check(expression))
            return exports.Type.String();
          const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
          return exports.Type.Union(literals);
        }
        TemplateLiteralResolver2.Resolve = Resolve;
      })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
      var TemplateLiteralParserError = class extends TypeBoxError {
      };
      exports.TemplateLiteralParserError = TemplateLiteralParserError;
      var TemplateLiteralParser;
      (function(TemplateLiteralParser2) {
        function IsNonEscaped(pattern, index, char) {
          return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
        }
        function IsOpenParen(pattern, index) {
          return IsNonEscaped(pattern, index, "(");
        }
        function IsCloseParen(pattern, index) {
          return IsNonEscaped(pattern, index, ")");
        }
        function IsSeparator(pattern, index) {
          return IsNonEscaped(pattern, index, "|");
        }
        function IsGroup(pattern) {
          if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
            return false;
          let count = 0;
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
              count += 1;
            if (IsCloseParen(pattern, index))
              count -= 1;
            if (count === 0 && index !== pattern.length - 1)
              return false;
          }
          return true;
        }
        function InGroup(pattern) {
          return pattern.slice(1, pattern.length - 1);
        }
        function IsPrecedenceOr(pattern) {
          let count = 0;
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
              count += 1;
            if (IsCloseParen(pattern, index))
              count -= 1;
            if (IsSeparator(pattern, index) && count === 0)
              return true;
          }
          return false;
        }
        function IsPrecedenceAnd(pattern) {
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
              return true;
          }
          return false;
        }
        function Or(pattern) {
          let [count, start] = [0, 0];
          const expressions = [];
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
              count += 1;
            if (IsCloseParen(pattern, index))
              count -= 1;
            if (IsSeparator(pattern, index) && count === 0) {
              const range2 = pattern.slice(start, index);
              if (range2.length > 0)
                expressions.push(Parse(range2));
              start = index + 1;
            }
          }
          const range = pattern.slice(start);
          if (range.length > 0)
            expressions.push(Parse(range));
          if (expressions.length === 0)
            return { type: "const", const: "" };
          if (expressions.length === 1)
            return expressions[0];
          return { type: "or", expr: expressions };
        }
        function And(pattern) {
          function Group(value, index) {
            if (!IsOpenParen(value, index))
              throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
            let count = 0;
            for (let scan = index; scan < value.length; scan++) {
              if (IsOpenParen(value, scan))
                count += 1;
              if (IsCloseParen(value, scan))
                count -= 1;
              if (count === 0)
                return [index, scan];
            }
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
          }
          function Range(pattern2, index) {
            for (let scan = index; scan < pattern2.length; scan++) {
              if (IsOpenParen(pattern2, scan))
                return [index, scan];
            }
            return [index, pattern2.length];
          }
          const expressions = [];
          for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index)) {
              const [start, end] = Group(pattern, index);
              const range = pattern.slice(start, end + 1);
              expressions.push(Parse(range));
              index = end;
            } else {
              const [start, end] = Range(pattern, index);
              const range = pattern.slice(start, end);
              if (range.length > 0)
                expressions.push(Parse(range));
              index = end - 1;
            }
          }
          return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
        }
        function Parse(pattern) {
          return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
        }
        TemplateLiteralParser2.Parse = Parse;
        function ParseExact(pattern) {
          return Parse(pattern.slice(1, pattern.length - 1));
        }
        TemplateLiteralParser2.ParseExact = ParseExact;
      })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
      var TemplateLiteralFiniteError = class extends TypeBoxError {
      };
      exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
      var TemplateLiteralFinite;
      (function(TemplateLiteralFinite2) {
        function Throw(message) {
          throw new TemplateLiteralFiniteError(message);
        }
        function IsNumber(expression) {
          return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
        }
        function IsBoolean(expression) {
          return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
        }
        function IsString(expression) {
          return expression.type === "const" && expression.const === ".*";
        }
        function Check(expression) {
          return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
        }
        TemplateLiteralFinite2.Check = Check;
      })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
      var TemplateLiteralGeneratorError = class extends TypeBoxError {
      };
      exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
      var TemplateLiteralGenerator;
      (function(TemplateLiteralGenerator2) {
        function* Reduce(buffer) {
          if (buffer.length === 1)
            return yield* buffer[0];
          for (const left of buffer[0]) {
            for (const right of Reduce(buffer.slice(1))) {
              yield `${left}${right}`;
            }
          }
        }
        function* And(expression) {
          return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
        }
        function* Or(expression) {
          for (const expr of expression.expr)
            yield* Generate(expr);
        }
        function* Const(expression) {
          return yield expression.const;
        }
        function* Generate(expression) {
          return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
            throw new TemplateLiteralGeneratorError("Unknown expression");
          })();
        }
        TemplateLiteralGenerator2.Generate = Generate;
      })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
      var TemplateLiteralDslParser;
      (function(TemplateLiteralDslParser2) {
        function* ParseUnion(template) {
          const trim2 = template.trim().replace(/"|'/g, "");
          return trim2 === "boolean" ? yield exports.Type.Boolean() : trim2 === "number" ? yield exports.Type.Number() : trim2 === "bigint" ? yield exports.Type.BigInt() : trim2 === "string" ? yield exports.Type.String() : yield (() => {
            const literals = trim2.split("|").map((literal) => exports.Type.Literal(literal.trim()));
            return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
          })();
        }
        function* ParseTerminal(template) {
          if (template[1] !== "{") {
            const L = exports.Type.Literal("$");
            const R = ParseLiteral(template.slice(1));
            return yield* [L, ...R];
          }
          for (let i2 = 2; i2 < template.length; i2++) {
            if (template[i2] === "}") {
              const L = ParseUnion(template.slice(2, i2));
              const R = ParseLiteral(template.slice(i2 + 1));
              return yield* [...L, ...R];
            }
          }
          yield exports.Type.Literal(template);
        }
        function* ParseLiteral(template) {
          for (let i2 = 0; i2 < template.length; i2++) {
            if (template[i2] === "$") {
              const L = exports.Type.Literal(template.slice(0, i2));
              const R = ParseTerminal(template.slice(i2));
              return yield* [L, ...R];
            }
          }
          yield exports.Type.Literal(template);
        }
        function Parse(template_dsl) {
          return [...ParseLiteral(template_dsl)];
        }
        TemplateLiteralDslParser2.Parse = Parse;
      })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
      var TransformDecodeBuilder = class {
        constructor(schema) {
          this.schema = schema;
        }
        Decode(decode) {
          return new TransformEncodeBuilder(this.schema, decode);
        }
      };
      exports.TransformDecodeBuilder = TransformDecodeBuilder;
      var TransformEncodeBuilder = class {
        constructor(schema, decode) {
          this.schema = schema;
          this.decode = decode;
        }
        Encode(encode3) {
          const schema = TypeClone.Type(this.schema);
          return TypeGuard.TTransform(schema) ? (() => {
            const Encode = (value) => schema[exports.Transform].Encode(encode3(value));
            const Decode = (value) => this.decode(schema[exports.Transform].Decode(value));
            const Codec = { Encode, Decode };
            return { ...schema, [exports.Transform]: Codec };
          })() : (() => {
            const Codec = { Decode: this.decode, Encode: encode3 };
            return { ...schema, [exports.Transform]: Codec };
          })();
        }
      };
      exports.TransformEncodeBuilder = TransformEncodeBuilder;
      var TypeOrdinal = 0;
      var TypeBuilderError = class extends TypeBoxError {
      };
      exports.TypeBuilderError = TypeBuilderError;
      var TypeBuilder = class {
        /** `[Internal]` Creates a schema without `static` and `params` types */
        Create(schema) {
          return schema;
        }
        /** `[Internal]` Throws a TypeBuilder error with the given message */
        Throw(message) {
          throw new TypeBuilderError(message);
        }
        /** `[Internal]` Discards property keys from the given record type */
        Discard(record, keys2) {
          return keys2.reduce((acc, key) => {
            const { [key]: _, ...rest } = acc;
            return rest;
          }, record);
        }
        /** `[Json]` Omits compositing symbols from this schema */
        Strict(schema) {
          return JSON.parse(JSON.stringify(schema));
        }
      };
      exports.TypeBuilder = TypeBuilder;
      var JsonTypeBuilder = class extends TypeBuilder {
        // ------------------------------------------------------------------------
        // Modifiers
        // ------------------------------------------------------------------------
        /** `[Json]` Creates a Readonly and Optional property */
        ReadonlyOptional(schema) {
          return this.Readonly(this.Optional(schema));
        }
        /** `[Json]` Creates a Readonly property */
        Readonly(schema) {
          return { ...TypeClone.Type(schema), [exports.Readonly]: "Readonly" };
        }
        /** `[Json]` Creates an Optional property */
        Optional(schema) {
          return { ...TypeClone.Type(schema), [exports.Optional]: "Optional" };
        }
        // ------------------------------------------------------------------------
        // Types
        // ------------------------------------------------------------------------
        /** `[Json]` Creates an Any type */
        Any(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Any" });
        }
        /** `[Json]` Creates an Array type */
        Array(schema, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Type(schema) });
        }
        /** `[Json]` Creates a Boolean type */
        Boolean(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
        }
        /** `[Json]` Intrinsic function to Capitalize LiteralString types */
        Capitalize(schema, options = {}) {
          return { ...Intrinsic.Map(TypeClone.Type(schema), "Capitalize"), ...options };
        }
        /** `[Json]` Creates a Composite object type */
        Composite(objects, options) {
          const intersect = exports.Type.Intersect(objects, {});
          const keys2 = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
          const properties = keys2.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
          return exports.Type.Object(properties, options);
        }
        /** `[Json]` Creates a Enum type */
        Enum(item, options = {}) {
          if (ValueGuard.IsUndefined(item))
            return this.Throw("Enum undefined or empty");
          const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
          const values2 = [...new Set(values1)];
          const anyOf = values2.map((value) => exports.Type.Literal(value));
          return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
        }
        /** `[Json]` Creates a Conditional type */
        Extends(left, right, trueType, falseType, options = {}) {
          switch (TypeExtends.Extends(left, right)) {
            case TypeExtendsResult.Union:
              return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
            case TypeExtendsResult.True:
              return TypeClone.Type(trueType, options);
            case TypeExtendsResult.False:
              return TypeClone.Type(falseType, options);
          }
        }
        /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
        Exclude(unionType2, excludedMembers, options = {}) {
          return TypeGuard.TTemplateLiteral(unionType2) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType2), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType2, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType2) ? (() => {
            const narrowed = unionType2.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
            return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
          })() : TypeExtends.Extends(unionType2, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType2, options);
        }
        /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
        Extract(type2, union, options = {}) {
          return TypeGuard.TTemplateLiteral(type2) ? this.Extract(TemplateLiteralResolver.Resolve(type2), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type2, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type2) ? (() => {
            const narrowed = type2.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
            return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
          })() : TypeExtends.Extends(type2, union) !== TypeExtendsResult.False ? TypeClone.Type(type2, options) : this.Never(options);
        }
        /** `[Json]` Returns an Indexed property type for the given keys */
        Index(schema, unresolved, options = {}) {
          return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {
            return TypeClone.Type(schema.items, options);
          })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {
            const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
            const cloned = items.map((schema2) => TypeClone.Type(schema2));
            return this.Union(cloned, options);
          })() : (() => {
            const keys2 = KeyArrayResolver.Resolve(unresolved);
            const clone = TypeClone.Type(schema);
            return IndexedAccessor.Resolve(clone, keys2, options);
          })();
        }
        /** `[Json]` Creates an Integer type */
        Integer(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
        }
        /** `[Json]` Creates an Intersect type */
        Intersect(allOf, options = {}) {
          if (allOf.length === 0)
            return exports.Type.Never();
          if (allOf.length === 1)
            return TypeClone.Type(allOf[0], options);
          if (allOf.some((schema) => TypeGuard.TTransform(schema)))
            this.Throw("Cannot intersect transform types");
          const objects = allOf.every((schema) => TypeGuard.TObject(schema));
          const cloned = TypeClone.Rest(allOf);
          const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
          return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
        }
        /** `[Json]` Creates a KeyOf type */
        KeyOf(schema, options = {}) {
          return TypeGuard.TRecord(schema) ? (() => {
            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
            return pattern === exports.PatternNumberExact ? this.Number(options) : pattern === exports.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
          })() : TypeGuard.TTuple(schema) ? (() => {
            const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
            const literals = items.map((_, index) => exports.Type.Literal(index.toString()));
            return this.Union(literals, options);
          })() : TypeGuard.TArray(schema) ? (() => {
            return this.Number(options);
          })() : (() => {
            const keys2 = KeyResolver.ResolveKeys(schema, { includePatterns: false });
            if (keys2.length === 0)
              return this.Never(options);
            const literals = keys2.map((key) => this.Literal(key));
            return this.Union(literals, options);
          })();
        }
        /** `[Json]` Creates a Literal type */
        Literal(value, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
        }
        /** `[Json]` Intrinsic function to Lowercase LiteralString types */
        Lowercase(schema, options = {}) {
          return { ...Intrinsic.Map(TypeClone.Type(schema), "Lowercase"), ...options };
        }
        /** `[Json]` Creates a Never type */
        Never(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
        }
        /** `[Json]` Creates a Not type */
        Not(schema, options) {
          return this.Create({ ...options, [exports.Kind]: "Not", not: TypeClone.Type(schema) });
        }
        /** `[Json]` Creates a Null type */
        Null(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
        }
        /** `[Json]` Creates a Number type */
        Number(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
        }
        /** `[Json]` Creates an Object type */
        Object(properties, options = {}) {
          const propertyKeys = Object.getOwnPropertyNames(properties);
          const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
          const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
          const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
          const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
          return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
        }
        /** `[Json]` Constructs a type whose keys are omitted from the given type */
        Omit(schema, unresolved, options = {}) {
          const keys2 = KeyArrayResolver.Resolve(unresolved);
          return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
            if (ValueGuard.IsArray(object.required)) {
              object.required = object.required.filter((key) => !keys2.includes(key));
              if (object.required.length === 0)
                delete object.required;
            }
            for (const key of Object.getOwnPropertyNames(object.properties)) {
              if (keys2.includes(key))
                delete object.properties[key];
            }
            return this.Create(object);
          }, options);
        }
        /** `[Json]` Constructs a type where all properties are optional */
        Partial(schema, options = {}) {
          return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
              return { ...acc, [key]: this.Optional(object.properties[key]) };
            }, {});
            return this.Object(
              properties,
              this.Discard(object, ["required"])
              /* object used as options to retain other constraints */
            );
          }, options);
        }
        /** `[Json]` Constructs a type whose keys are picked from the given type */
        Pick(schema, unresolved, options = {}) {
          const keys2 = KeyArrayResolver.Resolve(unresolved);
          return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
            if (ValueGuard.IsArray(object.required)) {
              object.required = object.required.filter((key) => keys2.includes(key));
              if (object.required.length === 0)
                delete object.required;
            }
            for (const key of Object.getOwnPropertyNames(object.properties)) {
              if (!keys2.includes(key))
                delete object.properties[key];
            }
            return this.Create(object);
          }, options);
        }
        /** `[Json]` Creates a Record type */
        Record(key, schema, options = {}) {
          return TypeGuard.TTemplateLiteral(key) ? (() => {
            const expression = TemplateLiteralParser.ParseExact(key.pattern);
            return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema) } });
          })() : TypeGuard.TUnion(key) ? (() => {
            const union = UnionResolver.Resolve(key);
            if (TypeGuard.TUnionLiteral(union)) {
              const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});
              return this.Object(properties, { ...options, [exports.Hint]: "Record" });
            } else
              this.Throw("Record key of type union contains non-literal types");
          })() : TypeGuard.TLiteral(key) ? (() => {
            return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema) }, options) : this.Throw("Record key of type literal is not of type string or number");
          })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
            return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema) } });
          })() : TypeGuard.TString(key) ? (() => {
            const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
            return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Type(schema) } });
          })() : this.Never();
        }
        /** `[Json]` Creates a Recursive type */
        Recursive(callback, options = {}) {
          if (ValueGuard.IsUndefined(options.$id))
            options.$id = `T${TypeOrdinal++}`;
          const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
          thisType.$id = options.$id;
          return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
        }
        /** `[Json]` Creates a Ref type. */
        Ref(unresolved, options = {}) {
          if (ValueGuard.IsString(unresolved))
            return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved });
          if (ValueGuard.IsUndefined(unresolved.$id))
            this.Throw("Reference target type must specify an $id");
          return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved.$id });
        }
        /** `[Json]` Constructs a type where all properties are required */
        Required(schema, options = {}) {
          return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
              return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };
            }, {});
            return this.Object(
              properties,
              object
              /* object used as options to retain other constraints  */
            );
          }, options);
        }
        /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
        Rest(schema) {
          return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];
        }
        /** `[Json]` Creates a String type */
        String(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
        }
        /** `[Json]` Creates a TemplateLiteral type */
        TemplateLiteral(unresolved, options = {}) {
          const pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
          return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
        }
        /** `[Json]` Creates a Transform type */
        Transform(schema) {
          return new TransformDecodeBuilder(schema);
        }
        /** `[Json]` Creates a Tuple type */
        Tuple(items, options = {}) {
          const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
          const clonedItems = TypeClone.Rest(items);
          const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
          return this.Create(schema);
        }
        /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
        Uncapitalize(schema, options = {}) {
          return { ...Intrinsic.Map(TypeClone.Type(schema), "Uncapitalize"), ...options };
        }
        /** `[Json]` Creates a Union type */
        Union(union, options = {}) {
          return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
            const anyOf = union;
            if (anyOf.length === 0)
              return this.Never(options);
            if (anyOf.length === 1)
              return this.Create(TypeClone.Type(anyOf[0], options));
            const clonedAnyOf = TypeClone.Rest(anyOf);
            return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
          })();
        }
        /** `[Json]` Creates an Unknown type */
        Unknown(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Unknown" });
        }
        /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
        Unsafe(options = {}) {
          return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
        }
        /** `[Json]` Intrinsic function to Uppercase LiteralString types */
        Uppercase(schema, options = {}) {
          return { ...Intrinsic.Map(TypeClone.Type(schema), "Uppercase"), ...options };
        }
      };
      exports.JsonTypeBuilder = JsonTypeBuilder;
      var JavaScriptTypeBuilder = class extends JsonTypeBuilder {
        /** `[JavaScript]` Creates a AsyncIterator type */
        AsyncIterator(items, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
        }
        /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
        Awaited(schema, options = {}) {
          const Unwrap = (rest) => rest.length > 0 ? (() => {
            const [L, ...R] = rest;
            return [this.Awaited(L), ...Unwrap(R)];
          })() : rest;
          return TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);
        }
        /** `[JavaScript]` Creates a BigInt type */
        BigInt(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "BigInt", type: "bigint" });
        }
        /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
        ConstructorParameters(schema, options = {}) {
          return this.Tuple([...schema.parameters], { ...options });
        }
        /** `[JavaScript]` Creates a Constructor type */
        Constructor(parameters, returns, options) {
          const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
          return this.Create({ ...options, [exports.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
        }
        /** `[JavaScript]` Creates a Date type */
        Date(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Date", type: "Date" });
        }
        /** `[JavaScript]` Creates a Function type */
        Function(parameters, returns, options) {
          const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
          return this.Create({ ...options, [exports.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
        }
        /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
        InstanceType(schema, options = {}) {
          return TypeClone.Type(schema.returns, options);
        }
        /** `[JavaScript]` Creates an Iterator type */
        Iterator(items, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
        }
        /** `[JavaScript]` Extracts the Parameters from the given Function type */
        Parameters(schema, options = {}) {
          return this.Tuple(schema.parameters, { ...options });
        }
        /** `[JavaScript]` Creates a Promise type */
        Promise(item, options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
        }
        /** `[Extended]` Creates a String type */
        RegExp(unresolved, options = {}) {
          const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
          return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern });
        }
        /**
         * @deprecated Use `Type.RegExp`
         */
        RegEx(regex, options = {}) {
          return this.RegExp(regex, options);
        }
        /** `[JavaScript]` Extracts the ReturnType from the given Function type */
        ReturnType(schema, options = {}) {
          return TypeClone.Type(schema.returns, options);
        }
        /** `[JavaScript]` Creates a Symbol type */
        Symbol(options) {
          return this.Create({ ...options, [exports.Kind]: "Symbol", type: "symbol" });
        }
        /** `[JavaScript]` Creates a Undefined type */
        Undefined(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Undefined", type: "undefined" });
        }
        /** `[JavaScript]` Creates a Uint8Array type */
        Uint8Array(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "Uint8Array" });
        }
        /** `[JavaScript]` Creates a Void type */
        Void(options = {}) {
          return this.Create({ ...options, [exports.Kind]: "Void", type: "void" });
        }
      };
      exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
      exports.JsonType = new JsonTypeBuilder();
      exports.Type = new JavaScriptTypeBuilder();
    }
  });

  // ../node_modules/@sinclair/typebox/system/system.js
  var require_system = __commonJS({
    "../node_modules/@sinclair/typebox/system/system.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultErrorFunction = exports.TypeSystemPolicy = exports.TypeSystemErrorFunction = exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;
      var guard_1 = require_guard();
      var errors_1 = require_errors();
      var Types2 = require_typebox();
      var TypeSystemDuplicateTypeKind = class extends Types2.TypeBoxError {
        constructor(kind) {
          super(`Duplicate type kind '${kind}' detected`);
        }
      };
      exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
      var TypeSystemDuplicateFormat = class extends Types2.TypeBoxError {
        constructor(kind) {
          super(`Duplicate string format '${kind}' detected`);
        }
      };
      exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
      var TypeSystem;
      (function(TypeSystem2) {
        function Type(kind, check) {
          if (Types2.TypeRegistry.Has(kind))
            throw new TypeSystemDuplicateTypeKind(kind);
          Types2.TypeRegistry.Set(kind, check);
          return (options = {}) => Types2.Type.Unsafe({ ...options, [Types2.Kind]: kind });
        }
        TypeSystem2.Type = Type;
        function Format(format2, check) {
          if (Types2.FormatRegistry.Has(format2))
            throw new TypeSystemDuplicateFormat(format2);
          Types2.FormatRegistry.Set(format2, check);
          return format2;
        }
        TypeSystem2.Format = Format;
      })(TypeSystem || (exports.TypeSystem = TypeSystem = {}));
      var TypeSystemErrorFunction;
      (function(TypeSystemErrorFunction2) {
        let errorMessageFunction = DefaultErrorFunction;
        function Reset() {
          errorMessageFunction = DefaultErrorFunction;
        }
        TypeSystemErrorFunction2.Reset = Reset;
        function Set2(callback) {
          errorMessageFunction = callback;
        }
        TypeSystemErrorFunction2.Set = Set2;
        function Get() {
          return errorMessageFunction;
        }
        TypeSystemErrorFunction2.Get = Get;
      })(TypeSystemErrorFunction || (exports.TypeSystemErrorFunction = TypeSystemErrorFunction = {}));
      var TypeSystemPolicy;
      (function(TypeSystemPolicy2) {
        TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
        TypeSystemPolicy2.AllowArrayObject = false;
        TypeSystemPolicy2.AllowNaN = false;
        TypeSystemPolicy2.AllowNullVoid = false;
        function IsExactOptionalProperty(value, key) {
          return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
        }
        TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
        function IsObjectLike(value) {
          const isObject4 = (0, guard_1.IsObject)(value);
          return TypeSystemPolicy2.AllowArrayObject ? isObject4 : isObject4 && !(0, guard_1.IsArray)(value);
        }
        TypeSystemPolicy2.IsObjectLike = IsObjectLike;
        function IsRecordLike(value) {
          return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
        }
        TypeSystemPolicy2.IsRecordLike = IsRecordLike;
        function IsNumberLike(value) {
          const isNumber3 = (0, guard_1.IsNumber)(value);
          return TypeSystemPolicy2.AllowNaN ? isNumber3 : isNumber3 && Number.isFinite(value);
        }
        TypeSystemPolicy2.IsNumberLike = IsNumberLike;
        function IsVoidLike(value) {
          const isUndefined3 = (0, guard_1.IsUndefined)(value);
          return TypeSystemPolicy2.AllowNullVoid ? isUndefined3 || value === null : isUndefined3;
        }
        TypeSystemPolicy2.IsVoidLike = IsVoidLike;
      })(TypeSystemPolicy || (exports.TypeSystemPolicy = TypeSystemPolicy = {}));
      function DefaultErrorFunction(schema, errorType) {
        switch (errorType) {
          case errors_1.ValueErrorType.ArrayContains:
            return "Expected array to contain at least one matching value";
          case errors_1.ValueErrorType.ArrayMaxContains:
            return `Expected array to contain no more than ${schema.maxContains} matching values`;
          case errors_1.ValueErrorType.ArrayMinContains:
            return `Expected array to contain at least ${schema.minContains} matching values`;
          case errors_1.ValueErrorType.ArrayMaxItems:
            return `Expected array length to be less or equal to ${schema.maxItems}`;
          case errors_1.ValueErrorType.ArrayMinItems:
            return `Expected array length to be greater or equal to ${schema.minItems}`;
          case errors_1.ValueErrorType.ArrayUniqueItems:
            return "Expected array elements to be unique";
          case errors_1.ValueErrorType.Array:
            return "Expected array";
          case errors_1.ValueErrorType.AsyncIterator:
            return "Expected AsyncIterator";
          case errors_1.ValueErrorType.BigIntExclusiveMaximum:
            return `Expected bigint to be less than ${schema.exclusiveMaximum}`;
          case errors_1.ValueErrorType.BigIntExclusiveMinimum:
            return `Expected bigint to be greater than ${schema.exclusiveMinimum}`;
          case errors_1.ValueErrorType.BigIntMaximum:
            return `Expected bigint to be less or equal to ${schema.maximum}`;
          case errors_1.ValueErrorType.BigIntMinimum:
            return `Expected bigint to be greater or equal to ${schema.minimum}`;
          case errors_1.ValueErrorType.BigIntMultipleOf:
            return `Expected bigint to be a multiple of ${schema.multipleOf}`;
          case errors_1.ValueErrorType.BigInt:
            return "Expected bigint";
          case errors_1.ValueErrorType.Boolean:
            return "Expected boolean";
          case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
            return `Expected Date timestamp to be greater than ${schema.exclusiveMinimumTimestamp}`;
          case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
            return `Expected Date timestamp to be less than ${schema.exclusiveMaximumTimestamp}`;
          case errors_1.ValueErrorType.DateMinimumTimestamp:
            return `Expected Date timestamp to be greater or equal to ${schema.minimumTimestamp}`;
          case errors_1.ValueErrorType.DateMaximumTimestamp:
            return `Expected Date timestamp to be less or equal to ${schema.maximumTimestamp}`;
          case errors_1.ValueErrorType.DateMultipleOfTimestamp:
            return `Expected Date timestamp to be a multiple of ${schema.multipleOfTimestamp}`;
          case errors_1.ValueErrorType.Date:
            return "Expected Date";
          case errors_1.ValueErrorType.Function:
            return "Expected function";
          case errors_1.ValueErrorType.IntegerExclusiveMaximum:
            return `Expected integer to be less than ${schema.exclusiveMaximum}`;
          case errors_1.ValueErrorType.IntegerExclusiveMinimum:
            return `Expected integer to be greater than ${schema.exclusiveMinimum}`;
          case errors_1.ValueErrorType.IntegerMaximum:
            return `Expected integer to be less or equal to ${schema.maximum}`;
          case errors_1.ValueErrorType.IntegerMinimum:
            return `Expected integer to be greater or equal to ${schema.minimum}`;
          case errors_1.ValueErrorType.IntegerMultipleOf:
            return `Expected integer to be a multiple of ${schema.multipleOf}`;
          case errors_1.ValueErrorType.Integer:
            return "Expected integer";
          case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
            return "Unexpected property";
          case errors_1.ValueErrorType.Intersect:
            return "Expected all values to match";
          case errors_1.ValueErrorType.Iterator:
            return "Expected Iterator";
          case errors_1.ValueErrorType.Literal:
            return `Expected ${typeof schema.const === "string" ? `'${schema.const}'` : schema.const}`;
          case errors_1.ValueErrorType.Never:
            return "Never";
          case errors_1.ValueErrorType.Not:
            return "Value should not match";
          case errors_1.ValueErrorType.Null:
            return "Expected null";
          case errors_1.ValueErrorType.NumberExclusiveMaximum:
            return `Expected number to be less than ${schema.exclusiveMaximum}`;
          case errors_1.ValueErrorType.NumberExclusiveMinimum:
            return `Expected number to be greater than ${schema.exclusiveMinimum}`;
          case errors_1.ValueErrorType.NumberMaximum:
            return `Expected number to be less or equal to ${schema.maximum}`;
          case errors_1.ValueErrorType.NumberMinimum:
            return `Expected number to be greater or equal to ${schema.minimum}`;
          case errors_1.ValueErrorType.NumberMultipleOf:
            return `Expected number to be a multiple of ${schema.multipleOf}`;
          case errors_1.ValueErrorType.Number:
            return "Expected number";
          case errors_1.ValueErrorType.Object:
            return "Expected object";
          case errors_1.ValueErrorType.ObjectAdditionalProperties:
            return "Unexpected property";
          case errors_1.ValueErrorType.ObjectMaxProperties:
            return `Expected object to have no more than ${schema.maxProperties} properties`;
          case errors_1.ValueErrorType.ObjectMinProperties:
            return `Expected object to have at least ${schema.minProperties} properties`;
          case errors_1.ValueErrorType.ObjectRequiredProperty:
            return "Required property";
          case errors_1.ValueErrorType.Promise:
            return "Expected Promise";
          case errors_1.ValueErrorType.StringFormatUnknown:
            return `Unknown format '${schema.format}'`;
          case errors_1.ValueErrorType.StringFormat:
            return `Expected string to match '${schema.format}' format`;
          case errors_1.ValueErrorType.StringMaxLength:
            return `Expected string length less or equal to ${schema.maxLength}`;
          case errors_1.ValueErrorType.StringMinLength:
            return `Expected string length greater or equal to ${schema.minLength}`;
          case errors_1.ValueErrorType.StringPattern:
            return `Expected string to match '${schema.pattern}'`;
          case errors_1.ValueErrorType.String:
            return "Expected string";
          case errors_1.ValueErrorType.Symbol:
            return "Expected symbol";
          case errors_1.ValueErrorType.TupleLength:
            return `Expected tuple to have ${schema.maxItems || 0} elements`;
          case errors_1.ValueErrorType.Tuple:
            return "Expected tuple";
          case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
            return `Expected byte length less or equal to ${schema.maxByteLength}`;
          case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
            return `Expected byte length greater or equal to ${schema.minByteLength}`;
          case errors_1.ValueErrorType.Uint8Array:
            return "Expected Uint8Array";
          case errors_1.ValueErrorType.Undefined:
            return "Expected undefined";
          case errors_1.ValueErrorType.Union:
            return "Expected union value";
          case errors_1.ValueErrorType.Void:
            return "Expected void";
          case errors_1.ValueErrorType.Kind:
            return `Expected kind '${schema[Types2.Kind]}'`;
          default:
            return "Unknown error type";
        }
      }
      exports.DefaultErrorFunction = DefaultErrorFunction;
    }
  });

  // ../node_modules/@sinclair/typebox/value/deref.js
  var require_deref = __commonJS({
    "../node_modules/@sinclair/typebox/value/deref.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Deref = exports.TypeDereferenceError = void 0;
      var typebox_1 = require_typebox();
      var TypeDereferenceError = class extends typebox_1.TypeBoxError {
        constructor(schema) {
          super(`Unable to dereference schema with $id '${schema.$id}'`);
          this.schema = schema;
        }
      };
      exports.TypeDereferenceError = TypeDereferenceError;
      function Deref(schema, references) {
        const index = references.findIndex((target) => target.$id === schema.$ref);
        if (index === -1)
          throw new TypeDereferenceError(schema);
        return references[index];
      }
      exports.Deref = Deref;
    }
  });

  // ../node_modules/@sinclair/typebox/value/hash.js
  var require_hash = __commonJS({
    "../node_modules/@sinclair/typebox/value/hash.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Hash = exports.ByteMarker = exports.ValueHashError = void 0;
      var guard_1 = require_guard();
      var ValueHashError = class extends Error {
        constructor(value) {
          super(`Unable to hash value`);
          this.value = value;
        }
      };
      exports.ValueHashError = ValueHashError;
      var ByteMarker;
      (function(ByteMarker2) {
        ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
        ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
        ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
        ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
        ByteMarker2[ByteMarker2["String"] = 4] = "String";
        ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
        ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
        ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
        ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
        ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
        ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
      })(ByteMarker || (exports.ByteMarker = ByteMarker = {}));
      var Accumulator = BigInt("14695981039346656037");
      var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
      var Bytes = Array.from({ length: 256 }).map((_, i2) => BigInt(i2));
      var F64 = new Float64Array(1);
      var F64In = new DataView(F64.buffer);
      var F64Out = new Uint8Array(F64.buffer);
      function* NumberToBytes(value) {
        const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
        for (let i2 = 0; i2 < byteCount; i2++) {
          yield value >> 8 * (byteCount - 1 - i2) & 255;
        }
      }
      function ArrayType(value) {
        FNV1A64(ByteMarker.Array);
        for (const item of value) {
          Visit(item);
        }
      }
      function BooleanType(value) {
        FNV1A64(ByteMarker.Boolean);
        FNV1A64(value ? 1 : 0);
      }
      function BigIntType(value) {
        FNV1A64(ByteMarker.BigInt);
        F64In.setBigInt64(0, value);
        for (const byte of F64Out) {
          FNV1A64(byte);
        }
      }
      function DateType(value) {
        FNV1A64(ByteMarker.Date);
        Visit(value.getTime());
      }
      function NullType(value) {
        FNV1A64(ByteMarker.Null);
      }
      function NumberType(value) {
        FNV1A64(ByteMarker.Number);
        F64In.setFloat64(0, value);
        for (const byte of F64Out) {
          FNV1A64(byte);
        }
      }
      function ObjectType(value) {
        FNV1A64(ByteMarker.Object);
        for (const key of globalThis.Object.keys(value).sort()) {
          Visit(key);
          Visit(value[key]);
        }
      }
      function StringType(value) {
        FNV1A64(ByteMarker.String);
        for (let i2 = 0; i2 < value.length; i2++) {
          for (const byte of NumberToBytes(value.charCodeAt(i2))) {
            FNV1A64(byte);
          }
        }
      }
      function SymbolType(value) {
        FNV1A64(ByteMarker.Symbol);
        Visit(value.description);
      }
      function Uint8ArrayType(value) {
        FNV1A64(ByteMarker.Uint8Array);
        for (let i2 = 0; i2 < value.length; i2++) {
          FNV1A64(value[i2]);
        }
      }
      function UndefinedType(value) {
        return FNV1A64(ByteMarker.Undefined);
      }
      function Visit(value) {
        if ((0, guard_1.IsArray)(value))
          return ArrayType(value);
        if ((0, guard_1.IsBoolean)(value))
          return BooleanType(value);
        if ((0, guard_1.IsBigInt)(value))
          return BigIntType(value);
        if ((0, guard_1.IsDate)(value))
          return DateType(value);
        if ((0, guard_1.IsNull)(value))
          return NullType(value);
        if ((0, guard_1.IsNumber)(value))
          return NumberType(value);
        if ((0, guard_1.IsPlainObject)(value))
          return ObjectType(value);
        if ((0, guard_1.IsString)(value))
          return StringType(value);
        if ((0, guard_1.IsSymbol)(value))
          return SymbolType(value);
        if ((0, guard_1.IsUint8Array)(value))
          return Uint8ArrayType(value);
        if ((0, guard_1.IsUndefined)(value))
          return UndefinedType(value);
        throw new ValueHashError(value);
      }
      function FNV1A64(byte) {
        Accumulator = Accumulator ^ Bytes[byte];
        Accumulator = Accumulator * Prime % Size;
      }
      function Hash(value) {
        Accumulator = BigInt("14695981039346656037");
        Visit(value);
        return Accumulator;
      }
      exports.Hash = Hash;
    }
  });

  // ../node_modules/@sinclair/typebox/errors/errors.js
  var require_errors = __commonJS({
    "../node_modules/@sinclair/typebox/errors/errors.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Errors = exports.ValueErrorIterator = exports.EscapeKey = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;
      var guard_1 = require_guard();
      var system_1 = require_system();
      var deref_1 = require_deref();
      var hash_1 = require_hash();
      var Types2 = require_typebox();
      var ValueErrorType;
      (function(ValueErrorType2) {
        ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
        ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
        ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
        ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
        ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
        ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
        ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
        ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
        ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
        ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
        ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
        ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
        ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
        ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
        ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
        ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
        ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
        ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
        ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
        ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
        ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
        ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
        ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
        ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
        ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
        ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
        ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
        ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
        ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
        ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
        ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
        ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
        ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
        ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
        ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
        ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
        ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
        ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
        ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
        ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
        ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
        ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
        ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
        ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
        ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
        ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
        ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
        ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
        ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 48] = "StringFormatUnknown";
        ValueErrorType2[ValueErrorType2["StringFormat"] = 49] = "StringFormat";
        ValueErrorType2[ValueErrorType2["StringMaxLength"] = 50] = "StringMaxLength";
        ValueErrorType2[ValueErrorType2["StringMinLength"] = 51] = "StringMinLength";
        ValueErrorType2[ValueErrorType2["StringPattern"] = 52] = "StringPattern";
        ValueErrorType2[ValueErrorType2["String"] = 53] = "String";
        ValueErrorType2[ValueErrorType2["Symbol"] = 54] = "Symbol";
        ValueErrorType2[ValueErrorType2["TupleLength"] = 55] = "TupleLength";
        ValueErrorType2[ValueErrorType2["Tuple"] = 56] = "Tuple";
        ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 57] = "Uint8ArrayMaxByteLength";
        ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 58] = "Uint8ArrayMinByteLength";
        ValueErrorType2[ValueErrorType2["Uint8Array"] = 59] = "Uint8Array";
        ValueErrorType2[ValueErrorType2["Undefined"] = 60] = "Undefined";
        ValueErrorType2[ValueErrorType2["Union"] = 61] = "Union";
        ValueErrorType2[ValueErrorType2["Void"] = 62] = "Void";
      })(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));
      var ValueErrorsUnknownTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Unknown type");
          this.schema = schema;
        }
      };
      exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
      function EscapeKey(key) {
        return key.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      exports.EscapeKey = EscapeKey;
      function IsDefined(value) {
        return value !== void 0;
      }
      var ValueErrorIterator = class {
        constructor(iterator) {
          this.iterator = iterator;
        }
        [Symbol.iterator]() {
          return this.iterator;
        }
        /** Returns the first value error or undefined if no errors */
        First() {
          const next = this.iterator.next();
          return next.done ? void 0 : next.value;
        }
      };
      exports.ValueErrorIterator = ValueErrorIterator;
      function Create(type2, schema, path, value) {
        return { type: type2, schema, path, value, message: system_1.TypeSystemErrorFunction.Get()(schema, type2) };
      }
      function* TAny(schema, references, path, value) {
      }
      function* TArray(schema, references, path, value) {
        if (!(0, guard_1.IsArray)(value)) {
          return yield Create(ValueErrorType.Array, schema, path, value);
        }
        if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
          yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
        }
        if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
          yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
        }
        for (let i2 = 0; i2 < value.length; i2++) {
          yield* Visit(schema.items, references, `${path}/${i2}`, value[i2]);
        }
        if (schema.uniqueItems === true && !function() {
          const set = /* @__PURE__ */ new Set();
          for (const element of value) {
            const hashed = (0, hash_1.Hash)(element);
            if (set.has(hashed)) {
              return false;
            } else {
              set.add(hashed);
            }
          }
          return true;
        }()) {
          yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
        }
        if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
          return;
        }
        const containsSchema = IsDefined(schema.contains) ? schema.contains : Types2.Type.Never();
        const containsCount = value.reduce((acc, value2, index) => Visit(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
        if (containsCount === 0) {
          yield Create(ValueErrorType.ArrayContains, schema, path, value);
        }
        if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
          yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
        }
        if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
          yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
        }
      }
      function* TAsyncIterator(schema, references, path, value) {
        if (!(0, guard_1.IsAsyncIterator)(value))
          yield Create(ValueErrorType.AsyncIterator, schema, path, value);
      }
      function* TBigInt(schema, references, path, value) {
        if (!(0, guard_1.IsBigInt)(value))
          return yield Create(ValueErrorType.BigInt, schema, path, value);
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
          yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
          yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
          yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
          yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
          yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
        }
      }
      function* TBoolean(schema, references, path, value) {
        if (!(0, guard_1.IsBoolean)(value))
          yield Create(ValueErrorType.Boolean, schema, path, value);
      }
      function* TConstructor(schema, references, path, value) {
        yield* Visit(schema.returns, references, path, value.prototype);
      }
      function* TDate(schema, references, path, value) {
        if (!(0, guard_1.IsDate)(value))
          return yield Create(ValueErrorType.Date, schema, path, value);
        if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
          yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
        }
        if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
          yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
        }
        if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
          yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
        }
        if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
          yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
        }
        if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
          yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
        }
      }
      function* TFunction(schema, references, path, value) {
        if (!(0, guard_1.IsFunction)(value))
          yield Create(ValueErrorType.Function, schema, path, value);
      }
      function* TInteger(schema, references, path, value) {
        if (!(0, guard_1.IsInteger)(value))
          return yield Create(ValueErrorType.Integer, schema, path, value);
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
          yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
          yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
          yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
          yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
          yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
        }
      }
      function* TIntersect(schema, references, path, value) {
        for (const inner of schema.allOf) {
          const next = Visit(inner, references, path, value).next();
          if (!next.done) {
            yield Create(ValueErrorType.Intersect, schema, path, value);
            yield next.value;
          }
        }
        if (schema.unevaluatedProperties === false) {
          const keyCheck = new RegExp(Types2.KeyResolver.ResolvePattern(schema));
          for (const valueKey of Object.getOwnPropertyNames(value)) {
            if (!keyCheck.test(valueKey)) {
              yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
            }
          }
        }
        if (typeof schema.unevaluatedProperties === "object") {
          const keyCheck = new RegExp(Types2.KeyResolver.ResolvePattern(schema));
          for (const valueKey of Object.getOwnPropertyNames(value)) {
            if (!keyCheck.test(valueKey)) {
              const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
              if (!next.done)
                yield next.value;
            }
          }
        }
      }
      function* TIterator(schema, references, path, value) {
        if (!(0, guard_1.IsIterator)(value))
          yield Create(ValueErrorType.Iterator, schema, path, value);
      }
      function* TLiteral(schema, references, path, value) {
        if (!(value === schema.const))
          yield Create(ValueErrorType.Literal, schema, path, value);
      }
      function* TNever(schema, references, path, value) {
        yield Create(ValueErrorType.Never, schema, path, value);
      }
      function* TNot(schema, references, path, value) {
        if (Visit(schema.not, references, path, value).next().done === true)
          yield Create(ValueErrorType.Not, schema, path, value);
      }
      function* TNull(schema, references, path, value) {
        if (!(0, guard_1.IsNull)(value))
          yield Create(ValueErrorType.Null, schema, path, value);
      }
      function* TNumber(schema, references, path, value) {
        if (!system_1.TypeSystemPolicy.IsNumberLike(value))
          return yield Create(ValueErrorType.Number, schema, path, value);
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
          yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
          yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
          yield Create(ValueErrorType.NumberMaximum, schema, path, value);
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
          yield Create(ValueErrorType.NumberMinimum, schema, path, value);
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
          yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
        }
      }
      function* TObject(schema, references, path, value) {
        if (!system_1.TypeSystemPolicy.IsObjectLike(value))
          return yield Create(ValueErrorType.Object, schema, path, value);
        if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
          yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
        }
        if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
          yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
        }
        const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
        const knownKeys = Object.getOwnPropertyNames(schema.properties);
        const unknownKeys = Object.getOwnPropertyNames(value);
        for (const requiredKey of requiredKeys) {
          if (unknownKeys.includes(requiredKey))
            continue;
          yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, void 0);
        }
        if (schema.additionalProperties === false) {
          for (const valueKey of unknownKeys) {
            if (!knownKeys.includes(valueKey)) {
              yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
            }
          }
        }
        if (typeof schema.additionalProperties === "object") {
          for (const valueKey of unknownKeys) {
            if (knownKeys.includes(valueKey))
              continue;
            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
          }
        }
        for (const knownKey of knownKeys) {
          const property = schema.properties[knownKey];
          if (schema.required && schema.required.includes(knownKey)) {
            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
            if (Types2.ExtendsUndefined.Check(schema) && !(knownKey in value)) {
              yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, void 0);
            }
          } else {
            if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
              yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
            }
          }
        }
      }
      function* TPromise(schema, references, path, value) {
        if (!(0, guard_1.IsPromise)(value))
          yield Create(ValueErrorType.Promise, schema, path, value);
      }
      function* TRecord(schema, references, path, value) {
        if (!system_1.TypeSystemPolicy.IsRecordLike(value))
          return yield Create(ValueErrorType.Object, schema, path, value);
        if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
          yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
        }
        if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
          yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
        }
        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
        const regex = new RegExp(patternKey);
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
          if (regex.test(propertyKey))
            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
        }
        if (typeof schema.additionalProperties === "object") {
          for (const [propertyKey, propertyValue] of Object.entries(value)) {
            if (!regex.test(propertyKey))
              yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
          }
        }
        if (schema.additionalProperties === false) {
          for (const [propertyKey, propertyValue] of Object.entries(value)) {
            if (regex.test(propertyKey))
              continue;
            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
          }
        }
      }
      function* TRef(schema, references, path, value) {
        yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);
      }
      function* TString(schema, references, path, value) {
        if (!(0, guard_1.IsString)(value))
          return yield Create(ValueErrorType.String, schema, path, value);
        if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
          yield Create(ValueErrorType.StringMinLength, schema, path, value);
        }
        if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
          yield Create(ValueErrorType.StringMaxLength, schema, path, value);
        }
        if ((0, guard_1.IsString)(schema.pattern)) {
          const regex = new RegExp(schema.pattern);
          if (!regex.test(value)) {
            yield Create(ValueErrorType.StringPattern, schema, path, value);
          }
        }
        if ((0, guard_1.IsString)(schema.format)) {
          if (!Types2.FormatRegistry.Has(schema.format)) {
            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
          } else {
            const format2 = Types2.FormatRegistry.Get(schema.format);
            if (!format2(value)) {
              yield Create(ValueErrorType.StringFormat, schema, path, value);
            }
          }
        }
      }
      function* TSymbol(schema, references, path, value) {
        if (!(0, guard_1.IsSymbol)(value))
          yield Create(ValueErrorType.Symbol, schema, path, value);
      }
      function* TTemplateLiteral(schema, references, path, value) {
        if (!(0, guard_1.IsString)(value))
          return yield Create(ValueErrorType.String, schema, path, value);
        const regex = new RegExp(schema.pattern);
        if (!regex.test(value)) {
          yield Create(ValueErrorType.StringPattern, schema, path, value);
        }
      }
      function* TThis(schema, references, path, value) {
        yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);
      }
      function* TTuple(schema, references, path, value) {
        if (!(0, guard_1.IsArray)(value))
          return yield Create(ValueErrorType.Tuple, schema, path, value);
        if (schema.items === void 0 && !(value.length === 0)) {
          return yield Create(ValueErrorType.TupleLength, schema, path, value);
        }
        if (!(value.length === schema.maxItems)) {
          return yield Create(ValueErrorType.TupleLength, schema, path, value);
        }
        if (!schema.items) {
          return;
        }
        for (let i2 = 0; i2 < schema.items.length; i2++) {
          yield* Visit(schema.items[i2], references, `${path}/${i2}`, value[i2]);
        }
      }
      function* TUndefined(schema, references, path, value) {
        if (!(0, guard_1.IsUndefined)(value))
          yield Create(ValueErrorType.Undefined, schema, path, value);
      }
      function* TUnion(schema, references, path, value) {
        let count = 0;
        for (const subschema of schema.anyOf) {
          const errors = [...Visit(subschema, references, path, value)];
          if (errors.length === 0)
            return;
          count += errors.length;
        }
        if (count > 0) {
          yield Create(ValueErrorType.Union, schema, path, value);
        }
      }
      function* TUint8Array(schema, references, path, value) {
        if (!(0, guard_1.IsUint8Array)(value))
          return yield Create(ValueErrorType.Uint8Array, schema, path, value);
        if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
          yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
        }
        if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
          yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
        }
      }
      function* TUnknown(schema, references, path, value) {
      }
      function* TVoid(schema, references, path, value) {
        if (!system_1.TypeSystemPolicy.IsVoidLike(value))
          yield Create(ValueErrorType.Void, schema, path, value);
      }
      function* TKind(schema, references, path, value) {
        const check = Types2.TypeRegistry.Get(schema[Types2.Kind]);
        if (!check(schema, value))
          yield Create(ValueErrorType.Kind, schema, path, value);
      }
      function* Visit(schema, references, path, value) {
        const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema_[Types2.Kind]) {
          case "Any":
            return yield* TAny(schema_, references_, path, value);
          case "Array":
            return yield* TArray(schema_, references_, path, value);
          case "AsyncIterator":
            return yield* TAsyncIterator(schema_, references_, path, value);
          case "BigInt":
            return yield* TBigInt(schema_, references_, path, value);
          case "Boolean":
            return yield* TBoolean(schema_, references_, path, value);
          case "Constructor":
            return yield* TConstructor(schema_, references_, path, value);
          case "Date":
            return yield* TDate(schema_, references_, path, value);
          case "Function":
            return yield* TFunction(schema_, references_, path, value);
          case "Integer":
            return yield* TInteger(schema_, references_, path, value);
          case "Intersect":
            return yield* TIntersect(schema_, references_, path, value);
          case "Iterator":
            return yield* TIterator(schema_, references_, path, value);
          case "Literal":
            return yield* TLiteral(schema_, references_, path, value);
          case "Never":
            return yield* TNever(schema_, references_, path, value);
          case "Not":
            return yield* TNot(schema_, references_, path, value);
          case "Null":
            return yield* TNull(schema_, references_, path, value);
          case "Number":
            return yield* TNumber(schema_, references_, path, value);
          case "Object":
            return yield* TObject(schema_, references_, path, value);
          case "Promise":
            return yield* TPromise(schema_, references_, path, value);
          case "Record":
            return yield* TRecord(schema_, references_, path, value);
          case "Ref":
            return yield* TRef(schema_, references_, path, value);
          case "String":
            return yield* TString(schema_, references_, path, value);
          case "Symbol":
            return yield* TSymbol(schema_, references_, path, value);
          case "TemplateLiteral":
            return yield* TTemplateLiteral(schema_, references_, path, value);
          case "This":
            return yield* TThis(schema_, references_, path, value);
          case "Tuple":
            return yield* TTuple(schema_, references_, path, value);
          case "Undefined":
            return yield* TUndefined(schema_, references_, path, value);
          case "Union":
            return yield* TUnion(schema_, references_, path, value);
          case "Uint8Array":
            return yield* TUint8Array(schema_, references_, path, value);
          case "Unknown":
            return yield* TUnknown(schema_, references_, path, value);
          case "Void":
            return yield* TVoid(schema_, references_, path, value);
          default:
            if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
              throw new ValueErrorsUnknownTypeError(schema);
            return yield* TKind(schema_, references_, path, value);
        }
      }
      function Errors(...args) {
        const iterator = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
        return new ValueErrorIterator(iterator);
      }
      exports.Errors = Errors;
    }
  });

  // ../node_modules/@sinclair/typebox/errors/index.js
  var require_errors2 = __commonJS({
    "../node_modules/@sinclair/typebox/errors/index.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m2[k2];
      });
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
            __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_errors(), exports);
    }
  });

  // ../node_modules/@sinclair/typebox/value/pointer.js
  var require_pointer = __commonJS({
    "../node_modules/@sinclair/typebox/value/pointer.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValuePointer = exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = void 0;
      var ValuePointerRootSetError = class extends Error {
        constructor(value, path, update) {
          super("Cannot set root value");
          this.value = value;
          this.path = path;
          this.update = update;
        }
      };
      exports.ValuePointerRootSetError = ValuePointerRootSetError;
      var ValuePointerRootDeleteError = class extends Error {
        constructor(value, path) {
          super("Cannot delete root value");
          this.value = value;
          this.path = path;
        }
      };
      exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
      var ValuePointer;
      (function(ValuePointer2) {
        function Escape(component) {
          return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
        }
        function* Format(pointer) {
          if (pointer === "")
            return;
          let [start, end] = [0, 0];
          for (let i2 = 0; i2 < pointer.length; i2++) {
            const char = pointer.charAt(i2);
            if (char === "/") {
              if (i2 === 0) {
                start = i2 + 1;
              } else {
                end = i2;
                yield Escape(pointer.slice(start, end));
                start = i2 + 1;
              }
            } else {
              end = i2;
            }
          }
          yield Escape(pointer.slice(start));
        }
        ValuePointer2.Format = Format;
        function Set2(value, pointer, update) {
          if (pointer === "")
            throw new ValuePointerRootSetError(value, pointer, update);
          let [owner, next, key] = [null, value, ""];
          for (const component of Format(pointer)) {
            if (next[component] === void 0)
              next[component] = {};
            owner = next;
            next = next[component];
            key = component;
          }
          owner[key] = update;
        }
        ValuePointer2.Set = Set2;
        function Delete(value, pointer) {
          if (pointer === "")
            throw new ValuePointerRootDeleteError(value, pointer);
          let [owner, next, key] = [null, value, ""];
          for (const component of Format(pointer)) {
            if (next[component] === void 0 || next[component] === null)
              return;
            owner = next;
            next = next[component];
            key = component;
          }
          if (Array.isArray(owner)) {
            const index = parseInt(key);
            owner.splice(index, 1);
          } else {
            delete owner[key];
          }
        }
        ValuePointer2.Delete = Delete;
        function Has(value, pointer) {
          if (pointer === "")
            return true;
          let [owner, next, key] = [null, value, ""];
          for (const component of Format(pointer)) {
            if (next[component] === void 0)
              return false;
            owner = next;
            next = next[component];
            key = component;
          }
          return Object.getOwnPropertyNames(owner).includes(key);
        }
        ValuePointer2.Has = Has;
        function Get(value, pointer) {
          if (pointer === "")
            return value;
          let current = value;
          for (const component of Format(pointer)) {
            if (current[component] === void 0)
              return void 0;
            current = current[component];
          }
          return current;
        }
        ValuePointer2.Get = Get;
      })(ValuePointer || (exports.ValuePointer = ValuePointer = {}));
    }
  });

  // ../node_modules/@sinclair/typebox/value/clone.js
  var require_clone = __commonJS({
    "../node_modules/@sinclair/typebox/value/clone.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Clone = void 0;
      var guard_1 = require_guard();
      function ObjectType(value) {
        const keys2 = [...Object.getOwnPropertyNames(value), ...Object.getOwnPropertySymbols(value)];
        return keys2.reduce((acc, key) => ({ ...acc, [key]: Clone(value[key]) }), {});
      }
      function ArrayType(value) {
        return value.map((element) => Clone(element));
      }
      function TypedArrayType(value) {
        return value.slice();
      }
      function DateType(value) {
        return new Date(value.toISOString());
      }
      function ValueType(value) {
        return value;
      }
      function Clone(value) {
        if ((0, guard_1.IsArray)(value))
          return ArrayType(value);
        if ((0, guard_1.IsDate)(value))
          return DateType(value);
        if ((0, guard_1.IsPlainObject)(value))
          return ObjectType(value);
        if ((0, guard_1.IsTypedArray)(value))
          return TypedArrayType(value);
        if ((0, guard_1.IsValueType)(value))
          return ValueType(value);
        throw new Error("ValueClone: Unable to clone value");
      }
      exports.Clone = Clone;
    }
  });

  // ../node_modules/@sinclair/typebox/value/delta.js
  var require_delta = __commonJS({
    "../node_modules/@sinclair/typebox/value/delta.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Patch = exports.Diff = exports.ValueDeltaUnableToDiffUnknownValue = exports.ValueDeltaObjectWithSymbolKeyError = exports.Edit = exports.Delete = exports.Update = exports.Insert = void 0;
      var guard_1 = require_guard();
      var typebox_1 = require_typebox();
      var pointer_1 = require_pointer();
      var clone_1 = require_clone();
      exports.Insert = typebox_1.Type.Object({
        type: typebox_1.Type.Literal("insert"),
        path: typebox_1.Type.String(),
        value: typebox_1.Type.Unknown()
      });
      exports.Update = typebox_1.Type.Object({
        type: typebox_1.Type.Literal("update"),
        path: typebox_1.Type.String(),
        value: typebox_1.Type.Unknown()
      });
      exports.Delete = typebox_1.Type.Object({
        type: typebox_1.Type.Literal("delete"),
        path: typebox_1.Type.String()
      });
      exports.Edit = typebox_1.Type.Union([exports.Insert, exports.Update, exports.Delete]);
      var ValueDeltaObjectWithSymbolKeyError = class extends Error {
        constructor(key) {
          super("Cannot diff objects with symbol keys");
          this.key = key;
        }
      };
      exports.ValueDeltaObjectWithSymbolKeyError = ValueDeltaObjectWithSymbolKeyError;
      var ValueDeltaUnableToDiffUnknownValue = class extends Error {
        constructor(value) {
          super("Unable to create diff edits for unknown value");
          this.value = value;
        }
      };
      exports.ValueDeltaUnableToDiffUnknownValue = ValueDeltaUnableToDiffUnknownValue;
      function CreateUpdate(path, value) {
        return { type: "update", path, value };
      }
      function CreateInsert(path, value) {
        return { type: "insert", path, value };
      }
      function CreateDelete(path) {
        return { type: "delete", path };
      }
      function* ObjectType(path, current, next) {
        if (!(0, guard_1.IsPlainObject)(next))
          return yield CreateUpdate(path, next);
        const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];
        const nextKeys = [...Object.keys(next), ...Object.getOwnPropertySymbols(next)];
        for (const key of currentKeys) {
          if ((0, guard_1.IsSymbol)(key))
            throw new ValueDeltaObjectWithSymbolKeyError(key);
          if ((0, guard_1.IsUndefined)(next[key]) && nextKeys.includes(key))
            yield CreateUpdate(`${path}/${String(key)}`, void 0);
        }
        for (const key of nextKeys) {
          if ((0, guard_1.IsUndefined)(current[key]) || (0, guard_1.IsUndefined)(next[key]))
            continue;
          if ((0, guard_1.IsSymbol)(key))
            throw new ValueDeltaObjectWithSymbolKeyError(key);
          yield* Visit(`${path}/${String(key)}`, current[key], next[key]);
        }
        for (const key of nextKeys) {
          if ((0, guard_1.IsSymbol)(key))
            throw new ValueDeltaObjectWithSymbolKeyError(key);
          if ((0, guard_1.IsUndefined)(current[key]))
            yield CreateInsert(`${path}/${String(key)}`, next[key]);
        }
        for (const key of currentKeys.reverse()) {
          if ((0, guard_1.IsSymbol)(key))
            throw new ValueDeltaObjectWithSymbolKeyError(key);
          if ((0, guard_1.IsUndefined)(next[key]) && !nextKeys.includes(key))
            yield CreateDelete(`${path}/${String(key)}`);
        }
      }
      function* ArrayType(path, current, next) {
        if (!(0, guard_1.IsArray)(next))
          return yield CreateUpdate(path, next);
        for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
          yield* Visit(`${path}/${i2}`, current[i2], next[i2]);
        }
        for (let i2 = 0; i2 < next.length; i2++) {
          if (i2 < current.length)
            continue;
          yield CreateInsert(`${path}/${i2}`, next[i2]);
        }
        for (let i2 = current.length - 1; i2 >= 0; i2--) {
          if (i2 < next.length)
            continue;
          yield CreateDelete(`${path}/${i2}`);
        }
      }
      function* TypedArrayType(path, current, next) {
        if (!(0, guard_1.IsTypedArray)(next) || current.length !== next.length || Object.getPrototypeOf(current).constructor.name !== Object.getPrototypeOf(next).constructor.name)
          return yield CreateUpdate(path, next);
        for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
          yield* Visit(`${path}/${i2}`, current[i2], next[i2]);
        }
      }
      function* ValueType(path, current, next) {
        if (current === next)
          return;
        yield CreateUpdate(path, next);
      }
      function* Visit(path, current, next) {
        if ((0, guard_1.IsPlainObject)(current))
          return yield* ObjectType(path, current, next);
        if ((0, guard_1.IsArray)(current))
          return yield* ArrayType(path, current, next);
        if ((0, guard_1.IsTypedArray)(current))
          return yield* TypedArrayType(path, current, next);
        if ((0, guard_1.IsValueType)(current))
          return yield* ValueType(path, current, next);
        throw new ValueDeltaUnableToDiffUnknownValue(current);
      }
      function Diff(current, next) {
        return [...Visit("", current, next)];
      }
      exports.Diff = Diff;
      function IsRootUpdate(edits) {
        return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
      }
      function IsIdentity(edits) {
        return edits.length === 0;
      }
      function Patch(current, edits) {
        if (IsRootUpdate(edits)) {
          return (0, clone_1.Clone)(edits[0].value);
        }
        if (IsIdentity(edits)) {
          return (0, clone_1.Clone)(current);
        }
        const clone = (0, clone_1.Clone)(current);
        for (const edit of edits) {
          switch (edit.type) {
            case "insert": {
              pointer_1.ValuePointer.Set(clone, edit.path, edit.value);
              break;
            }
            case "update": {
              pointer_1.ValuePointer.Set(clone, edit.path, edit.value);
              break;
            }
            case "delete": {
              pointer_1.ValuePointer.Delete(clone, edit.path);
              break;
            }
          }
        }
        return clone;
      }
      exports.Patch = Patch;
    }
  });

  // ../node_modules/@sinclair/typebox/value/mutate.js
  var require_mutate = __commonJS({
    "../node_modules/@sinclair/typebox/value/mutate.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Mutate = exports.ValueMutateInvalidRootMutationError = exports.ValueMutateTypeMismatchError = void 0;
      var guard_1 = require_guard();
      var pointer_1 = require_pointer();
      var clone_1 = require_clone();
      var ValueMutateTypeMismatchError = class extends Error {
        constructor() {
          super("Cannot assign due type mismatch of assignable values");
        }
      };
      exports.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;
      var ValueMutateInvalidRootMutationError = class extends Error {
        constructor() {
          super("Only object and array types can be mutated at the root level");
        }
      };
      exports.ValueMutateInvalidRootMutationError = ValueMutateInvalidRootMutationError;
      function ObjectType(root, path, current, next) {
        if (!(0, guard_1.IsPlainObject)(current)) {
          pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
        } else {
          const currentKeys = Object.keys(current);
          const nextKeys = Object.keys(next);
          for (const currentKey of currentKeys) {
            if (!nextKeys.includes(currentKey)) {
              delete current[currentKey];
            }
          }
          for (const nextKey of nextKeys) {
            if (!currentKeys.includes(nextKey)) {
              current[nextKey] = null;
            }
          }
          for (const nextKey of nextKeys) {
            Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
          }
        }
      }
      function ArrayType(root, path, current, next) {
        if (!(0, guard_1.IsArray)(current)) {
          pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
        } else {
          for (let index = 0; index < next.length; index++) {
            Visit(root, `${path}/${index}`, current[index], next[index]);
          }
          current.splice(next.length);
        }
      }
      function TypedArrayType(root, path, current, next) {
        if ((0, guard_1.IsTypedArray)(current) && current.length === next.length) {
          for (let i2 = 0; i2 < current.length; i2++) {
            current[i2] = next[i2];
          }
        } else {
          pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
        }
      }
      function ValueType(root, path, current, next) {
        if (current === next)
          return;
        pointer_1.ValuePointer.Set(root, path, next);
      }
      function Visit(root, path, current, next) {
        if ((0, guard_1.IsArray)(next))
          return ArrayType(root, path, current, next);
        if ((0, guard_1.IsTypedArray)(next))
          return TypedArrayType(root, path, current, next);
        if ((0, guard_1.IsPlainObject)(next))
          return ObjectType(root, path, current, next);
        if ((0, guard_1.IsValueType)(next))
          return ValueType(root, path, current, next);
      }
      function IsNonMutableValue(value) {
        return (0, guard_1.IsTypedArray)(value) || (0, guard_1.IsValueType)(value);
      }
      function IsMismatchedValue(current, next) {
        return (0, guard_1.IsPlainObject)(current) && (0, guard_1.IsArray)(next) || (0, guard_1.IsArray)(current) && (0, guard_1.IsPlainObject)(next);
      }
      function Mutate(current, next) {
        if (IsNonMutableValue(current) || IsNonMutableValue(next))
          throw new ValueMutateInvalidRootMutationError();
        if (IsMismatchedValue(current, next))
          throw new ValueMutateTypeMismatchError();
        Visit(current, "", current, next);
      }
      exports.Mutate = Mutate;
    }
  });

  // ../node_modules/@sinclair/typebox/value/equal.js
  var require_equal = __commonJS({
    "../node_modules/@sinclair/typebox/value/equal.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Equal = void 0;
      var guard_1 = require_guard();
      function ObjectType(left, right) {
        if (!(0, guard_1.IsPlainObject)(right))
          return false;
        const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
        const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
        if (leftKeys.length !== rightKeys.length)
          return false;
        return leftKeys.every((key) => Equal(left[key], right[key]));
      }
      function DateType(left, right) {
        return (0, guard_1.IsDate)(right) && left.getTime() === right.getTime();
      }
      function ArrayType(left, right) {
        if (!(0, guard_1.IsArray)(right) || left.length !== right.length)
          return false;
        return left.every((value, index) => Equal(value, right[index]));
      }
      function TypedArrayType(left, right) {
        if (!(0, guard_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
          return false;
        return left.every((value, index) => Equal(value, right[index]));
      }
      function ValueType(left, right) {
        return left === right;
      }
      function Equal(left, right) {
        if ((0, guard_1.IsPlainObject)(left))
          return ObjectType(left, right);
        if ((0, guard_1.IsDate)(left))
          return DateType(left, right);
        if ((0, guard_1.IsTypedArray)(left))
          return TypedArrayType(left, right);
        if ((0, guard_1.IsArray)(left))
          return ArrayType(left, right);
        if ((0, guard_1.IsValueType)(left))
          return ValueType(left, right);
        throw new Error("ValueEquals: Unable to compare value");
      }
      exports.Equal = Equal;
    }
  });

  // ../node_modules/@sinclair/typebox/system/index.js
  var require_system2 = __commonJS({
    "../node_modules/@sinclair/typebox/system/index.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m2[k2];
      });
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
            __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValueErrorType = void 0;
      var errors_1 = require_errors();
      Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
        return errors_1.ValueErrorType;
      } });
      __exportStar(require_system(), exports);
    }
  });

  // ../node_modules/@sinclair/typebox/value/check.js
  var require_check = __commonJS({
    "../node_modules/@sinclair/typebox/value/check.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Check = exports.ValueCheckUnknownTypeError = void 0;
      var guard_1 = require_guard();
      var index_1 = require_system2();
      var deref_1 = require_deref();
      var hash_1 = require_hash();
      var Types2 = require_typebox();
      var ValueCheckUnknownTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super(`Unknown type`);
          this.schema = schema;
        }
      };
      exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
      function IsAnyOrUnknown(schema) {
        return schema[Types2.Kind] === "Any" || schema[Types2.Kind] === "Unknown";
      }
      function IsDefined(value) {
        return value !== void 0;
      }
      function TAny(schema, references, value) {
        return true;
      }
      function TArray(schema, references, value) {
        if (!(0, guard_1.IsArray)(value))
          return false;
        if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
          return false;
        }
        if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
          return false;
        }
        if (!value.every((value2) => Visit(schema.items, references, value2))) {
          return false;
        }
        if (schema.uniqueItems === true && !function() {
          const set = /* @__PURE__ */ new Set();
          for (const element of value) {
            const hashed = (0, hash_1.Hash)(element);
            if (set.has(hashed)) {
              return false;
            } else {
              set.add(hashed);
            }
          }
          return true;
        }()) {
          return false;
        }
        if (!(IsDefined(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains))) {
          return true;
        }
        const containsSchema = IsDefined(schema.contains) ? schema.contains : Types2.Type.Never();
        const containsCount = value.reduce((acc, value2) => Visit(containsSchema, references, value2) ? acc + 1 : acc, 0);
        if (containsCount === 0) {
          return false;
        }
        if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
          return false;
        }
        if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
          return false;
        }
        return true;
      }
      function TAsyncIterator(schema, references, value) {
        return (0, guard_1.IsAsyncIterator)(value);
      }
      function TBigInt(schema, references, value) {
        if (!(0, guard_1.IsBigInt)(value))
          return false;
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
          return false;
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
          return false;
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
          return false;
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
          return false;
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
          return false;
        }
        return true;
      }
      function TBoolean(schema, references, value) {
        return (0, guard_1.IsBoolean)(value);
      }
      function TConstructor(schema, references, value) {
        return Visit(schema.returns, references, value.prototype);
      }
      function TDate(schema, references, value) {
        if (!(0, guard_1.IsDate)(value))
          return false;
        if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
          return false;
        }
        if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
          return false;
        }
        if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
          return false;
        }
        if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
          return false;
        }
        if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
          return false;
        }
        return true;
      }
      function TFunction(schema, references, value) {
        return (0, guard_1.IsFunction)(value);
      }
      function TInteger(schema, references, value) {
        if (!(0, guard_1.IsInteger)(value)) {
          return false;
        }
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
          return false;
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
          return false;
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
          return false;
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
          return false;
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
          return false;
        }
        return true;
      }
      function TIntersect(schema, references, value) {
        const check1 = schema.allOf.every((schema2) => Visit(schema2, references, value));
        if (schema.unevaluatedProperties === false) {
          const keyPattern = new RegExp(Types2.KeyResolver.ResolvePattern(schema));
          const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
          return check1 && check2;
        } else if (Types2.TypeGuard.TSchema(schema.unevaluatedProperties)) {
          const keyCheck = new RegExp(Types2.KeyResolver.ResolvePattern(schema));
          const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
          return check1 && check2;
        } else {
          return check1;
        }
      }
      function TIterator(schema, references, value) {
        return (0, guard_1.IsIterator)(value);
      }
      function TLiteral(schema, references, value) {
        return value === schema.const;
      }
      function TNever(schema, references, value) {
        return false;
      }
      function TNot(schema, references, value) {
        return !Visit(schema.not, references, value);
      }
      function TNull(schema, references, value) {
        return (0, guard_1.IsNull)(value);
      }
      function TNumber(schema, references, value) {
        if (!index_1.TypeSystemPolicy.IsNumberLike(value))
          return false;
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
          return false;
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
          return false;
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
          return false;
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
          return false;
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
          return false;
        }
        return true;
      }
      function TObject(schema, references, value) {
        if (!index_1.TypeSystemPolicy.IsObjectLike(value))
          return false;
        if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
          return false;
        }
        if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
          return false;
        }
        const knownKeys = Object.getOwnPropertyNames(schema.properties);
        for (const knownKey of knownKeys) {
          const property = schema.properties[knownKey];
          if (schema.required && schema.required.includes(knownKey)) {
            if (!Visit(property, references, value[knownKey])) {
              return false;
            }
            if ((Types2.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
              return false;
            }
          } else {
            if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {
              return false;
            }
          }
        }
        if (schema.additionalProperties === false) {
          const valueKeys = Object.getOwnPropertyNames(value);
          if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
            return true;
          } else {
            return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
          }
        } else if (typeof schema.additionalProperties === "object") {
          const valueKeys = Object.getOwnPropertyNames(value);
          return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));
        } else {
          return true;
        }
      }
      function TPromise(schema, references, value) {
        return (0, guard_1.IsPromise)(value);
      }
      function TRecord(schema, references, value) {
        if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
          return false;
        }
        if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
          return false;
        }
        if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
          return false;
        }
        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
        const regex = new RegExp(patternKey);
        const check1 = Object.entries(value).every(([key, value2]) => {
          return regex.test(key) ? Visit(patternSchema, references, value2) : true;
        });
        const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
          return !regex.test(key) ? Visit(schema.additionalProperties, references, value2) : true;
        }) : true;
        const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
          return regex.test(key);
        }) : true;
        return check1 && check2 && check3;
      }
      function TRef(schema, references, value) {
        return Visit((0, deref_1.Deref)(schema, references), references, value);
      }
      function TString(schema, references, value) {
        if (!(0, guard_1.IsString)(value)) {
          return false;
        }
        if (IsDefined(schema.minLength)) {
          if (!(value.length >= schema.minLength))
            return false;
        }
        if (IsDefined(schema.maxLength)) {
          if (!(value.length <= schema.maxLength))
            return false;
        }
        if (IsDefined(schema.pattern)) {
          const regex = new RegExp(schema.pattern);
          if (!regex.test(value))
            return false;
        }
        if (IsDefined(schema.format)) {
          if (!Types2.FormatRegistry.Has(schema.format))
            return false;
          const func = Types2.FormatRegistry.Get(schema.format);
          return func(value);
        }
        return true;
      }
      function TSymbol(schema, references, value) {
        return (0, guard_1.IsSymbol)(value);
      }
      function TTemplateLiteral(schema, references, value) {
        return (0, guard_1.IsString)(value) && new RegExp(schema.pattern).test(value);
      }
      function TThis(schema, references, value) {
        return Visit((0, deref_1.Deref)(schema, references), references, value);
      }
      function TTuple(schema, references, value) {
        if (!(0, guard_1.IsArray)(value)) {
          return false;
        }
        if (schema.items === void 0 && !(value.length === 0)) {
          return false;
        }
        if (!(value.length === schema.maxItems)) {
          return false;
        }
        if (!schema.items) {
          return true;
        }
        for (let i2 = 0; i2 < schema.items.length; i2++) {
          if (!Visit(schema.items[i2], references, value[i2]))
            return false;
        }
        return true;
      }
      function TUndefined(schema, references, value) {
        return (0, guard_1.IsUndefined)(value);
      }
      function TUnion(schema, references, value) {
        return schema.anyOf.some((inner) => Visit(inner, references, value));
      }
      function TUint8Array(schema, references, value) {
        if (!(0, guard_1.IsUint8Array)(value)) {
          return false;
        }
        if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
          return false;
        }
        if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
          return false;
        }
        return true;
      }
      function TUnknown(schema, references, value) {
        return true;
      }
      function TVoid(schema, references, value) {
        return index_1.TypeSystemPolicy.IsVoidLike(value);
      }
      function TKind(schema, references, value) {
        if (!Types2.TypeRegistry.Has(schema[Types2.Kind]))
          return false;
        const func = Types2.TypeRegistry.Get(schema[Types2.Kind]);
        return func(schema, value);
      }
      function Visit(schema, references, value) {
        const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema_[Types2.Kind]) {
          case "Any":
            return TAny(schema_, references_, value);
          case "Array":
            return TArray(schema_, references_, value);
          case "AsyncIterator":
            return TAsyncIterator(schema_, references_, value);
          case "BigInt":
            return TBigInt(schema_, references_, value);
          case "Boolean":
            return TBoolean(schema_, references_, value);
          case "Constructor":
            return TConstructor(schema_, references_, value);
          case "Date":
            return TDate(schema_, references_, value);
          case "Function":
            return TFunction(schema_, references_, value);
          case "Integer":
            return TInteger(schema_, references_, value);
          case "Intersect":
            return TIntersect(schema_, references_, value);
          case "Iterator":
            return TIterator(schema_, references_, value);
          case "Literal":
            return TLiteral(schema_, references_, value);
          case "Never":
            return TNever(schema_, references_, value);
          case "Not":
            return TNot(schema_, references_, value);
          case "Null":
            return TNull(schema_, references_, value);
          case "Number":
            return TNumber(schema_, references_, value);
          case "Object":
            return TObject(schema_, references_, value);
          case "Promise":
            return TPromise(schema_, references_, value);
          case "Record":
            return TRecord(schema_, references_, value);
          case "Ref":
            return TRef(schema_, references_, value);
          case "String":
            return TString(schema_, references_, value);
          case "Symbol":
            return TSymbol(schema_, references_, value);
          case "TemplateLiteral":
            return TTemplateLiteral(schema_, references_, value);
          case "This":
            return TThis(schema_, references_, value);
          case "Tuple":
            return TTuple(schema_, references_, value);
          case "Undefined":
            return TUndefined(schema_, references_, value);
          case "Union":
            return TUnion(schema_, references_, value);
          case "Uint8Array":
            return TUint8Array(schema_, references_, value);
          case "Unknown":
            return TUnknown(schema_, references_, value);
          case "Void":
            return TVoid(schema_, references_, value);
          default:
            if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
              throw new ValueCheckUnknownTypeError(schema_);
            return TKind(schema_, references_, value);
        }
      }
      function Check(...args) {
        return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
      }
      exports.Check = Check;
    }
  });

  // ../node_modules/@sinclair/typebox/value/create.js
  var require_create = __commonJS({
    "../node_modules/@sinclair/typebox/value/create.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Create = exports.ValueCreateRecursiveInstantiationError = exports.ValueCreateTempateLiteralTypeError = exports.ValueCreateIntersectTypeError = exports.ValueCreateNotTypeError = exports.ValueCreateNeverTypeError = exports.ValueCreateUnknownTypeError = void 0;
      var guard_1 = require_guard();
      var check_1 = require_check();
      var deref_1 = require_deref();
      var Types2 = require_typebox();
      var ValueCreateUnknownTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Unknown type");
          this.schema = schema;
        }
      };
      exports.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;
      var ValueCreateNeverTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Never types cannot be created");
          this.schema = schema;
        }
      };
      exports.ValueCreateNeverTypeError = ValueCreateNeverTypeError;
      var ValueCreateNotTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Not types must have a default value");
          this.schema = schema;
        }
      };
      exports.ValueCreateNotTypeError = ValueCreateNotTypeError;
      var ValueCreateIntersectTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Intersect produced invalid value. Consider using a default value.");
          this.schema = schema;
        }
      };
      exports.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;
      var ValueCreateTempateLiteralTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
          this.schema = schema;
        }
      };
      exports.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;
      var ValueCreateRecursiveInstantiationError = class extends Types2.TypeBoxError {
        constructor(schema, recursiveMaxDepth2) {
          super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
          this.schema = schema;
          this.recursiveMaxDepth = recursiveMaxDepth2;
        }
      };
      exports.ValueCreateRecursiveInstantiationError = ValueCreateRecursiveInstantiationError;
      function TAny(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return {};
        }
      }
      function TArray(schema, references) {
        if (schema.uniqueItems === true && !(0, guard_1.HasPropertyKey)(schema, "default")) {
          throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
        } else if ("contains" in schema && !(0, guard_1.HasPropertyKey)(schema, "default")) {
          throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
        } else if ("default" in schema) {
          return schema.default;
        } else if (schema.minItems !== void 0) {
          return Array.from({ length: schema.minItems }).map((item) => {
            return Visit(schema.items, references);
          });
        } else {
          return [];
        }
      }
      function TAsyncIterator(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return async function* () {
          }();
        }
      }
      function TBigInt(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return BigInt(0);
        }
      }
      function TBoolean(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return false;
        }
      }
      function TConstructor(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          const value = Visit(schema.returns, references);
          if (typeof value === "object" && !Array.isArray(value)) {
            return class {
              constructor() {
                for (const [key, val] of Object.entries(value)) {
                  const self2 = this;
                  self2[key] = val;
                }
              }
            };
          } else {
            return class {
            };
          }
        }
      }
      function TDate(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else if (schema.minimumTimestamp !== void 0) {
          return new Date(schema.minimumTimestamp);
        } else {
          return /* @__PURE__ */ new Date(0);
        }
      }
      function TFunction(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return () => Visit(schema.returns, references);
        }
      }
      function TInteger(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else if (schema.minimum !== void 0) {
          return schema.minimum;
        } else {
          return 0;
        }
      }
      function TIntersect(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          const value = schema.allOf.reduce((acc, schema2) => {
            const next = Visit(schema2, references);
            return typeof next === "object" ? { ...acc, ...next } : next;
          }, {});
          if (!(0, check_1.Check)(schema, references, value))
            throw new ValueCreateIntersectTypeError(schema);
          return value;
        }
      }
      function TIterator(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return function* () {
          }();
        }
      }
      function TLiteral(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return schema.const;
        }
      }
      function TNever(schema, references) {
        throw new ValueCreateNeverTypeError(schema);
      }
      function TNot(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          throw new ValueCreateNotTypeError(schema);
        }
      }
      function TNull(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return null;
        }
      }
      function TNumber(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else if (schema.minimum !== void 0) {
          return schema.minimum;
        } else {
          return 0;
        }
      }
      function TObject(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          const required = new Set(schema.required);
          return schema.default || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
            return required.has(key) ? { ...acc, [key]: Visit(schema2, references) } : { ...acc };
          }, {});
        }
      }
      function TPromise(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return Promise.resolve(Visit(schema.item, references));
        }
      }
      function TRecord(schema, references) {
        const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else if (!(keyPattern === Types2.PatternStringExact || keyPattern === Types2.PatternNumberExact)) {
          const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
          return propertyKeys.reduce((acc, key) => {
            return { ...acc, [key]: Visit(valueSchema, references) };
          }, {});
        } else {
          return {};
        }
      }
      function TRef(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return Visit((0, deref_1.Deref)(schema, references), references);
        }
      }
      function TString(schema, references) {
        if (schema.pattern !== void 0) {
          if (!(0, guard_1.HasPropertyKey)(schema, "default")) {
            throw new Error("ValueCreate.String: String types with patterns must specify a default value");
          } else {
            return schema.default;
          }
        } else if (schema.format !== void 0) {
          if (!(0, guard_1.HasPropertyKey)(schema, "default")) {
            throw new Error("ValueCreate.String: String types with formats must specify a default value");
          } else {
            return schema.default;
          }
        } else {
          if ((0, guard_1.HasPropertyKey)(schema, "default")) {
            return schema.default;
          } else if (schema.minLength !== void 0) {
            return Array.from({ length: schema.minLength }).map(() => ".").join("");
          } else {
            return "";
          }
        }
      }
      function TSymbol(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else if ("value" in schema) {
          return Symbol.for(schema.value);
        } else {
          return Symbol();
        }
      }
      function TTemplateLiteral(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        }
        const expression = Types2.TemplateLiteralParser.ParseExact(schema.pattern);
        if (!Types2.TemplateLiteralFinite.Check(expression))
          throw new ValueCreateTempateLiteralTypeError(schema);
        const sequence = Types2.TemplateLiteralGenerator.Generate(expression);
        return sequence.next().value;
      }
      function TThis(schema, references) {
        if (recursiveDepth++ > recursiveMaxDepth)
          throw new ValueCreateRecursiveInstantiationError(schema, recursiveMaxDepth);
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return Visit((0, deref_1.Deref)(schema, references), references);
        }
      }
      function TTuple(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        }
        if (schema.items === void 0) {
          return [];
        } else {
          return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));
        }
      }
      function TUndefined(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return void 0;
        }
      }
      function TUnion(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else if (schema.anyOf.length === 0) {
          throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
        } else {
          return Visit(schema.anyOf[0], references);
        }
      }
      function TUint8Array(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else if (schema.minByteLength !== void 0) {
          return new Uint8Array(schema.minByteLength);
        } else {
          return new Uint8Array(0);
        }
      }
      function TUnknown(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return {};
        }
      }
      function TVoid(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          return void 0;
        }
      }
      function TKind(schema, references) {
        if ((0, guard_1.HasPropertyKey)(schema, "default")) {
          return schema.default;
        } else {
          throw new Error("User defined types must specify a default value");
        }
      }
      function Visit(schema, references) {
        const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema_[Types2.Kind]) {
          case "Any":
            return TAny(schema_, references_);
          case "Array":
            return TArray(schema_, references_);
          case "AsyncIterator":
            return TAsyncIterator(schema_, references_);
          case "BigInt":
            return TBigInt(schema_, references_);
          case "Boolean":
            return TBoolean(schema_, references_);
          case "Constructor":
            return TConstructor(schema_, references_);
          case "Date":
            return TDate(schema_, references_);
          case "Function":
            return TFunction(schema_, references_);
          case "Integer":
            return TInteger(schema_, references_);
          case "Intersect":
            return TIntersect(schema_, references_);
          case "Iterator":
            return TIterator(schema_, references_);
          case "Literal":
            return TLiteral(schema_, references_);
          case "Never":
            return TNever(schema_, references_);
          case "Not":
            return TNot(schema_, references_);
          case "Null":
            return TNull(schema_, references_);
          case "Number":
            return TNumber(schema_, references_);
          case "Object":
            return TObject(schema_, references_);
          case "Promise":
            return TPromise(schema_, references_);
          case "Record":
            return TRecord(schema_, references_);
          case "Ref":
            return TRef(schema_, references_);
          case "String":
            return TString(schema_, references_);
          case "Symbol":
            return TSymbol(schema_, references_);
          case "TemplateLiteral":
            return TTemplateLiteral(schema_, references_);
          case "This":
            return TThis(schema_, references_);
          case "Tuple":
            return TTuple(schema_, references_);
          case "Undefined":
            return TUndefined(schema_, references_);
          case "Union":
            return TUnion(schema_, references_);
          case "Uint8Array":
            return TUint8Array(schema_, references_);
          case "Unknown":
            return TUnknown(schema_, references_);
          case "Void":
            return TVoid(schema_, references_);
          default:
            if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
              throw new ValueCreateUnknownTypeError(schema_);
            return TKind(schema_, references_);
        }
      }
      var recursiveMaxDepth = 512;
      var recursiveDepth = 0;
      function Create(...args) {
        recursiveDepth = 0;
        return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
      }
      exports.Create = Create;
    }
  });

  // ../node_modules/@sinclair/typebox/value/cast.js
  var require_cast = __commonJS({
    "../node_modules/@sinclair/typebox/value/cast.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Cast = exports.Default = exports.DefaultClone = exports.ValueCastUnknownTypeError = exports.ValueCastRecursiveTypeError = exports.ValueCastNeverTypeError = exports.ValueCastArrayUniqueItemsTypeError = void 0;
      var guard_1 = require_guard();
      var create_1 = require_create();
      var check_1 = require_check();
      var clone_1 = require_clone();
      var deref_1 = require_deref();
      var Types2 = require_typebox();
      var ValueCastArrayUniqueItemsTypeError = class extends Types2.TypeBoxError {
        constructor(schema, value) {
          super("Array cast produced invalid data due to uniqueItems constraint");
          this.schema = schema;
          this.value = value;
        }
      };
      exports.ValueCastArrayUniqueItemsTypeError = ValueCastArrayUniqueItemsTypeError;
      var ValueCastNeverTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Never types cannot be cast");
          this.schema = schema;
        }
      };
      exports.ValueCastNeverTypeError = ValueCastNeverTypeError;
      var ValueCastRecursiveTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Cannot cast recursive schemas");
          this.schema = schema;
        }
      };
      exports.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;
      var ValueCastUnknownTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Unknown type");
          this.schema = schema;
        }
      };
      exports.ValueCastUnknownTypeError = ValueCastUnknownTypeError;
      var UnionCastCreate;
      (function(UnionCastCreate2) {
        function Score(schema, references, value) {
          if (schema[Types2.Kind] === "Object" && typeof value === "object" && !(0, guard_1.IsNull)(value)) {
            const object = schema;
            const keys2 = Object.getOwnPropertyNames(value);
            const entries = Object.entries(object.properties);
            const [point, max] = [1 / entries.length, entries.length];
            return entries.reduce((acc, [key, schema2]) => {
              const literal = schema2[Types2.Kind] === "Literal" && schema2.const === value[key] ? max : 0;
              const checks = (0, check_1.Check)(schema2, references, value[key]) ? point : 0;
              const exists = keys2.includes(key) ? point : 0;
              return acc + (literal + checks + exists);
            }, 0);
          } else {
            return (0, check_1.Check)(schema, references, value) ? 1 : 0;
          }
        }
        function Select(union, references, value) {
          let [select, best] = [union.anyOf[0], 0];
          for (const schema of union.anyOf) {
            const score = Score(schema, references, value);
            if (score > best) {
              select = schema;
              best = score;
            }
          }
          return select;
        }
        function Create(union, references, value) {
          if ("default" in union) {
            return union.default;
          } else {
            const schema = Select(union, references, value);
            return Cast(schema, references, value);
          }
        }
        UnionCastCreate2.Create = Create;
      })(UnionCastCreate || (UnionCastCreate = {}));
      function DefaultClone(schema, references, value) {
        return (0, check_1.Check)(schema, references, value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema, references);
      }
      exports.DefaultClone = DefaultClone;
      function Default(schema, references, value) {
        return (0, check_1.Check)(schema, references, value) ? value : (0, create_1.Create)(schema, references);
      }
      exports.Default = Default;
      function TArray(schema, references, value) {
        if ((0, check_1.Check)(schema, references, value))
          return (0, clone_1.Clone)(value);
        const created = (0, guard_1.IsArray)(value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema, references);
        const minimum = (0, guard_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
        const maximum = (0, guard_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
        const casted = maximum.map((value2) => Visit(schema.items, references, value2));
        if (schema.uniqueItems !== true)
          return casted;
        const unique = [...new Set(casted)];
        if (!(0, check_1.Check)(schema, references, unique))
          throw new ValueCastArrayUniqueItemsTypeError(schema, unique);
        return unique;
      }
      function TConstructor(schema, references, value) {
        if ((0, check_1.Check)(schema, references, value))
          return (0, create_1.Create)(schema, references);
        const required = new Set(schema.returns.required || []);
        const result = function() {
        };
        for (const [key, property] of Object.entries(schema.returns.properties)) {
          if (!required.has(key) && value.prototype[key] === void 0)
            continue;
          result.prototype[key] = Visit(property, references, value.prototype[key]);
        }
        return result;
      }
      function TIntersect(schema, references, value) {
        const created = (0, create_1.Create)(schema, references);
        const mapped = (0, guard_1.IsPlainObject)(created) && (0, guard_1.IsPlainObject)(value) ? { ...created, ...value } : value;
        return (0, check_1.Check)(schema, references, mapped) ? mapped : (0, create_1.Create)(schema, references);
      }
      function TNever(schema, references, value) {
        throw new ValueCastNeverTypeError(schema);
      }
      function TObject(schema, references, value) {
        if ((0, check_1.Check)(schema, references, value))
          return value;
        if (value === null || typeof value !== "object")
          return (0, create_1.Create)(schema, references);
        const required = new Set(schema.required || []);
        const result = {};
        for (const [key, property] of Object.entries(schema.properties)) {
          if (!required.has(key) && value[key] === void 0)
            continue;
          result[key] = Visit(property, references, value[key]);
        }
        if (typeof schema.additionalProperties === "object") {
          const propertyNames = Object.getOwnPropertyNames(schema.properties);
          for (const propertyName of Object.getOwnPropertyNames(value)) {
            if (propertyNames.includes(propertyName))
              continue;
            result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);
          }
        }
        return result;
      }
      function TRecord(schema, references, value) {
        if ((0, check_1.Check)(schema, references, value))
          return (0, clone_1.Clone)(value);
        if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
          return (0, create_1.Create)(schema, references);
        const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
        const subschema = schema.patternProperties[subschemaPropertyName];
        const result = {};
        for (const [propKey, propValue] of Object.entries(value)) {
          result[propKey] = Visit(subschema, references, propValue);
        }
        return result;
      }
      function TRef(schema, references, value) {
        return Visit((0, deref_1.Deref)(schema, references), references, value);
      }
      function TThis(schema, references, value) {
        return Visit((0, deref_1.Deref)(schema, references), references, value);
      }
      function TTuple(schema, references, value) {
        if ((0, check_1.Check)(schema, references, value))
          return (0, clone_1.Clone)(value);
        if (!(0, guard_1.IsArray)(value))
          return (0, create_1.Create)(schema, references);
        if (schema.items === void 0)
          return [];
        return schema.items.map((schema2, index) => Visit(schema2, references, value[index]));
      }
      function TUnion(schema, references, value) {
        return (0, check_1.Check)(schema, references, value) ? (0, clone_1.Clone)(value) : UnionCastCreate.Create(schema, references, value);
      }
      function Visit(schema, references, value) {
        const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema[Types2.Kind]) {
          case "Array":
            return TArray(schema_, references_, value);
          case "Constructor":
            return TConstructor(schema_, references_, value);
          case "Intersect":
            return TIntersect(schema_, references_, value);
          case "Never":
            return TNever(schema_, references_, value);
          case "Object":
            return TObject(schema_, references_, value);
          case "Record":
            return TRecord(schema_, references_, value);
          case "Ref":
            return TRef(schema_, references_, value);
          case "This":
            return TThis(schema_, references_, value);
          case "Tuple":
            return TTuple(schema_, references_, value);
          case "Union":
            return TUnion(schema_, references_, value);
          case "Date":
          case "Symbol":
          case "Uint8Array":
            return DefaultClone(schema, references, value);
          case "Any":
          case "AsyncIterator":
          case "BigInt":
          case "Boolean":
          case "Function":
          case "Integer":
          case "Iterator":
          case "Literal":
          case "Not":
          case "Null":
          case "Number":
          case "Promise":
          case "String":
          case "TemplateLiteral":
          case "Undefined":
          case "Unknown":
          case "Void":
            return Default(schema_, references_, value);
          default:
            if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
              throw new ValueCastUnknownTypeError(schema_);
            return Default(schema_, references_, value);
        }
      }
      function Cast(...args) {
        return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
      }
      exports.Cast = Cast;
    }
  });

  // ../node_modules/@sinclair/typebox/value/convert.js
  var require_convert = __commonJS({
    "../node_modules/@sinclair/typebox/value/convert.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Convert = exports.Default = exports.ValueConvertUnknownTypeError = void 0;
      var guard_1 = require_guard();
      var clone_1 = require_clone();
      var check_1 = require_check();
      var deref_1 = require_deref();
      var Types2 = require_typebox();
      var ValueConvertUnknownTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Unknown type");
          this.schema = schema;
        }
      };
      exports.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;
      function IsStringNumeric(value) {
        return (0, guard_1.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
      }
      function IsValueToString(value) {
        return (0, guard_1.IsBigInt)(value) || (0, guard_1.IsBoolean)(value) || (0, guard_1.IsNumber)(value);
      }
      function IsValueTrue(value) {
        return value === true || (0, guard_1.IsNumber)(value) && value === 1 || (0, guard_1.IsBigInt)(value) && value === BigInt("1") || (0, guard_1.IsString)(value) && (value.toLowerCase() === "true" || value === "1");
      }
      function IsValueFalse(value) {
        return value === false || (0, guard_1.IsNumber)(value) && (value === 0 || Object.is(value, -0)) || (0, guard_1.IsBigInt)(value) && value === BigInt("0") || (0, guard_1.IsString)(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
      }
      function IsTimeStringWithTimeZone(value) {
        return (0, guard_1.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
      }
      function IsTimeStringWithoutTimeZone(value) {
        return (0, guard_1.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
      }
      function IsDateTimeStringWithTimeZone(value) {
        return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
      }
      function IsDateTimeStringWithoutTimeZone(value) {
        return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
      }
      function IsDateString(value) {
        return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
      }
      function TryConvertLiteralString(value, target) {
        const conversion = TryConvertString(value);
        return conversion === target ? conversion : value;
      }
      function TryConvertLiteralNumber(value, target) {
        const conversion = TryConvertNumber(value);
        return conversion === target ? conversion : value;
      }
      function TryConvertLiteralBoolean(value, target) {
        const conversion = TryConvertBoolean(value);
        return conversion === target ? conversion : value;
      }
      function TryConvertLiteral(schema, value) {
        if (typeof schema.const === "string") {
          return TryConvertLiteralString(value, schema.const);
        } else if (typeof schema.const === "number") {
          return TryConvertLiteralNumber(value, schema.const);
        } else if (typeof schema.const === "boolean") {
          return TryConvertLiteralBoolean(value, schema.const);
        } else {
          return (0, clone_1.Clone)(value);
        }
      }
      function TryConvertBoolean(value) {
        return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
      }
      function TryConvertBigInt(value) {
        return IsStringNumeric(value) ? BigInt(parseInt(value)) : (0, guard_1.IsNumber)(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
      }
      function TryConvertString(value) {
        return IsValueToString(value) ? value.toString() : (0, guard_1.IsSymbol)(value) && value.description !== void 0 ? value.description.toString() : value;
      }
      function TryConvertNumber(value) {
        return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
      }
      function TryConvertInteger(value) {
        return IsStringNumeric(value) ? parseInt(value) : (0, guard_1.IsNumber)(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
      }
      function TryConvertNull(value) {
        return (0, guard_1.IsString)(value) && value.toLowerCase() === "null" ? null : value;
      }
      function TryConvertUndefined(value) {
        return (0, guard_1.IsString)(value) && value === "undefined" ? void 0 : value;
      }
      function TryConvertDate(value) {
        return (0, guard_1.IsDate)(value) ? value : (0, guard_1.IsNumber)(value) ? new Date(value) : IsValueTrue(value) ? /* @__PURE__ */ new Date(1) : IsValueFalse(value) ? /* @__PURE__ */ new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? /* @__PURE__ */ new Date(`${value}T00:00:00.000Z`) : value;
      }
      function Default(value) {
        return value;
      }
      exports.Default = Default;
      function TArray(schema, references, value) {
        if ((0, guard_1.IsArray)(value)) {
          return value.map((value2) => Visit(schema.items, references, value2));
        }
        return value;
      }
      function TBigInt(schema, references, value) {
        return TryConvertBigInt(value);
      }
      function TBoolean(schema, references, value) {
        return TryConvertBoolean(value);
      }
      function TDate(schema, references, value) {
        return TryConvertDate(value);
      }
      function TInteger(schema, references, value) {
        return TryConvertInteger(value);
      }
      function TIntersect(schema, references, value) {
        return schema.allOf.every((schema2) => Types2.TypeGuard.TObject(schema2)) ? Visit(Types2.Type.Composite(schema.allOf), references, value) : Visit(schema.allOf[0], references, value);
      }
      function TLiteral(schema, references, value) {
        return TryConvertLiteral(schema, value);
      }
      function TNull(schema, references, value) {
        return TryConvertNull(value);
      }
      function TNumber(schema, references, value) {
        return TryConvertNumber(value);
      }
      function TObject(schema, references, value) {
        if ((0, guard_1.IsObject)(value))
          return Object.getOwnPropertyNames(schema.properties).reduce((acc, key) => {
            return value[key] !== void 0 ? { ...acc, [key]: Visit(schema.properties[key], references, value[key]) } : { ...acc };
          }, value);
        return value;
      }
      function TRecord(schema, references, value) {
        const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
        const property = schema.patternProperties[propertyKey];
        const result = {};
        for (const [propKey, propValue] of Object.entries(value)) {
          result[propKey] = Visit(property, references, propValue);
        }
        return result;
      }
      function TRef(schema, references, value) {
        return Visit((0, deref_1.Deref)(schema, references), references, value);
      }
      function TString(schema, references, value) {
        return TryConvertString(value);
      }
      function TSymbol(schema, references, value) {
        return (0, guard_1.IsString)(value) || (0, guard_1.IsNumber)(value) ? Symbol(value) : value;
      }
      function TThis(schema, references, value) {
        return Visit((0, deref_1.Deref)(schema, references), references, value);
      }
      function TTuple(schema, references, value) {
        if ((0, guard_1.IsArray)(value) && !(0, guard_1.IsUndefined)(schema.items)) {
          return value.map((value2, index) => {
            return index < schema.items.length ? Visit(schema.items[index], references, value2) : value2;
          });
        }
        return value;
      }
      function TUndefined(schema, references, value) {
        return TryConvertUndefined(value);
      }
      function TUnion(schema, references, value) {
        for (const subschema of schema.anyOf) {
          const converted = Visit(subschema, references, value);
          if ((0, check_1.Check)(subschema, references, converted)) {
            return converted;
          }
        }
        return value;
      }
      function Visit(schema, references, value) {
        const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema[Types2.Kind]) {
          case "Array":
            return TArray(schema_, references_, value);
          case "BigInt":
            return TBigInt(schema_, references_, value);
          case "Boolean":
            return TBoolean(schema_, references_, value);
          case "Date":
            return TDate(schema_, references_, value);
          case "Integer":
            return TInteger(schema_, references_, value);
          case "Intersect":
            return TIntersect(schema_, references_, value);
          case "Literal":
            return TLiteral(schema_, references_, value);
          case "Null":
            return TNull(schema_, references_, value);
          case "Number":
            return TNumber(schema_, references_, value);
          case "Object":
            return TObject(schema_, references_, value);
          case "Record":
            return TRecord(schema_, references_, value);
          case "Ref":
            return TRef(schema_, references_, value);
          case "String":
            return TString(schema_, references_, value);
          case "Symbol":
            return TSymbol(schema_, references_, value);
          case "This":
            return TThis(schema_, references_, value);
          case "Tuple":
            return TTuple(schema_, references_, value);
          case "Undefined":
            return TUndefined(schema_, references_, value);
          case "Union":
            return TUnion(schema_, references_, value);
          case "Any":
          case "AsyncIterator":
          case "Constructor":
          case "Function":
          case "Iterator":
          case "Never":
          case "Promise":
          case "TemplateLiteral":
          case "Uint8Array":
          case "Unknown":
          case "Void":
            return Default(value);
          default:
            if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
              throw new ValueConvertUnknownTypeError(schema_);
            return Default(value);
        }
      }
      function Convert(...args) {
        return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
      }
      exports.Convert = Convert;
    }
  });

  // ../node_modules/@sinclair/typebox/value/transform.js
  var require_transform = __commonJS({
    "../node_modules/@sinclair/typebox/value/transform.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EncodeTransform = exports.DecodeTransform = exports.HasTransform = exports.TransformEncodeError = exports.TransformDecodeError = exports.TransformEncodeCheckError = exports.TransformDecodeCheckError = exports.TransformUnknownTypeError = void 0;
      var guard_1 = require_guard();
      var deref_1 = require_deref();
      var Types2 = require_typebox();
      var TransformUnknownTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super(`Unknown type`);
          this.schema = schema;
        }
      };
      exports.TransformUnknownTypeError = TransformUnknownTypeError;
      var TransformDecodeCheckError = class extends Types2.TypeBoxError {
        constructor(schema, value, error) {
          super(`Unable to decode due to invalid value`);
          this.schema = schema;
          this.value = value;
          this.error = error;
        }
      };
      exports.TransformDecodeCheckError = TransformDecodeCheckError;
      var TransformEncodeCheckError = class extends Types2.TypeBoxError {
        constructor(schema, value, error) {
          super(`Unable to encode due to invalid value`);
          this.schema = schema;
          this.value = value;
          this.error = error;
        }
      };
      exports.TransformEncodeCheckError = TransformEncodeCheckError;
      var TransformDecodeError = class extends Types2.TypeBoxError {
        constructor(schema, value, error) {
          super(`${error instanceof Error ? error.message : "Unknown error"}`);
          this.schema = schema;
          this.value = value;
        }
      };
      exports.TransformDecodeError = TransformDecodeError;
      var TransformEncodeError = class extends Types2.TypeBoxError {
        constructor(schema, value, error) {
          super(`${error instanceof Error ? error.message : "Unknown error"}`);
          this.schema = schema;
          this.value = value;
        }
      };
      exports.TransformEncodeError = TransformEncodeError;
      var HasTransform;
      (function(HasTransform2) {
        function TArray(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Visit(schema.items, references);
        }
        function TAsyncIterator(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Visit(schema.items, references);
        }
        function TConstructor(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
        }
        function TFunction(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
        }
        function TIntersect(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Types2.TypeGuard.TTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit(schema2, references));
        }
        function TIterator(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Visit(schema.items, references);
        }
        function TNot(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Visit(schema.not, references);
        }
        function TObject(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Object.values(schema.properties).some((schema2) => Visit(schema2, references)) || Types2.TypeGuard.TSchema(schema.additionalProperties) && Visit(schema.additionalProperties, references);
        }
        function TPromise(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Visit(schema.item, references);
        }
        function TRecord(schema, references) {
          const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
          const property = schema.patternProperties[pattern];
          return Types2.TypeGuard.TTransform(schema) || Visit(property, references) || Types2.TypeGuard.TSchema(schema.additionalProperties) && Types2.TypeGuard.TTransform(schema.additionalProperties);
        }
        function TRef(schema, references) {
          if (Types2.TypeGuard.TTransform(schema))
            return true;
          return Visit((0, deref_1.Deref)(schema, references), references);
        }
        function TThis(schema, references) {
          if (Types2.TypeGuard.TTransform(schema))
            return true;
          return Visit((0, deref_1.Deref)(schema, references), references);
        }
        function TTuple(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || Types2.TypeGuard.TSchema(schema.items) && schema.items.some((schema2) => Visit(schema2, references));
        }
        function TUnion(schema, references) {
          return Types2.TypeGuard.TTransform(schema) || schema.anyOf.some((schema2) => Visit(schema2, references));
        }
        function Visit(schema, references) {
          const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
          const schema_ = schema;
          if (schema.$id && visited.has(schema.$id))
            return false;
          if (schema.$id)
            visited.add(schema.$id);
          switch (schema[Types2.Kind]) {
            case "Array":
              return TArray(schema_, references_);
            case "AsyncIterator":
              return TAsyncIterator(schema_, references_);
            case "Constructor":
              return TConstructor(schema_, references_);
            case "Function":
              return TFunction(schema_, references_);
            case "Intersect":
              return TIntersect(schema_, references_);
            case "Iterator":
              return TIterator(schema_, references_);
            case "Not":
              return TNot(schema_, references_);
            case "Object":
              return TObject(schema_, references_);
            case "Promise":
              return TPromise(schema_, references_);
            case "Record":
              return TRecord(schema_, references_);
            case "Ref":
              return TRef(schema_, references_);
            case "This":
              return TThis(schema_, references_);
            case "Tuple":
              return TTuple(schema_, references_);
            case "Union":
              return TUnion(schema_, references_);
            case "Any":
            case "BigInt":
            case "Boolean":
            case "Date":
            case "Integer":
            case "Literal":
            case "Never":
            case "Null":
            case "Number":
            case "String":
            case "Symbol":
            case "TemplateLiteral":
            case "Undefined":
            case "Uint8Array":
            case "Unknown":
            case "Void":
              return Types2.TypeGuard.TTransform(schema);
            default:
              if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
                throw new TransformUnknownTypeError(schema_);
              return Types2.TypeGuard.TTransform(schema);
          }
        }
        const visited = /* @__PURE__ */ new Set();
        function Has(schema, references) {
          visited.clear();
          return Visit(schema, references);
        }
        HasTransform2.Has = Has;
      })(HasTransform || (exports.HasTransform = HasTransform = {}));
      var DecodeTransform;
      (function(DecodeTransform2) {
        function Default(schema, value) {
          try {
            return Types2.TypeGuard.TTransform(schema) ? schema[Types2.Transform].Decode(value) : value;
          } catch (error) {
            throw new TransformDecodeError(schema, value, error);
          }
        }
        function TArray(schema, references, value) {
          const elements1 = value.map((value2) => Visit(schema.items, references, value2));
          return Default(schema, elements1);
        }
        function TIntersect(schema, references, value) {
          if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))
            return Default(schema, value);
          const keys2 = Types2.KeyResolver.ResolveKeys(schema, { includePatterns: false });
          const properties1 = Object.entries(value).reduce((acc, [key, value2]) => {
            return !keys2.includes(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Default(Types2.IndexedAccessor.Resolve(schema, [key]), value2) };
          }, {});
          if (!Types2.TypeGuard.TTransform(schema.unevaluatedProperties))
            return Default(schema, properties1);
          const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
            return keys2.includes(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Default(schema.unevaluatedProperties, value2) };
          }, {});
          return Default(schema, properties2);
        }
        function TNot(schema, references, value) {
          const value1 = Visit(schema.not, references, value);
          return Default(schema, value1);
        }
        function TObject(schema, references, value) {
          if (!(0, guard_1.IsPlainObject)(value))
            return Default(schema, value);
          const properties1 = Object.entries(value).reduce((acc, [key, value2]) => {
            return !(key in schema.properties) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(schema.properties[key], references, value2) };
          }, {});
          if (!Types2.TypeGuard.TSchema(schema.additionalProperties))
            return Default(schema, properties1);
          const additionalProperties = schema.additionalProperties;
          const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
            return key in schema.properties ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(additionalProperties, references, value2) };
          }, {});
          return Default(schema, properties2);
        }
        function TRecord(schema, references, value) {
          if (!(0, guard_1.IsPlainObject)(value))
            return Default(schema, value);
          const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
          const property = schema.patternProperties[pattern];
          const regex = new RegExp(pattern);
          const properties1 = Object.entries(value).reduce((acc, [key, value2]) => {
            return !regex.test(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(property, references, value2) };
          }, {});
          if (!Types2.TypeGuard.TSchema(schema.additionalProperties))
            return Default(schema, properties1);
          const additionalProperties = schema.additionalProperties;
          const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
            return regex.test(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(additionalProperties, references, value2) };
          }, {});
          return Default(schema, properties2);
        }
        function TRef(schema, references, value) {
          const target = (0, deref_1.Deref)(schema, references);
          const resolved = Visit(target, references, value);
          return Default(schema, resolved);
        }
        function TThis(schema, references, value) {
          const target = (0, deref_1.Deref)(schema, references);
          const resolved = Visit(target, references, value);
          return Default(schema, resolved);
        }
        function TTuple(schema, references, value) {
          const value1 = (0, guard_1.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit(schema2, references, value[index])) : [];
          return Default(schema, value1);
        }
        function TUnion(schema, references, value) {
          const value1 = Default(schema, value);
          for (const subschema of schema.anyOf) {
            if (!checkFunction(subschema, references, value1))
              continue;
            return Visit(subschema, references, value1);
          }
          return value1;
        }
        function Visit(schema, references, value) {
          const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
          const schema_ = schema;
          switch (schema[Types2.Kind]) {
            case "Array":
              return TArray(schema_, references_, value);
            case "Intersect":
              return TIntersect(schema_, references_, value);
            case "Not":
              return TNot(schema_, references_, value);
            case "Object":
              return TObject(schema_, references_, value);
            case "Record":
              return TRecord(schema_, references_, value);
            case "Ref":
              return TRef(schema_, references_, value);
            case "Symbol":
              return Default(schema_, value);
            case "This":
              return TThis(schema_, references_, value);
            case "Tuple":
              return TTuple(schema_, references_, value);
            case "Union":
              return TUnion(schema_, references_, value);
            case "Any":
            case "AsyncIterator":
            case "BigInt":
            case "Boolean":
            case "Constructor":
            case "Date":
            case "Function":
            case "Integer":
            case "Iterator":
            case "Literal":
            case "Never":
            case "Null":
            case "Number":
            case "Promise":
            case "String":
            case "TemplateLiteral":
            case "Undefined":
            case "Uint8Array":
            case "Unknown":
            case "Void":
              return Default(schema_, value);
            default:
              if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
                throw new TransformUnknownTypeError(schema_);
              return Default(schema_, value);
          }
        }
        let checkFunction = () => false;
        function Decode(schema, references, value, check) {
          checkFunction = check;
          return Visit(schema, references, value);
        }
        DecodeTransform2.Decode = Decode;
      })(DecodeTransform || (exports.DecodeTransform = DecodeTransform = {}));
      var EncodeTransform;
      (function(EncodeTransform2) {
        function Default(schema, value) {
          try {
            return Types2.TypeGuard.TTransform(schema) ? schema[Types2.Transform].Encode(value) : value;
          } catch (error) {
            throw new TransformEncodeError(schema, value, error);
          }
        }
        function TArray(schema, references, value) {
          const elements1 = Default(schema, value);
          return elements1.map((value2) => Visit(schema.items, references, value2));
        }
        function TIntersect(schema, references, value) {
          const properties1 = Default(schema, value);
          if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))
            return properties1;
          const keys2 = Types2.KeyResolver.ResolveKeys(schema, { includePatterns: false });
          const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
            return !keys2.includes(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Default(Types2.IndexedAccessor.Resolve(schema, [key]), value2) };
          }, {});
          if (!Types2.TypeGuard.TTransform(schema.unevaluatedProperties))
            return Default(schema, properties2);
          return Object.entries(properties2).reduce((acc, [key, value2]) => {
            return keys2.includes(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Default(schema.unevaluatedProperties, value2) };
          }, {});
        }
        function TNot(schema, references, value) {
          const value1 = Default(schema, value);
          return Default(schema.not, value1);
        }
        function TObject(schema, references, value) {
          const properties1 = Default(schema, value);
          if (!(0, guard_1.IsPlainObject)(value))
            return properties1;
          const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
            return !(key in schema.properties) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(schema.properties[key], references, value2) };
          }, {});
          if (!Types2.TypeGuard.TSchema(schema.additionalProperties))
            return properties2;
          const additionalProperties = schema.additionalProperties;
          return Object.entries(properties2).reduce((acc, [key, value2]) => {
            return key in schema.properties ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(additionalProperties, references, value2) };
          }, {});
        }
        function TRecord(schema, references, value) {
          const properties1 = Default(schema, value);
          if (!(0, guard_1.IsPlainObject)(value))
            return properties1;
          const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
          const property = schema.patternProperties[pattern];
          const regex = new RegExp(pattern);
          const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
            return !regex.test(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(property, references, value2) };
          }, {});
          if (!Types2.TypeGuard.TSchema(schema.additionalProperties))
            return Default(schema, properties2);
          const additionalProperties = schema.additionalProperties;
          return Object.entries(properties2).reduce((acc, [key, value2]) => {
            return regex.test(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(additionalProperties, references, value2) };
          }, {});
        }
        function TRef(schema, references, value) {
          const target = (0, deref_1.Deref)(schema, references);
          const resolved = Visit(target, references, value);
          return Default(schema, resolved);
        }
        function TThis(schema, references, value) {
          const target = (0, deref_1.Deref)(schema, references);
          const resolved = Visit(target, references, value);
          return Default(schema, resolved);
        }
        function TTuple(schema, references, value) {
          const value1 = Default(schema, value);
          return (0, guard_1.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit(schema2, references, value1[index])) : [];
        }
        function TUnion(schema, references, value) {
          for (const subschema of schema.anyOf) {
            if (!checkFunction(subschema, references, value))
              continue;
            const value1 = Visit(subschema, references, value);
            return Default(schema, value1);
          }
          for (const subschema of schema.anyOf) {
            const value1 = Visit(subschema, references, value);
            if (!checkFunction(schema, references, value1))
              continue;
            return Default(schema, value1);
          }
          return Default(schema, value);
        }
        function Visit(schema, references, value) {
          const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
          const schema_ = schema;
          switch (schema[Types2.Kind]) {
            case "Array":
              return TArray(schema_, references_, value);
            case "Intersect":
              return TIntersect(schema_, references_, value);
            case "Not":
              return TNot(schema_, references_, value);
            case "Object":
              return TObject(schema_, references_, value);
            case "Record":
              return TRecord(schema_, references_, value);
            case "Ref":
              return TRef(schema_, references_, value);
            case "This":
              return TThis(schema_, references_, value);
            case "Tuple":
              return TTuple(schema_, references_, value);
            case "Union":
              return TUnion(schema_, references_, value);
            case "Any":
            case "AsyncIterator":
            case "BigInt":
            case "Boolean":
            case "Constructor":
            case "Date":
            case "Function":
            case "Integer":
            case "Iterator":
            case "Literal":
            case "Never":
            case "Null":
            case "Number":
            case "Promise":
            case "String":
            case "Symbol":
            case "TemplateLiteral":
            case "Undefined":
            case "Uint8Array":
            case "Unknown":
            case "Void":
              return Default(schema_, value);
            default:
              if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
                throw new TransformUnknownTypeError(schema_);
              return Default(schema_, value);
          }
        }
        let checkFunction = () => false;
        function Encode(schema, references, value, check) {
          checkFunction = check;
          return Visit(schema, references, value);
        }
        EncodeTransform2.Encode = Encode;
      })(EncodeTransform || (exports.EncodeTransform = EncodeTransform = {}));
    }
  });

  // ../node_modules/@sinclair/typebox/value/value.js
  var require_value = __commonJS({
    "../node_modules/@sinclair/typebox/value/value.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Value = void 0;
      var ValueErrors = require_errors2();
      var ValueMutate = require_mutate();
      var ValueHash = require_hash();
      var ValueEqual = require_equal();
      var ValueCast = require_cast();
      var ValueClone = require_clone();
      var ValueConvert = require_convert();
      var ValueCreate = require_create();
      var ValueCheck = require_check();
      var ValueDelta = require_delta();
      var ValueTransform = require_transform();
      var Value;
      (function(Value2) {
        function Cast(...args) {
          return ValueCast.Cast.apply(ValueCast, args);
        }
        Value2.Cast = Cast;
        function Create(...args) {
          return ValueCreate.Create.apply(ValueCreate, args);
        }
        Value2.Create = Create;
        function Check(...args) {
          return ValueCheck.Check.apply(ValueCheck, args);
        }
        Value2.Check = Check;
        function Convert(...args) {
          return ValueConvert.Convert.apply(ValueConvert, args);
        }
        Value2.Convert = Convert;
        function Clone(value) {
          return ValueClone.Clone(value);
        }
        Value2.Clone = Clone;
        function Decode(...args) {
          const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
          if (!Check(schema, references, value))
            throw new ValueTransform.TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
          return ValueTransform.DecodeTransform.Decode(schema, references, value, ValueCheck.Check);
        }
        Value2.Decode = Decode;
        function Encode(...args) {
          const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
          const encoded = ValueTransform.EncodeTransform.Encode(schema, references, value, ValueCheck.Check);
          if (!Check(schema, references, encoded))
            throw new ValueTransform.TransformEncodeCheckError(schema, value, Errors(schema, references, value).First());
          return encoded;
        }
        Value2.Encode = Encode;
        function Errors(...args) {
          return ValueErrors.Errors.apply(ValueErrors, args);
        }
        Value2.Errors = Errors;
        function Equal(left, right) {
          return ValueEqual.Equal(left, right);
        }
        Value2.Equal = Equal;
        function Diff(current, next) {
          return ValueDelta.Diff(current, next);
        }
        Value2.Diff = Diff;
        function Hash(value) {
          return ValueHash.Hash(value);
        }
        Value2.Hash = Hash;
        function Patch(current, edits) {
          return ValueDelta.Patch(current, edits);
        }
        Value2.Patch = Patch;
        function Mutate(current, next) {
          ValueMutate.Mutate(current, next);
        }
        Value2.Mutate = Mutate;
      })(Value || (exports.Value = Value = {}));
    }
  });

  // ../node_modules/@sinclair/typebox/value/index.js
  var require_value2 = __commonJS({
    "../node_modules/@sinclair/typebox/value/index.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Value = exports.ValuePointer = exports.Delete = exports.Update = exports.Insert = exports.Edit = exports.ValueErrorIterator = exports.ValueErrorType = void 0;
      var index_1 = require_errors2();
      Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
        return index_1.ValueErrorType;
      } });
      Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
        return index_1.ValueErrorIterator;
      } });
      var delta_1 = require_delta();
      Object.defineProperty(exports, "Edit", { enumerable: true, get: function() {
        return delta_1.Edit;
      } });
      Object.defineProperty(exports, "Insert", { enumerable: true, get: function() {
        return delta_1.Insert;
      } });
      Object.defineProperty(exports, "Update", { enumerable: true, get: function() {
        return delta_1.Update;
      } });
      Object.defineProperty(exports, "Delete", { enumerable: true, get: function() {
        return delta_1.Delete;
      } });
      var pointer_1 = require_pointer();
      Object.defineProperty(exports, "ValuePointer", { enumerable: true, get: function() {
        return pointer_1.ValuePointer;
      } });
      var value_1 = require_value();
      Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
        return value_1.Value;
      } });
    }
  });

  // ../node_modules/cookie/index.js
  var require_cookie = __commonJS({
    "../node_modules/cookie/index.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      exports.parse = parse;
      exports.serialize = serialize;
      var __toString = Object.prototype.toString;
      var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
      function parse(str, options) {
        if (typeof str !== "string") {
          throw new TypeError("argument str must be a string");
        }
        var obj = {};
        var opt = options || {};
        var dec = opt.decode || decode;
        var index = 0;
        while (index < str.length) {
          var eqIdx = str.indexOf("=", index);
          if (eqIdx === -1) {
            break;
          }
          var endIdx = str.indexOf(";", index);
          if (endIdx === -1) {
            endIdx = str.length;
          } else if (endIdx < eqIdx) {
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
          }
          var key = str.slice(index, eqIdx).trim();
          if (void 0 === obj[key]) {
            var val = str.slice(eqIdx + 1, endIdx).trim();
            if (val.charCodeAt(0) === 34) {
              val = val.slice(1, -1);
            }
            obj[key] = tryDecode(val, dec);
          }
          index = endIdx + 1;
        }
        return obj;
      }
      function serialize(name, val, options) {
        var opt = options || {};
        var enc = opt.encode || encode3;
        if (typeof enc !== "function") {
          throw new TypeError("option encode is invalid");
        }
        if (!fieldContentRegExp.test(name)) {
          throw new TypeError("argument name is invalid");
        }
        var value = enc(val);
        if (value && !fieldContentRegExp.test(value)) {
          throw new TypeError("argument val is invalid");
        }
        var str = name + "=" + value;
        if (null != opt.maxAge) {
          var maxAge = opt.maxAge - 0;
          if (isNaN(maxAge) || !isFinite(maxAge)) {
            throw new TypeError("option maxAge is invalid");
          }
          str += "; Max-Age=" + Math.floor(maxAge);
        }
        if (opt.domain) {
          if (!fieldContentRegExp.test(opt.domain)) {
            throw new TypeError("option domain is invalid");
          }
          str += "; Domain=" + opt.domain;
        }
        if (opt.path) {
          if (!fieldContentRegExp.test(opt.path)) {
            throw new TypeError("option path is invalid");
          }
          str += "; Path=" + opt.path;
        }
        if (opt.expires) {
          var expires = opt.expires;
          if (!isDate3(expires) || isNaN(expires.valueOf())) {
            throw new TypeError("option expires is invalid");
          }
          str += "; Expires=" + expires.toUTCString();
        }
        if (opt.httpOnly) {
          str += "; HttpOnly";
        }
        if (opt.secure) {
          str += "; Secure";
        }
        if (opt.priority) {
          var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
          switch (priority) {
            case "low":
              str += "; Priority=Low";
              break;
            case "medium":
              str += "; Priority=Medium";
              break;
            case "high":
              str += "; Priority=High";
              break;
            default:
              throw new TypeError("option priority is invalid");
          }
        }
        if (opt.sameSite) {
          var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
          switch (sameSite) {
            case true:
              str += "; SameSite=Strict";
              break;
            case "lax":
              str += "; SameSite=Lax";
              break;
            case "strict":
              str += "; SameSite=Strict";
              break;
            case "none":
              str += "; SameSite=None";
              break;
            default:
              throw new TypeError("option sameSite is invalid");
          }
        }
        return str;
      }
      function decode(str) {
        return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
      }
      function encode3(val) {
        return encodeURIComponent(val);
      }
      function isDate3(val) {
        return __toString.call(val) === "[object Date]" || val instanceof Date;
      }
      function tryDecode(str, decode2) {
        try {
          return decode2(str);
        } catch (e8) {
          return str;
        }
      }
    }
  });

  // ../node_modules/@sinclair/typebox/compiler/compiler.js
  var require_compiler = __commonJS({
    "../node_modules/@sinclair/typebox/compiler/compiler.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = void 0;
      var transform_1 = require_transform();
      var guard_1 = require_guard();
      var errors_1 = require_errors();
      var index_1 = require_system2();
      var deref_1 = require_deref();
      var hash_1 = require_hash();
      var Types2 = require_typebox();
      var TypeCheck = class {
        constructor(schema, references, checkFunc, code) {
          this.schema = schema;
          this.references = references;
          this.checkFunc = checkFunc;
          this.code = code;
          this.hasTransform = transform_1.HasTransform.Has(schema, references);
        }
        /** Returns the generated assertion code used to validate this type. */
        Code() {
          return this.code;
        }
        /** Returns an iterator for each error in this value. */
        Errors(value) {
          return (0, errors_1.Errors)(this.schema, this.references, value);
        }
        /** Returns true if the value matches the compiled type. */
        Check(value) {
          return this.checkFunc(value);
        }
        /** Decodes a value or throws if error */
        Decode(value) {
          if (!this.checkFunc(value))
            throw new transform_1.TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
          return this.hasTransform ? transform_1.DecodeTransform.Decode(this.schema, this.references, value, (_, __, value2) => this.Check(value2)) : value;
        }
        /** Encodes a value or throws if error */
        Encode(value) {
          const encoded = this.hasTransform ? transform_1.EncodeTransform.Encode(this.schema, this.references, value, (_, __, value2) => this.Check(value2)) : value;
          if (!this.checkFunc(encoded))
            throw new transform_1.TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
          return encoded;
        }
      };
      exports.TypeCheck = TypeCheck;
      var Character;
      (function(Character2) {
        function DollarSign(code) {
          return code === 36;
        }
        Character2.DollarSign = DollarSign;
        function IsUnderscore(code) {
          return code === 95;
        }
        Character2.IsUnderscore = IsUnderscore;
        function IsAlpha(code) {
          return code >= 65 && code <= 90 || code >= 97 && code <= 122;
        }
        Character2.IsAlpha = IsAlpha;
        function IsNumeric(code) {
          return code >= 48 && code <= 57;
        }
        Character2.IsNumeric = IsNumeric;
      })(Character || (Character = {}));
      var MemberExpression;
      (function(MemberExpression2) {
        function IsFirstCharacterNumeric(value) {
          if (value.length === 0)
            return false;
          return Character.IsNumeric(value.charCodeAt(0));
        }
        function IsAccessor(value) {
          if (IsFirstCharacterNumeric(value))
            return false;
          for (let i2 = 0; i2 < value.length; i2++) {
            const code = value.charCodeAt(i2);
            const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
            if (!check)
              return false;
          }
          return true;
        }
        function EscapeHyphen(key) {
          return key.replace(/'/g, "\\'");
        }
        function Encode(object, key) {
          return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
        }
        MemberExpression2.Encode = Encode;
      })(MemberExpression || (MemberExpression = {}));
      var Identifier;
      (function(Identifier2) {
        function Encode($id) {
          const buffer = [];
          for (let i2 = 0; i2 < $id.length; i2++) {
            const code = $id.charCodeAt(i2);
            if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
              buffer.push($id.charAt(i2));
            } else {
              buffer.push(`_${code}_`);
            }
          }
          return buffer.join("").replace(/__/g, "_");
        }
        Identifier2.Encode = Encode;
      })(Identifier || (Identifier = {}));
      var LiteralString;
      (function(LiteralString2) {
        function Escape(content) {
          return content.replace(/'/g, "\\'");
        }
        LiteralString2.Escape = Escape;
      })(LiteralString || (LiteralString = {}));
      var TypeCompilerUnknownTypeError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Unknown type");
          this.schema = schema;
        }
      };
      exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
      var TypeCompilerTypeGuardError = class extends Types2.TypeBoxError {
        constructor(schema) {
          super("Preflight validation check failed to guard for the given schema");
          this.schema = schema;
        }
      };
      exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
      var Policy;
      (function(Policy2) {
        function IsExactOptionalProperty(value, key, expression) {
          return index_1.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
        }
        Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
        function IsObjectLike(value) {
          return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
        }
        Policy2.IsObjectLike = IsObjectLike;
        function IsRecordLike(value) {
          return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
        }
        Policy2.IsRecordLike = IsRecordLike;
        function IsNumberLike(value) {
          return !index_1.TypeSystemPolicy.AllowNaN ? `(typeof ${value} === 'number' && Number.isFinite(${value}))` : `typeof ${value} === 'number'`;
        }
        Policy2.IsNumberLike = IsNumberLike;
        function IsVoidLike(value) {
          return index_1.TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
        }
        Policy2.IsVoidLike = IsVoidLike;
      })(Policy || (exports.Policy = Policy = {}));
      var TypeCompiler;
      (function(TypeCompiler2) {
        function IsAnyOrUnknown(schema) {
          return schema[Types2.Kind] === "Any" || schema[Types2.Kind] === "Unknown";
        }
        function* TAny(schema, references, value) {
          yield "true";
        }
        function* TArray(schema, references, value) {
          yield `Array.isArray(${value})`;
          const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
          if ((0, guard_1.IsNumber)(schema.maxItems))
            yield `${value}.length <= ${schema.maxItems}`;
          if ((0, guard_1.IsNumber)(schema.minItems))
            yield `${value}.length >= ${schema.minItems}`;
          const elementExpression = CreateExpression(schema.items, references, "value");
          yield `${value}.every((${parameter}) => ${elementExpression})`;
          if (Types2.TypeGuard.TSchema(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains)) {
            const containsSchema = Types2.TypeGuard.TSchema(schema.contains) ? schema.contains : Types2.Type.Never();
            const checkExpression = CreateExpression(containsSchema, references, "value");
            const checkMinContains = (0, guard_1.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
            const checkMaxContains = (0, guard_1.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
            const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
            const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
            yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
          }
          if (schema.uniqueItems === true) {
            const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
            const block = `const set = new Set(); for(const element of value) { ${check} }`;
            yield `((${parameter}) => { ${block} )(${value})`;
          }
        }
        function* TAsyncIterator(schema, references, value) {
          yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
        }
        function* TBigInt(schema, references, value) {
          yield `(typeof ${value} === 'bigint')`;
          if ((0, guard_1.IsBigInt)(schema.exclusiveMaximum))
            yield `${value} < BigInt(${schema.exclusiveMaximum})`;
          if ((0, guard_1.IsBigInt)(schema.exclusiveMinimum))
            yield `${value} > BigInt(${schema.exclusiveMinimum})`;
          if ((0, guard_1.IsBigInt)(schema.maximum))
            yield `${value} <= BigInt(${schema.maximum})`;
          if ((0, guard_1.IsBigInt)(schema.minimum))
            yield `${value} >= BigInt(${schema.minimum})`;
          if ((0, guard_1.IsBigInt)(schema.multipleOf))
            yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
        }
        function* TBoolean(schema, references, value) {
          yield `(typeof ${value} === 'boolean')`;
        }
        function* TConstructor(schema, references, value) {
          yield* Visit(schema.returns, references, `${value}.prototype`);
        }
        function* TDate(schema, references, value) {
          yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
          if ((0, guard_1.IsNumber)(schema.exclusiveMaximumTimestamp))
            yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
          if ((0, guard_1.IsNumber)(schema.exclusiveMinimumTimestamp))
            yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
          if ((0, guard_1.IsNumber)(schema.maximumTimestamp))
            yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
          if ((0, guard_1.IsNumber)(schema.minimumTimestamp))
            yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
          if ((0, guard_1.IsNumber)(schema.multipleOfTimestamp))
            yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
        }
        function* TFunction(schema, references, value) {
          yield `(typeof ${value} === 'function')`;
        }
        function* TInteger(schema, references, value) {
          yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;
          if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
            yield `${value} < ${schema.exclusiveMaximum}`;
          if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
            yield `${value} > ${schema.exclusiveMinimum}`;
          if ((0, guard_1.IsNumber)(schema.maximum))
            yield `${value} <= ${schema.maximum}`;
          if ((0, guard_1.IsNumber)(schema.minimum))
            yield `${value} >= ${schema.minimum}`;
          if ((0, guard_1.IsNumber)(schema.multipleOf))
            yield `(${value} % ${schema.multipleOf}) === 0`;
        }
        function* TIntersect(schema, references, value) {
          const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
          if (schema.unevaluatedProperties === false) {
            const keyCheck = CreateVariable(`${new RegExp(Types2.KeyResolver.ResolvePattern(schema))};`);
            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
            yield `(${check1} && ${check2})`;
          } else if (Types2.TypeGuard.TSchema(schema.unevaluatedProperties)) {
            const keyCheck = CreateVariable(`${new RegExp(Types2.KeyResolver.ResolvePattern(schema))};`);
            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
            yield `(${check1} && ${check2})`;
          } else {
            yield `(${check1})`;
          }
        }
        function* TIterator(schema, references, value) {
          yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
        }
        function* TLiteral(schema, references, value) {
          if (typeof schema.const === "number" || typeof schema.const === "boolean") {
            yield `(${value} === ${schema.const})`;
          } else {
            yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
          }
        }
        function* TNever(schema, references, value) {
          yield `false`;
        }
        function* TNot(schema, references, value) {
          const expression = CreateExpression(schema.not, references, value);
          yield `(!${expression})`;
        }
        function* TNull(schema, references, value) {
          yield `(${value} === null)`;
        }
        function* TNumber(schema, references, value) {
          yield Policy.IsNumberLike(value);
          if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
            yield `${value} < ${schema.exclusiveMaximum}`;
          if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
            yield `${value} > ${schema.exclusiveMinimum}`;
          if ((0, guard_1.IsNumber)(schema.maximum))
            yield `${value} <= ${schema.maximum}`;
          if ((0, guard_1.IsNumber)(schema.minimum))
            yield `${value} >= ${schema.minimum}`;
          if ((0, guard_1.IsNumber)(schema.multipleOf))
            yield `(${value} % ${schema.multipleOf}) === 0`;
        }
        function* TObject(schema, references, value) {
          yield Policy.IsObjectLike(value);
          if ((0, guard_1.IsNumber)(schema.minProperties))
            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
          if ((0, guard_1.IsNumber)(schema.maxProperties))
            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
          const knownKeys = Object.getOwnPropertyNames(schema.properties);
          for (const knownKey of knownKeys) {
            const memberExpression = MemberExpression.Encode(value, knownKey);
            const property = schema.properties[knownKey];
            if (schema.required && schema.required.includes(knownKey)) {
              yield* Visit(property, references, memberExpression);
              if (Types2.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property))
                yield `('${knownKey}' in ${value})`;
            } else {
              const expression = CreateExpression(property, references, memberExpression);
              yield Policy.IsExactOptionalProperty(value, knownKey, expression);
            }
          }
          if (schema.additionalProperties === false) {
            if (schema.required && schema.required.length === knownKeys.length) {
              yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
            } else {
              const keys2 = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
              yield `Object.getOwnPropertyNames(${value}).every(key => ${keys2}.includes(key))`;
            }
          }
          if (typeof schema.additionalProperties === "object") {
            const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
            const keys2 = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
            yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys2}.includes(key) || ${expression}))`;
          }
        }
        function* TPromise(schema, references, value) {
          yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
        }
        function* TRecord(schema, references, value) {
          yield Policy.IsRecordLike(value);
          if ((0, guard_1.IsNumber)(schema.minProperties))
            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
          if ((0, guard_1.IsNumber)(schema.maxProperties))
            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
          const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
          const variable = CreateVariable(`${new RegExp(patternKey)}`);
          const check1 = CreateExpression(patternSchema, references, "value");
          const check2 = Types2.TypeGuard.TSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
          const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
          yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
        }
        function* TRef(schema, references, value) {
          const target = (0, deref_1.Deref)(schema, references);
          if (state.functions.has(schema.$ref))
            return yield `${CreateFunctionName(schema.$ref)}(${value})`;
          yield* Visit(target, references, value);
        }
        function* TString(schema, references, value) {
          yield `(typeof ${value} === 'string')`;
          if ((0, guard_1.IsNumber)(schema.maxLength))
            yield `${value}.length <= ${schema.maxLength}`;
          if ((0, guard_1.IsNumber)(schema.minLength))
            yield `${value}.length >= ${schema.minLength}`;
          if (schema.pattern !== void 0) {
            const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
            yield `${variable}.test(${value})`;
          }
          if (schema.format !== void 0) {
            yield `format('${schema.format}', ${value})`;
          }
        }
        function* TSymbol(schema, references, value) {
          yield `(typeof ${value} === 'symbol')`;
        }
        function* TTemplateLiteral(schema, references, value) {
          yield `(typeof ${value} === 'string')`;
          const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
          yield `${variable}.test(${value})`;
        }
        function* TThis(schema, references, value) {
          yield `${CreateFunctionName(schema.$ref)}(${value})`;
        }
        function* TTuple(schema, references, value) {
          yield `Array.isArray(${value})`;
          if (schema.items === void 0)
            return yield `${value}.length === 0`;
          yield `(${value}.length === ${schema.maxItems})`;
          for (let i2 = 0; i2 < schema.items.length; i2++) {
            const expression = CreateExpression(schema.items[i2], references, `${value}[${i2}]`);
            yield `${expression}`;
          }
        }
        function* TUndefined(schema, references, value) {
          yield `${value} === undefined`;
        }
        function* TUnion(schema, references, value) {
          const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
          yield `(${expressions.join(" || ")})`;
        }
        function* TUint8Array(schema, references, value) {
          yield `${value} instanceof Uint8Array`;
          if ((0, guard_1.IsNumber)(schema.maxByteLength))
            yield `(${value}.length <= ${schema.maxByteLength})`;
          if ((0, guard_1.IsNumber)(schema.minByteLength))
            yield `(${value}.length >= ${schema.minByteLength})`;
        }
        function* TUnknown(schema, references, value) {
          yield "true";
        }
        function* TVoid(schema, references, value) {
          yield Policy.IsVoidLike(value);
        }
        function* TKind(schema, references, value) {
          const instance = state.instances.size;
          state.instances.set(instance, schema);
          yield `kind('${schema[Types2.Kind]}', ${instance}, ${value})`;
        }
        function* Visit(schema, references, value, useHoisting = true) {
          const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
          const schema_ = schema;
          if (useHoisting && (0, guard_1.IsString)(schema.$id)) {
            const functionName = CreateFunctionName(schema.$id);
            if (state.functions.has(functionName)) {
              return yield `${functionName}(${value})`;
            } else {
              const functionCode = CreateFunction(functionName, schema, references, "value", false);
              state.functions.set(functionName, functionCode);
              return yield `${functionName}(${value})`;
            }
          }
          switch (schema_[Types2.Kind]) {
            case "Any":
              return yield* TAny(schema_, references_, value);
            case "Array":
              return yield* TArray(schema_, references_, value);
            case "AsyncIterator":
              return yield* TAsyncIterator(schema_, references_, value);
            case "BigInt":
              return yield* TBigInt(schema_, references_, value);
            case "Boolean":
              return yield* TBoolean(schema_, references_, value);
            case "Constructor":
              return yield* TConstructor(schema_, references_, value);
            case "Date":
              return yield* TDate(schema_, references_, value);
            case "Function":
              return yield* TFunction(schema_, references_, value);
            case "Integer":
              return yield* TInteger(schema_, references_, value);
            case "Intersect":
              return yield* TIntersect(schema_, references_, value);
            case "Iterator":
              return yield* TIterator(schema_, references_, value);
            case "Literal":
              return yield* TLiteral(schema_, references_, value);
            case "Never":
              return yield* TNever(schema_, references_, value);
            case "Not":
              return yield* TNot(schema_, references_, value);
            case "Null":
              return yield* TNull(schema_, references_, value);
            case "Number":
              return yield* TNumber(schema_, references_, value);
            case "Object":
              return yield* TObject(schema_, references_, value);
            case "Promise":
              return yield* TPromise(schema_, references_, value);
            case "Record":
              return yield* TRecord(schema_, references_, value);
            case "Ref":
              return yield* TRef(schema_, references_, value);
            case "String":
              return yield* TString(schema_, references_, value);
            case "Symbol":
              return yield* TSymbol(schema_, references_, value);
            case "TemplateLiteral":
              return yield* TTemplateLiteral(schema_, references_, value);
            case "This":
              return yield* TThis(schema_, references_, value);
            case "Tuple":
              return yield* TTuple(schema_, references_, value);
            case "Undefined":
              return yield* TUndefined(schema_, references_, value);
            case "Union":
              return yield* TUnion(schema_, references_, value);
            case "Uint8Array":
              return yield* TUint8Array(schema_, references_, value);
            case "Unknown":
              return yield* TUnknown(schema_, references_, value);
            case "Void":
              return yield* TVoid(schema_, references_, value);
            default:
              if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
                throw new TypeCompilerUnknownTypeError(schema);
              return yield* TKind(schema_, references_, value);
          }
        }
        const state = {
          language: "javascript",
          functions: /* @__PURE__ */ new Map(),
          variables: /* @__PURE__ */ new Map(),
          instances: /* @__PURE__ */ new Map()
          // exterior kind instances
        };
        function CreateExpression(schema, references, value, useHoisting = true) {
          return `(${[...Visit(schema, references, value, useHoisting)].join(" && ")})`;
        }
        function CreateFunctionName($id) {
          return `check_${Identifier.Encode($id)}`;
        }
        function CreateVariable(expression) {
          const variableName = `local_${state.variables.size}`;
          state.variables.set(variableName, `const ${variableName} = ${expression}`);
          return variableName;
        }
        function CreateFunction(name, schema, references, value, useHoisting = true) {
          const [newline, pad2] = ["\n", (length) => "".padStart(length, " ")];
          const parameter = CreateParameter("value", "any");
          const returns = CreateReturns("boolean");
          const expression = [...Visit(schema, references, value, useHoisting)].map((expression2) => `${pad2(4)}${expression2}`).join(` &&${newline}`);
          return `function ${name}(${parameter})${returns} {${newline}${pad2(2)}return (${newline}${expression}${newline}${pad2(2)})
}`;
        }
        function CreateParameter(name, type2) {
          const annotation = state.language === "typescript" ? `: ${type2}` : "";
          return `${name}${annotation}`;
        }
        function CreateReturns(type2) {
          return state.language === "typescript" ? `: ${type2}` : "";
        }
        function Build(schema, references, options) {
          const functionCode = CreateFunction("check", schema, references, "value");
          const parameter = CreateParameter("value", "any");
          const returns = CreateReturns("boolean");
          const functions = [...state.functions.values()];
          const variables = [...state.variables.values()];
          const checkFunction = (0, guard_1.IsString)(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
          return [...variables, ...functions, checkFunction].join("\n");
        }
        function Code(...args) {
          const defaults2 = { language: "javascript" };
          const [schema, references, options] = args.length === 2 && (0, guard_1.IsArray)(args[1]) ? [args[0], args[1], defaults2] : args.length === 2 && !(0, guard_1.IsArray)(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults2] : [null, [], defaults2];
          state.language = options.language;
          state.variables.clear();
          state.functions.clear();
          state.instances.clear();
          if (!Types2.TypeGuard.TSchema(schema))
            throw new TypeCompilerTypeGuardError(schema);
          for (const schema2 of references)
            if (!Types2.TypeGuard.TSchema(schema2))
              throw new TypeCompilerTypeGuardError(schema2);
          return Build(schema, references, options);
        }
        TypeCompiler2.Code = Code;
        function Compile(schema, references = []) {
          const generatedCode = Code(schema, references, { language: "javascript" });
          const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
          const instances = new Map(state.instances);
          function typeRegistryFunction(kind, instance, value) {
            if (!Types2.TypeRegistry.Has(kind) || !instances.has(instance))
              return false;
            const checkFunc = Types2.TypeRegistry.Get(kind);
            const schema2 = instances.get(instance);
            return checkFunc(schema2, value);
          }
          function formatRegistryFunction(format2, value) {
            if (!Types2.FormatRegistry.Has(format2))
              return false;
            const checkFunc = Types2.FormatRegistry.Get(format2);
            return checkFunc(value);
          }
          function hashFunction(value) {
            return (0, hash_1.Hash)(value);
          }
          const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
          return new TypeCheck(schema, references, checkFunction, generatedCode);
        }
        TypeCompiler2.Compile = Compile;
      })(TypeCompiler || (exports.TypeCompiler = TypeCompiler = {}));
    }
  });

  // ../node_modules/@sinclair/typebox/compiler/index.js
  var require_compiler2 = __commonJS({
    "../node_modules/@sinclair/typebox/compiler/index.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m2[k2];
      });
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
            __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValueErrorIterator = exports.ValueErrorType = void 0;
      var index_1 = require_errors2();
      Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
        return index_1.ValueErrorType;
      } });
      Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
        return index_1.ValueErrorIterator;
      } });
      __exportStar(require_compiler(), exports);
    }
  });

  // ../node_modules/fast-decode-uri-component/index.js
  var require_fast_decode_uri_component = __commonJS({
    "../node_modules/fast-decode-uri-component/index.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var UTF8_ACCEPT = 12;
      var UTF8_REJECT = 0;
      var UTF8_DATA = [
        // The first part of the table maps bytes to character to a transition.
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        7,
        7,
        10,
        9,
        9,
        9,
        11,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        // The second part of the table maps a state to a new state when adding a
        // transition.
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        12,
        0,
        0,
        0,
        0,
        24,
        36,
        48,
        60,
        72,
        84,
        96,
        0,
        12,
        12,
        12,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // The third part maps the current transition to a mask that needs to apply
        // to the byte.
        127,
        63,
        63,
        63,
        0,
        31,
        15,
        15,
        15,
        7,
        7,
        7
      ];
      function decodeURIComponent2(uri) {
        var percentPosition = uri.indexOf("%");
        if (percentPosition === -1)
          return uri;
        var length = uri.length;
        var decoded = "";
        var last = 0;
        var codepoint = 0;
        var startOfOctets = percentPosition;
        var state = UTF8_ACCEPT;
        while (percentPosition > -1 && percentPosition < length) {
          var high = hexCodeToInt(uri[percentPosition + 1], 4);
          var low = hexCodeToInt(uri[percentPosition + 2], 0);
          var byte = high | low;
          var type2 = UTF8_DATA[byte];
          state = UTF8_DATA[256 + state + type2];
          codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type2];
          if (state === UTF8_ACCEPT) {
            decoded += uri.slice(last, startOfOctets);
            decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
              55232 + (codepoint >> 10),
              56320 + (codepoint & 1023)
            );
            codepoint = 0;
            last = percentPosition + 3;
            percentPosition = startOfOctets = uri.indexOf("%", last);
          } else if (state === UTF8_REJECT) {
            return null;
          } else {
            percentPosition += 3;
            if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
              continue;
            return null;
          }
        }
        return decoded + uri.slice(last);
      }
      var HEX = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "a": 10,
        "A": 10,
        "b": 11,
        "B": 11,
        "c": 12,
        "C": 12,
        "d": 13,
        "D": 13,
        "e": 14,
        "E": 14,
        "f": 15,
        "F": 15
      };
      function hexCodeToInt(c2, shift) {
        var i2 = HEX[c2];
        return i2 === void 0 ? 255 : i2 << shift;
      }
      module.exports = decodeURIComponent2;
    }
  });

  // ../node_modules/fast-querystring/lib/parse.js
  var require_parse = __commonJS({
    "../node_modules/fast-querystring/lib/parse.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var fastDecode = require_fast_decode_uri_component();
      var plusRegex = /\+/g;
      var Empty = function() {
      };
      Empty.prototype = /* @__PURE__ */ Object.create(null);
      function parse(input) {
        const result = new Empty();
        if (typeof input !== "string") {
          return result;
        }
        let inputLength = input.length;
        let key = "";
        let value = "";
        let startingIndex = -1;
        let equalityIndex = -1;
        let shouldDecodeKey = false;
        let shouldDecodeValue = false;
        let keyHasPlus = false;
        let valueHasPlus = false;
        let hasBothKeyValuePair = false;
        let c2 = 0;
        for (let i2 = 0; i2 < inputLength + 1; i2++) {
          c2 = i2 !== inputLength ? input.charCodeAt(i2) : 38;
          if (c2 === 38) {
            hasBothKeyValuePair = equalityIndex > startingIndex;
            if (!hasBothKeyValuePair) {
              equalityIndex = i2;
            }
            key = input.slice(startingIndex + 1, equalityIndex);
            if (hasBothKeyValuePair || key.length > 0) {
              if (keyHasPlus) {
                key = key.replace(plusRegex, " ");
              }
              if (shouldDecodeKey) {
                key = fastDecode(key) || key;
              }
              if (hasBothKeyValuePair) {
                value = input.slice(equalityIndex + 1, i2);
                if (valueHasPlus) {
                  value = value.replace(plusRegex, " ");
                }
                if (shouldDecodeValue) {
                  value = fastDecode(value) || value;
                }
              }
              const currentValue = result[key];
              if (currentValue === void 0) {
                result[key] = value;
              } else {
                if (currentValue.pop) {
                  currentValue.push(value);
                } else {
                  result[key] = [currentValue, value];
                }
              }
            }
            value = "";
            startingIndex = i2;
            equalityIndex = i2;
            shouldDecodeKey = false;
            shouldDecodeValue = false;
            keyHasPlus = false;
            valueHasPlus = false;
          } else if (c2 === 61) {
            if (equalityIndex <= startingIndex) {
              equalityIndex = i2;
            } else {
              shouldDecodeValue = true;
            }
          } else if (c2 === 43) {
            if (equalityIndex > startingIndex) {
              valueHasPlus = true;
            } else {
              keyHasPlus = true;
            }
          } else if (c2 === 37) {
            if (equalityIndex > startingIndex) {
              shouldDecodeValue = true;
            } else {
              shouldDecodeKey = true;
            }
          }
        }
        return result;
      }
      module.exports = parse;
    }
  });

  // ../node_modules/fast-querystring/lib/internals/querystring.js
  var require_querystring = __commonJS({
    "../node_modules/fast-querystring/lib/internals/querystring.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var hexTable = Array.from(
        { length: 256 },
        (_, i2) => "%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase()
      );
      var noEscape = new Int8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // 0 - 15
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // 16 - 31
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0,
        0,
        1,
        1,
        0,
        // 32 - 47
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        // 48 - 63
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        // 64 - 79
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        1,
        // 80 - 95
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        // 96 - 111
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        0
        // 112 - 127
      ]);
      function encodeString(str) {
        const len = str.length;
        if (len === 0)
          return "";
        let out = "";
        let lastPos = 0;
        let i2 = 0;
        outer:
          for (; i2 < len; i2++) {
            let c2 = str.charCodeAt(i2);
            while (c2 < 128) {
              if (noEscape[c2] !== 1) {
                if (lastPos < i2)
                  out += str.slice(lastPos, i2);
                lastPos = i2 + 1;
                out += hexTable[c2];
              }
              if (++i2 === len)
                break outer;
              c2 = str.charCodeAt(i2);
            }
            if (lastPos < i2)
              out += str.slice(lastPos, i2);
            if (c2 < 2048) {
              lastPos = i2 + 1;
              out += hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
              continue;
            }
            if (c2 < 55296 || c2 >= 57344) {
              lastPos = i2 + 1;
              out += hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
              continue;
            }
            ++i2;
            if (i2 >= len) {
              throw new Error("URI malformed");
            }
            const c22 = str.charCodeAt(i2) & 1023;
            lastPos = i2 + 1;
            c2 = 65536 + ((c2 & 1023) << 10 | c22);
            out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          }
        if (lastPos === 0)
          return str;
        if (lastPos < len)
          return out + str.slice(lastPos);
        return out;
      }
      module.exports = { encodeString };
    }
  });

  // ../node_modules/fast-querystring/lib/stringify.js
  var require_stringify = __commonJS({
    "../node_modules/fast-querystring/lib/stringify.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var { encodeString } = require_querystring();
      function getAsPrimitive(value) {
        const type2 = typeof value;
        if (type2 === "string") {
          return encodeString(value);
        } else if (type2 === "bigint") {
          return value.toString();
        } else if (type2 === "boolean") {
          return value ? "true" : "false";
        } else if (type2 === "number" && Number.isFinite(value)) {
          return value < 1e21 ? "" + value : encodeString("" + value);
        }
        return "";
      }
      function stringify(input) {
        let result = "";
        if (input === null || typeof input !== "object") {
          return result;
        }
        const separator = "&";
        const keys2 = Object.keys(input);
        const keyLength = keys2.length;
        let valueLength = 0;
        for (let i2 = 0; i2 < keyLength; i2++) {
          const key = keys2[i2];
          const value = input[key];
          const encodedKey = encodeString(key) + "=";
          if (i2) {
            result += separator;
          }
          if (Array.isArray(value)) {
            valueLength = value.length;
            for (let j = 0; j < valueLength; j++) {
              if (j) {
                result += separator;
              }
              result += encodedKey;
              result += getAsPrimitive(value[j]);
            }
          } else {
            result += encodedKey;
            result += getAsPrimitive(value);
          }
        }
        return result;
      }
      module.exports = stringify;
    }
  });

  // ../node_modules/fast-querystring/lib/index.js
  var require_lib = __commonJS({
    "../node_modules/fast-querystring/lib/index.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var parse = require_parse();
      var stringify = require_stringify();
      var fastQuerystring = {
        parse,
        stringify
      };
      module.exports = fastQuerystring;
      module.exports.default = fastQuerystring;
      module.exports.parse = parse;
      module.exports.stringify = stringify;
    }
  });

  // ../node_modules/osmtogeojson/lodash.custom.js
  var require_lodash_custom = __commonJS({
    "../node_modules/osmtogeojson/lodash.custom.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      (function() {
        var undefined2;
        var VERSION3 = "4.15.0";
        var LARGE_ARRAY_SIZE = 200;
        var FUNC_ERROR_TEXT = "Expected a function";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reEscapeChar = /\\(\\)?/g;
        var reFlags = /\w*$/;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            return freeProcess && freeProcess.binding("util");
          } catch (e8) {
          }
        }();
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function addMapEntry(map, pair) {
          map.set(pair[0], pair[1]);
          return map;
        }
        function addSetEntry(set, value) {
          set.add(value);
          return set;
        }
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayEach(array, iteratee2) {
          var index = -1, length = array ? array.length : 0;
          while (++index < length) {
            if (iteratee2(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee2, accumulator, initAccum) {
          var index = -1, length = array ? array.length : 0;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee2(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array ? array.length : 0;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseTimes(n3, iteratee2) {
          var index = -1, result = Array(n3);
          while (++index < n3) {
            result[index] = iteratee2(index);
          }
          return result;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function isHostObject(value) {
          var result = false;
          if (value != null && typeof value.toString != "function") {
            try {
              result = !!(value + "");
            } catch (e8) {
            }
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
        var coreJsData = root["__core-js_shared__"];
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var funcToString = funcProto.toString;
        var hasOwnProperty3 = objectProto.hasOwnProperty;
        var objectCtorString = funcToString.call(Object);
        var objectToString2 = objectProto.toString;
        var reIsNative = RegExp(
          "^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer4 = moduleExports ? root.Buffer : undefined2, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
        var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : undefined2, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max;
        var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
        var nonEnumShadows = !propertyIsEnumerable.call({ "valueOf": 1 }, "valueOf");
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash() {
        }
        function Hash(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
        }
        function hashDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined2 : result;
          }
          return hasOwnProperty3.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty3.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          return getMapData(this, key)["delete"](key);
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          getMapData(this, key).set(key, value);
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values) {
          var index = -1, length = values ? values.length : 0;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          this.__data__ = new ListCache(entries);
        }
        function stackClear() {
          this.__data__ = new ListCache();
        }
        function stackDelete(key) {
          return this.__data__["delete"](key);
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var cache = this.__data__;
          if (cache instanceof ListCache) {
            var pairs = cache.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              return this;
            }
            cache = this.__data__ = new MapCache(pairs);
          }
          cache.set(key, value);
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var result = isArray4(value) || isArguments(value) ? baseTimes(value.length, String) : [];
          var length = result.length, skipIndexes = !!length;
          for (var key in value) {
            if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || typeof key == "number" && value === undefined2 && !(key in object)) {
            object[key] = value;
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty3.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            object[key] = value;
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys2(source), object);
        }
        function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined2) {
            return result;
          }
          if (!isObject4(value)) {
            return value;
          }
          var isArr = isArray4(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer5(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              if (isHostObject(value)) {
                return object ? value : {};
              }
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, baseClone, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);
          if (!isArr) {
            var props = isFull ? getAllKeys(value) : keys2(value);
          }
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
          });
          return result;
        }
        function baseCreate(proto) {
          return isObject4(proto) ? objectCreate(proto) : {};
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseFor = createBaseFor();
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys2);
        }
        function baseGet(object, path) {
          path = isKey(path, object) ? [path] : castPath(path);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray4(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function baseGetTag(value) {
          return objectToString2.call(value);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }
        function baseIsEqual(value, other, customizer, bitmask, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObject4(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
          var objIsArr = isArray4(object), othIsArr = isArray4(other), objTag = arrayTag, othTag = arrayTag;
          if (!objIsArr) {
            objTag = getTag(object);
            objTag = objTag == argsTag ? objectTag : objTag;
          }
          if (!othIsArr) {
            othTag = getTag(other);
            othTag = othTag == argsTag ? objectTag : othTag;
          }
          var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray2(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
          }
          if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined2 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject4(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction3(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString2.call(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty3.call(object, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        function baseKeysIn(object) {
          if (!isObject4(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty3.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined2, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          if (!(isArray4(source) || isTypedArray2(source))) {
            var props = baseKeysIn(source);
          }
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObject4(srcValue)) {
              stack || (stack = new Stack());
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(object[key], srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          });
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            newValue = srcValue;
            if (isArray4(srcValue) || isTypedArray2(srcValue)) {
              if (isArray4(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else {
                isCommon = false;
                newValue = baseClone(srcValue, true);
              }
            } else if (isPlainObject3(srcValue) || isArguments(srcValue)) {
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject4(objValue) || srcIndex && isFunction3(objValue)) {
                isCommon = false;
                newValue = baseClone(srcValue, true);
              } else {
                newValue = objValue;
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function baseRest(func, start) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = array;
            return apply(func, this, otherArgs);
          };
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isSymbol2(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function castPath(value) {
          return isArray4(value) ? value : stringToPath(value);
        }
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var result = new buffer.constructor(buffer.length);
          buffer.copy(result);
          return result;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
          return result;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map, isDeep, cloneFunc) {
          var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
          return arrayReduce(array, addMapEntry, new map.constructor());
        }
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
          var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
          return arrayReduce(array, addSetEntry, new set.constructor());
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            assignValue(object, key, newValue === undefined2 ? source[key] : newValue);
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var stacked = stack.get(array);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
                  return seen.add(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              result = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result;
        }
        function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= UNORDERED_COMPARE_FLAG;
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
              stack["delete"](object);
              return result;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys2(object), objLength = objProps.length, othProps = keys2(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
              return false;
            }
          }
          var stacked = stack.get(object);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result;
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys2, getSymbols);
        }
        function getIteratee() {
          var result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result = keys2(object), length = result.length;
          while (length--) {
            var key = result[length], value = object[key];
            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result = objectToString2.call(value), Ctor = result == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : undefined2;
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result;
          };
        }
        function hasPath(object, path, hasFunc) {
          path = isKey(path, object) ? [path] : castPath(path);
          var result, index = -1, length = path.length;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result) {
            return result;
          }
          var length = object ? object.length : 0;
          return !!length && isLength(length) && isIndex(key, length) && (isArray4(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result = array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty3.call(array, "index")) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, cloneFunc, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return cloneMap(object, isDeep, cloneFunc);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return cloneSet(object, isDeep, cloneFunc);
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function isIndex(value, length) {
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject4(object)) {
            return false;
          }
          var type2 = typeof index;
          if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray4(value)) {
            return false;
          }
          var type2 = typeof value;
          if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
        }
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject4(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object(object));
          };
        }
        function nativeKeysIn(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }
        var stringToPath = memoize(function(string) {
          string = toString6(string);
          var result = [];
          if (reLeadingDot.test(string)) {
            result.push("");
          }
          string.replace(rePropName, function(match, number, quote, string2) {
            result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
          });
          return result;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol2(value)) {
            return value;
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e8) {
            }
            try {
              return func + "";
            } catch (e8) {
            }
          }
          return "";
        }
        function compact(array) {
          var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function forEach3(collection, iteratee2) {
          var func = isArray4(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver && typeof resolver != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function clone(value) {
          return baseClone(value, false, true);
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        function isArguments(value) {
          return isArrayLikeObject(value) && hasOwnProperty3.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
        }
        var isArray4 = Array.isArray;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction3(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        var isBuffer5 = nativeIsBuffer || stubFalse;
        function isEmpty(value) {
          if (isArrayLike(value) && (isArray4(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer5(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (nonEnumShadows || isPrototype(value)) {
            return !nativeKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty3.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isFunction3(value) {
          var tag = isObject4(value) ? objectToString2.call(value) : "";
          return tag == funcTag || tag == genTag;
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject4(value) {
          var type2 = typeof value;
          return !!value && (type2 == "object" || type2 == "function");
        }
        function isObjectLike(value) {
          return !!value && typeof value == "object";
        }
        function isPlainObject3(value) {
          if (!isObjectLike(value) || objectToString2.call(value) != objectTag || isHostObject(value)) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        function isSymbol2(value) {
          return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
        }
        var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toString6(value) {
          return value == null ? "" : baseToString(value);
        }
        function get(object, path, defaultValue) {
          var result = object == null ? undefined2 : baseGet(object, path);
          return result === undefined2 ? defaultValue : result;
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        function keys2(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, true));
        }
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        lodash.compact = compact;
        lodash.iteratee = iteratee;
        lodash.keys = keys2;
        lodash.keysIn = keysIn;
        lodash.memoize = memoize;
        lodash.merge = merge2;
        lodash.property = property;
        lodash.toPlainObject = toPlainObject;
        lodash.clone = clone;
        lodash.eq = eq;
        lodash.forEach = forEach3;
        lodash.get = get;
        lodash.hasIn = hasIn;
        lodash.identity = identity;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray4;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBuffer = isBuffer5;
        lodash.isEmpty = isEmpty;
        lodash.isFunction = isFunction3;
        lodash.isLength = isLength;
        lodash.isObject = isObject4;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject3;
        lodash.isSymbol = isSymbol2;
        lodash.isTypedArray = isTypedArray2;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.toString = toString6;
        lodash.each = forEach3;
        lodash.VERSION = VERSION3;
        if (freeModule) {
          (freeModule.exports = lodash)._ = lodash;
          freeExports._ = lodash;
        }
      }).call(exports);
    }
  });

  // ../node_modules/@mapbox/geojson-rewind/index.js
  var require_geojson_rewind = __commonJS({
    "../node_modules/@mapbox/geojson-rewind/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = rewind;
      function rewind(gj, outer) {
        var type2 = gj && gj.type, i2;
        if (type2 === "FeatureCollection") {
          for (i2 = 0; i2 < gj.features.length; i2++)
            rewind(gj.features[i2], outer);
        } else if (type2 === "GeometryCollection") {
          for (i2 = 0; i2 < gj.geometries.length; i2++)
            rewind(gj.geometries[i2], outer);
        } else if (type2 === "Feature") {
          rewind(gj.geometry, outer);
        } else if (type2 === "Polygon") {
          rewindRings(gj.coordinates, outer);
        } else if (type2 === "MultiPolygon") {
          for (i2 = 0; i2 < gj.coordinates.length; i2++)
            rewindRings(gj.coordinates[i2], outer);
        }
        return gj;
      }
      function rewindRings(rings, outer) {
        if (rings.length === 0)
          return;
        rewindRing(rings[0], outer);
        for (var i2 = 1; i2 < rings.length; i2++) {
          rewindRing(rings[i2], !outer);
        }
      }
      function rewindRing(ring, dir) {
        var area = 0, err = 0;
        for (var i2 = 0, len = ring.length, j = len - 1; i2 < len; j = i2++) {
          var k2 = (ring[i2][0] - ring[j][0]) * (ring[j][1] + ring[i2][1]);
          var m2 = area + k2;
          err += Math.abs(area) >= Math.abs(k2) ? area - m2 + k2 : k2 - m2 + area;
          area = m2;
        }
        if (area + err >= 0 !== !!dir)
          ring.reverse();
      }
    }
  });

  // ../node_modules/osm-polygon-features/polygon-features.json
  var require_polygon_features = __commonJS({
    "../node_modules/osm-polygon-features/polygon-features.json"(exports, module) {
      module.exports = [
        {
          key: "building",
          polygon: "all"
        },
        {
          key: "highway",
          polygon: "whitelist",
          values: [
            "services",
            "rest_area",
            "escape",
            "elevator"
          ]
        },
        {
          key: "natural",
          polygon: "blacklist",
          values: [
            "coastline",
            "cliff",
            "ridge",
            "arete",
            "tree_row"
          ]
        },
        {
          key: "landuse",
          polygon: "all"
        },
        {
          key: "waterway",
          polygon: "whitelist",
          values: [
            "riverbank",
            "dock",
            "boatyard",
            "dam"
          ]
        },
        {
          key: "amenity",
          polygon: "all"
        },
        {
          key: "leisure",
          polygon: "all"
        },
        {
          key: "barrier",
          polygon: "whitelist",
          values: [
            "city_wall",
            "ditch",
            "hedge",
            "retaining_wall",
            "wall",
            "spikes"
          ]
        },
        {
          key: "railway",
          polygon: "whitelist",
          values: [
            "station",
            "turntable",
            "roundhouse",
            "platform"
          ]
        },
        {
          key: "area",
          polygon: "all"
        },
        {
          key: "boundary",
          polygon: "all"
        },
        {
          key: "man_made",
          polygon: "blacklist",
          values: [
            "cutline",
            "embankment",
            "pipeline"
          ]
        },
        {
          key: "power",
          polygon: "whitelist",
          values: [
            "plant",
            "substation",
            "generator",
            "transformer"
          ]
        },
        {
          key: "place",
          polygon: "all"
        },
        {
          key: "shop",
          polygon: "all"
        },
        {
          key: "aeroway",
          polygon: "blacklist",
          values: [
            "taxiway"
          ]
        },
        {
          key: "tourism",
          polygon: "all"
        },
        {
          key: "historic",
          polygon: "all"
        },
        {
          key: "public_transport",
          polygon: "all"
        },
        {
          key: "office",
          polygon: "all"
        },
        {
          key: "building:part",
          polygon: "all"
        },
        {
          key: "military",
          polygon: "all"
        },
        {
          key: "ruins",
          polygon: "all"
        },
        {
          key: "area:highway",
          polygon: "all"
        },
        {
          key: "craft",
          polygon: "all"
        },
        {
          key: "golf",
          polygon: "all"
        },
        {
          key: "indoor",
          polygon: "all"
        }
      ];
    }
  });

  // ../node_modules/osm-polygon-features/index.js
  var require_osm_polygon_features = __commonJS({
    "../node_modules/osm-polygon-features/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = require_polygon_features();
    }
  });

  // ../node_modules/osmtogeojson/index.js
  var require_osmtogeojson = __commonJS({
    "../node_modules/osmtogeojson/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var _ = require_lodash_custom();
      var rewind = require_geojson_rewind();
      var polygonFeatures = {};
      require_osm_polygon_features().forEach(function(tags) {
        if (tags.polygon === "all")
          polygonFeatures[tags.key] = true;
        else {
          var list = tags.polygon === "whitelist" ? "included_values" : "excluded_values", tagValuesObj = {};
          tags.values.forEach(function(value) {
            tagValuesObj[value] = true;
          });
          polygonFeatures[tags.key] = {};
          polygonFeatures[tags.key][list] = tagValuesObj;
        }
      });
      function default_deduplicator(objectA, objectB) {
        if ((objectA.version || objectB.version) && objectA.version !== objectB.version) {
          return (+objectA.version || 0) > (+objectB.version || 0) ? objectA : objectB;
        }
        return _.merge(objectA, objectB);
      }
      var osmtogeojson6 = {};
      osmtogeojson6 = function(data, options, featureCallback) {
        options = _.merge(
          {
            verbose: false,
            flatProperties: true,
            uninterestingTags: {
              "source": true,
              "source_ref": true,
              "source:ref": true,
              "history": true,
              "attribution": true,
              "created_by": true,
              "tiger:county": true,
              "tiger:tlid": true,
              "tiger:upload_uuid": true
            },
            polygonFeatures,
            deduplicator: default_deduplicator
          },
          options
        );
        var result;
        if (typeof XMLDocument !== "undefined" && data instanceof XMLDocument || typeof XMLDocument === "undefined" && data.childNodes)
          result = _osmXML2geoJSON(data);
        else
          result = _overpassJSON2geoJSON(data);
        return result;
        function _overpassJSON2geoJSON(json) {
          var nodes = new Array();
          var ways = new Array();
          var rels = new Array();
          function centerGeometry(object) {
            var pseudoNode = _.clone(object);
            pseudoNode.lat = object.center.lat;
            pseudoNode.lon = object.center.lon;
            pseudoNode.__is_center_placeholder = true;
            nodes.push(pseudoNode);
          }
          function boundsGeometry(object) {
            var pseudoWay = _.clone(object);
            pseudoWay.nodes = [];
            function addPseudoNode(lat, lon, i3) {
              var pseudoNode = {
                type: "node",
                id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i3,
                lat,
                lon
              };
              pseudoWay.nodes.push(pseudoNode.id);
              nodes.push(pseudoNode);
            }
            addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.minlon, 1);
            addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.minlon, 2);
            addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.maxlon, 3);
            addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.maxlon, 4);
            pseudoWay.nodes.push(pseudoWay.nodes[0]);
            pseudoWay.__is_bounds_placeholder = true;
            ways.push(pseudoWay);
          }
          function fullGeometryWay(way2) {
            function addFullGeometryNode(lat, lon, id) {
              var geometryNode = {
                type: "node",
                id,
                lat,
                lon
              };
              nodes.push(geometryNode);
            }
            if (!_.isArray(way2.nodes)) {
              way2.nodes = way2.geometry.map(function(nd) {
                if (nd !== null)
                  return "_anonymous@" + nd.lat + "/" + nd.lon;
                else
                  return "_anonymous@unknown_location";
              });
            }
            way2.geometry.forEach(function(nd, i3) {
              if (nd) {
                addFullGeometryNode(
                  nd.lat,
                  nd.lon,
                  way2.nodes[i3]
                );
              }
            });
          }
          function fullGeometryRelation(rel2) {
            function addFullGeometryNode(lat, lon, id) {
              var geometryNode = {
                type: "node",
                id,
                lat,
                lon
              };
              nodes.push(geometryNode);
            }
            function addFullGeometryWay(geometry, id) {
              if (ways.some(function(way2) {
                return way2.type == "way" && way2.id == id;
              }))
                return;
              var geometryWay = {
                type: "way",
                id,
                nodes: []
              };
              function addFullGeometryWayPseudoNode(lat, lon) {
                var geometryPseudoNode = {
                  type: "node",
                  id: "_anonymous@" + lat + "/" + lon,
                  lat,
                  lon
                };
                geometryWay.nodes.push(geometryPseudoNode.id);
                nodes.push(geometryPseudoNode);
              }
              geometry.forEach(function(nd) {
                if (nd) {
                  addFullGeometryWayPseudoNode(
                    nd.lat,
                    nd.lon
                  );
                } else {
                  geometryWay.nodes.push(void 0);
                }
              });
              ways.push(geometryWay);
            }
            rel2.members.forEach(function(member, i3) {
              if (member.type == "node") {
                if (member.lat) {
                  addFullGeometryNode(
                    member.lat,
                    member.lon,
                    member.ref
                  );
                }
              } else if (member.type == "way") {
                if (member.geometry) {
                  member.ref = "_fullGeom" + member.ref;
                  addFullGeometryWay(
                    member.geometry,
                    member.ref
                  );
                }
              }
            });
          }
          for (var i2 = 0; i2 < json.elements.length; i2++) {
            switch (json.elements[i2].type) {
              case "node":
                var node = json.elements[i2];
                nodes.push(node);
                break;
              case "way":
                var way = _.clone(json.elements[i2]);
                way.nodes = _.clone(way.nodes);
                ways.push(way);
                if (way.center)
                  centerGeometry(way);
                if (way.geometry)
                  fullGeometryWay(way);
                else if (way.bounds)
                  boundsGeometry(way);
                break;
              case "relation":
                var rel = _.clone(json.elements[i2]);
                rel.members = _.clone(rel.members);
                rels.push(rel);
                var has_full_geometry = rel.members && rel.members.some(function(member) {
                  return member.type == "node" && member.lat || member.type == "way" && member.geometry && member.geometry.length > 0;
                });
                if (rel.center)
                  centerGeometry(rel);
                if (has_full_geometry)
                  fullGeometryRelation(rel);
                else if (rel.bounds)
                  boundsGeometry(rel);
                break;
              default:
            }
          }
          return _convert2geoJSON(nodes, ways, rels);
        }
        function _osmXML2geoJSON(xml) {
          var nodes = new Array();
          var ways = new Array();
          var rels = new Array();
          function copy_attribute(x2, o, attr) {
            if (x2.hasAttribute(attr))
              o[attr] = x2.getAttribute(attr);
          }
          function centerGeometry(object, centroid2) {
            var pseudoNode = _.clone(object);
            copy_attribute(centroid2, pseudoNode, "lat");
            copy_attribute(centroid2, pseudoNode, "lon");
            pseudoNode.__is_center_placeholder = true;
            nodes.push(pseudoNode);
          }
          function boundsGeometry(object, bounds2) {
            var pseudoWay = _.clone(object);
            pseudoWay.nodes = [];
            function addPseudoNode(lat, lon, i2) {
              var pseudoNode = {
                type: "node",
                id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i2,
                lat,
                lon
              };
              pseudoWay.nodes.push(pseudoNode.id);
              nodes.push(pseudoNode);
            }
            addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("minlon"), 1);
            addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("minlon"), 2);
            addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("maxlon"), 3);
            addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("maxlon"), 4);
            pseudoWay.nodes.push(pseudoWay.nodes[0]);
            pseudoWay.__is_bounds_placeholder = true;
            ways.push(pseudoWay);
          }
          function fullGeometryWay(way, nds) {
            function addFullGeometryNode(lat, lon, id) {
              var geometryNode = {
                type: "node",
                id,
                lat,
                lon
              };
              nodes.push(geometryNode);
              return geometryNode.id;
            }
            if (!_.isArray(way.nodes)) {
              way.nodes = [];
              _.each(nds, function(nd, i2) {
                way.nodes.push("_anonymous@" + nd.getAttribute("lat") + "/" + nd.getAttribute("lon"));
              });
            }
            _.each(nds, function(nd, i2) {
              if (nd.getAttribute("lat")) {
                addFullGeometryNode(
                  nd.getAttribute("lat"),
                  nd.getAttribute("lon"),
                  way.nodes[i2]
                );
              }
            });
          }
          function fullGeometryRelation(rel, members) {
            function addFullGeometryNode(lat, lon, id) {
              var geometryNode = {
                type: "node",
                id,
                lat,
                lon
              };
              nodes.push(geometryNode);
            }
            function addFullGeometryWay(nds, id) {
              if (ways.some(function(way) {
                return way.type == "way" && way.id == id;
              }))
                return;
              var geometryWay = {
                type: "way",
                id,
                nodes: []
              };
              function addFullGeometryWayPseudoNode(lat, lon) {
                var geometryPseudoNode = {
                  type: "node",
                  id: "_anonymous@" + lat + "/" + lon,
                  lat,
                  lon
                };
                geometryWay.nodes.push(geometryPseudoNode.id);
                nodes.push(geometryPseudoNode);
              }
              _.each(nds, function(nd) {
                if (nd.getAttribute("lat")) {
                  addFullGeometryWayPseudoNode(
                    nd.getAttribute("lat"),
                    nd.getAttribute("lon")
                  );
                } else {
                  geometryWay.nodes.push(void 0);
                }
              });
              ways.push(geometryWay);
            }
            _.each(members, function(member, i2) {
              if (rel.members[i2].type == "node") {
                if (member.getAttribute("lat")) {
                  addFullGeometryNode(
                    member.getAttribute("lat"),
                    member.getAttribute("lon"),
                    rel.members[i2].ref
                  );
                }
              } else if (rel.members[i2].type == "way") {
                if (member.getElementsByTagName("nd").length > 0) {
                  rel.members[i2].ref = "_fullGeom" + rel.members[i2].ref;
                  addFullGeometryWay(
                    member.getElementsByTagName("nd"),
                    rel.members[i2].ref
                  );
                }
              }
            });
          }
          _.each(xml.getElementsByTagName("node"), function(node, i2) {
            var tags = {};
            _.each(node.getElementsByTagName("tag"), function(tag) {
              tags[tag.getAttribute("k")] = tag.getAttribute("v");
            });
            var nodeObject = {
              "type": "node"
            };
            copy_attribute(node, nodeObject, "id");
            copy_attribute(node, nodeObject, "lat");
            copy_attribute(node, nodeObject, "lon");
            copy_attribute(node, nodeObject, "version");
            copy_attribute(node, nodeObject, "timestamp");
            copy_attribute(node, nodeObject, "changeset");
            copy_attribute(node, nodeObject, "uid");
            copy_attribute(node, nodeObject, "user");
            if (!_.isEmpty(tags))
              nodeObject.tags = tags;
            nodes.push(nodeObject);
          });
          var centroid, bounds;
          _.each(xml.getElementsByTagName("way"), function(way, i2) {
            var tags = {};
            var wnodes = [];
            _.each(way.getElementsByTagName("tag"), function(tag) {
              tags[tag.getAttribute("k")] = tag.getAttribute("v");
            });
            var has_full_geometry = false;
            _.each(way.getElementsByTagName("nd"), function(nd, i3) {
              var id;
              if (id = nd.getAttribute("ref"))
                wnodes[i3] = id;
              if (!has_full_geometry && nd.getAttribute("lat"))
                has_full_geometry = true;
            });
            var wayObject = {
              "type": "way"
            };
            copy_attribute(way, wayObject, "id");
            copy_attribute(way, wayObject, "version");
            copy_attribute(way, wayObject, "timestamp");
            copy_attribute(way, wayObject, "changeset");
            copy_attribute(way, wayObject, "uid");
            copy_attribute(way, wayObject, "user");
            if (wnodes.length > 0)
              wayObject.nodes = wnodes;
            if (!_.isEmpty(tags))
              wayObject.tags = tags;
            if (centroid = way.getElementsByTagName("center")[0])
              centerGeometry(wayObject, centroid);
            if (has_full_geometry)
              fullGeometryWay(wayObject, way.getElementsByTagName("nd"));
            else if (bounds = way.getElementsByTagName("bounds")[0])
              boundsGeometry(wayObject, bounds);
            ways.push(wayObject);
          });
          _.each(xml.getElementsByTagName("relation"), function(relation, i2) {
            var tags = {};
            var members = [];
            _.each(relation.getElementsByTagName("tag"), function(tag) {
              tags[tag.getAttribute("k")] = tag.getAttribute("v");
            });
            var has_full_geometry = false;
            _.each(relation.getElementsByTagName("member"), function(member, i3) {
              members[i3] = {};
              copy_attribute(member, members[i3], "ref");
              copy_attribute(member, members[i3], "role");
              copy_attribute(member, members[i3], "type");
              if (!has_full_geometry && (members[i3].type == "node" && member.getAttribute("lat")) || members[i3].type == "way" && member.getElementsByTagName("nd").length > 0)
                has_full_geometry = true;
            });
            var relObject = {
              "type": "relation"
            };
            copy_attribute(relation, relObject, "id");
            copy_attribute(relation, relObject, "version");
            copy_attribute(relation, relObject, "timestamp");
            copy_attribute(relation, relObject, "changeset");
            copy_attribute(relation, relObject, "uid");
            copy_attribute(relation, relObject, "user");
            if (members.length > 0)
              relObject.members = members;
            if (!_.isEmpty(tags))
              relObject.tags = tags;
            if (centroid = relation.getElementsByTagName("center")[0])
              centerGeometry(relObject, centroid);
            if (has_full_geometry)
              fullGeometryRelation(relObject, relation.getElementsByTagName("member"));
            else if (bounds = relation.getElementsByTagName("bounds")[0])
              boundsGeometry(relObject, bounds);
            rels.push(relObject);
          });
          return _convert2geoJSON(nodes, ways, rels);
        }
        function _convert2geoJSON(nodes, ways, rels) {
          function has_interesting_tags(t5, ignore_tags) {
            if (typeof ignore_tags !== "object")
              ignore_tags = {};
            if (typeof options.uninterestingTags === "function")
              return !options.uninterestingTags(t5, ignore_tags);
            for (var k2 in t5)
              if (!(options.uninterestingTags[k2] === true) && !(ignore_tags[k2] === true || ignore_tags[k2] === t5[k2]))
                return true;
            return false;
          }
          ;
          function build_meta_information(object) {
            var res = {
              "timestamp": object.timestamp,
              "version": object.version,
              "changeset": object.changeset,
              "user": object.user,
              "uid": object.uid
            };
            for (var k2 in res)
              if (res[k2] === void 0)
                delete res[k2];
            return res;
          }
          var nodeids = new Object();
          var poinids = new Object();
          for (var i2 = 0; i2 < nodes.length; i2++) {
            var node = nodes[i2];
            if (nodeids[node.id] !== void 0) {
              node = options.deduplicator(node, nodeids[node.id]);
            }
            nodeids[node.id] = node;
            if (typeof node.tags != "undefined" && has_interesting_tags(node.tags))
              poinids[node.id] = true;
          }
          for (var i2 = 0; i2 < rels.length; i2++) {
            if (_.isArray(rels[i2].members)) {
              for (var j = 0; j < rels[i2].members.length; j++) {
                if (rels[i2].members[j].type == "node")
                  poinids[rels[i2].members[j].ref] = true;
              }
            }
          }
          var wayids = new Object();
          var waynids = new Object();
          for (var i2 = 0; i2 < ways.length; i2++) {
            var way = ways[i2];
            if (wayids[way.id]) {
              way = options.deduplicator(way, wayids[way.id]);
            }
            wayids[way.id] = way;
            if (_.isArray(way.nodes)) {
              for (var j = 0; j < way.nodes.length; j++) {
                if (typeof way.nodes[j] === "object")
                  continue;
                waynids[way.nodes[j]] = true;
                way.nodes[j] = nodeids[way.nodes[j]];
              }
            }
          }
          var pois = new Array();
          for (var id in nodeids) {
            var node = nodeids[id];
            if (!waynids[id] || poinids[id])
              pois.push(node);
          }
          var relids = new Array();
          for (var i2 = 0; i2 < rels.length; i2++) {
            var rel = rels[i2];
            if (relids[rel.id]) {
              rel = options.deduplicator(rel, relids[rel.id]);
            }
            relids[rel.id] = rel;
          }
          var relsmap = { node: {}, way: {}, relation: {} };
          for (var id in relids) {
            var rel = relids[id];
            if (!_.isArray(rel.members)) {
              if (options.verbose)
                console.warn("Relation", rel.type + "/" + rel.id, "ignored because it has no members");
              continue;
            }
            for (var j = 0; j < rel.members.length; j++) {
              var m_type = rel.members[j].type;
              var m_ref = rel.members[j].ref;
              if (typeof m_ref !== "number") {
                m_ref = m_ref.replace("_fullGeom", "");
              }
              if (!relsmap[m_type]) {
                if (options.verbose)
                  console.warn("Relation", rel.type + "/" + rel.id, "member", m_type + "/" + m_ref, "ignored because it has an invalid type");
                continue;
              }
              if (typeof relsmap[m_type][m_ref] === "undefined")
                relsmap[m_type][m_ref] = [];
              relsmap[m_type][m_ref].push({
                "role": rel.members[j].role,
                "rel": rel.id,
                "reltags": rel.tags
              });
            }
          }
          var geojson;
          var geojsonnodes = [];
          for (i2 = 0; i2 < pois.length; i2++) {
            if (typeof pois[i2].lon == "undefined" || typeof pois[i2].lat == "undefined") {
              if (options.verbose)
                console.warn("POI", pois[i2].type + "/" + pois[i2].id, "ignored because it lacks coordinates");
              continue;
            }
            var feature = {
              "type": "Feature",
              "id": pois[i2].type + "/" + pois[i2].id,
              "properties": {
                "type": pois[i2].type,
                "id": pois[i2].id,
                "tags": pois[i2].tags || {},
                "relations": relsmap["node"][pois[i2].id] || [],
                "meta": build_meta_information(pois[i2])
              },
              "geometry": {
                "type": "Point",
                "coordinates": [+pois[i2].lon, +pois[i2].lat]
              }
            };
            if (pois[i2].__is_center_placeholder)
              feature.properties["geometry"] = "center";
            if (!featureCallback)
              geojsonnodes.push(feature);
            else
              featureCallback(feature);
          }
          var geojsonlines = [];
          var geojsonpolygons = [];
          for (var i2 = 0; i2 < rels.length; i2++) {
            if (relids[rels[i2].id] !== rels[i2]) {
              continue;
            }
            if (typeof rels[i2].tags != "undefined" && (rels[i2].tags["type"] == "route" || rels[i2].tags["type"] == "waterway")) {
              let construct_multilinestring2 = function(rel2) {
                var is_tainted = false;
                var members;
                members = rel2.members.filter(function(m2) {
                  return m2.type === "way";
                });
                members = members.map(function(m2) {
                  var way2 = wayids[m2.ref];
                  if (way2 === void 0 || way2.nodes === void 0) {
                    if (options.verbose)
                      console.warn("Route " + rel2.type + "/" + rel2.id, "tainted by a missing or incomplete  way", m2.type + "/" + m2.ref);
                    is_tainted = true;
                    return;
                  }
                  return {
                    // TODO: this is slow! :(
                    id: m2.ref,
                    role: m2.role,
                    way: way2,
                    nodes: way2.nodes.filter(function(n3) {
                      if (n3 !== void 0)
                        return true;
                      is_tainted = true;
                      if (options.verbose)
                        console.warn("Route", rel2.type + "/" + rel2.id, "tainted by a way", m2.type + "/" + m2.ref, "with a missing node");
                      return false;
                    })
                  };
                });
                members = _.compact(members);
                var linestrings;
                linestrings = join3(members);
                var coords2 = [];
                coords2 = _.compact(linestrings.map(function(linestring) {
                  return _.compact(linestring.map(function(node2) {
                    return [+node2.lon, +node2.lat];
                  }));
                }));
                if (coords2.length == 0) {
                  if (options.verbose)
                    console.warn("Route", rel2.type + "/" + rel2.id, "contains no coordinates");
                  return false;
                }
                var feature2 = {
                  "type": "Feature",
                  "id": rel2.type + "/" + rel2.id,
                  "properties": {
                    "type": rel2.type,
                    "id": rel2.id,
                    "tags": rel2.tags || {},
                    "relations": relsmap[rel2.type][rel2.id] || [],
                    "meta": build_meta_information(rel2)
                  },
                  "geometry": {
                    "type": coords2.length === 1 ? "LineString" : "MultiLineString",
                    "coordinates": coords2.length === 1 ? coords2[0] : coords2
                  }
                };
                if (is_tainted) {
                  if (options.verbose)
                    console.warn("Route", rel2.type + "/" + rel2.id, "is tainted");
                  feature2.properties["tainted"] = true;
                }
                return feature2;
              };
              var construct_multilinestring = construct_multilinestring2;
              if (!_.isArray(rels[i2].members)) {
                if (options.verbose)
                  console.warn("Route", rels[i2].type + "/" + rels[i2].id, "ignored because it has no members");
                continue;
              }
              rels[i2].members.forEach(function(m2) {
                if (wayids[m2.ref] && !has_interesting_tags(wayids[m2.ref].tags))
                  wayids[m2.ref].is_skippablerelationmember = true;
              });
              feature = construct_multilinestring2(rels[i2]);
              if (feature === false) {
                if (options.verbose)
                  console.warn("Route relation", rels[i2].type + "/" + rels[i2].id, "ignored because it has invalid geometry");
                continue;
              }
              if (!featureCallback)
                geojsonpolygons.push(feature);
              else
                featureCallback(rewind(feature));
            }
            if (typeof rels[i2].tags != "undefined" && (rels[i2].tags["type"] == "multipolygon" || rels[i2].tags["type"] == "boundary")) {
              let construct_multipolygon2 = function(tag_object, rel2) {
                var is_tainted = false;
                var mp_geometry = simple_mp ? "way" : "relation", mp_id = typeof tag_object.id === "number" ? tag_object.id : +tag_object.id.replace("_fullGeom", "");
                var members;
                members = rel2.members.filter(function(m2) {
                  return m2.type === "way";
                });
                members = members.map(function(m2) {
                  var way2 = wayids[m2.ref];
                  if (way2 === void 0 || way2.nodes === void 0) {
                    if (options.verbose)
                      console.warn("Multipolygon", mp_geometry + "/" + mp_id, "tainted by a missing or incomplete way", m2.type + "/" + m2.ref);
                    is_tainted = true;
                    return;
                  }
                  return {
                    // TODO: this is slow! :(
                    id: m2.ref,
                    role: m2.role || "outer",
                    way: way2,
                    nodes: way2.nodes.filter(function(n3) {
                      if (n3 !== void 0)
                        return true;
                      is_tainted = true;
                      if (options.verbose)
                        console.warn("Multipolygon", mp_geometry + "/" + mp_id, "tainted by a way", m2.type + "/" + m2.ref, "with a missing node");
                      return false;
                    })
                  };
                });
                members = _.compact(members);
                var outers, inners;
                outers = join3(members.filter(function(m2) {
                  return m2.role === "outer";
                }));
                inners = join3(members.filter(function(m2) {
                  return m2.role === "inner";
                }));
                var mp;
                function findOuter(inner) {
                  var polygonIntersectsPolygon = function(outer2, inner2) {
                    for (var i3 = 0; i3 < inner2.length; i3++)
                      if (pointInPolygon(inner2[i3], outer2))
                        return true;
                    return false;
                  };
                  var mapCoordinates = function(from3) {
                    return from3.map(function(n3) {
                      return [+n3.lat, +n3.lon];
                    });
                  };
                  var pointInPolygon = function(point, polygon) {
                    var x2 = point[0], y2 = point[1], inside = false;
                    for (var i3 = 0, j3 = polygon.length - 1; i3 < polygon.length; j3 = i3++) {
                      var xi = polygon[i3][0], yi = polygon[i3][1];
                      var xj = polygon[j3][0], yj = polygon[j3][1];
                      var intersect = yi > y2 != yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
                      if (intersect)
                        inside = !inside;
                    }
                    return inside;
                  };
                  var o2, outer;
                  inner = mapCoordinates(inner);
                  for (o2 = 0; o2 < outers.length; o2++) {
                    outer = mapCoordinates(outers[o2]);
                    if (polygonIntersectsPolygon(outer, inner))
                      return o2;
                  }
                }
                mp = outers.map(function(o2) {
                  return [o2];
                });
                for (var j2 = 0; j2 < inners.length; j2++) {
                  var o = findOuter(inners[j2]);
                  if (o !== void 0)
                    mp[o].push(inners[j2]);
                  else if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains an inner ring with no containing outer");
                  ;
                }
                var mp_coords = [];
                mp_coords = _.compact(mp.map(function(cluster) {
                  var cl = _.compact(cluster.map(function(ring) {
                    if (ring.length < 4) {
                      if (options.verbose)
                        console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains a ring with less than four nodes");
                      return;
                    }
                    return _.compact(ring.map(function(node2) {
                      return [+node2.lon, +node2.lat];
                    }));
                  }));
                  if (cl.length == 0) {
                    if (options.verbose)
                      console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains an empty ring cluster");
                    return;
                  }
                  return cl;
                }));
                if (mp_coords.length == 0) {
                  if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains no coordinates");
                  return false;
                }
                var mp_type = "MultiPolygon";
                if (mp_coords.length === 1) {
                  mp_type = "Polygon";
                  mp_coords = mp_coords[0];
                }
                var feature2 = {
                  "type": "Feature",
                  "id": tag_object.type + "/" + mp_id,
                  "properties": {
                    "type": tag_object.type,
                    "id": mp_id,
                    "tags": tag_object.tags || {},
                    "relations": relsmap[tag_object.type][tag_object.id] || [],
                    "meta": build_meta_information(tag_object)
                  },
                  "geometry": {
                    "type": mp_type,
                    "coordinates": mp_coords
                  }
                };
                if (is_tainted) {
                  if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "is tainted");
                  feature2.properties["tainted"] = true;
                }
                return feature2;
              };
              var construct_multipolygon = construct_multipolygon2;
              if (!_.isArray(rels[i2].members)) {
                if (options.verbose)
                  console.warn("Multipolygon", rels[i2].type + "/" + rels[i2].id, "ignored because it has no members");
                continue;
              }
              var outer_count = 0;
              for (var j = 0; j < rels[i2].members.length; j++)
                if (rels[i2].members[j].role == "outer")
                  outer_count++;
                else if (options.verbose && rels[i2].members[j].role != "inner")
                  console.warn("Multipolygon", rels[i2].type + "/" + rels[i2].id, "member", rels[i2].members[j].type + "/" + rels[i2].members[j].ref, 'ignored because it has an invalid role: "' + rels[i2].members[j].role + '"');
              rels[i2].members.forEach(function(m2) {
                if (wayids[m2.ref]) {
                  if (m2.role === "outer" && !has_interesting_tags(wayids[m2.ref].tags, rels[i2].tags))
                    wayids[m2.ref].is_skippablerelationmember = true;
                  if (m2.role === "inner" && !has_interesting_tags(wayids[m2.ref].tags))
                    wayids[m2.ref].is_skippablerelationmember = true;
                }
              });
              if (outer_count == 0) {
                if (options.verbose)
                  console.warn("Multipolygon relation", rels[i2].type + "/" + rels[i2].id, "ignored because it has no outer ways");
                continue;
              }
              var simple_mp = false;
              if (outer_count == 1 && !has_interesting_tags(rels[i2].tags, { "type": true }))
                simple_mp = true;
              var feature = null;
              if (!simple_mp) {
                feature = construct_multipolygon2(rels[i2], rels[i2]);
              } else {
                var outer_way = rels[i2].members.filter(function(m2) {
                  return m2.role === "outer";
                })[0];
                outer_way = wayids[outer_way.ref];
                if (outer_way === void 0) {
                  if (options.verbose)
                    console.warn("Multipolygon relation", rels[i2].type + "/" + rels[i2].id, "ignored because outer way", outer_way.type + "/" + outer_way.ref, "is missing");
                  continue;
                }
                outer_way.is_skippablerelationmember = true;
                feature = construct_multipolygon2(outer_way, rels[i2]);
              }
              if (feature === false) {
                if (options.verbose)
                  console.warn("Multipolygon relation", rels[i2].type + "/" + rels[i2].id, "ignored because it has invalid geometry");
                continue;
              }
              if (!featureCallback)
                geojsonpolygons.push(feature);
              else
                featureCallback(rewind(feature));
            }
          }
          for (var i2 = 0; i2 < ways.length; i2++) {
            if (wayids[ways[i2].id] !== ways[i2]) {
              continue;
            }
            if (!_.isArray(ways[i2].nodes)) {
              if (options.verbose)
                console.warn("Way", ways[i2].type + "/" + ways[i2].id, "ignored because it has no nodes");
              continue;
            }
            if (ways[i2].is_skippablerelationmember)
              continue;
            if (typeof ways[i2].id !== "number") {
              ways[i2].id = +ways[i2].id.replace("_fullGeom", "");
            }
            ways[i2].tainted = false;
            ways[i2].hidden = false;
            var coords = new Array();
            for (j = 0; j < ways[i2].nodes.length; j++) {
              if (typeof ways[i2].nodes[j] == "object")
                coords.push([+ways[i2].nodes[j].lon, +ways[i2].nodes[j].lat]);
              else {
                if (options.verbose)
                  console.warn("Way", ways[i2].type + "/" + ways[i2].id, "is tainted by an invalid node");
                ways[i2].tainted = true;
              }
            }
            if (coords.length <= 1) {
              if (options.verbose)
                console.warn("Way", ways[i2].type + "/" + ways[i2].id, "ignored because it contains too few nodes");
              continue;
            }
            var way_type = "LineString";
            if (typeof ways[i2].nodes[0] != "undefined" && typeof ways[i2].nodes[ways[i2].nodes.length - 1] != "undefined" && // way has its start/end nodes loaded
            ways[i2].nodes[0].id === ways[i2].nodes[ways[i2].nodes.length - 1].id && // ... and forms a closed ring
            (typeof ways[i2].tags != "undefined" && // ... and has tags
            _isPolygonFeature(ways[i2].tags) || // or is a placeholder for a bounds geometry
            ways[i2].__is_bounds_placeholder)) {
              way_type = "Polygon";
              coords = [coords];
            }
            var feature = {
              "type": "Feature",
              "id": ways[i2].type + "/" + ways[i2].id,
              "properties": {
                "type": ways[i2].type,
                "id": ways[i2].id,
                "tags": ways[i2].tags || {},
                "relations": relsmap["way"][ways[i2].id] || [],
                "meta": build_meta_information(ways[i2])
              },
              "geometry": {
                "type": way_type,
                "coordinates": coords
              }
            };
            if (ways[i2].tainted) {
              if (options.verbose)
                console.warn("Way", ways[i2].type + "/" + ways[i2].id, "is tainted");
              feature.properties["tainted"] = true;
            }
            if (ways[i2].__is_bounds_placeholder)
              feature.properties["geometry"] = "bounds";
            if (!featureCallback) {
              if (way_type == "LineString")
                geojsonlines.push(feature);
              else
                geojsonpolygons.push(feature);
            } else {
              featureCallback(rewind(feature));
            }
          }
          if (featureCallback)
            return true;
          geojson = {
            "type": "FeatureCollection",
            "features": []
          };
          geojson.features = geojson.features.concat(geojsonpolygons);
          geojson.features = geojson.features.concat(geojsonlines);
          geojson.features = geojson.features.concat(geojsonnodes);
          if (options.flatProperties) {
            geojson.features.forEach(function(f) {
              f.properties = _.merge(
                f.properties.meta,
                f.properties.tags,
                { id: f.properties.type + "/" + f.properties.id }
              );
            });
          }
          geojson = rewind(geojson);
          return geojson;
        }
        function _isPolygonFeature(tags) {
          var polygonFeatures2 = options.polygonFeatures;
          if (typeof polygonFeatures2 === "function")
            return polygonFeatures2(tags);
          if (tags["area"] === "no")
            return false;
          for (var key in tags) {
            var val = tags[key];
            var pfk = polygonFeatures2[key];
            if (typeof pfk === "undefined")
              continue;
            if (val === "no")
              continue;
            if (pfk === true)
              return true;
            if (pfk.included_values && pfk.included_values[val] === true)
              return true;
            if (pfk.excluded_values && pfk.excluded_values[val] !== true)
              return true;
          }
          return false;
        }
      };
      function join3(ways) {
        var _first = function(arr) {
          return arr[0];
        };
        var _last = function(arr) {
          return arr[arr.length - 1];
        };
        var _fitTogether = function(n1, n22) {
          return n1 !== void 0 && n22 !== void 0 && n1.id === n22.id;
        };
        var joined = [], current, first, last, i2, how, what;
        while (ways.length) {
          current = ways.pop().nodes.slice();
          joined.push(current);
          while (ways.length && !_fitTogether(_first(current), _last(current))) {
            first = _first(current);
            last = _last(current);
            for (i2 = 0; i2 < ways.length; i2++) {
              what = ways[i2].nodes;
              if (_fitTogether(last, _first(what))) {
                how = current.push;
                what = what.slice(1);
                break;
              } else if (_fitTogether(last, _last(what))) {
                how = current.push;
                what = what.slice(0, -1).reverse();
                break;
              } else if (_fitTogether(first, _last(what))) {
                how = current.unshift;
                what = what.slice(0, -1);
                break;
              } else if (_fitTogether(first, _first(what))) {
                how = current.unshift;
                what = what.slice(1).reverse();
                break;
              } else {
                what = how = null;
              }
            }
            if (!what)
              break;
            ways.splice(i2, 1);
            how.apply(current, what);
          }
        }
        return joined;
      }
      osmtogeojson6.toGeojson = osmtogeojson6;
      module.exports = osmtogeojson6;
    }
  });

  // ../node_modules/@prisma/client/runtime/edge.js
  var require_edge = __commonJS({
    "../node_modules/@prisma/client/runtime/edge.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var il = Object.create;
      var tr = Object.defineProperty;
      var sl = Object.getOwnPropertyDescriptor;
      var al = Object.getOwnPropertyNames;
      var ul = Object.getPrototypeOf;
      var ll = Object.prototype.hasOwnProperty;
      var cl = (e8, t5, r6) => t5 in e8 ? tr(e8, t5, { enumerable: true, configurable: true, writable: true, value: r6 }) : e8[t5] = r6;
      var Br = (e8, t5) => () => (e8 && (t5 = e8(e8 = 0)), t5);
      var Z = (e8, t5) => () => (t5 || e8((t5 = { exports: {} }).exports, t5), t5.exports);
      var rr = (e8, t5) => {
        for (var r6 in t5)
          tr(e8, r6, { get: t5[r6], enumerable: true });
      };
      var vi = (e8, t5, r6, n3) => {
        if (t5 && typeof t5 == "object" || typeof t5 == "function")
          for (let o of al(t5))
            !ll.call(e8, o) && o !== r6 && tr(e8, o, { get: () => t5[o], enumerable: !(n3 = sl(t5, o)) || n3.enumerable });
        return e8;
      };
      var ve = (e8, t5, r6) => (r6 = e8 != null ? il(ul(e8)) : {}, vi(t5 || !e8 || !e8.__esModule ? tr(r6, "default", { value: e8, enumerable: true }) : r6, e8));
      var pl = (e8) => vi(tr({}, "__esModule", { value: true }), e8);
      var Ai = (e8, t5, r6) => (cl(e8, typeof t5 != "symbol" ? t5 + "" : t5, r6), r6);
      function B(e8) {
        return () => e8;
      }
      function Ie() {
        return y2;
      }
      var y2;
      var p2 = Br(() => {
        "use strict";
        y2 = { abort: B(void 0), addListener: B(Ie()), allowedNodeEnvironmentFlags: /* @__PURE__ */ new Set(), arch: "x64", argv: ["/bin/node"], argv0: "node", chdir: B(void 0), config: { target_defaults: { cflags: [], default_configuration: "", defines: [], include_dirs: [], libraries: [] }, variables: { clang: 0, host_arch: "x64", node_install_npm: false, node_install_waf: false, node_prefix: "", node_shared_openssl: false, node_shared_v8: false, node_shared_zlib: false, node_use_dtrace: false, node_use_etw: false, node_use_openssl: false, target_arch: "x64", v8_no_strict_aliasing: 0, v8_use_snapshot: false, visibility: "" } }, connected: false, cpuUsage: () => ({ user: 0, system: 0 }), cwd: () => "/", debugPort: 0, disconnect: B(void 0), constrainedMemory: () => {
        }, emit: B(Ie()), emitWarning: B(void 0), env: {}, eventNames: () => [], execArgv: [], execPath: "/", exit: B(void 0), features: { inspector: false, debug: false, uv: false, ipv6: false, tls_alpn: false, tls_sni: false, tls_ocsp: false, tls: false }, getMaxListeners: B(0), getegid: B(0), geteuid: B(0), getgid: B(0), getgroups: B([]), getuid: B(0), hasUncaughtExceptionCaptureCallback: B(false), hrtime: B([0, 0]), platform: "linux", kill: B(true), listenerCount: B(0), listeners: B([]), memoryUsage: B({ arrayBuffers: 0, external: 0, heapTotal: 0, heapUsed: 0, rss: 0 }), nextTick: (e8, ...t5) => {
          setTimeout(() => {
            e8(...t5);
          }, 0);
        }, off: B(Ie()), on: B(Ie()), once: B(Ie()), openStdin: B({}), pid: 0, ppid: 0, prependListener: B(Ie()), prependOnceListener: B(Ie()), rawListeners: B([]), release: { name: "node" }, removeAllListeners: B(Ie()), removeListener: B(Ie()), resourceUsage: B({ fsRead: 0, fsWrite: 0, involuntaryContextSwitches: 0, ipcReceived: 0, ipcSent: 0, majorPageFault: 0, maxRSS: 0, minorPageFault: 0, sharedMemorySize: 0, signalsCount: 0, swappedOut: 0, systemCPUTime: 0, unsharedDataSize: 0, unsharedStackSize: 0, userCPUTime: 0, voluntaryContextSwitches: 0 }), setMaxListeners: B(Ie()), setUncaughtExceptionCaptureCallback: B(void 0), setegid: B(void 0), seteuid: B(void 0), setgid: B(void 0), setgroups: B(void 0), setuid: B(void 0), stderr: { fd: 2 }, stdin: { fd: 0 }, stdout: { fd: 1 }, title: "node", traceDeprecation: false, umask: B(0), uptime: B(0), version: "", versions: { http_parser: "", node: "", v8: "", ares: "", uv: "", zlib: "", modules: "", openssl: "" } };
      });
      var h2;
      var f = Br(() => {
        "use strict";
        h2 = () => {
        };
        h2.prototype = h2;
      });
      var Vi = Z((Ot) => {
        "use strict";
        d2();
        p2();
        f();
        var Ri = (e8, t5) => () => (t5 || e8((t5 = { exports: {} }).exports, t5), t5.exports), fl = Ri((e8) => {
          "use strict";
          e8.byteLength = u2, e8.toByteArray = c2, e8.fromByteArray = w;
          var t5 = [], r6 = [], n3 = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (i2 = 0, s3 = o.length; i2 < s3; ++i2)
            t5[i2] = o[i2], r6[o.charCodeAt(i2)] = i2;
          var i2, s3;
          r6["-".charCodeAt(0)] = 62, r6["_".charCodeAt(0)] = 63;
          function a4(E) {
            var b2 = E.length;
            if (b2 % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var T = E.indexOf("=");
            T === -1 && (T = b2);
            var S = T === b2 ? 0 : 4 - T % 4;
            return [T, S];
          }
          function u2(E) {
            var b2 = a4(E), T = b2[0], S = b2[1];
            return (T + S) * 3 / 4 - S;
          }
          function l(E, b2, T) {
            return (b2 + T) * 3 / 4 - T;
          }
          function c2(E) {
            var b2, T = a4(E), S = T[0], R = T[1], C = new n3(l(E, S, R)), M = 0, N = R > 0 ? S - 4 : S, L;
            for (L = 0; L < N; L += 4)
              b2 = r6[E.charCodeAt(L)] << 18 | r6[E.charCodeAt(L + 1)] << 12 | r6[E.charCodeAt(L + 2)] << 6 | r6[E.charCodeAt(L + 3)], C[M++] = b2 >> 16 & 255, C[M++] = b2 >> 8 & 255, C[M++] = b2 & 255;
            return R === 2 && (b2 = r6[E.charCodeAt(L)] << 2 | r6[E.charCodeAt(L + 1)] >> 4, C[M++] = b2 & 255), R === 1 && (b2 = r6[E.charCodeAt(L)] << 10 | r6[E.charCodeAt(L + 1)] << 4 | r6[E.charCodeAt(L + 2)] >> 2, C[M++] = b2 >> 8 & 255, C[M++] = b2 & 255), C;
          }
          function m2(E) {
            return t5[E >> 18 & 63] + t5[E >> 12 & 63] + t5[E >> 6 & 63] + t5[E & 63];
          }
          function g2(E, b2, T) {
            for (var S, R = [], C = b2; C < T; C += 3)
              S = (E[C] << 16 & 16711680) + (E[C + 1] << 8 & 65280) + (E[C + 2] & 255), R.push(m2(S));
            return R.join("");
          }
          function w(E) {
            for (var b2, T = E.length, S = T % 3, R = [], C = 16383, M = 0, N = T - S; M < N; M += C)
              R.push(g2(E, M, M + C > N ? N : M + C));
            return S === 1 ? (b2 = E[T - 1], R.push(t5[b2 >> 2] + t5[b2 << 4 & 63] + "==")) : S === 2 && (b2 = (E[T - 2] << 8) + E[T - 1], R.push(t5[b2 >> 10] + t5[b2 >> 4 & 63] + t5[b2 << 2 & 63] + "=")), R.join("");
          }
        }), dl = Ri((e8) => {
          e8.read = function(t5, r6, n3, o, i2) {
            var s3, a4, u2 = i2 * 8 - o - 1, l = (1 << u2) - 1, c2 = l >> 1, m2 = -7, g2 = n3 ? i2 - 1 : 0, w = n3 ? -1 : 1, E = t5[r6 + g2];
            for (g2 += w, s3 = E & (1 << -m2) - 1, E >>= -m2, m2 += u2; m2 > 0; s3 = s3 * 256 + t5[r6 + g2], g2 += w, m2 -= 8)
              ;
            for (a4 = s3 & (1 << -m2) - 1, s3 >>= -m2, m2 += o; m2 > 0; a4 = a4 * 256 + t5[r6 + g2], g2 += w, m2 -= 8)
              ;
            if (s3 === 0)
              s3 = 1 - c2;
            else {
              if (s3 === l)
                return a4 ? NaN : (E ? -1 : 1) * (1 / 0);
              a4 = a4 + Math.pow(2, o), s3 = s3 - c2;
            }
            return (E ? -1 : 1) * a4 * Math.pow(2, s3 - o);
          }, e8.write = function(t5, r6, n3, o, i2, s3) {
            var a4, u2, l, c2 = s3 * 8 - i2 - 1, m2 = (1 << c2) - 1, g2 = m2 >> 1, w = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E = o ? 0 : s3 - 1, b2 = o ? 1 : -1, T = r6 < 0 || r6 === 0 && 1 / r6 < 0 ? 1 : 0;
            for (r6 = Math.abs(r6), isNaN(r6) || r6 === 1 / 0 ? (u2 = isNaN(r6) ? 1 : 0, a4 = m2) : (a4 = Math.floor(Math.log(r6) / Math.LN2), r6 * (l = Math.pow(2, -a4)) < 1 && (a4--, l *= 2), a4 + g2 >= 1 ? r6 += w / l : r6 += w * Math.pow(2, 1 - g2), r6 * l >= 2 && (a4++, l /= 2), a4 + g2 >= m2 ? (u2 = 0, a4 = m2) : a4 + g2 >= 1 ? (u2 = (r6 * l - 1) * Math.pow(2, i2), a4 = a4 + g2) : (u2 = r6 * Math.pow(2, g2 - 1) * Math.pow(2, i2), a4 = 0)); i2 >= 8; t5[n3 + E] = u2 & 255, E += b2, u2 /= 256, i2 -= 8)
              ;
            for (a4 = a4 << i2 | u2, c2 += i2; c2 > 0; t5[n3 + E] = a4 & 255, E += b2, a4 /= 256, c2 -= 8)
              ;
            t5[n3 + E - b2] |= T * 128;
          };
        }), Hn = fl(), St = dl(), Ti = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        Ot.Buffer = P;
        Ot.SlowBuffer = bl;
        Ot.INSPECT_MAX_BYTES = 50;
        var jr = 2147483647;
        Ot.kMaxLength = jr;
        P.TYPED_ARRAY_SUPPORT = ml();
        !P.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
        function ml() {
          try {
            let e8 = new Uint8Array(1), t5 = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(t5, Uint8Array.prototype), Object.setPrototypeOf(e8, t5), e8.foo() === 42;
          } catch (e8) {
            return false;
          }
        }
        Object.defineProperty(P.prototype, "parent", { enumerable: true, get: function() {
          if (P.isBuffer(this))
            return this.buffer;
        } });
        Object.defineProperty(P.prototype, "offset", { enumerable: true, get: function() {
          if (P.isBuffer(this))
            return this.byteOffset;
        } });
        function Ve(e8) {
          if (e8 > jr)
            throw new RangeError('The value "' + e8 + '" is invalid for option "size"');
          let t5 = new Uint8Array(e8);
          return Object.setPrototypeOf(t5, P.prototype), t5;
        }
        function P(e8, t5, r6) {
          if (typeof e8 == "number") {
            if (typeof t5 == "string")
              throw new TypeError('The "string" argument must be of type string. Received type number');
            return Yn(e8);
          }
          return Oi(e8, t5, r6);
        }
        P.poolSize = 8192;
        function Oi(e8, t5, r6) {
          if (typeof e8 == "string")
            return yl(e8, t5);
          if (ArrayBuffer.isView(e8))
            return hl(e8);
          if (e8 == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e8);
          if (ke(e8, ArrayBuffer) || e8 && ke(e8.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ke(e8, SharedArrayBuffer) || e8 && ke(e8.buffer, SharedArrayBuffer)))
            return Ii(e8, t5, r6);
          if (typeof e8 == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
          let n3 = e8.valueOf && e8.valueOf();
          if (n3 != null && n3 !== e8)
            return P.from(n3, t5, r6);
          let o = xl(e8);
          if (o)
            return o;
          if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e8[Symbol.toPrimitive] == "function")
            return P.from(e8[Symbol.toPrimitive]("string"), t5, r6);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e8);
        }
        P.from = function(e8, t5, r6) {
          return Oi(e8, t5, r6);
        };
        Object.setPrototypeOf(P.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(P, Uint8Array);
        function Fi(e8) {
          if (typeof e8 != "number")
            throw new TypeError('"size" argument must be of type number');
          if (e8 < 0)
            throw new RangeError('The value "' + e8 + '" is invalid for option "size"');
        }
        function gl(e8, t5, r6) {
          return Fi(e8), e8 <= 0 ? Ve(e8) : t5 !== void 0 ? typeof r6 == "string" ? Ve(e8).fill(t5, r6) : Ve(e8).fill(t5) : Ve(e8);
        }
        P.alloc = function(e8, t5, r6) {
          return gl(e8, t5, r6);
        };
        function Yn(e8) {
          return Fi(e8), Ve(e8 < 0 ? 0 : Xn(e8) | 0);
        }
        P.allocUnsafe = function(e8) {
          return Yn(e8);
        };
        P.allocUnsafeSlow = function(e8) {
          return Yn(e8);
        };
        function yl(e8, t5) {
          if ((typeof t5 != "string" || t5 === "") && (t5 = "utf8"), !P.isEncoding(t5))
            throw new TypeError("Unknown encoding: " + t5);
          let r6 = ki(e8, t5) | 0, n3 = Ve(r6), o = n3.write(e8, t5);
          return o !== r6 && (n3 = n3.slice(0, o)), n3;
        }
        function zn(e8) {
          let t5 = e8.length < 0 ? 0 : Xn(e8.length) | 0, r6 = Ve(t5);
          for (let n3 = 0; n3 < t5; n3 += 1)
            r6[n3] = e8[n3] & 255;
          return r6;
        }
        function hl(e8) {
          if (ke(e8, Uint8Array)) {
            let t5 = new Uint8Array(e8);
            return Ii(t5.buffer, t5.byteOffset, t5.byteLength);
          }
          return zn(e8);
        }
        function Ii(e8, t5, r6) {
          if (t5 < 0 || e8.byteLength < t5)
            throw new RangeError('"offset" is outside of buffer bounds');
          if (e8.byteLength < t5 + (r6 || 0))
            throw new RangeError('"length" is outside of buffer bounds');
          let n3;
          return t5 === void 0 && r6 === void 0 ? n3 = new Uint8Array(e8) : r6 === void 0 ? n3 = new Uint8Array(e8, t5) : n3 = new Uint8Array(e8, t5, r6), Object.setPrototypeOf(n3, P.prototype), n3;
        }
        function xl(e8) {
          if (P.isBuffer(e8)) {
            let t5 = Xn(e8.length) | 0, r6 = Ve(t5);
            return r6.length === 0 || e8.copy(r6, 0, 0, t5), r6;
          }
          if (e8.length !== void 0)
            return typeof e8.length != "number" || to(e8.length) ? Ve(0) : zn(e8);
          if (e8.type === "Buffer" && Array.isArray(e8.data))
            return zn(e8.data);
        }
        function Xn(e8) {
          if (e8 >= jr)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + jr.toString(16) + " bytes");
          return e8 | 0;
        }
        function bl(e8) {
          return +e8 != e8 && (e8 = 0), P.alloc(+e8);
        }
        P.isBuffer = function(e8) {
          return e8 != null && e8._isBuffer === true && e8 !== P.prototype;
        };
        P.compare = function(e8, t5) {
          if (ke(e8, Uint8Array) && (e8 = P.from(e8, e8.offset, e8.byteLength)), ke(t5, Uint8Array) && (t5 = P.from(t5, t5.offset, t5.byteLength)), !P.isBuffer(e8) || !P.isBuffer(t5))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (e8 === t5)
            return 0;
          let r6 = e8.length, n3 = t5.length;
          for (let o = 0, i2 = Math.min(r6, n3); o < i2; ++o)
            if (e8[o] !== t5[o]) {
              r6 = e8[o], n3 = t5[o];
              break;
            }
          return r6 < n3 ? -1 : n3 < r6 ? 1 : 0;
        };
        P.isEncoding = function(e8) {
          switch (String(e8).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        };
        P.concat = function(e8, t5) {
          if (!Array.isArray(e8))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (e8.length === 0)
            return P.alloc(0);
          let r6;
          if (t5 === void 0)
            for (t5 = 0, r6 = 0; r6 < e8.length; ++r6)
              t5 += e8[r6].length;
          let n3 = P.allocUnsafe(t5), o = 0;
          for (r6 = 0; r6 < e8.length; ++r6) {
            let i2 = e8[r6];
            if (ke(i2, Uint8Array))
              o + i2.length > n3.length ? (P.isBuffer(i2) || (i2 = P.from(i2)), i2.copy(n3, o)) : Uint8Array.prototype.set.call(n3, i2, o);
            else if (P.isBuffer(i2))
              i2.copy(n3, o);
            else
              throw new TypeError('"list" argument must be an Array of Buffers');
            o += i2.length;
          }
          return n3;
        };
        function ki(e8, t5) {
          if (P.isBuffer(e8))
            return e8.length;
          if (ArrayBuffer.isView(e8) || ke(e8, ArrayBuffer))
            return e8.byteLength;
          if (typeof e8 != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e8);
          let r6 = e8.length, n3 = arguments.length > 2 && arguments[2] === true;
          if (!n3 && r6 === 0)
            return 0;
          let o = false;
          for (; ; )
            switch (t5) {
              case "ascii":
              case "latin1":
              case "binary":
                return r6;
              case "utf8":
              case "utf-8":
                return Zn(e8).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return r6 * 2;
              case "hex":
                return r6 >>> 1;
              case "base64":
                return qi(e8).length;
              default:
                if (o)
                  return n3 ? -1 : Zn(e8).length;
                t5 = ("" + t5).toLowerCase(), o = true;
            }
        }
        P.byteLength = ki;
        function wl(e8, t5, r6) {
          let n3 = false;
          if ((t5 === void 0 || t5 < 0) && (t5 = 0), t5 > this.length || ((r6 === void 0 || r6 > this.length) && (r6 = this.length), r6 <= 0) || (r6 >>>= 0, t5 >>>= 0, r6 <= t5))
            return "";
          for (e8 || (e8 = "utf8"); ; )
            switch (e8) {
              case "hex":
                return Ol(this, t5, r6);
              case "utf8":
              case "utf-8":
                return _i(this, t5, r6);
              case "ascii":
                return Sl(this, t5, r6);
              case "latin1":
              case "binary":
                return Rl(this, t5, r6);
              case "base64":
                return Cl(this, t5, r6);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return Fl(this, t5, r6);
              default:
                if (n3)
                  throw new TypeError("Unknown encoding: " + e8);
                e8 = (e8 + "").toLowerCase(), n3 = true;
            }
        }
        P.prototype._isBuffer = true;
        function mt(e8, t5, r6) {
          let n3 = e8[t5];
          e8[t5] = e8[r6], e8[r6] = n3;
        }
        P.prototype.swap16 = function() {
          let e8 = this.length;
          if (e8 % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let t5 = 0; t5 < e8; t5 += 2)
            mt(this, t5, t5 + 1);
          return this;
        };
        P.prototype.swap32 = function() {
          let e8 = this.length;
          if (e8 % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let t5 = 0; t5 < e8; t5 += 4)
            mt(this, t5, t5 + 3), mt(this, t5 + 1, t5 + 2);
          return this;
        };
        P.prototype.swap64 = function() {
          let e8 = this.length;
          if (e8 % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let t5 = 0; t5 < e8; t5 += 8)
            mt(this, t5, t5 + 7), mt(this, t5 + 1, t5 + 6), mt(this, t5 + 2, t5 + 5), mt(this, t5 + 3, t5 + 4);
          return this;
        };
        P.prototype.toString = function() {
          let e8 = this.length;
          return e8 === 0 ? "" : arguments.length === 0 ? _i(this, 0, e8) : wl.apply(this, arguments);
        };
        P.prototype.toLocaleString = P.prototype.toString;
        P.prototype.equals = function(e8) {
          if (!P.isBuffer(e8))
            throw new TypeError("Argument must be a Buffer");
          return this === e8 ? true : P.compare(this, e8) === 0;
        };
        P.prototype.inspect = function() {
          let e8 = "", t5 = Ot.INSPECT_MAX_BYTES;
          return e8 = this.toString("hex", 0, t5).replace(/(.{2})/g, "$1 ").trim(), this.length > t5 && (e8 += " ... "), "<Buffer " + e8 + ">";
        };
        Ti && (P.prototype[Ti] = P.prototype.inspect);
        P.prototype.compare = function(e8, t5, r6, n3, o) {
          if (ke(e8, Uint8Array) && (e8 = P.from(e8, e8.offset, e8.byteLength)), !P.isBuffer(e8))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e8);
          if (t5 === void 0 && (t5 = 0), r6 === void 0 && (r6 = e8 ? e8.length : 0), n3 === void 0 && (n3 = 0), o === void 0 && (o = this.length), t5 < 0 || r6 > e8.length || n3 < 0 || o > this.length)
            throw new RangeError("out of range index");
          if (n3 >= o && t5 >= r6)
            return 0;
          if (n3 >= o)
            return -1;
          if (t5 >= r6)
            return 1;
          if (t5 >>>= 0, r6 >>>= 0, n3 >>>= 0, o >>>= 0, this === e8)
            return 0;
          let i2 = o - n3, s3 = r6 - t5, a4 = Math.min(i2, s3), u2 = this.slice(n3, o), l = e8.slice(t5, r6);
          for (let c2 = 0; c2 < a4; ++c2)
            if (u2[c2] !== l[c2]) {
              i2 = u2[c2], s3 = l[c2];
              break;
            }
          return i2 < s3 ? -1 : s3 < i2 ? 1 : 0;
        };
        function Di(e8, t5, r6, n3, o) {
          if (e8.length === 0)
            return -1;
          if (typeof r6 == "string" ? (n3 = r6, r6 = 0) : r6 > 2147483647 ? r6 = 2147483647 : r6 < -2147483648 && (r6 = -2147483648), r6 = +r6, to(r6) && (r6 = o ? 0 : e8.length - 1), r6 < 0 && (r6 = e8.length + r6), r6 >= e8.length) {
            if (o)
              return -1;
            r6 = e8.length - 1;
          } else if (r6 < 0)
            if (o)
              r6 = 0;
            else
              return -1;
          if (typeof t5 == "string" && (t5 = P.from(t5, n3)), P.isBuffer(t5))
            return t5.length === 0 ? -1 : Ci(e8, t5, r6, n3, o);
          if (typeof t5 == "number")
            return t5 = t5 & 255, typeof Uint8Array.prototype.indexOf == "function" ? o ? Uint8Array.prototype.indexOf.call(e8, t5, r6) : Uint8Array.prototype.lastIndexOf.call(e8, t5, r6) : Ci(e8, [t5], r6, n3, o);
          throw new TypeError("val must be string, number or Buffer");
        }
        function Ci(e8, t5, r6, n3, o) {
          let i2 = 1, s3 = e8.length, a4 = t5.length;
          if (n3 !== void 0 && (n3 = String(n3).toLowerCase(), n3 === "ucs2" || n3 === "ucs-2" || n3 === "utf16le" || n3 === "utf-16le")) {
            if (e8.length < 2 || t5.length < 2)
              return -1;
            i2 = 2, s3 /= 2, a4 /= 2, r6 /= 2;
          }
          function u2(c2, m2) {
            return i2 === 1 ? c2[m2] : c2.readUInt16BE(m2 * i2);
          }
          let l;
          if (o) {
            let c2 = -1;
            for (l = r6; l < s3; l++)
              if (u2(e8, l) === u2(t5, c2 === -1 ? 0 : l - c2)) {
                if (c2 === -1 && (c2 = l), l - c2 + 1 === a4)
                  return c2 * i2;
              } else
                c2 !== -1 && (l -= l - c2), c2 = -1;
          } else
            for (r6 + a4 > s3 && (r6 = s3 - a4), l = r6; l >= 0; l--) {
              let c2 = true;
              for (let m2 = 0; m2 < a4; m2++)
                if (u2(e8, l + m2) !== u2(t5, m2)) {
                  c2 = false;
                  break;
                }
              if (c2)
                return l;
            }
          return -1;
        }
        P.prototype.includes = function(e8, t5, r6) {
          return this.indexOf(e8, t5, r6) !== -1;
        };
        P.prototype.indexOf = function(e8, t5, r6) {
          return Di(this, e8, t5, r6, true);
        };
        P.prototype.lastIndexOf = function(e8, t5, r6) {
          return Di(this, e8, t5, r6, false);
        };
        function El(e8, t5, r6, n3) {
          r6 = Number(r6) || 0;
          let o = e8.length - r6;
          n3 ? (n3 = Number(n3), n3 > o && (n3 = o)) : n3 = o;
          let i2 = t5.length;
          n3 > i2 / 2 && (n3 = i2 / 2);
          let s3;
          for (s3 = 0; s3 < n3; ++s3) {
            let a4 = parseInt(t5.substr(s3 * 2, 2), 16);
            if (to(a4))
              return s3;
            e8[r6 + s3] = a4;
          }
          return s3;
        }
        function Pl(e8, t5, r6, n3) {
          return Ur(Zn(t5, e8.length - r6), e8, r6, n3);
        }
        function vl(e8, t5, r6, n3) {
          return Ur(_l(t5), e8, r6, n3);
        }
        function Al(e8, t5, r6, n3) {
          return Ur(qi(t5), e8, r6, n3);
        }
        function Tl(e8, t5, r6, n3) {
          return Ur(Nl(t5, e8.length - r6), e8, r6, n3);
        }
        P.prototype.write = function(e8, t5, r6, n3) {
          if (t5 === void 0)
            n3 = "utf8", r6 = this.length, t5 = 0;
          else if (r6 === void 0 && typeof t5 == "string")
            n3 = t5, r6 = this.length, t5 = 0;
          else if (isFinite(t5))
            t5 = t5 >>> 0, isFinite(r6) ? (r6 = r6 >>> 0, n3 === void 0 && (n3 = "utf8")) : (n3 = r6, r6 = void 0);
          else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          let o = this.length - t5;
          if ((r6 === void 0 || r6 > o) && (r6 = o), e8.length > 0 && (r6 < 0 || t5 < 0) || t5 > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          n3 || (n3 = "utf8");
          let i2 = false;
          for (; ; )
            switch (n3) {
              case "hex":
                return El(this, e8, t5, r6);
              case "utf8":
              case "utf-8":
                return Pl(this, e8, t5, r6);
              case "ascii":
              case "latin1":
              case "binary":
                return vl(this, e8, t5, r6);
              case "base64":
                return Al(this, e8, t5, r6);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return Tl(this, e8, t5, r6);
              default:
                if (i2)
                  throw new TypeError("Unknown encoding: " + n3);
                n3 = ("" + n3).toLowerCase(), i2 = true;
            }
        };
        P.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        function Cl(e8, t5, r6) {
          return t5 === 0 && r6 === e8.length ? Hn.fromByteArray(e8) : Hn.fromByteArray(e8.slice(t5, r6));
        }
        function _i(e8, t5, r6) {
          r6 = Math.min(e8.length, r6);
          let n3 = [], o = t5;
          for (; o < r6; ) {
            let i2 = e8[o], s3 = null, a4 = i2 > 239 ? 4 : i2 > 223 ? 3 : i2 > 191 ? 2 : 1;
            if (o + a4 <= r6) {
              let u2, l, c2, m2;
              switch (a4) {
                case 1:
                  i2 < 128 && (s3 = i2);
                  break;
                case 2:
                  u2 = e8[o + 1], (u2 & 192) === 128 && (m2 = (i2 & 31) << 6 | u2 & 63, m2 > 127 && (s3 = m2));
                  break;
                case 3:
                  u2 = e8[o + 1], l = e8[o + 2], (u2 & 192) === 128 && (l & 192) === 128 && (m2 = (i2 & 15) << 12 | (u2 & 63) << 6 | l & 63, m2 > 2047 && (m2 < 55296 || m2 > 57343) && (s3 = m2));
                  break;
                case 4:
                  u2 = e8[o + 1], l = e8[o + 2], c2 = e8[o + 3], (u2 & 192) === 128 && (l & 192) === 128 && (c2 & 192) === 128 && (m2 = (i2 & 15) << 18 | (u2 & 63) << 12 | (l & 63) << 6 | c2 & 63, m2 > 65535 && m2 < 1114112 && (s3 = m2));
              }
            }
            s3 === null ? (s3 = 65533, a4 = 1) : s3 > 65535 && (s3 -= 65536, n3.push(s3 >>> 10 & 1023 | 55296), s3 = 56320 | s3 & 1023), n3.push(s3), o += a4;
          }
          return Ml(n3);
        }
        var Mi = 4096;
        function Ml(e8) {
          let t5 = e8.length;
          if (t5 <= Mi)
            return String.fromCharCode.apply(String, e8);
          let r6 = "", n3 = 0;
          for (; n3 < t5; )
            r6 += String.fromCharCode.apply(String, e8.slice(n3, n3 += Mi));
          return r6;
        }
        function Sl(e8, t5, r6) {
          let n3 = "";
          r6 = Math.min(e8.length, r6);
          for (let o = t5; o < r6; ++o)
            n3 += String.fromCharCode(e8[o] & 127);
          return n3;
        }
        function Rl(e8, t5, r6) {
          let n3 = "";
          r6 = Math.min(e8.length, r6);
          for (let o = t5; o < r6; ++o)
            n3 += String.fromCharCode(e8[o]);
          return n3;
        }
        function Ol(e8, t5, r6) {
          let n3 = e8.length;
          (!t5 || t5 < 0) && (t5 = 0), (!r6 || r6 < 0 || r6 > n3) && (r6 = n3);
          let o = "";
          for (let i2 = t5; i2 < r6; ++i2)
            o += Ll[e8[i2]];
          return o;
        }
        function Fl(e8, t5, r6) {
          let n3 = e8.slice(t5, r6), o = "";
          for (let i2 = 0; i2 < n3.length - 1; i2 += 2)
            o += String.fromCharCode(n3[i2] + n3[i2 + 1] * 256);
          return o;
        }
        P.prototype.slice = function(e8, t5) {
          let r6 = this.length;
          e8 = ~~e8, t5 = t5 === void 0 ? r6 : ~~t5, e8 < 0 ? (e8 += r6, e8 < 0 && (e8 = 0)) : e8 > r6 && (e8 = r6), t5 < 0 ? (t5 += r6, t5 < 0 && (t5 = 0)) : t5 > r6 && (t5 = r6), t5 < e8 && (t5 = e8);
          let n3 = this.subarray(e8, t5);
          return Object.setPrototypeOf(n3, P.prototype), n3;
        };
        function ee(e8, t5, r6) {
          if (e8 % 1 !== 0 || e8 < 0)
            throw new RangeError("offset is not uint");
          if (e8 + t5 > r6)
            throw new RangeError("Trying to access beyond buffer length");
        }
        P.prototype.readUintLE = P.prototype.readUIntLE = function(e8, t5, r6) {
          e8 = e8 >>> 0, t5 = t5 >>> 0, r6 || ee(e8, t5, this.length);
          let n3 = this[e8], o = 1, i2 = 0;
          for (; ++i2 < t5 && (o *= 256); )
            n3 += this[e8 + i2] * o;
          return n3;
        };
        P.prototype.readUintBE = P.prototype.readUIntBE = function(e8, t5, r6) {
          e8 = e8 >>> 0, t5 = t5 >>> 0, r6 || ee(e8, t5, this.length);
          let n3 = this[e8 + --t5], o = 1;
          for (; t5 > 0 && (o *= 256); )
            n3 += this[e8 + --t5] * o;
          return n3;
        };
        P.prototype.readUint8 = P.prototype.readUInt8 = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 1, this.length), this[e8];
        };
        P.prototype.readUint16LE = P.prototype.readUInt16LE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 2, this.length), this[e8] | this[e8 + 1] << 8;
        };
        P.prototype.readUint16BE = P.prototype.readUInt16BE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 2, this.length), this[e8] << 8 | this[e8 + 1];
        };
        P.prototype.readUint32LE = P.prototype.readUInt32LE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 4, this.length), (this[e8] | this[e8 + 1] << 8 | this[e8 + 2] << 16) + this[e8 + 3] * 16777216;
        };
        P.prototype.readUint32BE = P.prototype.readUInt32BE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 4, this.length), this[e8] * 16777216 + (this[e8 + 1] << 16 | this[e8 + 2] << 8 | this[e8 + 3]);
        };
        P.prototype.readBigUInt64LE = Ze(function(e8) {
          e8 = e8 >>> 0, Rt(e8, "offset");
          let t5 = this[e8], r6 = this[e8 + 7];
          (t5 === void 0 || r6 === void 0) && nr(e8, this.length - 8);
          let n3 = t5 + this[++e8] * 2 ** 8 + this[++e8] * 2 ** 16 + this[++e8] * 2 ** 24, o = this[++e8] + this[++e8] * 2 ** 8 + this[++e8] * 2 ** 16 + r6 * 2 ** 24;
          return BigInt(n3) + (BigInt(o) << BigInt(32));
        });
        P.prototype.readBigUInt64BE = Ze(function(e8) {
          e8 = e8 >>> 0, Rt(e8, "offset");
          let t5 = this[e8], r6 = this[e8 + 7];
          (t5 === void 0 || r6 === void 0) && nr(e8, this.length - 8);
          let n3 = t5 * 2 ** 24 + this[++e8] * 2 ** 16 + this[++e8] * 2 ** 8 + this[++e8], o = this[++e8] * 2 ** 24 + this[++e8] * 2 ** 16 + this[++e8] * 2 ** 8 + r6;
          return (BigInt(n3) << BigInt(32)) + BigInt(o);
        });
        P.prototype.readIntLE = function(e8, t5, r6) {
          e8 = e8 >>> 0, t5 = t5 >>> 0, r6 || ee(e8, t5, this.length);
          let n3 = this[e8], o = 1, i2 = 0;
          for (; ++i2 < t5 && (o *= 256); )
            n3 += this[e8 + i2] * o;
          return o *= 128, n3 >= o && (n3 -= Math.pow(2, 8 * t5)), n3;
        };
        P.prototype.readIntBE = function(e8, t5, r6) {
          e8 = e8 >>> 0, t5 = t5 >>> 0, r6 || ee(e8, t5, this.length);
          let n3 = t5, o = 1, i2 = this[e8 + --n3];
          for (; n3 > 0 && (o *= 256); )
            i2 += this[e8 + --n3] * o;
          return o *= 128, i2 >= o && (i2 -= Math.pow(2, 8 * t5)), i2;
        };
        P.prototype.readInt8 = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 1, this.length), this[e8] & 128 ? (255 - this[e8] + 1) * -1 : this[e8];
        };
        P.prototype.readInt16LE = function(e8, t5) {
          e8 = e8 >>> 0, t5 || ee(e8, 2, this.length);
          let r6 = this[e8] | this[e8 + 1] << 8;
          return r6 & 32768 ? r6 | 4294901760 : r6;
        };
        P.prototype.readInt16BE = function(e8, t5) {
          e8 = e8 >>> 0, t5 || ee(e8, 2, this.length);
          let r6 = this[e8 + 1] | this[e8] << 8;
          return r6 & 32768 ? r6 | 4294901760 : r6;
        };
        P.prototype.readInt32LE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 4, this.length), this[e8] | this[e8 + 1] << 8 | this[e8 + 2] << 16 | this[e8 + 3] << 24;
        };
        P.prototype.readInt32BE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 4, this.length), this[e8] << 24 | this[e8 + 1] << 16 | this[e8 + 2] << 8 | this[e8 + 3];
        };
        P.prototype.readBigInt64LE = Ze(function(e8) {
          e8 = e8 >>> 0, Rt(e8, "offset");
          let t5 = this[e8], r6 = this[e8 + 7];
          (t5 === void 0 || r6 === void 0) && nr(e8, this.length - 8);
          let n3 = this[e8 + 4] + this[e8 + 5] * 2 ** 8 + this[e8 + 6] * 2 ** 16 + (r6 << 24);
          return (BigInt(n3) << BigInt(32)) + BigInt(t5 + this[++e8] * 2 ** 8 + this[++e8] * 2 ** 16 + this[++e8] * 2 ** 24);
        });
        P.prototype.readBigInt64BE = Ze(function(e8) {
          e8 = e8 >>> 0, Rt(e8, "offset");
          let t5 = this[e8], r6 = this[e8 + 7];
          (t5 === void 0 || r6 === void 0) && nr(e8, this.length - 8);
          let n3 = (t5 << 24) + this[++e8] * 2 ** 16 + this[++e8] * 2 ** 8 + this[++e8];
          return (BigInt(n3) << BigInt(32)) + BigInt(this[++e8] * 2 ** 24 + this[++e8] * 2 ** 16 + this[++e8] * 2 ** 8 + r6);
        });
        P.prototype.readFloatLE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 4, this.length), St.read(this, e8, true, 23, 4);
        };
        P.prototype.readFloatBE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 4, this.length), St.read(this, e8, false, 23, 4);
        };
        P.prototype.readDoubleLE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 8, this.length), St.read(this, e8, true, 52, 8);
        };
        P.prototype.readDoubleBE = function(e8, t5) {
          return e8 = e8 >>> 0, t5 || ee(e8, 8, this.length), St.read(this, e8, false, 52, 8);
        };
        function ye(e8, t5, r6, n3, o, i2) {
          if (!P.isBuffer(e8))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (t5 > o || t5 < i2)
            throw new RangeError('"value" argument is out of bounds');
          if (r6 + n3 > e8.length)
            throw new RangeError("Index out of range");
        }
        P.prototype.writeUintLE = P.prototype.writeUIntLE = function(e8, t5, r6, n3) {
          if (e8 = +e8, t5 = t5 >>> 0, r6 = r6 >>> 0, !n3) {
            let s3 = Math.pow(2, 8 * r6) - 1;
            ye(this, e8, t5, r6, s3, 0);
          }
          let o = 1, i2 = 0;
          for (this[t5] = e8 & 255; ++i2 < r6 && (o *= 256); )
            this[t5 + i2] = e8 / o & 255;
          return t5 + r6;
        };
        P.prototype.writeUintBE = P.prototype.writeUIntBE = function(e8, t5, r6, n3) {
          if (e8 = +e8, t5 = t5 >>> 0, r6 = r6 >>> 0, !n3) {
            let s3 = Math.pow(2, 8 * r6) - 1;
            ye(this, e8, t5, r6, s3, 0);
          }
          let o = r6 - 1, i2 = 1;
          for (this[t5 + o] = e8 & 255; --o >= 0 && (i2 *= 256); )
            this[t5 + o] = e8 / i2 & 255;
          return t5 + r6;
        };
        P.prototype.writeUint8 = P.prototype.writeUInt8 = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 1, 255, 0), this[t5] = e8 & 255, t5 + 1;
        };
        P.prototype.writeUint16LE = P.prototype.writeUInt16LE = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 2, 65535, 0), this[t5] = e8 & 255, this[t5 + 1] = e8 >>> 8, t5 + 2;
        };
        P.prototype.writeUint16BE = P.prototype.writeUInt16BE = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 2, 65535, 0), this[t5] = e8 >>> 8, this[t5 + 1] = e8 & 255, t5 + 2;
        };
        P.prototype.writeUint32LE = P.prototype.writeUInt32LE = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 4, 4294967295, 0), this[t5 + 3] = e8 >>> 24, this[t5 + 2] = e8 >>> 16, this[t5 + 1] = e8 >>> 8, this[t5] = e8 & 255, t5 + 4;
        };
        P.prototype.writeUint32BE = P.prototype.writeUInt32BE = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 4, 4294967295, 0), this[t5] = e8 >>> 24, this[t5 + 1] = e8 >>> 16, this[t5 + 2] = e8 >>> 8, this[t5 + 3] = e8 & 255, t5 + 4;
        };
        function Ni(e8, t5, r6, n3, o) {
          $i(t5, n3, o, e8, r6, 7);
          let i2 = Number(t5 & BigInt(4294967295));
          e8[r6++] = i2, i2 = i2 >> 8, e8[r6++] = i2, i2 = i2 >> 8, e8[r6++] = i2, i2 = i2 >> 8, e8[r6++] = i2;
          let s3 = Number(t5 >> BigInt(32) & BigInt(4294967295));
          return e8[r6++] = s3, s3 = s3 >> 8, e8[r6++] = s3, s3 = s3 >> 8, e8[r6++] = s3, s3 = s3 >> 8, e8[r6++] = s3, r6;
        }
        function Li(e8, t5, r6, n3, o) {
          $i(t5, n3, o, e8, r6, 7);
          let i2 = Number(t5 & BigInt(4294967295));
          e8[r6 + 7] = i2, i2 = i2 >> 8, e8[r6 + 6] = i2, i2 = i2 >> 8, e8[r6 + 5] = i2, i2 = i2 >> 8, e8[r6 + 4] = i2;
          let s3 = Number(t5 >> BigInt(32) & BigInt(4294967295));
          return e8[r6 + 3] = s3, s3 = s3 >> 8, e8[r6 + 2] = s3, s3 = s3 >> 8, e8[r6 + 1] = s3, s3 = s3 >> 8, e8[r6] = s3, r6 + 8;
        }
        P.prototype.writeBigUInt64LE = Ze(function(e8, t5 = 0) {
          return Ni(this, e8, t5, BigInt(0), BigInt("0xffffffffffffffff"));
        });
        P.prototype.writeBigUInt64BE = Ze(function(e8, t5 = 0) {
          return Li(this, e8, t5, BigInt(0), BigInt("0xffffffffffffffff"));
        });
        P.prototype.writeIntLE = function(e8, t5, r6, n3) {
          if (e8 = +e8, t5 = t5 >>> 0, !n3) {
            let a4 = Math.pow(2, 8 * r6 - 1);
            ye(this, e8, t5, r6, a4 - 1, -a4);
          }
          let o = 0, i2 = 1, s3 = 0;
          for (this[t5] = e8 & 255; ++o < r6 && (i2 *= 256); )
            e8 < 0 && s3 === 0 && this[t5 + o - 1] !== 0 && (s3 = 1), this[t5 + o] = (e8 / i2 >> 0) - s3 & 255;
          return t5 + r6;
        };
        P.prototype.writeIntBE = function(e8, t5, r6, n3) {
          if (e8 = +e8, t5 = t5 >>> 0, !n3) {
            let a4 = Math.pow(2, 8 * r6 - 1);
            ye(this, e8, t5, r6, a4 - 1, -a4);
          }
          let o = r6 - 1, i2 = 1, s3 = 0;
          for (this[t5 + o] = e8 & 255; --o >= 0 && (i2 *= 256); )
            e8 < 0 && s3 === 0 && this[t5 + o + 1] !== 0 && (s3 = 1), this[t5 + o] = (e8 / i2 >> 0) - s3 & 255;
          return t5 + r6;
        };
        P.prototype.writeInt8 = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 1, 127, -128), e8 < 0 && (e8 = 255 + e8 + 1), this[t5] = e8 & 255, t5 + 1;
        };
        P.prototype.writeInt16LE = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 2, 32767, -32768), this[t5] = e8 & 255, this[t5 + 1] = e8 >>> 8, t5 + 2;
        };
        P.prototype.writeInt16BE = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 2, 32767, -32768), this[t5] = e8 >>> 8, this[t5 + 1] = e8 & 255, t5 + 2;
        };
        P.prototype.writeInt32LE = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 4, 2147483647, -2147483648), this[t5] = e8 & 255, this[t5 + 1] = e8 >>> 8, this[t5 + 2] = e8 >>> 16, this[t5 + 3] = e8 >>> 24, t5 + 4;
        };
        P.prototype.writeInt32BE = function(e8, t5, r6) {
          return e8 = +e8, t5 = t5 >>> 0, r6 || ye(this, e8, t5, 4, 2147483647, -2147483648), e8 < 0 && (e8 = 4294967295 + e8 + 1), this[t5] = e8 >>> 24, this[t5 + 1] = e8 >>> 16, this[t5 + 2] = e8 >>> 8, this[t5 + 3] = e8 & 255, t5 + 4;
        };
        P.prototype.writeBigInt64LE = Ze(function(e8, t5 = 0) {
          return Ni(this, e8, t5, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        });
        P.prototype.writeBigInt64BE = Ze(function(e8, t5 = 0) {
          return Li(this, e8, t5, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        });
        function Bi(e8, t5, r6, n3, o, i2) {
          if (r6 + n3 > e8.length)
            throw new RangeError("Index out of range");
          if (r6 < 0)
            throw new RangeError("Index out of range");
        }
        function ji(e8, t5, r6, n3, o) {
          return t5 = +t5, r6 = r6 >>> 0, o || Bi(e8, t5, r6, 4, 34028234663852886e22, -34028234663852886e22), St.write(e8, t5, r6, n3, 23, 4), r6 + 4;
        }
        P.prototype.writeFloatLE = function(e8, t5, r6) {
          return ji(this, e8, t5, true, r6);
        };
        P.prototype.writeFloatBE = function(e8, t5, r6) {
          return ji(this, e8, t5, false, r6);
        };
        function Ui(e8, t5, r6, n3, o) {
          return t5 = +t5, r6 = r6 >>> 0, o || Bi(e8, t5, r6, 8, 17976931348623157e292, -17976931348623157e292), St.write(e8, t5, r6, n3, 52, 8), r6 + 8;
        }
        P.prototype.writeDoubleLE = function(e8, t5, r6) {
          return Ui(this, e8, t5, true, r6);
        };
        P.prototype.writeDoubleBE = function(e8, t5, r6) {
          return Ui(this, e8, t5, false, r6);
        };
        P.prototype.copy = function(e8, t5, r6, n3) {
          if (!P.isBuffer(e8))
            throw new TypeError("argument should be a Buffer");
          if (r6 || (r6 = 0), !n3 && n3 !== 0 && (n3 = this.length), t5 >= e8.length && (t5 = e8.length), t5 || (t5 = 0), n3 > 0 && n3 < r6 && (n3 = r6), n3 === r6 || e8.length === 0 || this.length === 0)
            return 0;
          if (t5 < 0)
            throw new RangeError("targetStart out of bounds");
          if (r6 < 0 || r6 >= this.length)
            throw new RangeError("Index out of range");
          if (n3 < 0)
            throw new RangeError("sourceEnd out of bounds");
          n3 > this.length && (n3 = this.length), e8.length - t5 < n3 - r6 && (n3 = e8.length - t5 + r6);
          let o = n3 - r6;
          return this === e8 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t5, r6, n3) : Uint8Array.prototype.set.call(e8, this.subarray(r6, n3), t5), o;
        };
        P.prototype.fill = function(e8, t5, r6, n3) {
          if (typeof e8 == "string") {
            if (typeof t5 == "string" ? (n3 = t5, t5 = 0, r6 = this.length) : typeof r6 == "string" && (n3 = r6, r6 = this.length), n3 !== void 0 && typeof n3 != "string")
              throw new TypeError("encoding must be a string");
            if (typeof n3 == "string" && !P.isEncoding(n3))
              throw new TypeError("Unknown encoding: " + n3);
            if (e8.length === 1) {
              let i2 = e8.charCodeAt(0);
              (n3 === "utf8" && i2 < 128 || n3 === "latin1") && (e8 = i2);
            }
          } else
            typeof e8 == "number" ? e8 = e8 & 255 : typeof e8 == "boolean" && (e8 = Number(e8));
          if (t5 < 0 || this.length < t5 || this.length < r6)
            throw new RangeError("Out of range index");
          if (r6 <= t5)
            return this;
          t5 = t5 >>> 0, r6 = r6 === void 0 ? this.length : r6 >>> 0, e8 || (e8 = 0);
          let o;
          if (typeof e8 == "number")
            for (o = t5; o < r6; ++o)
              this[o] = e8;
          else {
            let i2 = P.isBuffer(e8) ? e8 : P.from(e8, n3), s3 = i2.length;
            if (s3 === 0)
              throw new TypeError('The value "' + e8 + '" is invalid for argument "value"');
            for (o = 0; o < r6 - t5; ++o)
              this[o + t5] = i2[o % s3];
          }
          return this;
        };
        var Mt = {};
        function eo(e8, t5, r6) {
          Mt[e8] = class extends r6 {
            constructor() {
              super(), Object.defineProperty(this, "message", { value: t5.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e8}]`, this.stack, delete this.name;
            }
            get code() {
              return e8;
            }
            set code(n3) {
              Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n3, writable: true });
            }
            toString() {
              return `${this.name} [${e8}]: ${this.message}`;
            }
          };
        }
        eo("ERR_BUFFER_OUT_OF_BOUNDS", function(e8) {
          return e8 ? `${e8} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError);
        eo("ERR_INVALID_ARG_TYPE", function(e8, t5) {
          return `The "${e8}" argument must be of type number. Received type ${typeof t5}`;
        }, TypeError);
        eo("ERR_OUT_OF_RANGE", function(e8, t5, r6) {
          let n3 = `The value of "${e8}" is out of range.`, o = r6;
          return Number.isInteger(r6) && Math.abs(r6) > 2 ** 32 ? o = Si(String(r6)) : typeof r6 == "bigint" && (o = String(r6), (r6 > BigInt(2) ** BigInt(32) || r6 < -(BigInt(2) ** BigInt(32))) && (o = Si(o)), o += "n"), n3 += ` It must be ${t5}. Received ${o}`, n3;
        }, RangeError);
        function Si(e8) {
          let t5 = "", r6 = e8.length, n3 = e8[0] === "-" ? 1 : 0;
          for (; r6 >= n3 + 4; r6 -= 3)
            t5 = `_${e8.slice(r6 - 3, r6)}${t5}`;
          return `${e8.slice(0, r6)}${t5}`;
        }
        function Il(e8, t5, r6) {
          Rt(t5, "offset"), (e8[t5] === void 0 || e8[t5 + r6] === void 0) && nr(t5, e8.length - (r6 + 1));
        }
        function $i(e8, t5, r6, n3, o, i2) {
          if (e8 > r6 || e8 < t5) {
            let s3 = typeof t5 == "bigint" ? "n" : "", a4;
            throw i2 > 3 ? t5 === 0 || t5 === BigInt(0) ? a4 = `>= 0${s3} and < 2${s3} ** ${(i2 + 1) * 8}${s3}` : a4 = `>= -(2${s3} ** ${(i2 + 1) * 8 - 1}${s3}) and < 2 ** ${(i2 + 1) * 8 - 1}${s3}` : a4 = `>= ${t5}${s3} and <= ${r6}${s3}`, new Mt.ERR_OUT_OF_RANGE("value", a4, e8);
          }
          Il(n3, o, i2);
        }
        function Rt(e8, t5) {
          if (typeof e8 != "number")
            throw new Mt.ERR_INVALID_ARG_TYPE(t5, "number", e8);
        }
        function nr(e8, t5, r6) {
          throw Math.floor(e8) !== e8 ? (Rt(e8, r6), new Mt.ERR_OUT_OF_RANGE(r6 || "offset", "an integer", e8)) : t5 < 0 ? new Mt.ERR_BUFFER_OUT_OF_BOUNDS() : new Mt.ERR_OUT_OF_RANGE(r6 || "offset", `>= ${r6 ? 1 : 0} and <= ${t5}`, e8);
        }
        var kl = /[^+/0-9A-Za-z-_]/g;
        function Dl(e8) {
          if (e8 = e8.split("=")[0], e8 = e8.trim().replace(kl, ""), e8.length < 2)
            return "";
          for (; e8.length % 4 !== 0; )
            e8 = e8 + "=";
          return e8;
        }
        function Zn(e8, t5) {
          t5 = t5 || 1 / 0;
          let r6, n3 = e8.length, o = null, i2 = [];
          for (let s3 = 0; s3 < n3; ++s3) {
            if (r6 = e8.charCodeAt(s3), r6 > 55295 && r6 < 57344) {
              if (!o) {
                if (r6 > 56319) {
                  (t5 -= 3) > -1 && i2.push(239, 191, 189);
                  continue;
                } else if (s3 + 1 === n3) {
                  (t5 -= 3) > -1 && i2.push(239, 191, 189);
                  continue;
                }
                o = r6;
                continue;
              }
              if (r6 < 56320) {
                (t5 -= 3) > -1 && i2.push(239, 191, 189), o = r6;
                continue;
              }
              r6 = (o - 55296 << 10 | r6 - 56320) + 65536;
            } else
              o && (t5 -= 3) > -1 && i2.push(239, 191, 189);
            if (o = null, r6 < 128) {
              if ((t5 -= 1) < 0)
                break;
              i2.push(r6);
            } else if (r6 < 2048) {
              if ((t5 -= 2) < 0)
                break;
              i2.push(r6 >> 6 | 192, r6 & 63 | 128);
            } else if (r6 < 65536) {
              if ((t5 -= 3) < 0)
                break;
              i2.push(r6 >> 12 | 224, r6 >> 6 & 63 | 128, r6 & 63 | 128);
            } else if (r6 < 1114112) {
              if ((t5 -= 4) < 0)
                break;
              i2.push(r6 >> 18 | 240, r6 >> 12 & 63 | 128, r6 >> 6 & 63 | 128, r6 & 63 | 128);
            } else
              throw new Error("Invalid code point");
          }
          return i2;
        }
        function _l(e8) {
          let t5 = [];
          for (let r6 = 0; r6 < e8.length; ++r6)
            t5.push(e8.charCodeAt(r6) & 255);
          return t5;
        }
        function Nl(e8, t5) {
          let r6, n3, o, i2 = [];
          for (let s3 = 0; s3 < e8.length && !((t5 -= 2) < 0); ++s3)
            r6 = e8.charCodeAt(s3), n3 = r6 >> 8, o = r6 % 256, i2.push(o), i2.push(n3);
          return i2;
        }
        function qi(e8) {
          return Hn.toByteArray(Dl(e8));
        }
        function Ur(e8, t5, r6, n3) {
          let o;
          for (o = 0; o < n3 && !(o + r6 >= t5.length || o >= e8.length); ++o)
            t5[o + r6] = e8[o];
          return o;
        }
        function ke(e8, t5) {
          return e8 instanceof t5 || e8 != null && e8.constructor != null && e8.constructor.name != null && e8.constructor.name === t5.name;
        }
        function to(e8) {
          return e8 !== e8;
        }
        var Ll = function() {
          let e8 = "0123456789abcdef", t5 = new Array(256);
          for (let r6 = 0; r6 < 16; ++r6) {
            let n3 = r6 * 16;
            for (let o = 0; o < 16; ++o)
              t5[n3 + o] = e8[r6] + e8[o];
          }
          return t5;
        }();
        function Ze(e8) {
          return typeof BigInt > "u" ? Bl : e8;
        }
        function Bl() {
          throw new Error("BigInt not supported");
        }
      });
      var x2;
      var d2 = Br(() => {
        "use strict";
        x2 = ve(Vi());
      });
      var go = Z((j) => {
        "use strict";
        d2();
        p2();
        f();
        var W = (e8, t5) => () => (t5 || e8((t5 = { exports: {} }).exports, t5), t5.exports), Yi = W((e8, t5) => {
          "use strict";
          t5.exports = function() {
            if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
              return false;
            if (typeof Symbol.iterator == "symbol")
              return true;
            var r6 = {}, n3 = Symbol("test"), o = Object(n3);
            if (typeof n3 == "string" || Object.prototype.toString.call(n3) !== "[object Symbol]" || Object.prototype.toString.call(o) !== "[object Symbol]")
              return false;
            var i2 = 42;
            r6[n3] = i2;
            for (n3 in r6)
              return false;
            if (typeof Object.keys == "function" && Object.keys(r6).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(r6).length !== 0)
              return false;
            var s3 = Object.getOwnPropertySymbols(r6);
            if (s3.length !== 1 || s3[0] !== n3 || !Object.prototype.propertyIsEnumerable.call(r6, n3))
              return false;
            if (typeof Object.getOwnPropertyDescriptor == "function") {
              var a4 = Object.getOwnPropertyDescriptor(r6, n3);
              if (a4.value !== i2 || a4.enumerable !== true)
                return false;
            }
            return true;
          };
        }), Qr = W((e8, t5) => {
          "use strict";
          var r6 = Yi();
          t5.exports = function() {
            return r6() && !!Symbol.toStringTag;
          };
        }), jl = W((e8, t5) => {
          "use strict";
          var r6 = typeof Symbol < "u" && Symbol, n3 = Yi();
          t5.exports = function() {
            return typeof r6 != "function" || typeof Symbol != "function" || typeof r6("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : n3();
          };
        }), Ul = W((e8, t5) => {
          "use strict";
          var r6 = { foo: {} }, n3 = Object;
          t5.exports = function() {
            return { __proto__: r6 }.foo === r6.foo && !({ __proto__: null } instanceof n3);
          };
        }), $l = W((e8, t5) => {
          "use strict";
          var r6 = "Function.prototype.bind called on incompatible ", n3 = Array.prototype.slice, o = Object.prototype.toString, i2 = "[object Function]";
          t5.exports = function(s3) {
            var a4 = this;
            if (typeof a4 != "function" || o.call(a4) !== i2)
              throw new TypeError(r6 + a4);
            for (var u2 = n3.call(arguments, 1), l, c2 = function() {
              if (this instanceof l) {
                var b2 = a4.apply(this, u2.concat(n3.call(arguments)));
                return Object(b2) === b2 ? b2 : this;
              } else
                return a4.apply(s3, u2.concat(n3.call(arguments)));
            }, m2 = Math.max(0, a4.length - u2.length), g2 = [], w = 0; w < m2; w++)
              g2.push("$" + w);
            if (l = h2("binder", "return function (" + g2.join(",") + "){ return binder.apply(this,arguments); }")(c2), a4.prototype) {
              var E = function() {
              };
              E.prototype = a4.prototype, l.prototype = new E(), E.prototype = null;
            }
            return l;
          };
        }), lo = W((e8, t5) => {
          "use strict";
          var r6 = $l();
          t5.exports = h2.prototype.bind || r6;
        }), ql = W((e8, t5) => {
          "use strict";
          var r6 = lo();
          t5.exports = r6.call(h2.call, Object.prototype.hasOwnProperty);
        }), co = W((e8, t5) => {
          "use strict";
          var r6, n3 = SyntaxError, o = h2, i2 = TypeError, s3 = function($2) {
            try {
              return o('"use strict"; return (' + $2 + ").constructor;")();
            } catch (U) {
            }
          }, a4 = Object.getOwnPropertyDescriptor;
          if (a4)
            try {
              a4({}, "");
            } catch ($2) {
              a4 = null;
            }
          var u2 = function() {
            throw new i2();
          }, l = a4 ? function() {
            try {
              return arguments.callee, u2;
            } catch ($2) {
              try {
                return a4(arguments, "callee").get;
              } catch (U) {
                return u2;
              }
            }
          }() : u2, c2 = jl()(), m2 = Ul()(), g2 = Object.getPrototypeOf || (m2 ? function($2) {
            return $2.__proto__;
          } : null), w = {}, E = typeof Uint8Array > "u" || !g2 ? r6 : g2(Uint8Array), b2 = { "%AggregateError%": typeof AggregateError > "u" ? r6 : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r6 : ArrayBuffer, "%ArrayIteratorPrototype%": c2 && g2 ? g2([][Symbol.iterator]()) : r6, "%AsyncFromSyncIteratorPrototype%": r6, "%AsyncFunction%": w, "%AsyncGenerator%": w, "%AsyncGeneratorFunction%": w, "%AsyncIteratorPrototype%": w, "%Atomics%": typeof Atomics > "u" ? r6 : Atomics, "%BigInt%": typeof BigInt > "u" ? r6 : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? r6 : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? r6 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? r6 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": void 0, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? r6 : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? r6 : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r6 : FinalizationRegistry, "%Function%": o, "%GeneratorFunction%": w, "%Int8Array%": typeof Int8Array > "u" ? r6 : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? r6 : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? r6 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": c2 && g2 ? g2(g2([][Symbol.iterator]())) : r6, "%JSON%": typeof JSON == "object" ? JSON : r6, "%Map%": typeof Map > "u" ? r6 : Map, "%MapIteratorPrototype%": typeof Map > "u" || !c2 || !g2 ? r6 : g2((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? r6 : Promise, "%Proxy%": typeof Proxy > "u" ? r6 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? r6 : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? r6 : Set, "%SetIteratorPrototype%": typeof Set > "u" || !c2 || !g2 ? r6 : g2((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r6 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": c2 && g2 ? g2(""[Symbol.iterator]()) : r6, "%Symbol%": c2 ? Symbol : r6, "%SyntaxError%": n3, "%ThrowTypeError%": l, "%TypedArray%": E, "%TypeError%": i2, "%Uint8Array%": typeof Uint8Array > "u" ? r6 : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r6 : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? r6 : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? r6 : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? r6 : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? r6 : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? r6 : WeakSet };
          if (g2)
            try {
              null.error;
            } catch ($2) {
              T = g2(g2($2)), b2["%Error.prototype%"] = T;
            }
          var T, S = function $2(U) {
            var O;
            if (U === "%AsyncFunction%")
              O = s3("async function () {}");
            else if (U === "%GeneratorFunction%")
              O = s3("function* () {}");
            else if (U === "%AsyncGeneratorFunction%")
              O = s3("async function* () {}");
            else if (U === "%AsyncGenerator%") {
              var ie = $2("%AsyncGeneratorFunction%");
              ie && (O = ie.prototype);
            } else if (U === "%AsyncIteratorPrototype%") {
              var se = $2("%AsyncGenerator%");
              se && g2 && (O = g2(se.prototype));
            }
            return b2[U] = O, O;
          }, R = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, C = lo(), M = ql(), N = C.call(h2.call, Array.prototype.concat), L = C.call(h2.apply, Array.prototype.splice), Te = C.call(h2.call, String.prototype.replace), V = C.call(h2.call, String.prototype.slice), H = C.call(h2.call, RegExp.prototype.exec), Ee = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, z2 = /\\(\\)?/g, Pe = function($2) {
            var U = V($2, 0, 1), O = V($2, -1);
            if (U === "%" && O !== "%")
              throw new n3("invalid intrinsic syntax, expected closing `%`");
            if (O === "%" && U !== "%")
              throw new n3("invalid intrinsic syntax, expected opening `%`");
            var ie = [];
            return Te($2, Ee, function(se, He, Y, pt) {
              ie[ie.length] = Y ? Te(pt, z2, "$1") : He || se;
            }), ie;
          }, We = function($2, U) {
            var O = $2, ie;
            if (M(R, O) && (ie = R[O], O = "%" + ie[0] + "%"), M(b2, O)) {
              var se = b2[O];
              if (se === w && (se = S(O)), typeof se > "u" && !U)
                throw new i2("intrinsic " + $2 + " exists, but is not available. Please file an issue!");
              return { alias: ie, name: O, value: se };
            }
            throw new n3("intrinsic " + $2 + " does not exist!");
          };
          t5.exports = function($2, U) {
            if (typeof $2 != "string" || $2.length === 0)
              throw new i2("intrinsic name must be a non-empty string");
            if (arguments.length > 1 && typeof U != "boolean")
              throw new i2('"allowMissing" argument must be a boolean');
            if (H(/^%?[^%]*%?$/, $2) === null)
              throw new n3("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
            var O = Pe($2), ie = O.length > 0 ? O[0] : "", se = We("%" + ie + "%", U), He = se.name, Y = se.value, pt = false, ze = se.alias;
            ze && (ie = ze[0], L(O, N([0, 1], ze)));
            for (var ft = 1, qe = true; ft < O.length; ft += 1) {
              var de = O[ft], dt = V(de, 0, 1), Tt = V(de, -1);
              if ((dt === '"' || dt === "'" || dt === "`" || Tt === '"' || Tt === "'" || Tt === "`") && dt !== Tt)
                throw new n3("property names with quotes must have matching quotes");
              if ((de === "constructor" || !qe) && (pt = true), ie += "." + de, He = "%" + ie + "%", M(b2, He))
                Y = b2[He];
              else if (Y != null) {
                if (!(de in Y)) {
                  if (!U)
                    throw new i2("base intrinsic for " + $2 + " exists, but the property is not available.");
                  return;
                }
                if (a4 && ft + 1 >= O.length) {
                  var Ct = a4(Y, de);
                  qe = !!Ct, qe && "get" in Ct && !("originalValue" in Ct.get) ? Y = Ct.get : Y = Y[de];
                } else
                  qe = M(Y, de), Y = Y[de];
                qe && !pt && (b2[He] = Y);
              }
            }
            return Y;
          };
        }), Vl = W((e8, t5) => {
          "use strict";
          var r6 = lo(), n3 = co(), o = n3("%Function.prototype.apply%"), i2 = n3("%Function.prototype.call%"), s3 = n3("%Reflect.apply%", true) || r6.call(i2, o), a4 = n3("%Object.getOwnPropertyDescriptor%", true), u2 = n3("%Object.defineProperty%", true), l = n3("%Math.max%");
          if (u2)
            try {
              u2({}, "a", { value: 1 });
            } catch (m2) {
              u2 = null;
            }
          t5.exports = function(m2) {
            var g2 = s3(r6, i2, arguments);
            if (a4 && u2) {
              var w = a4(g2, "length");
              w.configurable && u2(g2, "length", { value: 1 + l(0, m2.length - (arguments.length - 1)) });
            }
            return g2;
          };
          var c2 = function() {
            return s3(r6, o, arguments);
          };
          u2 ? u2(t5.exports, "apply", { value: c2 }) : t5.exports.apply = c2;
        }), po = W((e8, t5) => {
          "use strict";
          var r6 = co(), n3 = Vl(), o = n3(r6("String.prototype.indexOf"));
          t5.exports = function(i2, s3) {
            var a4 = r6(i2, !!s3);
            return typeof a4 == "function" && o(i2, ".prototype.") > -1 ? n3(a4) : a4;
          };
        }), Kl = W((e8, t5) => {
          "use strict";
          var r6 = Qr()(), n3 = po(), o = n3("Object.prototype.toString"), i2 = function(u2) {
            return r6 && u2 && typeof u2 == "object" && Symbol.toStringTag in u2 ? false : o(u2) === "[object Arguments]";
          }, s3 = function(u2) {
            return i2(u2) ? true : u2 !== null && typeof u2 == "object" && typeof u2.length == "number" && u2.length >= 0 && o(u2) !== "[object Array]" && o(u2.callee) === "[object Function]";
          }, a4 = function() {
            return i2(arguments);
          }();
          i2.isLegacyArguments = s3, t5.exports = a4 ? i2 : s3;
        }), Gl = W((e8, t5) => {
          "use strict";
          var r6 = Object.prototype.toString, n3 = h2.prototype.toString, o = /^\s*(?:function)?\*/, i2 = Qr()(), s3 = Object.getPrototypeOf, a4 = function() {
            if (!i2)
              return false;
            try {
              return h2("return function*() {}")();
            } catch (l) {
            }
          }, u2;
          t5.exports = function(l) {
            if (typeof l != "function")
              return false;
            if (o.test(n3.call(l)))
              return true;
            if (!i2) {
              var c2 = r6.call(l);
              return c2 === "[object GeneratorFunction]";
            }
            if (!s3)
              return false;
            if (typeof u2 > "u") {
              var m2 = a4();
              u2 = m2 ? s3(m2) : false;
            }
            return s3(l) === u2;
          };
        }), Jl = W((e8, t5) => {
          "use strict";
          var r6 = h2.prototype.toString, n3 = typeof Reflect == "object" && Reflect !== null && Reflect.apply, o, i2;
          if (typeof n3 == "function" && typeof Object.defineProperty == "function")
            try {
              o = Object.defineProperty({}, "length", { get: function() {
                throw i2;
              } }), i2 = {}, n3(function() {
                throw 42;
              }, null, o);
            } catch (M) {
              M !== i2 && (n3 = null);
            }
          else
            n3 = null;
          var s3 = /^\s*class\b/, a4 = function(M) {
            try {
              var N = r6.call(M);
              return s3.test(N);
            } catch (L) {
              return false;
            }
          }, u2 = function(M) {
            try {
              return a4(M) ? false : (r6.call(M), true);
            } catch (N) {
              return false;
            }
          }, l = Object.prototype.toString, c2 = "[object Object]", m2 = "[object Function]", g2 = "[object GeneratorFunction]", w = "[object HTMLAllCollection]", E = "[object HTML document.all class]", b2 = "[object HTMLCollection]", T = typeof Symbol == "function" && !!Symbol.toStringTag, S = !(0 in [,]), R = function() {
            return false;
          };
          typeof document == "object" && (C = document.all, l.call(C) === l.call(document.all) && (R = function(M) {
            if ((S || !M) && (typeof M > "u" || typeof M == "object"))
              try {
                var N = l.call(M);
                return (N === w || N === E || N === b2 || N === c2) && M("") == null;
              } catch (L) {
              }
            return false;
          }));
          var C;
          t5.exports = n3 ? function(M) {
            if (R(M))
              return true;
            if (!M || typeof M != "function" && typeof M != "object")
              return false;
            try {
              n3(M, null, o);
            } catch (N) {
              if (N !== i2)
                return false;
            }
            return !a4(M) && u2(M);
          } : function(M) {
            if (R(M))
              return true;
            if (!M || typeof M != "function" && typeof M != "object")
              return false;
            if (T)
              return u2(M);
            if (a4(M))
              return false;
            var N = l.call(M);
            return N !== m2 && N !== g2 && !/^\[object HTML/.test(N) ? false : u2(M);
          };
        }), Xi = W((e8, t5) => {
          "use strict";
          var r6 = Jl(), n3 = Object.prototype.toString, o = Object.prototype.hasOwnProperty, i2 = function(l, c2, m2) {
            for (var g2 = 0, w = l.length; g2 < w; g2++)
              o.call(l, g2) && (m2 == null ? c2(l[g2], g2, l) : c2.call(m2, l[g2], g2, l));
          }, s3 = function(l, c2, m2) {
            for (var g2 = 0, w = l.length; g2 < w; g2++)
              m2 == null ? c2(l.charAt(g2), g2, l) : c2.call(m2, l.charAt(g2), g2, l);
          }, a4 = function(l, c2, m2) {
            for (var g2 in l)
              o.call(l, g2) && (m2 == null ? c2(l[g2], g2, l) : c2.call(m2, l[g2], g2, l));
          }, u2 = function(l, c2, m2) {
            if (!r6(c2))
              throw new TypeError("iterator must be a function");
            var g2;
            arguments.length >= 3 && (g2 = m2), n3.call(l) === "[object Array]" ? i2(l, c2, g2) : typeof l == "string" ? s3(l, c2, g2) : a4(l, c2, g2);
          };
          t5.exports = u2;
        }), es = W((e8, t5) => {
          "use strict";
          var r6 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], n3 = typeof globalThis > "u" ? globalThis : globalThis;
          t5.exports = function() {
            for (var o = [], i2 = 0; i2 < r6.length; i2++)
              typeof n3[r6[i2]] == "function" && (o[o.length] = r6[i2]);
            return o;
          };
        }), ts = W((e8, t5) => {
          "use strict";
          var r6 = co(), n3 = r6("%Object.getOwnPropertyDescriptor%", true);
          if (n3)
            try {
              n3([], "length");
            } catch (o) {
              n3 = null;
            }
          t5.exports = n3;
        }), rs = W((e8, t5) => {
          "use strict";
          var r6 = Xi(), n3 = es(), o = po(), i2 = o("Object.prototype.toString"), s3 = Qr()(), a4 = ts(), u2 = typeof globalThis > "u" ? globalThis : globalThis, l = n3(), c2 = o("Array.prototype.indexOf", true) || function(b2, T) {
            for (var S = 0; S < b2.length; S += 1)
              if (b2[S] === T)
                return S;
            return -1;
          }, m2 = o("String.prototype.slice"), g2 = {}, w = Object.getPrototypeOf;
          s3 && a4 && w && r6(l, function(b2) {
            var T = new u2[b2]();
            if (Symbol.toStringTag in T) {
              var S = w(T), R = a4(S, Symbol.toStringTag);
              if (!R) {
                var C = w(S);
                R = a4(C, Symbol.toStringTag);
              }
              g2[b2] = R.get;
            }
          });
          var E = function(b2) {
            var T = false;
            return r6(g2, function(S, R) {
              if (!T)
                try {
                  T = S.call(b2) === R;
                } catch (C) {
                }
            }), T;
          };
          t5.exports = function(b2) {
            if (!b2 || typeof b2 != "object")
              return false;
            if (!s3 || !(Symbol.toStringTag in b2)) {
              var T = m2(i2(b2), 8, -1);
              return c2(l, T) > -1;
            }
            return a4 ? E(b2) : false;
          };
        }), Ql = W((e8, t5) => {
          "use strict";
          var r6 = Xi(), n3 = es(), o = po(), i2 = ts(), s3 = o("Object.prototype.toString"), a4 = Qr()(), u2 = typeof globalThis > "u" ? globalThis : globalThis, l = n3(), c2 = o("String.prototype.slice"), m2 = {}, g2 = Object.getPrototypeOf;
          a4 && i2 && g2 && r6(l, function(b2) {
            if (typeof u2[b2] == "function") {
              var T = new u2[b2]();
              if (Symbol.toStringTag in T) {
                var S = g2(T), R = i2(S, Symbol.toStringTag);
                if (!R) {
                  var C = g2(S);
                  R = i2(C, Symbol.toStringTag);
                }
                m2[b2] = R.get;
              }
            }
          });
          var w = function(b2) {
            var T = false;
            return r6(m2, function(S, R) {
              if (!T)
                try {
                  var C = S.call(b2);
                  C === R && (T = C);
                } catch (M) {
                }
            }), T;
          }, E = rs();
          t5.exports = function(b2) {
            return E(b2) ? !a4 || !(Symbol.toStringTag in b2) ? c2(s3(b2), 8, -1) : w(b2) : false;
          };
        }), Wl = W((e8) => {
          "use strict";
          var t5 = Kl(), r6 = Gl(), n3 = Ql(), o = rs();
          function i2(A) {
            return A.call.bind(A);
          }
          var s3 = typeof BigInt < "u", a4 = typeof Symbol < "u", u2 = i2(Object.prototype.toString), l = i2(Number.prototype.valueOf), c2 = i2(String.prototype.valueOf), m2 = i2(Boolean.prototype.valueOf);
          s3 && (g2 = i2(BigInt.prototype.valueOf));
          var g2;
          a4 && (w = i2(Symbol.prototype.valueOf));
          var w;
          function E(A, ol) {
            if (typeof A != "object")
              return false;
            try {
              return ol(A), true;
            } catch (Hd) {
              return false;
            }
          }
          e8.isArgumentsObject = t5, e8.isGeneratorFunction = r6, e8.isTypedArray = o;
          function b2(A) {
            return typeof Promise < "u" && A instanceof Promise || A !== null && typeof A == "object" && typeof A.then == "function" && typeof A.catch == "function";
          }
          e8.isPromise = b2;
          function T(A) {
            return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(A) : o(A) || ft(A);
          }
          e8.isArrayBufferView = T;
          function S(A) {
            return n3(A) === "Uint8Array";
          }
          e8.isUint8Array = S;
          function R(A) {
            return n3(A) === "Uint8ClampedArray";
          }
          e8.isUint8ClampedArray = R;
          function C(A) {
            return n3(A) === "Uint16Array";
          }
          e8.isUint16Array = C;
          function M(A) {
            return n3(A) === "Uint32Array";
          }
          e8.isUint32Array = M;
          function N(A) {
            return n3(A) === "Int8Array";
          }
          e8.isInt8Array = N;
          function L(A) {
            return n3(A) === "Int16Array";
          }
          e8.isInt16Array = L;
          function Te(A) {
            return n3(A) === "Int32Array";
          }
          e8.isInt32Array = Te;
          function V(A) {
            return n3(A) === "Float32Array";
          }
          e8.isFloat32Array = V;
          function H(A) {
            return n3(A) === "Float64Array";
          }
          e8.isFloat64Array = H;
          function Ee(A) {
            return n3(A) === "BigInt64Array";
          }
          e8.isBigInt64Array = Ee;
          function z2(A) {
            return n3(A) === "BigUint64Array";
          }
          e8.isBigUint64Array = z2;
          function Pe(A) {
            return u2(A) === "[object Map]";
          }
          Pe.working = typeof Map < "u" && Pe(/* @__PURE__ */ new Map());
          function We(A) {
            return typeof Map > "u" ? false : Pe.working ? Pe(A) : A instanceof Map;
          }
          e8.isMap = We;
          function $2(A) {
            return u2(A) === "[object Set]";
          }
          $2.working = typeof Set < "u" && $2(/* @__PURE__ */ new Set());
          function U(A) {
            return typeof Set > "u" ? false : $2.working ? $2(A) : A instanceof Set;
          }
          e8.isSet = U;
          function O(A) {
            return u2(A) === "[object WeakMap]";
          }
          O.working = typeof WeakMap < "u" && O(/* @__PURE__ */ new WeakMap());
          function ie(A) {
            return typeof WeakMap > "u" ? false : O.working ? O(A) : A instanceof WeakMap;
          }
          e8.isWeakMap = ie;
          function se(A) {
            return u2(A) === "[object WeakSet]";
          }
          se.working = typeof WeakSet < "u" && se(/* @__PURE__ */ new WeakSet());
          function He(A) {
            return se(A);
          }
          e8.isWeakSet = He;
          function Y(A) {
            return u2(A) === "[object ArrayBuffer]";
          }
          Y.working = typeof ArrayBuffer < "u" && Y(new ArrayBuffer());
          function pt(A) {
            return typeof ArrayBuffer > "u" ? false : Y.working ? Y(A) : A instanceof ArrayBuffer;
          }
          e8.isArrayBuffer = pt;
          function ze(A) {
            return u2(A) === "[object DataView]";
          }
          ze.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ze(new DataView(new ArrayBuffer(1), 0, 1));
          function ft(A) {
            return typeof DataView > "u" ? false : ze.working ? ze(A) : A instanceof DataView;
          }
          e8.isDataView = ft;
          var qe = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
          function de(A) {
            return u2(A) === "[object SharedArrayBuffer]";
          }
          function dt(A) {
            return typeof qe > "u" ? false : (typeof de.working > "u" && (de.working = de(new qe())), de.working ? de(A) : A instanceof qe);
          }
          e8.isSharedArrayBuffer = dt;
          function Tt(A) {
            return u2(A) === "[object AsyncFunction]";
          }
          e8.isAsyncFunction = Tt;
          function Ct(A) {
            return u2(A) === "[object Map Iterator]";
          }
          e8.isMapIterator = Ct;
          function Xu(A) {
            return u2(A) === "[object Set Iterator]";
          }
          e8.isSetIterator = Xu;
          function el(A) {
            return u2(A) === "[object Generator]";
          }
          e8.isGeneratorObject = el;
          function tl(A) {
            return u2(A) === "[object WebAssembly.Module]";
          }
          e8.isWebAssemblyCompiledModule = tl;
          function xi(A) {
            return E(A, l);
          }
          e8.isNumberObject = xi;
          function bi(A) {
            return E(A, c2);
          }
          e8.isStringObject = bi;
          function wi(A) {
            return E(A, m2);
          }
          e8.isBooleanObject = wi;
          function Ei(A) {
            return s3 && E(A, g2);
          }
          e8.isBigIntObject = Ei;
          function Pi(A) {
            return a4 && E(A, w);
          }
          e8.isSymbolObject = Pi;
          function rl(A) {
            return xi(A) || bi(A) || wi(A) || Ei(A) || Pi(A);
          }
          e8.isBoxedPrimitive = rl;
          function nl(A) {
            return typeof Uint8Array < "u" && (pt(A) || dt(A));
          }
          e8.isAnyArrayBuffer = nl, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(A) {
            Object.defineProperty(e8, A, { enumerable: false, value: function() {
              throw new Error(A + " is not supported in userland");
            } });
          });
        }), Hl = W((e8, t5) => {
          t5.exports = function(r6) {
            return r6 instanceof x2.Buffer;
          };
        }), zl = W((e8, t5) => {
          typeof Object.create == "function" ? t5.exports = function(r6, n3) {
            n3 && (r6.super_ = n3, r6.prototype = Object.create(n3.prototype, { constructor: { value: r6, enumerable: false, writable: true, configurable: true } }));
          } : t5.exports = function(r6, n3) {
            if (n3) {
              r6.super_ = n3;
              var o = function() {
              };
              o.prototype = n3.prototype, r6.prototype = new o(), r6.prototype.constructor = r6;
            }
          };
        }), ns = Object.getOwnPropertyDescriptors || function(e8) {
          for (var t5 = Object.keys(e8), r6 = {}, n3 = 0; n3 < t5.length; n3++)
            r6[t5[n3]] = Object.getOwnPropertyDescriptor(e8, t5[n3]);
          return r6;
        }, Zl = /%[sdj%]/g;
        j.format = function(e8) {
          if (!Hr(e8)) {
            for (var t5 = [], r6 = 0; r6 < arguments.length; r6++)
              t5.push(Xe(arguments[r6]));
            return t5.join(" ");
          }
          for (var r6 = 1, n3 = arguments, o = n3.length, i2 = String(e8).replace(Zl, function(u2) {
            if (u2 === "%%")
              return "%";
            if (r6 >= o)
              return u2;
            switch (u2) {
              case "%s":
                return String(n3[r6++]);
              case "%d":
                return Number(n3[r6++]);
              case "%j":
                try {
                  return JSON.stringify(n3[r6++]);
                } catch (l) {
                  return "[Circular]";
                }
              default:
                return u2;
            }
          }), s3 = n3[r6]; r6 < o; s3 = n3[++r6])
            Wr(s3) || !Ft(s3) ? i2 += " " + s3 : i2 += " " + Xe(s3);
          return i2;
        };
        j.deprecate = function(e8, t5) {
          if (typeof y2 < "u" && y2.noDeprecation === true)
            return e8;
          if (typeof y2 > "u")
            return function() {
              return j.deprecate(e8, t5).apply(this, arguments);
            };
          var r6 = false;
          function n3() {
            if (!r6) {
              if (y2.throwDeprecation)
                throw new Error(t5);
              y2.traceDeprecation ? console.trace(t5) : console.error(t5), r6 = true;
            }
            return e8.apply(this, arguments);
          }
          return n3;
        };
        var qr = {}, os = /^$/;
        y2.env.NODE_DEBUG && (Vr = y2.env.NODE_DEBUG, Vr = Vr.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), os = new RegExp("^" + Vr + "$", "i"));
        var Vr;
        j.debuglog = function(e8) {
          if (e8 = e8.toUpperCase(), !qr[e8])
            if (os.test(e8)) {
              var t5 = y2.pid;
              qr[e8] = function() {
                var r6 = j.format.apply(j, arguments);
                console.error("%s %d: %s", e8, t5, r6);
              };
            } else
              qr[e8] = function() {
              };
          return qr[e8];
        };
        function Xe(e8, t5) {
          var r6 = { seen: [], stylize: Xl };
          return arguments.length >= 3 && (r6.depth = arguments[2]), arguments.length >= 4 && (r6.colors = arguments[3]), fo(t5) ? r6.showHidden = t5 : t5 && j._extend(r6, t5), yt(r6.showHidden) && (r6.showHidden = false), yt(r6.depth) && (r6.depth = 2), yt(r6.colors) && (r6.colors = false), yt(r6.customInspect) && (r6.customInspect = true), r6.colors && (r6.stylize = Yl), Gr(r6, e8, r6.depth);
        }
        j.inspect = Xe;
        Xe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
        Xe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
        function Yl(e8, t5) {
          var r6 = Xe.styles[t5];
          return r6 ? "\x1B[" + Xe.colors[r6][0] + "m" + e8 + "\x1B[" + Xe.colors[r6][1] + "m" : e8;
        }
        function Xl(e8, t5) {
          return e8;
        }
        function ec(e8) {
          var t5 = {};
          return e8.forEach(function(r6, n3) {
            t5[r6] = true;
          }), t5;
        }
        function Gr(e8, t5, r6) {
          if (e8.customInspect && t5 && Kr(t5.inspect) && t5.inspect !== j.inspect && !(t5.constructor && t5.constructor.prototype === t5)) {
            var n3 = t5.inspect(r6, e8);
            return Hr(n3) || (n3 = Gr(e8, n3, r6)), n3;
          }
          var o = tc(e8, t5);
          if (o)
            return o;
          var i2 = Object.keys(t5), s3 = ec(i2);
          if (e8.showHidden && (i2 = Object.getOwnPropertyNames(t5)), ir(t5) && (i2.indexOf("message") >= 0 || i2.indexOf("description") >= 0))
            return so(t5);
          if (i2.length === 0) {
            if (Kr(t5)) {
              var a4 = t5.name ? ": " + t5.name : "";
              return e8.stylize("[Function" + a4 + "]", "special");
            }
            if (or(t5))
              return e8.stylize(RegExp.prototype.toString.call(t5), "regexp");
            if (Jr(t5))
              return e8.stylize(Date.prototype.toString.call(t5), "date");
            if (ir(t5))
              return so(t5);
          }
          var u2 = "", l = false, c2 = ["{", "}"];
          if (is(t5) && (l = true, c2 = ["[", "]"]), Kr(t5)) {
            var m2 = t5.name ? ": " + t5.name : "";
            u2 = " [Function" + m2 + "]";
          }
          if (or(t5) && (u2 = " " + RegExp.prototype.toString.call(t5)), Jr(t5) && (u2 = " " + Date.prototype.toUTCString.call(t5)), ir(t5) && (u2 = " " + so(t5)), i2.length === 0 && (!l || t5.length == 0))
            return c2[0] + u2 + c2[1];
          if (r6 < 0)
            return or(t5) ? e8.stylize(RegExp.prototype.toString.call(t5), "regexp") : e8.stylize("[Object]", "special");
          e8.seen.push(t5);
          var g2;
          return l ? g2 = rc(e8, t5, r6, s3, i2) : g2 = i2.map(function(w) {
            return uo(e8, t5, r6, s3, w, l);
          }), e8.seen.pop(), nc(g2, u2, c2);
        }
        function tc(e8, t5) {
          if (yt(t5))
            return e8.stylize("undefined", "undefined");
          if (Hr(t5)) {
            var r6 = "'" + JSON.stringify(t5).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e8.stylize(r6, "string");
          }
          if (ss(t5))
            return e8.stylize("" + t5, "number");
          if (fo(t5))
            return e8.stylize("" + t5, "boolean");
          if (Wr(t5))
            return e8.stylize("null", "null");
        }
        function so(e8) {
          return "[" + Error.prototype.toString.call(e8) + "]";
        }
        function rc(e8, t5, r6, n3, o) {
          for (var i2 = [], s3 = 0, a4 = t5.length; s3 < a4; ++s3)
            as(t5, String(s3)) ? i2.push(uo(e8, t5, r6, n3, String(s3), true)) : i2.push("");
          return o.forEach(function(u2) {
            u2.match(/^\d+$/) || i2.push(uo(e8, t5, r6, n3, u2, true));
          }), i2;
        }
        function uo(e8, t5, r6, n3, o, i2) {
          var s3, a4, u2;
          if (u2 = Object.getOwnPropertyDescriptor(t5, o) || { value: t5[o] }, u2.get ? u2.set ? a4 = e8.stylize("[Getter/Setter]", "special") : a4 = e8.stylize("[Getter]", "special") : u2.set && (a4 = e8.stylize("[Setter]", "special")), as(n3, o) || (s3 = "[" + o + "]"), a4 || (e8.seen.indexOf(u2.value) < 0 ? (Wr(r6) ? a4 = Gr(e8, u2.value, null) : a4 = Gr(e8, u2.value, r6 - 1), a4.indexOf(`
`) > -1 && (i2 ? a4 = a4.split(`
`).map(function(l) {
            return "  " + l;
          }).join(`
`).slice(2) : a4 = `
` + a4.split(`
`).map(function(l) {
            return "   " + l;
          }).join(`
`))) : a4 = e8.stylize("[Circular]", "special")), yt(s3)) {
            if (i2 && o.match(/^\d+$/))
              return a4;
            s3 = JSON.stringify("" + o), s3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s3 = s3.slice(1, -1), s3 = e8.stylize(s3, "name")) : (s3 = s3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s3 = e8.stylize(s3, "string"));
          }
          return s3 + ": " + a4;
        }
        function nc(e8, t5, r6) {
          var n3 = 0, o = e8.reduce(function(i2, s3) {
            return n3++, s3.indexOf(`
`) >= 0 && n3++, i2 + s3.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return o > 60 ? r6[0] + (t5 === "" ? "" : t5 + `
 `) + " " + e8.join(`,
  `) + " " + r6[1] : r6[0] + t5 + " " + e8.join(", ") + " " + r6[1];
        }
        j.types = Wl();
        function is(e8) {
          return Array.isArray(e8);
        }
        j.isArray = is;
        function fo(e8) {
          return typeof e8 == "boolean";
        }
        j.isBoolean = fo;
        function Wr(e8) {
          return e8 === null;
        }
        j.isNull = Wr;
        function oc(e8) {
          return e8 == null;
        }
        j.isNullOrUndefined = oc;
        function ss(e8) {
          return typeof e8 == "number";
        }
        j.isNumber = ss;
        function Hr(e8) {
          return typeof e8 == "string";
        }
        j.isString = Hr;
        function ic(e8) {
          return typeof e8 == "symbol";
        }
        j.isSymbol = ic;
        function yt(e8) {
          return e8 === void 0;
        }
        j.isUndefined = yt;
        function or(e8) {
          return Ft(e8) && mo(e8) === "[object RegExp]";
        }
        j.isRegExp = or;
        j.types.isRegExp = or;
        function Ft(e8) {
          return typeof e8 == "object" && e8 !== null;
        }
        j.isObject = Ft;
        function Jr(e8) {
          return Ft(e8) && mo(e8) === "[object Date]";
        }
        j.isDate = Jr;
        j.types.isDate = Jr;
        function ir(e8) {
          return Ft(e8) && (mo(e8) === "[object Error]" || e8 instanceof Error);
        }
        j.isError = ir;
        j.types.isNativeError = ir;
        function Kr(e8) {
          return typeof e8 == "function";
        }
        j.isFunction = Kr;
        function sc(e8) {
          return e8 === null || typeof e8 == "boolean" || typeof e8 == "number" || typeof e8 == "string" || typeof e8 == "symbol" || typeof e8 > "u";
        }
        j.isPrimitive = sc;
        j.isBuffer = Hl();
        function mo(e8) {
          return Object.prototype.toString.call(e8);
        }
        function ao(e8) {
          return e8 < 10 ? "0" + e8.toString(10) : e8.toString(10);
        }
        var ac = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function uc() {
          var e8 = /* @__PURE__ */ new Date(), t5 = [ao(e8.getHours()), ao(e8.getMinutes()), ao(e8.getSeconds())].join(":");
          return [e8.getDate(), ac[e8.getMonth()], t5].join(" ");
        }
        j.log = function() {
          console.log("%s - %s", uc(), j.format.apply(j, arguments));
        };
        j.inherits = zl();
        j._extend = function(e8, t5) {
          if (!t5 || !Ft(t5))
            return e8;
          for (var r6 = Object.keys(t5), n3 = r6.length; n3--; )
            e8[r6[n3]] = t5[r6[n3]];
          return e8;
        };
        function as(e8, t5) {
          return Object.prototype.hasOwnProperty.call(e8, t5);
        }
        var gt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
        j.promisify = function(e8) {
          if (typeof e8 != "function")
            throw new TypeError('The "original" argument must be of type Function');
          if (gt && e8[gt]) {
            var t5 = e8[gt];
            if (typeof t5 != "function")
              throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(t5, gt, { value: t5, enumerable: false, writable: false, configurable: true }), t5;
          }
          function t5() {
            for (var r6, n3, o = new Promise(function(a4, u2) {
              r6 = a4, n3 = u2;
            }), i2 = [], s3 = 0; s3 < arguments.length; s3++)
              i2.push(arguments[s3]);
            i2.push(function(a4, u2) {
              a4 ? n3(a4) : r6(u2);
            });
            try {
              e8.apply(this, i2);
            } catch (a4) {
              n3(a4);
            }
            return o;
          }
          return Object.setPrototypeOf(t5, Object.getPrototypeOf(e8)), gt && Object.defineProperty(t5, gt, { value: t5, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t5, ns(e8));
        };
        j.promisify.custom = gt;
        function lc(e8, t5) {
          if (!e8) {
            var r6 = new Error("Promise was rejected with a falsy value");
            r6.reason = e8, e8 = r6;
          }
          return t5(e8);
        }
        function cc(e8) {
          if (typeof e8 != "function")
            throw new TypeError('The "original" argument must be of type Function');
          function t5() {
            for (var r6 = [], n3 = 0; n3 < arguments.length; n3++)
              r6.push(arguments[n3]);
            var o = r6.pop();
            if (typeof o != "function")
              throw new TypeError("The last argument must be of type Function");
            var i2 = this, s3 = function() {
              return o.apply(i2, arguments);
            };
            e8.apply(this, r6).then(function(a4) {
              y2.nextTick(s3.bind(null, null, a4));
            }, function(a4) {
              y2.nextTick(lc.bind(null, a4, s3));
            });
          }
          return Object.setPrototypeOf(t5, Object.getPrototypeOf(e8)), Object.defineProperties(t5, ns(e8)), t5;
        }
        j.callbackify = cc;
      });
      var ls = Z((og, us) => {
        "use strict";
        d2();
        p2();
        f();
        var It = 1e3, kt = It * 60, Dt = kt * 60, ht = Dt * 24, pc = ht * 7, fc = ht * 365.25;
        us.exports = function(e8, t5) {
          t5 = t5 || {};
          var r6 = typeof e8;
          if (r6 === "string" && e8.length > 0)
            return dc(e8);
          if (r6 === "number" && isFinite(e8))
            return t5.long ? gc(e8) : mc(e8);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e8));
        };
        function dc(e8) {
          if (e8 = String(e8), !(e8.length > 100)) {
            var t5 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e8);
            if (t5) {
              var r6 = parseFloat(t5[1]), n3 = (t5[2] || "ms").toLowerCase();
              switch (n3) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return r6 * fc;
                case "weeks":
                case "week":
                case "w":
                  return r6 * pc;
                case "days":
                case "day":
                case "d":
                  return r6 * ht;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return r6 * Dt;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return r6 * kt;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return r6 * It;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return r6;
                default:
                  return;
              }
            }
          }
        }
        function mc(e8) {
          var t5 = Math.abs(e8);
          return t5 >= ht ? Math.round(e8 / ht) + "d" : t5 >= Dt ? Math.round(e8 / Dt) + "h" : t5 >= kt ? Math.round(e8 / kt) + "m" : t5 >= It ? Math.round(e8 / It) + "s" : e8 + "ms";
        }
        function gc(e8) {
          var t5 = Math.abs(e8);
          return t5 >= ht ? zr(e8, t5, ht, "day") : t5 >= Dt ? zr(e8, t5, Dt, "hour") : t5 >= kt ? zr(e8, t5, kt, "minute") : t5 >= It ? zr(e8, t5, It, "second") : e8 + " ms";
        }
        function zr(e8, t5, r6, n3) {
          var o = t5 >= r6 * 1.5;
          return Math.round(e8 / r6) + " " + n3 + (o ? "s" : "");
        }
      });
      var yo = Z((ug, cs) => {
        "use strict";
        d2();
        p2();
        f();
        function yc(e8) {
          r6.debug = r6, r6.default = r6, r6.coerce = u2, r6.disable = i2, r6.enable = o, r6.enabled = s3, r6.humanize = ls(), r6.destroy = l, Object.keys(e8).forEach((c2) => {
            r6[c2] = e8[c2];
          }), r6.names = [], r6.skips = [], r6.formatters = {};
          function t5(c2) {
            let m2 = 0;
            for (let g2 = 0; g2 < c2.length; g2++)
              m2 = (m2 << 5) - m2 + c2.charCodeAt(g2), m2 |= 0;
            return r6.colors[Math.abs(m2) % r6.colors.length];
          }
          r6.selectColor = t5;
          function r6(c2) {
            let m2, g2 = null, w, E;
            function b2(...T) {
              if (!b2.enabled)
                return;
              let S = b2, R = Number(/* @__PURE__ */ new Date()), C = R - (m2 || R);
              S.diff = C, S.prev = m2, S.curr = R, m2 = R, T[0] = r6.coerce(T[0]), typeof T[0] != "string" && T.unshift("%O");
              let M = 0;
              T[0] = T[0].replace(/%([a-zA-Z%])/g, (L, Te) => {
                if (L === "%%")
                  return "%";
                M++;
                let V = r6.formatters[Te];
                if (typeof V == "function") {
                  let H = T[M];
                  L = V.call(S, H), T.splice(M, 1), M--;
                }
                return L;
              }), r6.formatArgs.call(S, T), (S.log || r6.log).apply(S, T);
            }
            return b2.namespace = c2, b2.useColors = r6.useColors(), b2.color = r6.selectColor(c2), b2.extend = n3, b2.destroy = r6.destroy, Object.defineProperty(b2, "enabled", { enumerable: true, configurable: false, get: () => g2 !== null ? g2 : (w !== r6.namespaces && (w = r6.namespaces, E = r6.enabled(c2)), E), set: (T) => {
              g2 = T;
            } }), typeof r6.init == "function" && r6.init(b2), b2;
          }
          function n3(c2, m2) {
            let g2 = r6(this.namespace + (typeof m2 == "undefined" ? ":" : m2) + c2);
            return g2.log = this.log, g2;
          }
          function o(c2) {
            r6.save(c2), r6.namespaces = c2, r6.names = [], r6.skips = [];
            let m2, g2 = (typeof c2 == "string" ? c2 : "").split(/[\s,]+/), w = g2.length;
            for (m2 = 0; m2 < w; m2++)
              g2[m2] && (c2 = g2[m2].replace(/\*/g, ".*?"), c2[0] === "-" ? r6.skips.push(new RegExp("^" + c2.slice(1) + "$")) : r6.names.push(new RegExp("^" + c2 + "$")));
          }
          function i2() {
            let c2 = [...r6.names.map(a4), ...r6.skips.map(a4).map((m2) => "-" + m2)].join(",");
            return r6.enable(""), c2;
          }
          function s3(c2) {
            if (c2[c2.length - 1] === "*")
              return true;
            let m2, g2;
            for (m2 = 0, g2 = r6.skips.length; m2 < g2; m2++)
              if (r6.skips[m2].test(c2))
                return false;
            for (m2 = 0, g2 = r6.names.length; m2 < g2; m2++)
              if (r6.names[m2].test(c2))
                return true;
            return false;
          }
          function a4(c2) {
            return c2.toString().substring(2, c2.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          function u2(c2) {
            return c2 instanceof Error ? c2.stack || c2.message : c2;
          }
          function l() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          return r6.enable(r6.load()), r6;
        }
        cs.exports = yc;
      });
      var ps = Z((Ae, Zr) => {
        "use strict";
        d2();
        p2();
        f();
        Ae.formatArgs = xc;
        Ae.save = bc;
        Ae.load = wc;
        Ae.useColors = hc;
        Ae.storage = Ec();
        Ae.destroy = (() => {
          let e8 = false;
          return () => {
            e8 || (e8 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })();
        Ae.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
        function hc() {
          return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function xc(e8) {
          if (e8[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e8[0] + (this.useColors ? "%c " : " ") + "+" + Zr.exports.humanize(this.diff), !this.useColors)
            return;
          let t5 = "color: " + this.color;
          e8.splice(1, 0, t5, "color: inherit");
          let r6 = 0, n3 = 0;
          e8[0].replace(/%[a-zA-Z%]/g, (o) => {
            o !== "%%" && (r6++, o === "%c" && (n3 = r6));
          }), e8.splice(n3, 0, t5);
        }
        Ae.log = console.debug || console.log || (() => {
        });
        function bc(e8) {
          try {
            e8 ? Ae.storage.setItem("debug", e8) : Ae.storage.removeItem("debug");
          } catch (t5) {
          }
        }
        function wc() {
          let e8;
          try {
            e8 = Ae.storage.getItem("debug");
          } catch (t5) {
          }
          return !e8 && typeof y2 != "undefined" && "env" in y2 && (e8 = y2.env.DEBUG), e8;
        }
        function Ec() {
          try {
            return localStorage;
          } catch (e8) {
          }
        }
        Zr.exports = yo()(Ae);
        var { formatters: Pc } = Zr.exports;
        Pc.j = function(e8) {
          try {
            return JSON.stringify(e8);
          } catch (t5) {
            return "[UnexpectedJSONParseError]: " + t5.message;
          }
        };
      });
      var ho = Z((Yr) => {
        "use strict";
        d2();
        p2();
        f();
        Yr.isatty = function() {
          return false;
        };
        function vc() {
          throw new Error("tty.ReadStream is not implemented");
        }
        Yr.ReadStream = vc;
        function Ac() {
          throw new Error("tty.WriteStream is not implemented");
        }
        Yr.WriteStream = Ac;
      });
      var fs = Z(() => {
        "use strict";
        d2();
        p2();
        f();
      });
      var ms = Z((Ag, ds) => {
        "use strict";
        d2();
        p2();
        f();
        ds.exports = (e8, t5 = y2.argv) => {
          let r6 = e8.startsWith("-") ? "" : e8.length === 1 ? "-" : "--", n3 = t5.indexOf(r6 + e8), o = t5.indexOf("--");
          return n3 !== -1 && (o === -1 || n3 < o);
        };
      });
      var hs = Z((Sg, ys) => {
        "use strict";
        d2();
        p2();
        f();
        var Tc = fs(), gs = ho(), Me = ms(), { env: te } = y2, et;
        Me("no-color") || Me("no-colors") || Me("color=false") || Me("color=never") ? et = 0 : (Me("color") || Me("colors") || Me("color=true") || Me("color=always")) && (et = 1);
        "FORCE_COLOR" in te && (te.FORCE_COLOR === "true" ? et = 1 : te.FORCE_COLOR === "false" ? et = 0 : et = te.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(te.FORCE_COLOR, 10), 3));
        function xo(e8) {
          return e8 === 0 ? false : { level: e8, hasBasic: true, has256: e8 >= 2, has16m: e8 >= 3 };
        }
        function bo(e8, t5) {
          if (et === 0)
            return 0;
          if (Me("color=16m") || Me("color=full") || Me("color=truecolor"))
            return 3;
          if (Me("color=256"))
            return 2;
          if (e8 && !t5 && et === void 0)
            return 0;
          let r6 = et || 0;
          if (te.TERM === "dumb")
            return r6;
          if (y2.platform === "win32") {
            let n3 = Tc.release().split(".");
            return Number(n3[0]) >= 10 && Number(n3[2]) >= 10586 ? Number(n3[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in te)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n3) => n3 in te) || te.CI_NAME === "codeship" ? 1 : r6;
          if ("TEAMCITY_VERSION" in te)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(te.TEAMCITY_VERSION) ? 1 : 0;
          if (te.COLORTERM === "truecolor")
            return 3;
          if ("TERM_PROGRAM" in te) {
            let n3 = parseInt((te.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (te.TERM_PROGRAM) {
              case "iTerm.app":
                return n3 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(te.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(te.TERM) || "COLORTERM" in te ? 1 : r6;
        }
        function Cc(e8) {
          let t5 = bo(e8, e8 && e8.isTTY);
          return xo(t5);
        }
        ys.exports = { supportsColor: Cc, stdout: xo(bo(true, gs.isatty(1))), stderr: xo(bo(true, gs.isatty(2))) };
      });
      var bs = Z((ae, en) => {
        "use strict";
        d2();
        p2();
        f();
        var Mc = ho(), Xr = go();
        ae.init = Dc;
        ae.log = Fc;
        ae.formatArgs = Rc;
        ae.save = Ic;
        ae.load = kc;
        ae.useColors = Sc;
        ae.destroy = Xr.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        ae.colors = [6, 2, 3, 4, 5, 1];
        try {
          let e8 = hs();
          e8 && (e8.stderr || e8).level >= 2 && (ae.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
        } catch (e8) {
        }
        ae.inspectOpts = Object.keys(y2.env).filter((e8) => /^debug_/i.test(e8)).reduce((e8, t5) => {
          let r6 = t5.substring(6).toLowerCase().replace(/_([a-z])/g, (o, i2) => i2.toUpperCase()), n3 = y2.env[t5];
          return /^(yes|on|true|enabled)$/i.test(n3) ? n3 = true : /^(no|off|false|disabled)$/i.test(n3) ? n3 = false : n3 === "null" ? n3 = null : n3 = Number(n3), e8[r6] = n3, e8;
        }, {});
        function Sc() {
          return "colors" in ae.inspectOpts ? !!ae.inspectOpts.colors : Mc.isatty(y2.stderr.fd);
        }
        function Rc(e8) {
          let { namespace: t5, useColors: r6 } = this;
          if (r6) {
            let n3 = this.color, o = "\x1B[3" + (n3 < 8 ? n3 : "8;5;" + n3), i2 = `  ${o};1m${t5} \x1B[0m`;
            e8[0] = i2 + e8[0].split(`
`).join(`
` + i2), e8.push(o + "m+" + en.exports.humanize(this.diff) + "\x1B[0m");
          } else
            e8[0] = Oc() + t5 + " " + e8[0];
        }
        function Oc() {
          return ae.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
        }
        function Fc(...e8) {
          return y2.stderr.write(Xr.format(...e8) + `
`);
        }
        function Ic(e8) {
          e8 ? y2.env.DEBUG = e8 : delete y2.env.DEBUG;
        }
        function kc() {
          return y2.env.DEBUG;
        }
        function Dc(e8) {
          e8.inspectOpts = {};
          let t5 = Object.keys(ae.inspectOpts);
          for (let r6 = 0; r6 < t5.length; r6++)
            e8.inspectOpts[t5[r6]] = ae.inspectOpts[t5[r6]];
        }
        en.exports = yo()(ae);
        var { formatters: xs } = en.exports;
        xs.o = function(e8) {
          return this.inspectOpts.colors = this.useColors, Xr.inspect(e8, this.inspectOpts).split(`
`).map((t5) => t5.trim()).join(" ");
        };
        xs.O = function(e8) {
          return this.inspectOpts.colors = this.useColors, Xr.inspect(e8, this.inspectOpts);
        };
      });
      var Eo = Z((_g, wo) => {
        "use strict";
        d2();
        p2();
        f();
        typeof y2 == "undefined" || y2.type === "renderer" || y2.browser === true || y2.__nwjs ? wo.exports = ps() : wo.exports = bs();
      });
      function Bc() {
        return false;
      }
      var jc;
      var Uc;
      var un;
      var Ao = Br(() => {
        "use strict";
        d2();
        p2();
        f();
        jc = {}, Uc = { existsSync: Bc, promises: jc }, un = Uc;
      });
      var To = Z((Py, Rs) => {
        "use strict";
        d2();
        p2();
        f();
        function De(e8) {
          if (typeof e8 != "string")
            throw new TypeError("Path must be a string. Received " + JSON.stringify(e8));
        }
        function Ss(e8, t5) {
          for (var r6 = "", n3 = 0, o = -1, i2 = 0, s3, a4 = 0; a4 <= e8.length; ++a4) {
            if (a4 < e8.length)
              s3 = e8.charCodeAt(a4);
            else {
              if (s3 === 47)
                break;
              s3 = 47;
            }
            if (s3 === 47) {
              if (!(o === a4 - 1 || i2 === 1))
                if (o !== a4 - 1 && i2 === 2) {
                  if (r6.length < 2 || n3 !== 2 || r6.charCodeAt(r6.length - 1) !== 46 || r6.charCodeAt(r6.length - 2) !== 46) {
                    if (r6.length > 2) {
                      var u2 = r6.lastIndexOf("/");
                      if (u2 !== r6.length - 1) {
                        u2 === -1 ? (r6 = "", n3 = 0) : (r6 = r6.slice(0, u2), n3 = r6.length - 1 - r6.lastIndexOf("/")), o = a4, i2 = 0;
                        continue;
                      }
                    } else if (r6.length === 2 || r6.length === 1) {
                      r6 = "", n3 = 0, o = a4, i2 = 0;
                      continue;
                    }
                  }
                  t5 && (r6.length > 0 ? r6 += "/.." : r6 = "..", n3 = 2);
                } else
                  r6.length > 0 ? r6 += "/" + e8.slice(o + 1, a4) : r6 = e8.slice(o + 1, a4), n3 = a4 - o - 1;
              o = a4, i2 = 0;
            } else
              s3 === 46 && i2 !== -1 ? ++i2 : i2 = -1;
          }
          return r6;
        }
        function $c(e8, t5) {
          var r6 = t5.dir || t5.root, n3 = t5.base || (t5.name || "") + (t5.ext || "");
          return r6 ? r6 === t5.root ? r6 + n3 : r6 + e8 + n3 : n3;
        }
        var Lt = { resolve: function() {
          for (var e8 = "", t5 = false, r6, n3 = arguments.length - 1; n3 >= -1 && !t5; n3--) {
            var o;
            n3 >= 0 ? o = arguments[n3] : (r6 === void 0 && (r6 = y2.cwd()), o = r6), De(o), o.length !== 0 && (e8 = o + "/" + e8, t5 = o.charCodeAt(0) === 47);
          }
          return e8 = Ss(e8, !t5), t5 ? e8.length > 0 ? "/" + e8 : "/" : e8.length > 0 ? e8 : ".";
        }, normalize: function(e8) {
          if (De(e8), e8.length === 0)
            return ".";
          var t5 = e8.charCodeAt(0) === 47, r6 = e8.charCodeAt(e8.length - 1) === 47;
          return e8 = Ss(e8, !t5), e8.length === 0 && !t5 && (e8 = "."), e8.length > 0 && r6 && (e8 += "/"), t5 ? "/" + e8 : e8;
        }, isAbsolute: function(e8) {
          return De(e8), e8.length > 0 && e8.charCodeAt(0) === 47;
        }, join: function() {
          if (arguments.length === 0)
            return ".";
          for (var e8, t5 = 0; t5 < arguments.length; ++t5) {
            var r6 = arguments[t5];
            De(r6), r6.length > 0 && (e8 === void 0 ? e8 = r6 : e8 += "/" + r6);
          }
          return e8 === void 0 ? "." : Lt.normalize(e8);
        }, relative: function(e8, t5) {
          if (De(e8), De(t5), e8 === t5 || (e8 = Lt.resolve(e8), t5 = Lt.resolve(t5), e8 === t5))
            return "";
          for (var r6 = 1; r6 < e8.length && e8.charCodeAt(r6) === 47; ++r6)
            ;
          for (var n3 = e8.length, o = n3 - r6, i2 = 1; i2 < t5.length && t5.charCodeAt(i2) === 47; ++i2)
            ;
          for (var s3 = t5.length, a4 = s3 - i2, u2 = o < a4 ? o : a4, l = -1, c2 = 0; c2 <= u2; ++c2) {
            if (c2 === u2) {
              if (a4 > u2) {
                if (t5.charCodeAt(i2 + c2) === 47)
                  return t5.slice(i2 + c2 + 1);
                if (c2 === 0)
                  return t5.slice(i2 + c2);
              } else
                o > u2 && (e8.charCodeAt(r6 + c2) === 47 ? l = c2 : c2 === 0 && (l = 0));
              break;
            }
            var m2 = e8.charCodeAt(r6 + c2), g2 = t5.charCodeAt(i2 + c2);
            if (m2 !== g2)
              break;
            m2 === 47 && (l = c2);
          }
          var w = "";
          for (c2 = r6 + l + 1; c2 <= n3; ++c2)
            (c2 === n3 || e8.charCodeAt(c2) === 47) && (w.length === 0 ? w += ".." : w += "/..");
          return w.length > 0 ? w + t5.slice(i2 + l) : (i2 += l, t5.charCodeAt(i2) === 47 && ++i2, t5.slice(i2));
        }, _makeLong: function(e8) {
          return e8;
        }, dirname: function(e8) {
          if (De(e8), e8.length === 0)
            return ".";
          for (var t5 = e8.charCodeAt(0), r6 = t5 === 47, n3 = -1, o = true, i2 = e8.length - 1; i2 >= 1; --i2)
            if (t5 = e8.charCodeAt(i2), t5 === 47) {
              if (!o) {
                n3 = i2;
                break;
              }
            } else
              o = false;
          return n3 === -1 ? r6 ? "/" : "." : r6 && n3 === 1 ? "//" : e8.slice(0, n3);
        }, basename: function(e8, t5) {
          if (t5 !== void 0 && typeof t5 != "string")
            throw new TypeError('"ext" argument must be a string');
          De(e8);
          var r6 = 0, n3 = -1, o = true, i2;
          if (t5 !== void 0 && t5.length > 0 && t5.length <= e8.length) {
            if (t5.length === e8.length && t5 === e8)
              return "";
            var s3 = t5.length - 1, a4 = -1;
            for (i2 = e8.length - 1; i2 >= 0; --i2) {
              var u2 = e8.charCodeAt(i2);
              if (u2 === 47) {
                if (!o) {
                  r6 = i2 + 1;
                  break;
                }
              } else
                a4 === -1 && (o = false, a4 = i2 + 1), s3 >= 0 && (u2 === t5.charCodeAt(s3) ? --s3 === -1 && (n3 = i2) : (s3 = -1, n3 = a4));
            }
            return r6 === n3 ? n3 = a4 : n3 === -1 && (n3 = e8.length), e8.slice(r6, n3);
          } else {
            for (i2 = e8.length - 1; i2 >= 0; --i2)
              if (e8.charCodeAt(i2) === 47) {
                if (!o) {
                  r6 = i2 + 1;
                  break;
                }
              } else
                n3 === -1 && (o = false, n3 = i2 + 1);
            return n3 === -1 ? "" : e8.slice(r6, n3);
          }
        }, extname: function(e8) {
          De(e8);
          for (var t5 = -1, r6 = 0, n3 = -1, o = true, i2 = 0, s3 = e8.length - 1; s3 >= 0; --s3) {
            var a4 = e8.charCodeAt(s3);
            if (a4 === 47) {
              if (!o) {
                r6 = s3 + 1;
                break;
              }
              continue;
            }
            n3 === -1 && (o = false, n3 = s3 + 1), a4 === 46 ? t5 === -1 ? t5 = s3 : i2 !== 1 && (i2 = 1) : t5 !== -1 && (i2 = -1);
          }
          return t5 === -1 || n3 === -1 || i2 === 0 || i2 === 1 && t5 === n3 - 1 && t5 === r6 + 1 ? "" : e8.slice(t5, n3);
        }, format: function(e8) {
          if (e8 === null || typeof e8 != "object")
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e8);
          return $c("/", e8);
        }, parse: function(e8) {
          De(e8);
          var t5 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (e8.length === 0)
            return t5;
          var r6 = e8.charCodeAt(0), n3 = r6 === 47, o;
          n3 ? (t5.root = "/", o = 1) : o = 0;
          for (var i2 = -1, s3 = 0, a4 = -1, u2 = true, l = e8.length - 1, c2 = 0; l >= o; --l) {
            if (r6 = e8.charCodeAt(l), r6 === 47) {
              if (!u2) {
                s3 = l + 1;
                break;
              }
              continue;
            }
            a4 === -1 && (u2 = false, a4 = l + 1), r6 === 46 ? i2 === -1 ? i2 = l : c2 !== 1 && (c2 = 1) : i2 !== -1 && (c2 = -1);
          }
          return i2 === -1 || a4 === -1 || c2 === 0 || c2 === 1 && i2 === a4 - 1 && i2 === s3 + 1 ? a4 !== -1 && (s3 === 0 && n3 ? t5.base = t5.name = e8.slice(1, a4) : t5.base = t5.name = e8.slice(s3, a4)) : (s3 === 0 && n3 ? (t5.name = e8.slice(1, i2), t5.base = e8.slice(1, a4)) : (t5.name = e8.slice(s3, i2), t5.base = e8.slice(s3, a4)), t5.ext = e8.slice(i2, a4)), s3 > 0 ? t5.dir = e8.slice(0, s3 - 1) : n3 && (t5.dir = "/"), t5;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        Lt.posix = Lt;
        Rs.exports = Lt;
      });
      var Is = Z((Oy, Fs) => {
        "use strict";
        d2();
        p2();
        f();
        Fs.exports = (e8) => {
          let t5 = e8.match(/^[ \t]*(?=\S)/gm);
          return t5 ? t5.reduce((r6, n3) => Math.min(r6, n3.length), 1 / 0) : 0;
        };
      });
      var Ds = Z((Dy, ks) => {
        "use strict";
        d2();
        p2();
        f();
        var Vc = Is();
        ks.exports = (e8) => {
          let t5 = Vc(e8);
          if (t5 === 0)
            return e8;
          let r6 = new RegExp(`^[ \\t]{${t5}}`, "gm");
          return e8.replace(r6, "");
        };
      });
      var Ns = Z((qy, So) => {
        "use strict";
        d2();
        p2();
        f();
        var Kc = Object.prototype.hasOwnProperty, me = "~";
        function ar() {
        }
        Object.create && (ar.prototype = /* @__PURE__ */ Object.create(null), new ar().__proto__ || (me = false));
        function Gc(e8, t5, r6) {
          this.fn = e8, this.context = t5, this.once = r6 || false;
        }
        function _s(e8, t5, r6, n3, o) {
          if (typeof r6 != "function")
            throw new TypeError("The listener must be a function");
          var i2 = new Gc(r6, n3 || e8, o), s3 = me ? me + t5 : t5;
          return e8._events[s3] ? e8._events[s3].fn ? e8._events[s3] = [e8._events[s3], i2] : e8._events[s3].push(i2) : (e8._events[s3] = i2, e8._eventsCount++), e8;
        }
        function ln(e8, t5) {
          --e8._eventsCount === 0 ? e8._events = new ar() : delete e8._events[t5];
        }
        function le() {
          this._events = new ar(), this._eventsCount = 0;
        }
        le.prototype.eventNames = function() {
          var e8 = [], t5, r6;
          if (this._eventsCount === 0)
            return e8;
          for (r6 in t5 = this._events)
            Kc.call(t5, r6) && e8.push(me ? r6.slice(1) : r6);
          return Object.getOwnPropertySymbols ? e8.concat(Object.getOwnPropertySymbols(t5)) : e8;
        };
        le.prototype.listeners = function(e8) {
          var t5 = me ? me + e8 : e8, r6 = this._events[t5];
          if (!r6)
            return [];
          if (r6.fn)
            return [r6.fn];
          for (var n3 = 0, o = r6.length, i2 = new Array(o); n3 < o; n3++)
            i2[n3] = r6[n3].fn;
          return i2;
        };
        le.prototype.listenerCount = function(e8) {
          var t5 = me ? me + e8 : e8, r6 = this._events[t5];
          return r6 ? r6.fn ? 1 : r6.length : 0;
        };
        le.prototype.emit = function(e8, t5, r6, n3, o, i2) {
          var s3 = me ? me + e8 : e8;
          if (!this._events[s3])
            return false;
          var a4 = this._events[s3], u2 = arguments.length, l, c2;
          if (a4.fn) {
            switch (a4.once && this.removeListener(e8, a4.fn, void 0, true), u2) {
              case 1:
                return a4.fn.call(a4.context), true;
              case 2:
                return a4.fn.call(a4.context, t5), true;
              case 3:
                return a4.fn.call(a4.context, t5, r6), true;
              case 4:
                return a4.fn.call(a4.context, t5, r6, n3), true;
              case 5:
                return a4.fn.call(a4.context, t5, r6, n3, o), true;
              case 6:
                return a4.fn.call(a4.context, t5, r6, n3, o, i2), true;
            }
            for (c2 = 1, l = new Array(u2 - 1); c2 < u2; c2++)
              l[c2 - 1] = arguments[c2];
            a4.fn.apply(a4.context, l);
          } else {
            var m2 = a4.length, g2;
            for (c2 = 0; c2 < m2; c2++)
              switch (a4[c2].once && this.removeListener(e8, a4[c2].fn, void 0, true), u2) {
                case 1:
                  a4[c2].fn.call(a4[c2].context);
                  break;
                case 2:
                  a4[c2].fn.call(a4[c2].context, t5);
                  break;
                case 3:
                  a4[c2].fn.call(a4[c2].context, t5, r6);
                  break;
                case 4:
                  a4[c2].fn.call(a4[c2].context, t5, r6, n3);
                  break;
                default:
                  if (!l)
                    for (g2 = 1, l = new Array(u2 - 1); g2 < u2; g2++)
                      l[g2 - 1] = arguments[g2];
                  a4[c2].fn.apply(a4[c2].context, l);
              }
          }
          return true;
        };
        le.prototype.on = function(e8, t5, r6) {
          return _s(this, e8, t5, r6, false);
        };
        le.prototype.once = function(e8, t5, r6) {
          return _s(this, e8, t5, r6, true);
        };
        le.prototype.removeListener = function(e8, t5, r6, n3) {
          var o = me ? me + e8 : e8;
          if (!this._events[o])
            return this;
          if (!t5)
            return ln(this, o), this;
          var i2 = this._events[o];
          if (i2.fn)
            i2.fn === t5 && (!n3 || i2.once) && (!r6 || i2.context === r6) && ln(this, o);
          else {
            for (var s3 = 0, a4 = [], u2 = i2.length; s3 < u2; s3++)
              (i2[s3].fn !== t5 || n3 && !i2[s3].once || r6 && i2[s3].context !== r6) && a4.push(i2[s3]);
            a4.length ? this._events[o] = a4.length === 1 ? a4[0] : a4 : ln(this, o);
          }
          return this;
        };
        le.prototype.removeAllListeners = function(e8) {
          var t5;
          return e8 ? (t5 = me ? me + e8 : e8, this._events[t5] && ln(this, t5)) : (this._events = new ar(), this._eventsCount = 0), this;
        };
        le.prototype.off = le.prototype.removeListener;
        le.prototype.addListener = le.prototype.on;
        le.prefixed = me;
        le.EventEmitter = le;
        typeof So < "u" && (So.exports = le);
      });
      var Bs = Z((Jy, Ls) => {
        "use strict";
        d2();
        p2();
        f();
        Ls.exports = (e8, t5 = 1, r6) => {
          if (r6 = { indent: " ", includeEmptyLines: false, ...r6 }, typeof e8 != "string")
            throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e8}\``);
          if (typeof t5 != "number")
            throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t5}\``);
          if (typeof r6.indent != "string")
            throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r6.indent}\``);
          if (t5 === 0)
            return e8;
          let n3 = r6.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
          return e8.replace(n3, r6.indent.repeat(t5));
        };
      });
      var $s = Z((eh, Us) => {
        "use strict";
        d2();
        p2();
        f();
        Us.exports = ({ onlyFirst: e8 = false } = {}) => {
          let t5 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(t5, e8 ? void 0 : "g");
        };
      });
      var Vs = Z((oh, qs) => {
        "use strict";
        d2();
        p2();
        f();
        var zc = $s();
        qs.exports = (e8) => typeof e8 == "string" ? e8.replace(zc(), "") : e8;
      });
      var Ws = Z(() => {
        "use strict";
        d2();
        p2();
        f();
      });
      var ui = Z((AM, uu) => {
        "use strict";
        d2();
        p2();
        f();
        uu.exports = function() {
          function e8(t5, r6, n3, o, i2) {
            return t5 < r6 || n3 < r6 ? t5 > n3 ? n3 + 1 : t5 + 1 : o === i2 ? r6 : r6 + 1;
          }
          return function(t5, r6) {
            if (t5 === r6)
              return 0;
            if (t5.length > r6.length) {
              var n3 = t5;
              t5 = r6, r6 = n3;
            }
            for (var o = t5.length, i2 = r6.length; o > 0 && t5.charCodeAt(o - 1) === r6.charCodeAt(i2 - 1); )
              o--, i2--;
            for (var s3 = 0; s3 < o && t5.charCodeAt(s3) === r6.charCodeAt(s3); )
              s3++;
            if (o -= s3, i2 -= s3, o === 0 || i2 < 3)
              return i2;
            var a4 = 0, u2, l, c2, m2, g2, w, E, b2, T, S, R, C, M = [];
            for (u2 = 0; u2 < o; u2++)
              M.push(u2 + 1), M.push(t5.charCodeAt(s3 + u2));
            for (var N = M.length - 1; a4 < i2 - 3; )
              for (T = r6.charCodeAt(s3 + (l = a4)), S = r6.charCodeAt(s3 + (c2 = a4 + 1)), R = r6.charCodeAt(s3 + (m2 = a4 + 2)), C = r6.charCodeAt(s3 + (g2 = a4 + 3)), w = a4 += 4, u2 = 0; u2 < N; u2 += 2)
                E = M[u2], b2 = M[u2 + 1], l = e8(E, l, c2, T, b2), c2 = e8(l, c2, m2, S, b2), m2 = e8(c2, m2, g2, R, b2), w = e8(m2, g2, w, C, b2), M[u2] = w, g2 = m2, m2 = c2, c2 = l, l = E;
            for (; a4 < i2; )
              for (T = r6.charCodeAt(s3 + (l = a4)), w = ++a4, u2 = 0; u2 < N; u2 += 2)
                E = M[u2], M[u2] = w = e8(E, l, w, T, M[u2 + 1]), l = E;
            return w;
          };
        }();
      });
      var Wd = {};
      rr(Wd, { DMMF: () => Ce, DMMFClass: () => $r, Debug: () => Po, Decimal: () => je, Extensions: () => ro, MetricsClient: () => Ut, NotFoundError: () => Ke, ObjectEnumValue: () => _e, PrismaClientInitializationError: () => re, PrismaClientKnownRequestError: () => ce, PrismaClientRustPanicError: () => Ge, PrismaClientUnknownRequestError: () => Se, PrismaClientValidationError: () => pe, Public: () => no, Sql: () => xe, Types: () => oo, defineDmmfProperty: () => Js, empty: () => zs, getPrismaClient: () => zu, itxClientDenyList: () => gi, join: () => Hs, makeStrictEnum: () => Zu, objectEnumNames: () => Yc, objectEnumValues: () => pn, raw: () => No, sqltag: () => Lo, warnEnvConflicts: () => void 0, warnOnce: () => lr });
      module.exports = pl(Wd);
      d2();
      p2();
      f();
      var ro = {};
      rr(ro, { defineExtension: () => Ki, getExtensionContext: () => Gi });
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function Ki(e8) {
        return typeof e8 == "function" ? e8 : (t5) => t5.$extends(e8);
      }
      d2();
      p2();
      f();
      function Gi(e8) {
        return e8;
      }
      var no = {};
      rr(no, { validator: () => Ji });
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function Ji(...e8) {
        return (t5) => t5;
      }
      var oo = {};
      rr(oo, { Extensions: () => Qi, Public: () => Wi, Result: () => Hi, Utils: () => zi });
      d2();
      p2();
      f();
      var Qi = {};
      d2();
      p2();
      f();
      var Wi = {};
      d2();
      p2();
      f();
      var Hi = {};
      d2();
      p2();
      f();
      var zi = {};
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Ye = (e8, t5) => {
        let r6 = {};
        for (let n3 of e8) {
          let o = n3[t5];
          r6[o] = n3;
        }
        return r6;
      };
      function Zi(e8) {
        return e8.substring(0, 1).toLowerCase() + e8.substring(1);
      }
      var $r = class {
        constructor(t5) {
          this.document = t5;
          this.compositeNames = new Set(this.datamodel.types.map((r6) => r6.name)), this.typeAndModelMap = this.buildTypeModelMap(), this.mappingsMap = this.buildMappingsMap(), this.outputTypeMap = this.buildMergedOutputTypeMap(), this.rootFieldMap = this.buildRootFieldMap(), this.inputTypesByName = this.buildInputTypesMap();
        }
        get datamodel() {
          return this.document.datamodel;
        }
        get mappings() {
          return this.document.mappings;
        }
        get schema() {
          return this.document.schema;
        }
        get inputObjectTypes() {
          return this.schema.inputObjectTypes;
        }
        get outputObjectTypes() {
          return this.schema.outputObjectTypes;
        }
        isComposite(t5) {
          return this.compositeNames.has(t5);
        }
        getOtherOperationNames() {
          return [Object.values(this.mappings.otherOperations.write), Object.values(this.mappings.otherOperations.read)].flat();
        }
        hasEnumInNamespace(t5, r6) {
          var n3;
          return ((n3 = this.schema.enumTypes[r6]) == null ? void 0 : n3.find((o) => o.name === t5)) !== void 0;
        }
        resolveInputObjectType(t5) {
          return this.inputTypesByName.get(io(t5.type, t5.namespace));
        }
        resolveOutputObjectType(t5) {
          var r6;
          if (t5.location === "outputObjectTypes")
            return this.outputObjectTypes[(r6 = t5.namespace) != null ? r6 : "prisma"].find((n3) => n3.name === t5.type);
        }
        buildModelMap() {
          return Ye(this.datamodel.models, "name");
        }
        buildTypeMap() {
          return Ye(this.datamodel.types, "name");
        }
        buildTypeModelMap() {
          return { ...this.buildTypeMap(), ...this.buildModelMap() };
        }
        buildMappingsMap() {
          return Ye(this.mappings.modelOperations, "model");
        }
        buildMergedOutputTypeMap() {
          return { model: Ye(this.schema.outputObjectTypes.model, "name"), prisma: Ye(this.schema.outputObjectTypes.prisma, "name") };
        }
        buildRootFieldMap() {
          return { ...Ye(this.outputTypeMap.prisma.Query.fields, "name"), ...Ye(this.outputTypeMap.prisma.Mutation.fields, "name") };
        }
        buildInputTypesMap() {
          let t5 = /* @__PURE__ */ new Map();
          for (let r6 of this.inputObjectTypes.prisma)
            t5.set(io(r6.name, "prisma"), r6);
          if (!this.inputObjectTypes.model)
            return t5;
          for (let r6 of this.inputObjectTypes.model)
            t5.set(io(r6.name, "model"), r6);
          return t5;
        }
      };
      function io(e8, t5) {
        return t5 ? `${t5}.${e8}` : e8;
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Ce;
      ((t5) => {
        let e8;
        ((C) => (C.findUnique = "findUnique", C.findUniqueOrThrow = "findUniqueOrThrow", C.findFirst = "findFirst", C.findFirstOrThrow = "findFirstOrThrow", C.findMany = "findMany", C.create = "create", C.createMany = "createMany", C.update = "update", C.updateMany = "updateMany", C.upsert = "upsert", C.delete = "delete", C.deleteMany = "deleteMany", C.groupBy = "groupBy", C.count = "count", C.aggregate = "aggregate", C.findRaw = "findRaw", C.aggregateRaw = "aggregateRaw"))(e8 = t5.ModelAction || (t5.ModelAction = {}));
      })(Ce || (Ce = {}));
      d2();
      p2();
      f();
      var rn = ve(Eo());
      var _c = 100;
      var tn = [];
      var ws;
      var Es;
      typeof y2 != "undefined" && typeof ((ws = y2.stderr) == null ? void 0 : ws.write) != "function" && (rn.default.log = (Es = console.debug) != null ? Es : console.log);
      function Nc(e8) {
        let t5 = (0, rn.default)(e8), r6 = Object.assign((...n3) => (t5.log = r6.log, n3.length !== 0 && tn.push([e8, ...n3]), tn.length > _c && tn.shift(), t5("", ...n3)), t5);
        return r6;
      }
      var Po = Object.assign(Nc, rn.default);
      function Ps() {
        tn.length = 0;
      }
      var he = Po;
      d2();
      p2();
      f();
      var vo;
      var vs;
      var As;
      var Ts;
      var Cs = true;
      typeof y2 != "undefined" && ({ FORCE_COLOR: vo, NODE_DISABLE_COLORS: vs, NO_COLOR: As, TERM: Ts } = y2.env || {}, Cs = y2.stdout && y2.stdout.isTTY);
      var Lc = { enabled: !vs && As == null && Ts !== "dumb" && (vo != null && vo !== "0" || Cs) };
      function G(e8, t5) {
        let r6 = new RegExp(`\\x1b\\[${t5}m`, "g"), n3 = `\x1B[${e8}m`, o = `\x1B[${t5}m`;
        return function(i2) {
          return !Lc.enabled || i2 == null ? i2 : n3 + (~("" + i2).indexOf(o) ? i2.replace(r6, o + n3) : i2) + o;
        };
      }
      var Vg = G(0, 0);
      var tt = G(1, 22);
      var nn = G(2, 22);
      var Kg = G(3, 23);
      var Ms = G(4, 24);
      var Gg = G(7, 27);
      var Jg = G(8, 28);
      var Qg = G(9, 29);
      var Wg = G(30, 39);
      var _t = G(31, 39);
      var on3 = G(32, 39);
      var sn = G(33, 39);
      var Nt = G(34, 39);
      var Hg = G(35, 39);
      var rt = G(36, 39);
      var zg = G(37, 39);
      var an = G(90, 39);
      var Zg = G(90, 39);
      var Yg = G(40, 49);
      var Xg = G(41, 49);
      var ey = G(42, 49);
      var ty = G(43, 49);
      var ry = G(44, 49);
      var ny = G(45, 49);
      var oy = G(46, 49);
      var iy = G(47, 49);
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Os = "library";
      function Co(e8) {
        let t5 = qc();
        return t5 || ((e8 == null ? void 0 : e8.config.engineType) === "library" ? "library" : (e8 == null ? void 0 : e8.config.engineType) === "binary" ? "binary" : Os);
      }
      function qc() {
        let e8 = y2.env.PRISMA_CLIENT_ENGINE_TYPE;
        return e8 === "library" ? "library" : e8 === "binary" ? "binary" : void 0;
      }
      d2();
      p2();
      f();
      var sr = ve(To());
      function Mo(e8) {
        return sr.default.sep === sr.default.posix.sep ? e8 : e8.split(sr.default.sep).join(sr.default.posix.sep);
      }
      var Bt = {};
      rr(Bt, { error: () => Wc, info: () => Qc, log: () => Jc, query: () => Hc, should: () => js, tags: () => ur, warn: () => Ro });
      d2();
      p2();
      f();
      var ur = { error: _t("prisma:error"), warn: sn("prisma:warn"), info: rt("prisma:info"), query: Nt("prisma:query") };
      var js = { warn: () => !y2.env.PRISMA_DISABLE_WARNINGS };
      function Jc(...e8) {
        console.log(...e8);
      }
      function Ro(e8, ...t5) {
        js.warn() && console.warn(`${ur.warn} ${e8}`, ...t5);
      }
      function Qc(e8, ...t5) {
        console.info(`${ur.info} ${e8}`, ...t5);
      }
      function Wc(e8, ...t5) {
        console.error(`${ur.error} ${e8}`, ...t5);
      }
      function Hc(e8, ...t5) {
        console.log(`${ur.query} ${e8}`, ...t5);
      }
      d2();
      p2();
      f();
      function xt(e8, t5) {
        throw new Error(t5);
      }
      d2();
      p2();
      f();
      function Oo(e8, t5) {
        return Object.prototype.hasOwnProperty.call(e8, t5);
      }
      d2();
      p2();
      f();
      var Fo = (e8, t5) => e8.reduce((r6, n3) => (r6[t5(n3)] = n3, r6), {});
      d2();
      p2();
      f();
      function jt(e8, t5) {
        let r6 = {};
        for (let n3 of Object.keys(e8))
          r6[n3] = t5(e8[n3], n3);
        return r6;
      }
      d2();
      p2();
      f();
      function Io(e8, t5) {
        if (e8.length === 0)
          return;
        let r6 = e8[0];
        for (let n3 = 1; n3 < e8.length; n3++)
          t5(r6, e8[n3]) < 0 && (r6 = e8[n3]);
        return r6;
      }
      d2();
      p2();
      f();
      function k2(e8, t5) {
        Object.defineProperty(e8, "name", { value: t5, configurable: true });
      }
      d2();
      p2();
      f();
      var Ks = /* @__PURE__ */ new Set();
      var lr = (e8, t5, ...r6) => {
        Ks.has(e8) || (Ks.add(e8), Ro(t5, ...r6));
      };
      d2();
      p2();
      f();
      var ce = class extends Error {
        constructor(r6, { code: n3, clientVersion: o, meta: i2, batchRequestIdx: s3 }) {
          super(r6);
          this.name = "PrismaClientKnownRequestError", this.code = n3, this.clientVersion = o, this.meta = i2, Object.defineProperty(this, "batchRequestIdx", { value: s3, enumerable: false, writable: true });
        }
        get [Symbol.toStringTag]() {
          return "PrismaClientKnownRequestError";
        }
      };
      k2(ce, "PrismaClientKnownRequestError");
      var Ke = class extends ce {
        constructor(t5, r6) {
          super(t5, { code: "P2025", clientVersion: r6 }), this.name = "NotFoundError";
        }
      };
      k2(Ke, "NotFoundError");
      d2();
      p2();
      f();
      var re = class e8 extends Error {
        constructor(r6, n3, o) {
          super(r6);
          this.name = "PrismaClientInitializationError", this.clientVersion = n3, this.errorCode = o, Error.captureStackTrace(e8);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClientInitializationError";
        }
      };
      k2(re, "PrismaClientInitializationError");
      d2();
      p2();
      f();
      var Ge = class extends Error {
        constructor(r6, n3) {
          super(r6);
          this.name = "PrismaClientRustPanicError", this.clientVersion = n3;
        }
        get [Symbol.toStringTag]() {
          return "PrismaClientRustPanicError";
        }
      };
      k2(Ge, "PrismaClientRustPanicError");
      d2();
      p2();
      f();
      var Se = class extends Error {
        constructor(r6, { clientVersion: n3, batchRequestIdx: o }) {
          super(r6);
          this.name = "PrismaClientUnknownRequestError", this.clientVersion = n3, Object.defineProperty(this, "batchRequestIdx", { value: o, writable: true, enumerable: false });
        }
        get [Symbol.toStringTag]() {
          return "PrismaClientUnknownRequestError";
        }
      };
      k2(Se, "PrismaClientUnknownRequestError");
      d2();
      p2();
      f();
      var pe = class extends Error {
        constructor(r6, { clientVersion: n3 }) {
          super(r6);
          this.name = "PrismaClientValidationError";
          this.clientVersion = n3;
        }
        get [Symbol.toStringTag]() {
          return "PrismaClientValidationError";
        }
      };
      k2(pe, "PrismaClientValidationError");
      d2();
      p2();
      f();
      var Ut = class {
        constructor(t5) {
          this._engine = t5;
        }
        prometheus(t5) {
          return this._engine.metrics({ format: "prometheus", ...t5 });
        }
        json(t5) {
          return this._engine.metrics({ format: "json", ...t5 });
        }
      };
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function cr(e8) {
        let t5;
        return { get() {
          return t5 || (t5 = { value: e8() }), t5.value;
        } };
      }
      function Js(e8, t5) {
        let r6 = cr(() => Zc(t5));
        Object.defineProperty(e8, "dmmf", { get: () => r6.get() });
      }
      function Zc(e8) {
        return { datamodel: { models: ko(e8.models), enums: ko(e8.enums), types: ko(e8.types) } };
      }
      function ko(e8) {
        return Object.entries(e8).map(([t5, r6]) => ({ name: t5, ...r6 }));
      }
      d2();
      p2();
      f();
      var Yc = ["JsonNullValueInput", "NullableJsonNullValueInput", "JsonNullValueFilter"];
      var cn = Symbol();
      var Do = /* @__PURE__ */ new WeakMap();
      var _e = class {
        constructor(t5) {
          t5 === cn ? Do.set(this, `Prisma.${this._getName()}`) : Do.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
        }
        _getName() {
          return this.constructor.name;
        }
        toString() {
          return Do.get(this);
        }
      };
      var pr = class extends _e {
        _getNamespace() {
          return "NullTypes";
        }
      };
      var fr = class extends pr {
      };
      _o(fr, "DbNull");
      var dr = class extends pr {
      };
      _o(dr, "JsonNull");
      var mr = class extends pr {
      };
      _o(mr, "AnyNull");
      var pn = { classes: { DbNull: fr, JsonNull: dr, AnyNull: mr }, instances: { DbNull: new fr(cn), JsonNull: new dr(cn), AnyNull: new mr(cn) } };
      function _o(e8, t5) {
        Object.defineProperty(e8, "name", { value: t5, configurable: true });
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var rp = ve(Eo(), 1);
      function fn(e8) {
        return { ok: false, error: e8, map() {
          return fn(e8);
        }, flatMap() {
          return fn(e8);
        } };
      }
      var Xc = class {
        constructor() {
          Ai(this, "registeredErrors", []);
        }
        consumeError(e8) {
          return this.registeredErrors[e8];
        }
        registerNewError(e8) {
          let t5 = 0;
          for (; this.registeredErrors[t5] !== void 0; )
            t5++;
          return this.registeredErrors[t5] = { error: e8 }, t5;
        }
      };
      var Qs = (e8) => {
        let t5 = new Xc(), r6 = nt(t5, e8.startTransaction.bind(e8));
        return { errorRegistry: t5, queryRaw: nt(t5, e8.queryRaw.bind(e8)), executeRaw: nt(t5, e8.executeRaw.bind(e8)), flavour: e8.flavour, startTransaction: async (...n3) => (await r6(...n3)).map((i2) => ep(t5, i2)), close: nt(t5, e8.close.bind(e8)) };
      };
      var ep = (e8, t5) => ({ flavour: t5.flavour, options: t5.options, queryRaw: nt(e8, t5.queryRaw.bind(t5)), executeRaw: nt(e8, t5.executeRaw.bind(t5)), commit: nt(e8, t5.commit.bind(t5)), rollback: nt(e8, t5.rollback.bind(t5)), dispose: tp(e8, t5.dispose.bind(t5)) });
      function nt(e8, t5) {
        return async (...r6) => {
          try {
            return await t5(...r6);
          } catch (n3) {
            let o = e8.registerNewError(n3);
            return fn({ kind: "GenericJs", id: o });
          }
        };
      }
      function tp(e8, t5) {
        return (...r6) => {
          try {
            return t5(...r6);
          } catch (n3) {
            let o = e8.registerNewError(n3);
            return fn({ kind: "GenericJs", id: o });
          }
        };
      }
      var O2 = ve(Ws());
      var Hu = ve(Ns());
      Ao();
      var Lr = ve(To());
      d2();
      p2();
      f();
      var xe = class e8 {
        constructor(t5, r6) {
          if (t5.length - 1 !== r6.length)
            throw t5.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t5.length} strings to have ${t5.length - 1} values`);
          let n3 = r6.reduce((s3, a4) => s3 + (a4 instanceof e8 ? a4.values.length : 1), 0);
          this.values = new Array(n3), this.strings = new Array(n3 + 1), this.strings[0] = t5[0];
          let o = 0, i2 = 0;
          for (; o < r6.length; ) {
            let s3 = r6[o++], a4 = t5[o];
            if (s3 instanceof e8) {
              this.strings[i2] += s3.strings[0];
              let u2 = 0;
              for (; u2 < s3.values.length; )
                this.values[i2++] = s3.values[u2++], this.strings[i2] = s3.strings[u2];
              this.strings[i2] += a4;
            } else
              this.values[i2++] = s3, this.strings[i2] = a4;
          }
        }
        get text() {
          let t5 = 1, r6 = this.strings[0];
          for (; t5 < this.strings.length; )
            r6 += `$${t5}${this.strings[t5++]}`;
          return r6;
        }
        get sql() {
          let t5 = 1, r6 = this.strings[0];
          for (; t5 < this.strings.length; )
            r6 += `?${this.strings[t5++]}`;
          return r6;
        }
        inspect() {
          return { text: this.text, sql: this.sql, values: this.values };
        }
      };
      function Hs(e8, t5 = ",", r6 = "", n3 = "") {
        if (e8.length === 0)
          throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
        return new xe([r6, ...Array(e8.length - 1).fill(t5), n3], e8);
      }
      function No(e8) {
        return new xe([e8], []);
      }
      var zs = No("");
      function Lo(e8, ...t5) {
        return new xe(e8, t5);
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function gr(e8) {
        return { getKeys() {
          return Object.keys(e8);
        }, getPropertyValue(t5) {
          return e8[t5];
        } };
      }
      d2();
      p2();
      f();
      function ge(e8, t5) {
        return { getKeys() {
          return [e8];
        }, getPropertyValue() {
          return t5();
        } };
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Ne = class {
        constructor() {
          this._map = /* @__PURE__ */ new Map();
        }
        get(t5) {
          var r6;
          return (r6 = this._map.get(t5)) == null ? void 0 : r6.value;
        }
        set(t5, r6) {
          this._map.set(t5, { value: r6 });
        }
        getOrCreate(t5, r6) {
          let n3 = this._map.get(t5);
          if (n3)
            return n3.value;
          let o = r6();
          return this.set(t5, o), o;
        }
      };
      function bt(e8) {
        let t5 = new Ne();
        return { getKeys() {
          return e8.getKeys();
        }, getPropertyValue(r6) {
          return t5.getOrCreate(r6, () => e8.getPropertyValue(r6));
        }, getPropertyDescriptor(r6) {
          var n3;
          return (n3 = e8.getPropertyDescriptor) == null ? void 0 : n3.call(e8, r6);
        } };
      }
      d2();
      p2();
      f();
      var Xs = ve(go());
      d2();
      p2();
      f();
      var dn = { enumerable: true, configurable: true, writable: true };
      function mn(e8) {
        let t5 = new Set(e8);
        return { getOwnPropertyDescriptor: () => dn, has: (r6, n3) => t5.has(n3), set: (r6, n3, o) => t5.add(n3) && Reflect.set(r6, n3, o), ownKeys: () => [...t5] };
      }
      var Zs = Symbol.for("nodejs.util.inspect.custom");
      function Le(e8, t5) {
        let r6 = np(t5), n3 = /* @__PURE__ */ new Set(), o = new Proxy(e8, { get(i2, s3) {
          if (n3.has(s3))
            return i2[s3];
          let a4 = r6.get(s3);
          return a4 ? a4.getPropertyValue(s3) : i2[s3];
        }, has(i2, s3) {
          var u2, l;
          if (n3.has(s3))
            return true;
          let a4 = r6.get(s3);
          return a4 ? (l = (u2 = a4.has) == null ? void 0 : u2.call(a4, s3)) != null ? l : true : Reflect.has(i2, s3);
        }, ownKeys(i2) {
          let s3 = Ys(Reflect.ownKeys(i2), r6), a4 = Ys(Array.from(r6.keys()), r6);
          return [.../* @__PURE__ */ new Set([...s3, ...a4, ...n3])];
        }, set(i2, s3, a4) {
          var l, c2;
          let u2 = r6.get(s3);
          return ((c2 = (l = u2 == null ? void 0 : u2.getPropertyDescriptor) == null ? void 0 : l.call(u2, s3)) == null ? void 0 : c2.writable) === false ? false : (n3.add(s3), Reflect.set(i2, s3, a4));
        }, getOwnPropertyDescriptor(i2, s3) {
          let a4 = Reflect.getOwnPropertyDescriptor(i2, s3);
          if (a4 && !a4.configurable)
            return a4;
          let u2 = r6.get(s3);
          return u2 ? u2.getPropertyDescriptor ? { ...dn, ...u2 == null ? void 0 : u2.getPropertyDescriptor(s3) } : dn : a4;
        }, defineProperty(i2, s3, a4) {
          return n3.add(s3), Reflect.defineProperty(i2, s3, a4);
        } });
        return o[Zs] = function(i2, s3, a4 = Xs.inspect) {
          let u2 = { ...this };
          return delete u2[Zs], a4(u2, s3);
        }, o;
      }
      function np(e8) {
        let t5 = /* @__PURE__ */ new Map();
        for (let r6 of e8) {
          let n3 = r6.getKeys();
          for (let o of n3)
            t5.set(o, r6);
        }
        return t5;
      }
      function Ys(e8, t5) {
        return e8.filter((r6) => {
          var o, i2;
          let n3 = t5.get(r6);
          return (i2 = (o = n3 == null ? void 0 : n3.has) == null ? void 0 : o.call(n3, r6)) != null ? i2 : true;
        });
      }
      d2();
      p2();
      f();
      function yr(e8) {
        return { getKeys() {
          return e8;
        }, has() {
          return false;
        }, getPropertyValue() {
        } };
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var $t = class {
        constructor(t5 = 0, r6) {
          this.context = r6;
          this.lines = [];
          this.currentLine = "";
          this.currentIndent = 0;
          this.currentIndent = t5;
        }
        write(t5) {
          return typeof t5 == "string" ? this.currentLine += t5 : t5.write(this), this;
        }
        writeJoined(t5, r6) {
          let n3 = r6.length - 1;
          for (let o = 0; o < r6.length; o++)
            this.write(r6[o]), o !== n3 && this.write(t5);
          return this;
        }
        writeLine(t5) {
          return this.write(t5).newLine();
        }
        newLine() {
          this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = void 0;
          let t5 = this.afterNextNewLineCallback;
          return this.afterNextNewLineCallback = void 0, t5 == null || t5(), this;
        }
        withIndent(t5) {
          return this.indent(), t5(this), this.unindent(), this;
        }
        afterNextNewline(t5) {
          return this.afterNextNewLineCallback = t5, this;
        }
        indent() {
          return this.currentIndent++, this;
        }
        unindent() {
          return this.currentIndent > 0 && this.currentIndent--, this;
        }
        addMarginSymbol(t5) {
          return this.marginSymbol = t5, this;
        }
        toString() {
          return this.lines.concat(this.indentedCurrentLine()).join(`
`);
        }
        getCurrentLineLength() {
          return this.currentLine.length;
        }
        indentedCurrentLine() {
          let t5 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
          return this.marginSymbol ? this.marginSymbol + t5.slice(1) : t5;
        }
      };
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function qt(e8) {
        return e8 instanceof Date || Object.prototype.toString.call(e8) === "[object Date]";
      }
      function gn(e8) {
        return e8.toString() !== "Invalid Date";
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Vt = 9e15;
      var at = 1e9;
      var Bo = "0123456789abcdef";
      var hn = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
      var xn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
      var jo = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -Vt, maxE: Vt, crypto: false };
      var na;
      var Je;
      var D = true;
      var wn = "[DecimalError] ";
      var st = wn + "Invalid argument: ";
      var oa = wn + "Precision limit exceeded";
      var ia = wn + "crypto unavailable";
      var sa = "[object Decimal]";
      var fe = Math.floor;
      var X = Math.pow;
      var op = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
      var ip = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
      var sp = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
      var aa = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
      var Oe = 1e7;
      var I = 7;
      var ap = 9007199254740991;
      var up = hn.length - 1;
      var Uo = xn.length - 1;
      var v = { toStringTag: sa };
      v.absoluteValue = v.abs = function() {
        var e8 = new this.constructor(this);
        return e8.s < 0 && (e8.s = 1), F(e8);
      };
      v.ceil = function() {
        return F(new this.constructor(this), this.e + 1, 2);
      };
      v.clampedTo = v.clamp = function(e8, t5) {
        var r6, n3 = this, o = n3.constructor;
        if (e8 = new o(e8), t5 = new o(t5), !e8.s || !t5.s)
          return new o(NaN);
        if (e8.gt(t5))
          throw Error(st + t5);
        return r6 = n3.cmp(e8), r6 < 0 ? e8 : n3.cmp(t5) > 0 ? t5 : new o(n3);
      };
      v.comparedTo = v.cmp = function(e8) {
        var t5, r6, n3, o, i2 = this, s3 = i2.d, a4 = (e8 = new i2.constructor(e8)).d, u2 = i2.s, l = e8.s;
        if (!s3 || !a4)
          return !u2 || !l ? NaN : u2 !== l ? u2 : s3 === a4 ? 0 : !s3 ^ u2 < 0 ? 1 : -1;
        if (!s3[0] || !a4[0])
          return s3[0] ? u2 : a4[0] ? -l : 0;
        if (u2 !== l)
          return u2;
        if (i2.e !== e8.e)
          return i2.e > e8.e ^ u2 < 0 ? 1 : -1;
        for (n3 = s3.length, o = a4.length, t5 = 0, r6 = n3 < o ? n3 : o; t5 < r6; ++t5)
          if (s3[t5] !== a4[t5])
            return s3[t5] > a4[t5] ^ u2 < 0 ? 1 : -1;
        return n3 === o ? 0 : n3 > o ^ u2 < 0 ? 1 : -1;
      };
      v.cosine = v.cos = function() {
        var e8, t5, r6 = this, n3 = r6.constructor;
        return r6.d ? r6.d[0] ? (e8 = n3.precision, t5 = n3.rounding, n3.precision = e8 + Math.max(r6.e, r6.sd()) + I, n3.rounding = 1, r6 = lp(n3, fa(n3, r6)), n3.precision = e8, n3.rounding = t5, F(Je == 2 || Je == 3 ? r6.neg() : r6, e8, t5, true)) : new n3(1) : new n3(NaN);
      };
      v.cubeRoot = v.cbrt = function() {
        var e8, t5, r6, n3, o, i2, s3, a4, u2, l, c2 = this, m2 = c2.constructor;
        if (!c2.isFinite() || c2.isZero())
          return new m2(c2);
        for (D = false, i2 = c2.s * X(c2.s * c2, 1 / 3), !i2 || Math.abs(i2) == 1 / 0 ? (r6 = ue(c2.d), e8 = c2.e, (i2 = (e8 - r6.length + 1) % 3) && (r6 += i2 == 1 || i2 == -2 ? "0" : "00"), i2 = X(r6, 1 / 3), e8 = fe((e8 + 1) / 3) - (e8 % 3 == (e8 < 0 ? -1 : 2)), i2 == 1 / 0 ? r6 = "5e" + e8 : (r6 = i2.toExponential(), r6 = r6.slice(0, r6.indexOf("e") + 1) + e8), n3 = new m2(r6), n3.s = c2.s) : n3 = new m2(i2.toString()), s3 = (e8 = m2.precision) + 3; ; )
          if (a4 = n3, u2 = a4.times(a4).times(a4), l = u2.plus(c2), n3 = K(l.plus(c2).times(a4), l.plus(u2), s3 + 2, 1), ue(a4.d).slice(0, s3) === (r6 = ue(n3.d)).slice(0, s3))
            if (r6 = r6.slice(s3 - 3, s3 + 1), r6 == "9999" || !o && r6 == "4999") {
              if (!o && (F(a4, e8 + 1, 0), a4.times(a4).times(a4).eq(c2))) {
                n3 = a4;
                break;
              }
              s3 += 4, o = 1;
            } else {
              (!+r6 || !+r6.slice(1) && r6.charAt(0) == "5") && (F(n3, e8 + 1, 1), t5 = !n3.times(n3).times(n3).eq(c2));
              break;
            }
        return D = true, F(n3, e8, m2.rounding, t5);
      };
      v.decimalPlaces = v.dp = function() {
        var e8, t5 = this.d, r6 = NaN;
        if (t5) {
          if (e8 = t5.length - 1, r6 = (e8 - fe(this.e / I)) * I, e8 = t5[e8], e8)
            for (; e8 % 10 == 0; e8 /= 10)
              r6--;
          r6 < 0 && (r6 = 0);
        }
        return r6;
      };
      v.dividedBy = v.div = function(e8) {
        return K(this, new this.constructor(e8));
      };
      v.dividedToIntegerBy = v.divToInt = function(e8) {
        var t5 = this, r6 = t5.constructor;
        return F(K(t5, new r6(e8), 0, 1, 1), r6.precision, r6.rounding);
      };
      v.equals = v.eq = function(e8) {
        return this.cmp(e8) === 0;
      };
      v.floor = function() {
        return F(new this.constructor(this), this.e + 1, 3);
      };
      v.greaterThan = v.gt = function(e8) {
        return this.cmp(e8) > 0;
      };
      v.greaterThanOrEqualTo = v.gte = function(e8) {
        var t5 = this.cmp(e8);
        return t5 == 1 || t5 === 0;
      };
      v.hyperbolicCosine = v.cosh = function() {
        var e8, t5, r6, n3, o, i2 = this, s3 = i2.constructor, a4 = new s3(1);
        if (!i2.isFinite())
          return new s3(i2.s ? 1 / 0 : NaN);
        if (i2.isZero())
          return a4;
        r6 = s3.precision, n3 = s3.rounding, s3.precision = r6 + Math.max(i2.e, i2.sd()) + 4, s3.rounding = 1, o = i2.d.length, o < 32 ? (e8 = Math.ceil(o / 3), t5 = (1 / Pn(4, e8)).toString()) : (e8 = 16, t5 = "2.3283064365386962890625e-10"), i2 = Kt(s3, 1, i2.times(t5), new s3(1), true);
        for (var u2, l = e8, c2 = new s3(8); l--; )
          u2 = i2.times(i2), i2 = a4.minus(u2.times(c2.minus(u2.times(c2))));
        return F(i2, s3.precision = r6, s3.rounding = n3, true);
      };
      v.hyperbolicSine = v.sinh = function() {
        var e8, t5, r6, n3, o = this, i2 = o.constructor;
        if (!o.isFinite() || o.isZero())
          return new i2(o);
        if (t5 = i2.precision, r6 = i2.rounding, i2.precision = t5 + Math.max(o.e, o.sd()) + 4, i2.rounding = 1, n3 = o.d.length, n3 < 3)
          o = Kt(i2, 2, o, o, true);
        else {
          e8 = 1.4 * Math.sqrt(n3), e8 = e8 > 16 ? 16 : e8 | 0, o = o.times(1 / Pn(5, e8)), o = Kt(i2, 2, o, o, true);
          for (var s3, a4 = new i2(5), u2 = new i2(16), l = new i2(20); e8--; )
            s3 = o.times(o), o = o.times(a4.plus(s3.times(u2.times(s3).plus(l))));
        }
        return i2.precision = t5, i2.rounding = r6, F(o, t5, r6, true);
      };
      v.hyperbolicTangent = v.tanh = function() {
        var e8, t5, r6 = this, n3 = r6.constructor;
        return r6.isFinite() ? r6.isZero() ? new n3(r6) : (e8 = n3.precision, t5 = n3.rounding, n3.precision = e8 + 7, n3.rounding = 1, K(r6.sinh(), r6.cosh(), n3.precision = e8, n3.rounding = t5)) : new n3(r6.s);
      };
      v.inverseCosine = v.acos = function() {
        var e8, t5 = this, r6 = t5.constructor, n3 = t5.abs().cmp(1), o = r6.precision, i2 = r6.rounding;
        return n3 !== -1 ? n3 === 0 ? t5.isNeg() ? Re(r6, o, i2) : new r6(0) : new r6(NaN) : t5.isZero() ? Re(r6, o + 4, i2).times(0.5) : (r6.precision = o + 6, r6.rounding = 1, t5 = t5.asin(), e8 = Re(r6, o + 4, i2).times(0.5), r6.precision = o, r6.rounding = i2, e8.minus(t5));
      };
      v.inverseHyperbolicCosine = v.acosh = function() {
        var e8, t5, r6 = this, n3 = r6.constructor;
        return r6.lte(1) ? new n3(r6.eq(1) ? 0 : NaN) : r6.isFinite() ? (e8 = n3.precision, t5 = n3.rounding, n3.precision = e8 + Math.max(Math.abs(r6.e), r6.sd()) + 4, n3.rounding = 1, D = false, r6 = r6.times(r6).minus(1).sqrt().plus(r6), D = true, n3.precision = e8, n3.rounding = t5, r6.ln()) : new n3(r6);
      };
      v.inverseHyperbolicSine = v.asinh = function() {
        var e8, t5, r6 = this, n3 = r6.constructor;
        return !r6.isFinite() || r6.isZero() ? new n3(r6) : (e8 = n3.precision, t5 = n3.rounding, n3.precision = e8 + 2 * Math.max(Math.abs(r6.e), r6.sd()) + 6, n3.rounding = 1, D = false, r6 = r6.times(r6).plus(1).sqrt().plus(r6), D = true, n3.precision = e8, n3.rounding = t5, r6.ln());
      };
      v.inverseHyperbolicTangent = v.atanh = function() {
        var e8, t5, r6, n3, o = this, i2 = o.constructor;
        return o.isFinite() ? o.e >= 0 ? new i2(o.abs().eq(1) ? o.s / 0 : o.isZero() ? o : NaN) : (e8 = i2.precision, t5 = i2.rounding, n3 = o.sd(), Math.max(n3, e8) < 2 * -o.e - 1 ? F(new i2(o), e8, t5, true) : (i2.precision = r6 = n3 - o.e, o = K(o.plus(1), new i2(1).minus(o), r6 + e8, 1), i2.precision = e8 + 4, i2.rounding = 1, o = o.ln(), i2.precision = e8, i2.rounding = t5, o.times(0.5))) : new i2(NaN);
      };
      v.inverseSine = v.asin = function() {
        var e8, t5, r6, n3, o = this, i2 = o.constructor;
        return o.isZero() ? new i2(o) : (t5 = o.abs().cmp(1), r6 = i2.precision, n3 = i2.rounding, t5 !== -1 ? t5 === 0 ? (e8 = Re(i2, r6 + 4, n3).times(0.5), e8.s = o.s, e8) : new i2(NaN) : (i2.precision = r6 + 6, i2.rounding = 1, o = o.div(new i2(1).minus(o.times(o)).sqrt().plus(1)).atan(), i2.precision = r6, i2.rounding = n3, o.times(2)));
      };
      v.inverseTangent = v.atan = function() {
        var e8, t5, r6, n3, o, i2, s3, a4, u2, l = this, c2 = l.constructor, m2 = c2.precision, g2 = c2.rounding;
        if (l.isFinite()) {
          if (l.isZero())
            return new c2(l);
          if (l.abs().eq(1) && m2 + 4 <= Uo)
            return s3 = Re(c2, m2 + 4, g2).times(0.25), s3.s = l.s, s3;
        } else {
          if (!l.s)
            return new c2(NaN);
          if (m2 + 4 <= Uo)
            return s3 = Re(c2, m2 + 4, g2).times(0.5), s3.s = l.s, s3;
        }
        for (c2.precision = a4 = m2 + 10, c2.rounding = 1, r6 = Math.min(28, a4 / I + 2 | 0), e8 = r6; e8; --e8)
          l = l.div(l.times(l).plus(1).sqrt().plus(1));
        for (D = false, t5 = Math.ceil(a4 / I), n3 = 1, u2 = l.times(l), s3 = new c2(l), o = l; e8 !== -1; )
          if (o = o.times(u2), i2 = s3.minus(o.div(n3 += 2)), o = o.times(u2), s3 = i2.plus(o.div(n3 += 2)), s3.d[t5] !== void 0)
            for (e8 = t5; s3.d[e8] === i2.d[e8] && e8--; )
              ;
        return r6 && (s3 = s3.times(2 << r6 - 1)), D = true, F(s3, c2.precision = m2, c2.rounding = g2, true);
      };
      v.isFinite = function() {
        return !!this.d;
      };
      v.isInteger = v.isInt = function() {
        return !!this.d && fe(this.e / I) > this.d.length - 2;
      };
      v.isNaN = function() {
        return !this.s;
      };
      v.isNegative = v.isNeg = function() {
        return this.s < 0;
      };
      v.isPositive = v.isPos = function() {
        return this.s > 0;
      };
      v.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      v.lessThan = v.lt = function(e8) {
        return this.cmp(e8) < 0;
      };
      v.lessThanOrEqualTo = v.lte = function(e8) {
        return this.cmp(e8) < 1;
      };
      v.logarithm = v.log = function(e8) {
        var t5, r6, n3, o, i2, s3, a4, u2, l = this, c2 = l.constructor, m2 = c2.precision, g2 = c2.rounding, w = 5;
        if (e8 == null)
          e8 = new c2(10), t5 = true;
        else {
          if (e8 = new c2(e8), r6 = e8.d, e8.s < 0 || !r6 || !r6[0] || e8.eq(1))
            return new c2(NaN);
          t5 = e8.eq(10);
        }
        if (r6 = l.d, l.s < 0 || !r6 || !r6[0] || l.eq(1))
          return new c2(r6 && !r6[0] ? -1 / 0 : l.s != 1 ? NaN : r6 ? 0 : 1 / 0);
        if (t5)
          if (r6.length > 1)
            i2 = true;
          else {
            for (o = r6[0]; o % 10 === 0; )
              o /= 10;
            i2 = o !== 1;
          }
        if (D = false, a4 = m2 + w, s3 = it(l, a4), n3 = t5 ? bn(c2, a4 + 10) : it(e8, a4), u2 = K(s3, n3, a4, 1), hr(u2.d, o = m2, g2))
          do
            if (a4 += 10, s3 = it(l, a4), n3 = t5 ? bn(c2, a4 + 10) : it(e8, a4), u2 = K(s3, n3, a4, 1), !i2) {
              +ue(u2.d).slice(o + 1, o + 15) + 1 == 1e14 && (u2 = F(u2, m2 + 1, 0));
              break;
            }
          while (hr(u2.d, o += 10, g2));
        return D = true, F(u2, m2, g2);
      };
      v.minus = v.sub = function(e8) {
        var t5, r6, n3, o, i2, s3, a4, u2, l, c2, m2, g2, w = this, E = w.constructor;
        if (e8 = new E(e8), !w.d || !e8.d)
          return !w.s || !e8.s ? e8 = new E(NaN) : w.d ? e8.s = -e8.s : e8 = new E(e8.d || w.s !== e8.s ? w : NaN), e8;
        if (w.s != e8.s)
          return e8.s = -e8.s, w.plus(e8);
        if (l = w.d, g2 = e8.d, a4 = E.precision, u2 = E.rounding, !l[0] || !g2[0]) {
          if (g2[0])
            e8.s = -e8.s;
          else if (l[0])
            e8 = new E(w);
          else
            return new E(u2 === 3 ? -0 : 0);
          return D ? F(e8, a4, u2) : e8;
        }
        if (r6 = fe(e8.e / I), c2 = fe(w.e / I), l = l.slice(), i2 = c2 - r6, i2) {
          for (m2 = i2 < 0, m2 ? (t5 = l, i2 = -i2, s3 = g2.length) : (t5 = g2, r6 = c2, s3 = l.length), n3 = Math.max(Math.ceil(a4 / I), s3) + 2, i2 > n3 && (i2 = n3, t5.length = 1), t5.reverse(), n3 = i2; n3--; )
            t5.push(0);
          t5.reverse();
        } else {
          for (n3 = l.length, s3 = g2.length, m2 = n3 < s3, m2 && (s3 = n3), n3 = 0; n3 < s3; n3++)
            if (l[n3] != g2[n3]) {
              m2 = l[n3] < g2[n3];
              break;
            }
          i2 = 0;
        }
        for (m2 && (t5 = l, l = g2, g2 = t5, e8.s = -e8.s), s3 = l.length, n3 = g2.length - s3; n3 > 0; --n3)
          l[s3++] = 0;
        for (n3 = g2.length; n3 > i2; ) {
          if (l[--n3] < g2[n3]) {
            for (o = n3; o && l[--o] === 0; )
              l[o] = Oe - 1;
            --l[o], l[n3] += Oe;
          }
          l[n3] -= g2[n3];
        }
        for (; l[--s3] === 0; )
          l.pop();
        for (; l[0] === 0; l.shift())
          --r6;
        return l[0] ? (e8.d = l, e8.e = En(l, r6), D ? F(e8, a4, u2) : e8) : new E(u2 === 3 ? -0 : 0);
      };
      v.modulo = v.mod = function(e8) {
        var t5, r6 = this, n3 = r6.constructor;
        return e8 = new n3(e8), !r6.d || !e8.s || e8.d && !e8.d[0] ? new n3(NaN) : !e8.d || r6.d && !r6.d[0] ? F(new n3(r6), n3.precision, n3.rounding) : (D = false, n3.modulo == 9 ? (t5 = K(r6, e8.abs(), 0, 3, 1), t5.s *= e8.s) : t5 = K(r6, e8, 0, n3.modulo, 1), t5 = t5.times(e8), D = true, r6.minus(t5));
      };
      v.naturalExponential = v.exp = function() {
        return $o(this);
      };
      v.naturalLogarithm = v.ln = function() {
        return it(this);
      };
      v.negated = v.neg = function() {
        var e8 = new this.constructor(this);
        return e8.s = -e8.s, F(e8);
      };
      v.plus = v.add = function(e8) {
        var t5, r6, n3, o, i2, s3, a4, u2, l, c2, m2 = this, g2 = m2.constructor;
        if (e8 = new g2(e8), !m2.d || !e8.d)
          return !m2.s || !e8.s ? e8 = new g2(NaN) : m2.d || (e8 = new g2(e8.d || m2.s === e8.s ? m2 : NaN)), e8;
        if (m2.s != e8.s)
          return e8.s = -e8.s, m2.minus(e8);
        if (l = m2.d, c2 = e8.d, a4 = g2.precision, u2 = g2.rounding, !l[0] || !c2[0])
          return c2[0] || (e8 = new g2(m2)), D ? F(e8, a4, u2) : e8;
        if (i2 = fe(m2.e / I), n3 = fe(e8.e / I), l = l.slice(), o = i2 - n3, o) {
          for (o < 0 ? (r6 = l, o = -o, s3 = c2.length) : (r6 = c2, n3 = i2, s3 = l.length), i2 = Math.ceil(a4 / I), s3 = i2 > s3 ? i2 + 1 : s3 + 1, o > s3 && (o = s3, r6.length = 1), r6.reverse(); o--; )
            r6.push(0);
          r6.reverse();
        }
        for (s3 = l.length, o = c2.length, s3 - o < 0 && (o = s3, r6 = c2, c2 = l, l = r6), t5 = 0; o; )
          t5 = (l[--o] = l[o] + c2[o] + t5) / Oe | 0, l[o] %= Oe;
        for (t5 && (l.unshift(t5), ++n3), s3 = l.length; l[--s3] == 0; )
          l.pop();
        return e8.d = l, e8.e = En(l, n3), D ? F(e8, a4, u2) : e8;
      };
      v.precision = v.sd = function(e8) {
        var t5, r6 = this;
        if (e8 !== void 0 && e8 !== !!e8 && e8 !== 1 && e8 !== 0)
          throw Error(st + e8);
        return r6.d ? (t5 = ua(r6.d), e8 && r6.e + 1 > t5 && (t5 = r6.e + 1)) : t5 = NaN, t5;
      };
      v.round = function() {
        var e8 = this, t5 = e8.constructor;
        return F(new t5(e8), e8.e + 1, t5.rounding);
      };
      v.sine = v.sin = function() {
        var e8, t5, r6 = this, n3 = r6.constructor;
        return r6.isFinite() ? r6.isZero() ? new n3(r6) : (e8 = n3.precision, t5 = n3.rounding, n3.precision = e8 + Math.max(r6.e, r6.sd()) + I, n3.rounding = 1, r6 = pp(n3, fa(n3, r6)), n3.precision = e8, n3.rounding = t5, F(Je > 2 ? r6.neg() : r6, e8, t5, true)) : new n3(NaN);
      };
      v.squareRoot = v.sqrt = function() {
        var e8, t5, r6, n3, o, i2, s3 = this, a4 = s3.d, u2 = s3.e, l = s3.s, c2 = s3.constructor;
        if (l !== 1 || !a4 || !a4[0])
          return new c2(!l || l < 0 && (!a4 || a4[0]) ? NaN : a4 ? s3 : 1 / 0);
        for (D = false, l = Math.sqrt(+s3), l == 0 || l == 1 / 0 ? (t5 = ue(a4), (t5.length + u2) % 2 == 0 && (t5 += "0"), l = Math.sqrt(t5), u2 = fe((u2 + 1) / 2) - (u2 < 0 || u2 % 2), l == 1 / 0 ? t5 = "5e" + u2 : (t5 = l.toExponential(), t5 = t5.slice(0, t5.indexOf("e") + 1) + u2), n3 = new c2(t5)) : n3 = new c2(l.toString()), r6 = (u2 = c2.precision) + 3; ; )
          if (i2 = n3, n3 = i2.plus(K(s3, i2, r6 + 2, 1)).times(0.5), ue(i2.d).slice(0, r6) === (t5 = ue(n3.d)).slice(0, r6))
            if (t5 = t5.slice(r6 - 3, r6 + 1), t5 == "9999" || !o && t5 == "4999") {
              if (!o && (F(i2, u2 + 1, 0), i2.times(i2).eq(s3))) {
                n3 = i2;
                break;
              }
              r6 += 4, o = 1;
            } else {
              (!+t5 || !+t5.slice(1) && t5.charAt(0) == "5") && (F(n3, u2 + 1, 1), e8 = !n3.times(n3).eq(s3));
              break;
            }
        return D = true, F(n3, u2, c2.rounding, e8);
      };
      v.tangent = v.tan = function() {
        var e8, t5, r6 = this, n3 = r6.constructor;
        return r6.isFinite() ? r6.isZero() ? new n3(r6) : (e8 = n3.precision, t5 = n3.rounding, n3.precision = e8 + 10, n3.rounding = 1, r6 = r6.sin(), r6.s = 1, r6 = K(r6, new n3(1).minus(r6.times(r6)).sqrt(), e8 + 10, 0), n3.precision = e8, n3.rounding = t5, F(Je == 2 || Je == 4 ? r6.neg() : r6, e8, t5, true)) : new n3(NaN);
      };
      v.times = v.mul = function(e8) {
        var t5, r6, n3, o, i2, s3, a4, u2, l, c2 = this, m2 = c2.constructor, g2 = c2.d, w = (e8 = new m2(e8)).d;
        if (e8.s *= c2.s, !g2 || !g2[0] || !w || !w[0])
          return new m2(!e8.s || g2 && !g2[0] && !w || w && !w[0] && !g2 ? NaN : !g2 || !w ? e8.s / 0 : e8.s * 0);
        for (r6 = fe(c2.e / I) + fe(e8.e / I), u2 = g2.length, l = w.length, u2 < l && (i2 = g2, g2 = w, w = i2, s3 = u2, u2 = l, l = s3), i2 = [], s3 = u2 + l, n3 = s3; n3--; )
          i2.push(0);
        for (n3 = l; --n3 >= 0; ) {
          for (t5 = 0, o = u2 + n3; o > n3; )
            a4 = i2[o] + w[n3] * g2[o - n3 - 1] + t5, i2[o--] = a4 % Oe | 0, t5 = a4 / Oe | 0;
          i2[o] = (i2[o] + t5) % Oe | 0;
        }
        for (; !i2[--s3]; )
          i2.pop();
        return t5 ? ++r6 : i2.shift(), e8.d = i2, e8.e = En(i2, r6), D ? F(e8, m2.precision, m2.rounding) : e8;
      };
      v.toBinary = function(e8, t5) {
        return Vo(this, 2, e8, t5);
      };
      v.toDecimalPlaces = v.toDP = function(e8, t5) {
        var r6 = this, n3 = r6.constructor;
        return r6 = new n3(r6), e8 === void 0 ? r6 : (be(e8, 0, at), t5 === void 0 ? t5 = n3.rounding : be(t5, 0, 8), F(r6, e8 + r6.e + 1, t5));
      };
      v.toExponential = function(e8, t5) {
        var r6, n3 = this, o = n3.constructor;
        return e8 === void 0 ? r6 = Be(n3, true) : (be(e8, 0, at), t5 === void 0 ? t5 = o.rounding : be(t5, 0, 8), n3 = F(new o(n3), e8 + 1, t5), r6 = Be(n3, true, e8 + 1)), n3.isNeg() && !n3.isZero() ? "-" + r6 : r6;
      };
      v.toFixed = function(e8, t5) {
        var r6, n3, o = this, i2 = o.constructor;
        return e8 === void 0 ? r6 = Be(o) : (be(e8, 0, at), t5 === void 0 ? t5 = i2.rounding : be(t5, 0, 8), n3 = F(new i2(o), e8 + o.e + 1, t5), r6 = Be(n3, false, e8 + n3.e + 1)), o.isNeg() && !o.isZero() ? "-" + r6 : r6;
      };
      v.toFraction = function(e8) {
        var t5, r6, n3, o, i2, s3, a4, u2, l, c2, m2, g2, w = this, E = w.d, b2 = w.constructor;
        if (!E)
          return new b2(w);
        if (l = r6 = new b2(1), n3 = u2 = new b2(0), t5 = new b2(n3), i2 = t5.e = ua(E) - w.e - 1, s3 = i2 % I, t5.d[0] = X(10, s3 < 0 ? I + s3 : s3), e8 == null)
          e8 = i2 > 0 ? t5 : l;
        else {
          if (a4 = new b2(e8), !a4.isInt() || a4.lt(l))
            throw Error(st + a4);
          e8 = a4.gt(t5) ? i2 > 0 ? t5 : l : a4;
        }
        for (D = false, a4 = new b2(ue(E)), c2 = b2.precision, b2.precision = i2 = E.length * I * 2; m2 = K(a4, t5, 0, 1, 1), o = r6.plus(m2.times(n3)), o.cmp(e8) != 1; )
          r6 = n3, n3 = o, o = l, l = u2.plus(m2.times(o)), u2 = o, o = t5, t5 = a4.minus(m2.times(o)), a4 = o;
        return o = K(e8.minus(r6), n3, 0, 1, 1), u2 = u2.plus(o.times(l)), r6 = r6.plus(o.times(n3)), u2.s = l.s = w.s, g2 = K(l, n3, i2, 1).minus(w).abs().cmp(K(u2, r6, i2, 1).minus(w).abs()) < 1 ? [l, n3] : [u2, r6], b2.precision = c2, D = true, g2;
      };
      v.toHexadecimal = v.toHex = function(e8, t5) {
        return Vo(this, 16, e8, t5);
      };
      v.toNearest = function(e8, t5) {
        var r6 = this, n3 = r6.constructor;
        if (r6 = new n3(r6), e8 == null) {
          if (!r6.d)
            return r6;
          e8 = new n3(1), t5 = n3.rounding;
        } else {
          if (e8 = new n3(e8), t5 === void 0 ? t5 = n3.rounding : be(t5, 0, 8), !r6.d)
            return e8.s ? r6 : e8;
          if (!e8.d)
            return e8.s && (e8.s = r6.s), e8;
        }
        return e8.d[0] ? (D = false, r6 = K(r6, e8, 0, t5, 1).times(e8), D = true, F(r6)) : (e8.s = r6.s, r6 = e8), r6;
      };
      v.toNumber = function() {
        return +this;
      };
      v.toOctal = function(e8, t5) {
        return Vo(this, 8, e8, t5);
      };
      v.toPower = v.pow = function(e8) {
        var t5, r6, n3, o, i2, s3, a4 = this, u2 = a4.constructor, l = +(e8 = new u2(e8));
        if (!a4.d || !e8.d || !a4.d[0] || !e8.d[0])
          return new u2(X(+a4, l));
        if (a4 = new u2(a4), a4.eq(1))
          return a4;
        if (n3 = u2.precision, i2 = u2.rounding, e8.eq(1))
          return F(a4, n3, i2);
        if (t5 = fe(e8.e / I), t5 >= e8.d.length - 1 && (r6 = l < 0 ? -l : l) <= ap)
          return o = la(u2, a4, r6, n3), e8.s < 0 ? new u2(1).div(o) : F(o, n3, i2);
        if (s3 = a4.s, s3 < 0) {
          if (t5 < e8.d.length - 1)
            return new u2(NaN);
          if (e8.d[t5] & 1 || (s3 = 1), a4.e == 0 && a4.d[0] == 1 && a4.d.length == 1)
            return a4.s = s3, a4;
        }
        return r6 = X(+a4, l), t5 = r6 == 0 || !isFinite(r6) ? fe(l * (Math.log("0." + ue(a4.d)) / Math.LN10 + a4.e + 1)) : new u2(r6 + "").e, t5 > u2.maxE + 1 || t5 < u2.minE - 1 ? new u2(t5 > 0 ? s3 / 0 : 0) : (D = false, u2.rounding = a4.s = 1, r6 = Math.min(12, (t5 + "").length), o = $o(e8.times(it(a4, n3 + r6)), n3), o.d && (o = F(o, n3 + 5, 1), hr(o.d, n3, i2) && (t5 = n3 + 10, o = F($o(e8.times(it(a4, t5 + r6)), t5), t5 + 5, 1), +ue(o.d).slice(n3 + 1, n3 + 15) + 1 == 1e14 && (o = F(o, n3 + 1, 0)))), o.s = s3, D = true, u2.rounding = i2, F(o, n3, i2));
      };
      v.toPrecision = function(e8, t5) {
        var r6, n3 = this, o = n3.constructor;
        return e8 === void 0 ? r6 = Be(n3, n3.e <= o.toExpNeg || n3.e >= o.toExpPos) : (be(e8, 1, at), t5 === void 0 ? t5 = o.rounding : be(t5, 0, 8), n3 = F(new o(n3), e8, t5), r6 = Be(n3, e8 <= n3.e || n3.e <= o.toExpNeg, e8)), n3.isNeg() && !n3.isZero() ? "-" + r6 : r6;
      };
      v.toSignificantDigits = v.toSD = function(e8, t5) {
        var r6 = this, n3 = r6.constructor;
        return e8 === void 0 ? (e8 = n3.precision, t5 = n3.rounding) : (be(e8, 1, at), t5 === void 0 ? t5 = n3.rounding : be(t5, 0, 8)), F(new n3(r6), e8, t5);
      };
      v.toString = function() {
        var e8 = this, t5 = e8.constructor, r6 = Be(e8, e8.e <= t5.toExpNeg || e8.e >= t5.toExpPos);
        return e8.isNeg() && !e8.isZero() ? "-" + r6 : r6;
      };
      v.truncated = v.trunc = function() {
        return F(new this.constructor(this), this.e + 1, 1);
      };
      v.valueOf = v.toJSON = function() {
        var e8 = this, t5 = e8.constructor, r6 = Be(e8, e8.e <= t5.toExpNeg || e8.e >= t5.toExpPos);
        return e8.isNeg() ? "-" + r6 : r6;
      };
      function ue(e8) {
        var t5, r6, n3, o = e8.length - 1, i2 = "", s3 = e8[0];
        if (o > 0) {
          for (i2 += s3, t5 = 1; t5 < o; t5++)
            n3 = e8[t5] + "", r6 = I - n3.length, r6 && (i2 += ot(r6)), i2 += n3;
          s3 = e8[t5], n3 = s3 + "", r6 = I - n3.length, r6 && (i2 += ot(r6));
        } else if (s3 === 0)
          return "0";
        for (; s3 % 10 === 0; )
          s3 /= 10;
        return i2 + s3;
      }
      function be(e8, t5, r6) {
        if (e8 !== ~~e8 || e8 < t5 || e8 > r6)
          throw Error(st + e8);
      }
      function hr(e8, t5, r6, n3) {
        var o, i2, s3, a4;
        for (i2 = e8[0]; i2 >= 10; i2 /= 10)
          --t5;
        return --t5 < 0 ? (t5 += I, o = 0) : (o = Math.ceil((t5 + 1) / I), t5 %= I), i2 = X(10, I - t5), a4 = e8[o] % i2 | 0, n3 == null ? t5 < 3 ? (t5 == 0 ? a4 = a4 / 100 | 0 : t5 == 1 && (a4 = a4 / 10 | 0), s3 = r6 < 4 && a4 == 99999 || r6 > 3 && a4 == 49999 || a4 == 5e4 || a4 == 0) : s3 = (r6 < 4 && a4 + 1 == i2 || r6 > 3 && a4 + 1 == i2 / 2) && (e8[o + 1] / i2 / 100 | 0) == X(10, t5 - 2) - 1 || (a4 == i2 / 2 || a4 == 0) && (e8[o + 1] / i2 / 100 | 0) == 0 : t5 < 4 ? (t5 == 0 ? a4 = a4 / 1e3 | 0 : t5 == 1 ? a4 = a4 / 100 | 0 : t5 == 2 && (a4 = a4 / 10 | 0), s3 = (n3 || r6 < 4) && a4 == 9999 || !n3 && r6 > 3 && a4 == 4999) : s3 = ((n3 || r6 < 4) && a4 + 1 == i2 || !n3 && r6 > 3 && a4 + 1 == i2 / 2) && (e8[o + 1] / i2 / 1e3 | 0) == X(10, t5 - 3) - 1, s3;
      }
      function yn(e8, t5, r6) {
        for (var n3, o = [0], i2, s3 = 0, a4 = e8.length; s3 < a4; ) {
          for (i2 = o.length; i2--; )
            o[i2] *= t5;
          for (o[0] += Bo.indexOf(e8.charAt(s3++)), n3 = 0; n3 < o.length; n3++)
            o[n3] > r6 - 1 && (o[n3 + 1] === void 0 && (o[n3 + 1] = 0), o[n3 + 1] += o[n3] / r6 | 0, o[n3] %= r6);
        }
        return o.reverse();
      }
      function lp(e8, t5) {
        var r6, n3, o;
        if (t5.isZero())
          return t5;
        n3 = t5.d.length, n3 < 32 ? (r6 = Math.ceil(n3 / 3), o = (1 / Pn(4, r6)).toString()) : (r6 = 16, o = "2.3283064365386962890625e-10"), e8.precision += r6, t5 = Kt(e8, 1, t5.times(o), new e8(1));
        for (var i2 = r6; i2--; ) {
          var s3 = t5.times(t5);
          t5 = s3.times(s3).minus(s3).times(8).plus(1);
        }
        return e8.precision -= r6, t5;
      }
      var K = function() {
        function e8(n3, o, i2) {
          var s3, a4 = 0, u2 = n3.length;
          for (n3 = n3.slice(); u2--; )
            s3 = n3[u2] * o + a4, n3[u2] = s3 % i2 | 0, a4 = s3 / i2 | 0;
          return a4 && n3.unshift(a4), n3;
        }
        function t5(n3, o, i2, s3) {
          var a4, u2;
          if (i2 != s3)
            u2 = i2 > s3 ? 1 : -1;
          else
            for (a4 = u2 = 0; a4 < i2; a4++)
              if (n3[a4] != o[a4]) {
                u2 = n3[a4] > o[a4] ? 1 : -1;
                break;
              }
          return u2;
        }
        function r6(n3, o, i2, s3) {
          for (var a4 = 0; i2--; )
            n3[i2] -= a4, a4 = n3[i2] < o[i2] ? 1 : 0, n3[i2] = a4 * s3 + n3[i2] - o[i2];
          for (; !n3[0] && n3.length > 1; )
            n3.shift();
        }
        return function(n3, o, i2, s3, a4, u2) {
          var l, c2, m2, g2, w, E, b2, T, S, R, C, M, N, L, Te, V, H, Ee, z2, Pe, We = n3.constructor, $2 = n3.s == o.s ? 1 : -1, U = n3.d, O = o.d;
          if (!U || !U[0] || !O || !O[0])
            return new We(!n3.s || !o.s || (U ? O && U[0] == O[0] : !O) ? NaN : U && U[0] == 0 || !O ? $2 * 0 : $2 / 0);
          for (u2 ? (w = 1, c2 = n3.e - o.e) : (u2 = Oe, w = I, c2 = fe(n3.e / w) - fe(o.e / w)), z2 = O.length, H = U.length, S = new We($2), R = S.d = [], m2 = 0; O[m2] == (U[m2] || 0); m2++)
            ;
          if (O[m2] > (U[m2] || 0) && c2--, i2 == null ? (L = i2 = We.precision, s3 = We.rounding) : a4 ? L = i2 + (n3.e - o.e) + 1 : L = i2, L < 0)
            R.push(1), E = true;
          else {
            if (L = L / w + 2 | 0, m2 = 0, z2 == 1) {
              for (g2 = 0, O = O[0], L++; (m2 < H || g2) && L--; m2++)
                Te = g2 * u2 + (U[m2] || 0), R[m2] = Te / O | 0, g2 = Te % O | 0;
              E = g2 || m2 < H;
            } else {
              for (g2 = u2 / (O[0] + 1) | 0, g2 > 1 && (O = e8(O, g2, u2), U = e8(U, g2, u2), z2 = O.length, H = U.length), V = z2, C = U.slice(0, z2), M = C.length; M < z2; )
                C[M++] = 0;
              Pe = O.slice(), Pe.unshift(0), Ee = O[0], O[1] >= u2 / 2 && ++Ee;
              do
                g2 = 0, l = t5(O, C, z2, M), l < 0 ? (N = C[0], z2 != M && (N = N * u2 + (C[1] || 0)), g2 = N / Ee | 0, g2 > 1 ? (g2 >= u2 && (g2 = u2 - 1), b2 = e8(O, g2, u2), T = b2.length, M = C.length, l = t5(b2, C, T, M), l == 1 && (g2--, r6(b2, z2 < T ? Pe : O, T, u2))) : (g2 == 0 && (l = g2 = 1), b2 = O.slice()), T = b2.length, T < M && b2.unshift(0), r6(C, b2, M, u2), l == -1 && (M = C.length, l = t5(O, C, z2, M), l < 1 && (g2++, r6(C, z2 < M ? Pe : O, M, u2))), M = C.length) : l === 0 && (g2++, C = [0]), R[m2++] = g2, l && C[0] ? C[M++] = U[V] || 0 : (C = [U[V]], M = 1);
              while ((V++ < H || C[0] !== void 0) && L--);
              E = C[0] !== void 0;
            }
            R[0] || R.shift();
          }
          if (w == 1)
            S.e = c2, na = E;
          else {
            for (m2 = 1, g2 = R[0]; g2 >= 10; g2 /= 10)
              m2++;
            S.e = m2 + c2 * w - 1, F(S, a4 ? i2 + S.e + 1 : i2, s3, E);
          }
          return S;
        };
      }();
      function F(e8, t5, r6, n3) {
        var o, i2, s3, a4, u2, l, c2, m2, g2, w = e8.constructor;
        e:
          if (t5 != null) {
            if (m2 = e8.d, !m2)
              return e8;
            for (o = 1, a4 = m2[0]; a4 >= 10; a4 /= 10)
              o++;
            if (i2 = t5 - o, i2 < 0)
              i2 += I, s3 = t5, c2 = m2[g2 = 0], u2 = c2 / X(10, o - s3 - 1) % 10 | 0;
            else if (g2 = Math.ceil((i2 + 1) / I), a4 = m2.length, g2 >= a4)
              if (n3) {
                for (; a4++ <= g2; )
                  m2.push(0);
                c2 = u2 = 0, o = 1, i2 %= I, s3 = i2 - I + 1;
              } else
                break e;
            else {
              for (c2 = a4 = m2[g2], o = 1; a4 >= 10; a4 /= 10)
                o++;
              i2 %= I, s3 = i2 - I + o, u2 = s3 < 0 ? 0 : c2 / X(10, o - s3 - 1) % 10 | 0;
            }
            if (n3 = n3 || t5 < 0 || m2[g2 + 1] !== void 0 || (s3 < 0 ? c2 : c2 % X(10, o - s3 - 1)), l = r6 < 4 ? (u2 || n3) && (r6 == 0 || r6 == (e8.s < 0 ? 3 : 2)) : u2 > 5 || u2 == 5 && (r6 == 4 || n3 || r6 == 6 && (i2 > 0 ? s3 > 0 ? c2 / X(10, o - s3) : 0 : m2[g2 - 1]) % 10 & 1 || r6 == (e8.s < 0 ? 8 : 7)), t5 < 1 || !m2[0])
              return m2.length = 0, l ? (t5 -= e8.e + 1, m2[0] = X(10, (I - t5 % I) % I), e8.e = -t5 || 0) : m2[0] = e8.e = 0, e8;
            if (i2 == 0 ? (m2.length = g2, a4 = 1, g2--) : (m2.length = g2 + 1, a4 = X(10, I - i2), m2[g2] = s3 > 0 ? (c2 / X(10, o - s3) % X(10, s3) | 0) * a4 : 0), l)
              for (; ; )
                if (g2 == 0) {
                  for (i2 = 1, s3 = m2[0]; s3 >= 10; s3 /= 10)
                    i2++;
                  for (s3 = m2[0] += a4, a4 = 1; s3 >= 10; s3 /= 10)
                    a4++;
                  i2 != a4 && (e8.e++, m2[0] == Oe && (m2[0] = 1));
                  break;
                } else {
                  if (m2[g2] += a4, m2[g2] != Oe)
                    break;
                  m2[g2--] = 0, a4 = 1;
                }
            for (i2 = m2.length; m2[--i2] === 0; )
              m2.pop();
          }
        return D && (e8.e > w.maxE ? (e8.d = null, e8.e = NaN) : e8.e < w.minE && (e8.e = 0, e8.d = [0])), e8;
      }
      function Be(e8, t5, r6) {
        if (!e8.isFinite())
          return pa(e8);
        var n3, o = e8.e, i2 = ue(e8.d), s3 = i2.length;
        return t5 ? (r6 && (n3 = r6 - s3) > 0 ? i2 = i2.charAt(0) + "." + i2.slice(1) + ot(n3) : s3 > 1 && (i2 = i2.charAt(0) + "." + i2.slice(1)), i2 = i2 + (e8.e < 0 ? "e" : "e+") + e8.e) : o < 0 ? (i2 = "0." + ot(-o - 1) + i2, r6 && (n3 = r6 - s3) > 0 && (i2 += ot(n3))) : o >= s3 ? (i2 += ot(o + 1 - s3), r6 && (n3 = r6 - o - 1) > 0 && (i2 = i2 + "." + ot(n3))) : ((n3 = o + 1) < s3 && (i2 = i2.slice(0, n3) + "." + i2.slice(n3)), r6 && (n3 = r6 - s3) > 0 && (o + 1 === s3 && (i2 += "."), i2 += ot(n3))), i2;
      }
      function En(e8, t5) {
        var r6 = e8[0];
        for (t5 *= I; r6 >= 10; r6 /= 10)
          t5++;
        return t5;
      }
      function bn(e8, t5, r6) {
        if (t5 > up)
          throw D = true, r6 && (e8.precision = r6), Error(oa);
        return F(new e8(hn), t5, 1, true);
      }
      function Re(e8, t5, r6) {
        if (t5 > Uo)
          throw Error(oa);
        return F(new e8(xn), t5, r6, true);
      }
      function ua(e8) {
        var t5 = e8.length - 1, r6 = t5 * I + 1;
        if (t5 = e8[t5], t5) {
          for (; t5 % 10 == 0; t5 /= 10)
            r6--;
          for (t5 = e8[0]; t5 >= 10; t5 /= 10)
            r6++;
        }
        return r6;
      }
      function ot(e8) {
        for (var t5 = ""; e8--; )
          t5 += "0";
        return t5;
      }
      function la(e8, t5, r6, n3) {
        var o, i2 = new e8(1), s3 = Math.ceil(n3 / I + 4);
        for (D = false; ; ) {
          if (r6 % 2 && (i2 = i2.times(t5), ta(i2.d, s3) && (o = true)), r6 = fe(r6 / 2), r6 === 0) {
            r6 = i2.d.length - 1, o && i2.d[r6] === 0 && ++i2.d[r6];
            break;
          }
          t5 = t5.times(t5), ta(t5.d, s3);
        }
        return D = true, i2;
      }
      function ea(e8) {
        return e8.d[e8.d.length - 1] & 1;
      }
      function ca(e8, t5, r6) {
        for (var n3, o = new e8(t5[0]), i2 = 0; ++i2 < t5.length; )
          if (n3 = new e8(t5[i2]), n3.s)
            o[r6](n3) && (o = n3);
          else {
            o = n3;
            break;
          }
        return o;
      }
      function $o(e8, t5) {
        var r6, n3, o, i2, s3, a4, u2, l = 0, c2 = 0, m2 = 0, g2 = e8.constructor, w = g2.rounding, E = g2.precision;
        if (!e8.d || !e8.d[0] || e8.e > 17)
          return new g2(e8.d ? e8.d[0] ? e8.s < 0 ? 0 : 1 / 0 : 1 : e8.s ? e8.s < 0 ? 0 : e8 : 0 / 0);
        for (t5 == null ? (D = false, u2 = E) : u2 = t5, a4 = new g2(0.03125); e8.e > -2; )
          e8 = e8.times(a4), m2 += 5;
        for (n3 = Math.log(X(2, m2)) / Math.LN10 * 2 + 5 | 0, u2 += n3, r6 = i2 = s3 = new g2(1), g2.precision = u2; ; ) {
          if (i2 = F(i2.times(e8), u2, 1), r6 = r6.times(++c2), a4 = s3.plus(K(i2, r6, u2, 1)), ue(a4.d).slice(0, u2) === ue(s3.d).slice(0, u2)) {
            for (o = m2; o--; )
              s3 = F(s3.times(s3), u2, 1);
            if (t5 == null)
              if (l < 3 && hr(s3.d, u2 - n3, w, l))
                g2.precision = u2 += 10, r6 = i2 = a4 = new g2(1), c2 = 0, l++;
              else
                return F(s3, g2.precision = E, w, D = true);
            else
              return g2.precision = E, s3;
          }
          s3 = a4;
        }
      }
      function it(e8, t5) {
        var r6, n3, o, i2, s3, a4, u2, l, c2, m2, g2, w = 1, E = 10, b2 = e8, T = b2.d, S = b2.constructor, R = S.rounding, C = S.precision;
        if (b2.s < 0 || !T || !T[0] || !b2.e && T[0] == 1 && T.length == 1)
          return new S(T && !T[0] ? -1 / 0 : b2.s != 1 ? NaN : T ? 0 : b2);
        if (t5 == null ? (D = false, c2 = C) : c2 = t5, S.precision = c2 += E, r6 = ue(T), n3 = r6.charAt(0), Math.abs(i2 = b2.e) < 15e14) {
          for (; n3 < 7 && n3 != 1 || n3 == 1 && r6.charAt(1) > 3; )
            b2 = b2.times(e8), r6 = ue(b2.d), n3 = r6.charAt(0), w++;
          i2 = b2.e, n3 > 1 ? (b2 = new S("0." + r6), i2++) : b2 = new S(n3 + "." + r6.slice(1));
        } else
          return l = bn(S, c2 + 2, C).times(i2 + ""), b2 = it(new S(n3 + "." + r6.slice(1)), c2 - E).plus(l), S.precision = C, t5 == null ? F(b2, C, R, D = true) : b2;
        for (m2 = b2, u2 = s3 = b2 = K(b2.minus(1), b2.plus(1), c2, 1), g2 = F(b2.times(b2), c2, 1), o = 3; ; ) {
          if (s3 = F(s3.times(g2), c2, 1), l = u2.plus(K(s3, new S(o), c2, 1)), ue(l.d).slice(0, c2) === ue(u2.d).slice(0, c2))
            if (u2 = u2.times(2), i2 !== 0 && (u2 = u2.plus(bn(S, c2 + 2, C).times(i2 + ""))), u2 = K(u2, new S(w), c2, 1), t5 == null)
              if (hr(u2.d, c2 - E, R, a4))
                S.precision = c2 += E, l = s3 = b2 = K(m2.minus(1), m2.plus(1), c2, 1), g2 = F(b2.times(b2), c2, 1), o = a4 = 1;
              else
                return F(u2, S.precision = C, R, D = true);
            else
              return S.precision = C, u2;
          u2 = l, o += 2;
        }
      }
      function pa(e8) {
        return String(e8.s * e8.s / 0);
      }
      function qo(e8, t5) {
        var r6, n3, o;
        for ((r6 = t5.indexOf(".")) > -1 && (t5 = t5.replace(".", "")), (n3 = t5.search(/e/i)) > 0 ? (r6 < 0 && (r6 = n3), r6 += +t5.slice(n3 + 1), t5 = t5.substring(0, n3)) : r6 < 0 && (r6 = t5.length), n3 = 0; t5.charCodeAt(n3) === 48; n3++)
          ;
        for (o = t5.length; t5.charCodeAt(o - 1) === 48; --o)
          ;
        if (t5 = t5.slice(n3, o), t5) {
          if (o -= n3, e8.e = r6 = r6 - n3 - 1, e8.d = [], n3 = (r6 + 1) % I, r6 < 0 && (n3 += I), n3 < o) {
            for (n3 && e8.d.push(+t5.slice(0, n3)), o -= I; n3 < o; )
              e8.d.push(+t5.slice(n3, n3 += I));
            t5 = t5.slice(n3), n3 = I - t5.length;
          } else
            n3 -= o;
          for (; n3--; )
            t5 += "0";
          e8.d.push(+t5), D && (e8.e > e8.constructor.maxE ? (e8.d = null, e8.e = NaN) : e8.e < e8.constructor.minE && (e8.e = 0, e8.d = [0]));
        } else
          e8.e = 0, e8.d = [0];
        return e8;
      }
      function cp(e8, t5) {
        var r6, n3, o, i2, s3, a4, u2, l, c2;
        if (t5.indexOf("_") > -1) {
          if (t5 = t5.replace(/(\d)_(?=\d)/g, "$1"), aa.test(t5))
            return qo(e8, t5);
        } else if (t5 === "Infinity" || t5 === "NaN")
          return +t5 || (e8.s = NaN), e8.e = NaN, e8.d = null, e8;
        if (ip.test(t5))
          r6 = 16, t5 = t5.toLowerCase();
        else if (op.test(t5))
          r6 = 2;
        else if (sp.test(t5))
          r6 = 8;
        else
          throw Error(st + t5);
        for (i2 = t5.search(/p/i), i2 > 0 ? (u2 = +t5.slice(i2 + 1), t5 = t5.substring(2, i2)) : t5 = t5.slice(2), i2 = t5.indexOf("."), s3 = i2 >= 0, n3 = e8.constructor, s3 && (t5 = t5.replace(".", ""), a4 = t5.length, i2 = a4 - i2, o = la(n3, new n3(r6), i2, i2 * 2)), l = yn(t5, r6, Oe), c2 = l.length - 1, i2 = c2; l[i2] === 0; --i2)
          l.pop();
        return i2 < 0 ? new n3(e8.s * 0) : (e8.e = En(l, c2), e8.d = l, D = false, s3 && (e8 = K(e8, o, a4 * 4)), u2 && (e8 = e8.times(Math.abs(u2) < 54 ? X(2, u2) : wt.pow(2, u2))), D = true, e8);
      }
      function pp(e8, t5) {
        var r6, n3 = t5.d.length;
        if (n3 < 3)
          return t5.isZero() ? t5 : Kt(e8, 2, t5, t5);
        r6 = 1.4 * Math.sqrt(n3), r6 = r6 > 16 ? 16 : r6 | 0, t5 = t5.times(1 / Pn(5, r6)), t5 = Kt(e8, 2, t5, t5);
        for (var o, i2 = new e8(5), s3 = new e8(16), a4 = new e8(20); r6--; )
          o = t5.times(t5), t5 = t5.times(i2.plus(o.times(s3.times(o).minus(a4))));
        return t5;
      }
      function Kt(e8, t5, r6, n3, o) {
        var i2, s3, a4, u2, l = 1, c2 = e8.precision, m2 = Math.ceil(c2 / I);
        for (D = false, u2 = r6.times(r6), a4 = new e8(n3); ; ) {
          if (s3 = K(a4.times(u2), new e8(t5++ * t5++), c2, 1), a4 = o ? n3.plus(s3) : n3.minus(s3), n3 = K(s3.times(u2), new e8(t5++ * t5++), c2, 1), s3 = a4.plus(n3), s3.d[m2] !== void 0) {
            for (i2 = m2; s3.d[i2] === a4.d[i2] && i2--; )
              ;
            if (i2 == -1)
              break;
          }
          i2 = a4, a4 = n3, n3 = s3, s3 = i2, l++;
        }
        return D = true, s3.d.length = m2 + 1, s3;
      }
      function Pn(e8, t5) {
        for (var r6 = e8; --t5; )
          r6 *= e8;
        return r6;
      }
      function fa(e8, t5) {
        var r6, n3 = t5.s < 0, o = Re(e8, e8.precision, 1), i2 = o.times(0.5);
        if (t5 = t5.abs(), t5.lte(i2))
          return Je = n3 ? 4 : 1, t5;
        if (r6 = t5.divToInt(o), r6.isZero())
          Je = n3 ? 3 : 2;
        else {
          if (t5 = t5.minus(r6.times(o)), t5.lte(i2))
            return Je = ea(r6) ? n3 ? 2 : 3 : n3 ? 4 : 1, t5;
          Je = ea(r6) ? n3 ? 1 : 4 : n3 ? 3 : 2;
        }
        return t5.minus(o).abs();
      }
      function Vo(e8, t5, r6, n3) {
        var o, i2, s3, a4, u2, l, c2, m2, g2, w = e8.constructor, E = r6 !== void 0;
        if (E ? (be(r6, 1, at), n3 === void 0 ? n3 = w.rounding : be(n3, 0, 8)) : (r6 = w.precision, n3 = w.rounding), !e8.isFinite())
          c2 = pa(e8);
        else {
          for (c2 = Be(e8), s3 = c2.indexOf("."), E ? (o = 2, t5 == 16 ? r6 = r6 * 4 - 3 : t5 == 8 && (r6 = r6 * 3 - 2)) : o = t5, s3 >= 0 && (c2 = c2.replace(".", ""), g2 = new w(1), g2.e = c2.length - s3, g2.d = yn(Be(g2), 10, o), g2.e = g2.d.length), m2 = yn(c2, 10, o), i2 = u2 = m2.length; m2[--u2] == 0; )
            m2.pop();
          if (!m2[0])
            c2 = E ? "0p+0" : "0";
          else {
            if (s3 < 0 ? i2-- : (e8 = new w(e8), e8.d = m2, e8.e = i2, e8 = K(e8, g2, r6, n3, 0, o), m2 = e8.d, i2 = e8.e, l = na), s3 = m2[r6], a4 = o / 2, l = l || m2[r6 + 1] !== void 0, l = n3 < 4 ? (s3 !== void 0 || l) && (n3 === 0 || n3 === (e8.s < 0 ? 3 : 2)) : s3 > a4 || s3 === a4 && (n3 === 4 || l || n3 === 6 && m2[r6 - 1] & 1 || n3 === (e8.s < 0 ? 8 : 7)), m2.length = r6, l)
              for (; ++m2[--r6] > o - 1; )
                m2[r6] = 0, r6 || (++i2, m2.unshift(1));
            for (u2 = m2.length; !m2[u2 - 1]; --u2)
              ;
            for (s3 = 0, c2 = ""; s3 < u2; s3++)
              c2 += Bo.charAt(m2[s3]);
            if (E) {
              if (u2 > 1)
                if (t5 == 16 || t5 == 8) {
                  for (s3 = t5 == 16 ? 4 : 3, --u2; u2 % s3; u2++)
                    c2 += "0";
                  for (m2 = yn(c2, o, t5), u2 = m2.length; !m2[u2 - 1]; --u2)
                    ;
                  for (s3 = 1, c2 = "1."; s3 < u2; s3++)
                    c2 += Bo.charAt(m2[s3]);
                } else
                  c2 = c2.charAt(0) + "." + c2.slice(1);
              c2 = c2 + (i2 < 0 ? "p" : "p+") + i2;
            } else if (i2 < 0) {
              for (; ++i2; )
                c2 = "0" + c2;
              c2 = "0." + c2;
            } else if (++i2 > u2)
              for (i2 -= u2; i2--; )
                c2 += "0";
            else
              i2 < u2 && (c2 = c2.slice(0, i2) + "." + c2.slice(i2));
          }
          c2 = (t5 == 16 ? "0x" : t5 == 2 ? "0b" : t5 == 8 ? "0o" : "") + c2;
        }
        return e8.s < 0 ? "-" + c2 : c2;
      }
      function ta(e8, t5) {
        if (e8.length > t5)
          return e8.length = t5, true;
      }
      function fp(e8) {
        return new this(e8).abs();
      }
      function dp(e8) {
        return new this(e8).acos();
      }
      function mp(e8) {
        return new this(e8).acosh();
      }
      function gp(e8, t5) {
        return new this(e8).plus(t5);
      }
      function yp(e8) {
        return new this(e8).asin();
      }
      function hp(e8) {
        return new this(e8).asinh();
      }
      function xp(e8) {
        return new this(e8).atan();
      }
      function bp(e8) {
        return new this(e8).atanh();
      }
      function wp(e8, t5) {
        e8 = new this(e8), t5 = new this(t5);
        var r6, n3 = this.precision, o = this.rounding, i2 = n3 + 4;
        return !e8.s || !t5.s ? r6 = new this(NaN) : !e8.d && !t5.d ? (r6 = Re(this, i2, 1).times(t5.s > 0 ? 0.25 : 0.75), r6.s = e8.s) : !t5.d || e8.isZero() ? (r6 = t5.s < 0 ? Re(this, n3, o) : new this(0), r6.s = e8.s) : !e8.d || t5.isZero() ? (r6 = Re(this, i2, 1).times(0.5), r6.s = e8.s) : t5.s < 0 ? (this.precision = i2, this.rounding = 1, r6 = this.atan(K(e8, t5, i2, 1)), t5 = Re(this, i2, 1), this.precision = n3, this.rounding = o, r6 = e8.s < 0 ? r6.minus(t5) : r6.plus(t5)) : r6 = this.atan(K(e8, t5, i2, 1)), r6;
      }
      function Ep(e8) {
        return new this(e8).cbrt();
      }
      function Pp(e8) {
        return F(e8 = new this(e8), e8.e + 1, 2);
      }
      function vp(e8, t5, r6) {
        return new this(e8).clamp(t5, r6);
      }
      function Ap(e8) {
        if (!e8 || typeof e8 != "object")
          throw Error(wn + "Object expected");
        var t5, r6, n3, o = e8.defaults === true, i2 = ["precision", 1, at, "rounding", 0, 8, "toExpNeg", -Vt, 0, "toExpPos", 0, Vt, "maxE", 0, Vt, "minE", -Vt, 0, "modulo", 0, 9];
        for (t5 = 0; t5 < i2.length; t5 += 3)
          if (r6 = i2[t5], o && (this[r6] = jo[r6]), (n3 = e8[r6]) !== void 0)
            if (fe(n3) === n3 && n3 >= i2[t5 + 1] && n3 <= i2[t5 + 2])
              this[r6] = n3;
            else
              throw Error(st + r6 + ": " + n3);
        if (r6 = "crypto", o && (this[r6] = jo[r6]), (n3 = e8[r6]) !== void 0)
          if (n3 === true || n3 === false || n3 === 0 || n3 === 1)
            if (n3)
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                this[r6] = true;
              else
                throw Error(ia);
            else
              this[r6] = false;
          else
            throw Error(st + r6 + ": " + n3);
        return this;
      }
      function Tp(e8) {
        return new this(e8).cos();
      }
      function Cp(e8) {
        return new this(e8).cosh();
      }
      function da(e8) {
        var t5, r6, n3;
        function o(i2) {
          var s3, a4, u2, l = this;
          if (!(l instanceof o))
            return new o(i2);
          if (l.constructor = o, ra(i2)) {
            l.s = i2.s, D ? !i2.d || i2.e > o.maxE ? (l.e = NaN, l.d = null) : i2.e < o.minE ? (l.e = 0, l.d = [0]) : (l.e = i2.e, l.d = i2.d.slice()) : (l.e = i2.e, l.d = i2.d ? i2.d.slice() : i2.d);
            return;
          }
          if (u2 = typeof i2, u2 === "number") {
            if (i2 === 0) {
              l.s = 1 / i2 < 0 ? -1 : 1, l.e = 0, l.d = [0];
              return;
            }
            if (i2 < 0 ? (i2 = -i2, l.s = -1) : l.s = 1, i2 === ~~i2 && i2 < 1e7) {
              for (s3 = 0, a4 = i2; a4 >= 10; a4 /= 10)
                s3++;
              D ? s3 > o.maxE ? (l.e = NaN, l.d = null) : s3 < o.minE ? (l.e = 0, l.d = [0]) : (l.e = s3, l.d = [i2]) : (l.e = s3, l.d = [i2]);
              return;
            } else if (i2 * 0 !== 0) {
              i2 || (l.s = NaN), l.e = NaN, l.d = null;
              return;
            }
            return qo(l, i2.toString());
          } else if (u2 !== "string")
            throw Error(st + i2);
          return (a4 = i2.charCodeAt(0)) === 45 ? (i2 = i2.slice(1), l.s = -1) : (a4 === 43 && (i2 = i2.slice(1)), l.s = 1), aa.test(i2) ? qo(l, i2) : cp(l, i2);
        }
        if (o.prototype = v, o.ROUND_UP = 0, o.ROUND_DOWN = 1, o.ROUND_CEIL = 2, o.ROUND_FLOOR = 3, o.ROUND_HALF_UP = 4, o.ROUND_HALF_DOWN = 5, o.ROUND_HALF_EVEN = 6, o.ROUND_HALF_CEIL = 7, o.ROUND_HALF_FLOOR = 8, o.EUCLID = 9, o.config = o.set = Ap, o.clone = da, o.isDecimal = ra, o.abs = fp, o.acos = dp, o.acosh = mp, o.add = gp, o.asin = yp, o.asinh = hp, o.atan = xp, o.atanh = bp, o.atan2 = wp, o.cbrt = Ep, o.ceil = Pp, o.clamp = vp, o.cos = Tp, o.cosh = Cp, o.div = Mp, o.exp = Sp, o.floor = Rp, o.hypot = Op, o.ln = Fp, o.log = Ip, o.log10 = Dp, o.log2 = kp, o.max = _p, o.min = Np, o.mod = Lp, o.mul = Bp, o.pow = jp, o.random = Up, o.round = $p, o.sign = qp, o.sin = Vp, o.sinh = Kp, o.sqrt = Gp, o.sub = Jp, o.sum = Qp, o.tan = Wp, o.tanh = Hp, o.trunc = zp, e8 === void 0 && (e8 = {}), e8 && e8.defaults !== true)
          for (n3 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t5 = 0; t5 < n3.length; )
            e8.hasOwnProperty(r6 = n3[t5++]) || (e8[r6] = this[r6]);
        return o.config(e8), o;
      }
      function Mp(e8, t5) {
        return new this(e8).div(t5);
      }
      function Sp(e8) {
        return new this(e8).exp();
      }
      function Rp(e8) {
        return F(e8 = new this(e8), e8.e + 1, 3);
      }
      function Op() {
        var e8, t5, r6 = new this(0);
        for (D = false, e8 = 0; e8 < arguments.length; )
          if (t5 = new this(arguments[e8++]), t5.d)
            r6.d && (r6 = r6.plus(t5.times(t5)));
          else {
            if (t5.s)
              return D = true, new this(1 / 0);
            r6 = t5;
          }
        return D = true, r6.sqrt();
      }
      function ra(e8) {
        return e8 instanceof wt || e8 && e8.toStringTag === sa || false;
      }
      function Fp(e8) {
        return new this(e8).ln();
      }
      function Ip(e8, t5) {
        return new this(e8).log(t5);
      }
      function kp(e8) {
        return new this(e8).log(2);
      }
      function Dp(e8) {
        return new this(e8).log(10);
      }
      function _p() {
        return ca(this, arguments, "lt");
      }
      function Np() {
        return ca(this, arguments, "gt");
      }
      function Lp(e8, t5) {
        return new this(e8).mod(t5);
      }
      function Bp(e8, t5) {
        return new this(e8).mul(t5);
      }
      function jp(e8, t5) {
        return new this(e8).pow(t5);
      }
      function Up(e8) {
        var t5, r6, n3, o, i2 = 0, s3 = new this(1), a4 = [];
        if (e8 === void 0 ? e8 = this.precision : be(e8, 1, at), n3 = Math.ceil(e8 / I), this.crypto)
          if (crypto.getRandomValues)
            for (t5 = crypto.getRandomValues(new Uint32Array(n3)); i2 < n3; )
              o = t5[i2], o >= 429e7 ? t5[i2] = crypto.getRandomValues(new Uint32Array(1))[0] : a4[i2++] = o % 1e7;
          else if (crypto.randomBytes) {
            for (t5 = crypto.randomBytes(n3 *= 4); i2 < n3; )
              o = t5[i2] + (t5[i2 + 1] << 8) + (t5[i2 + 2] << 16) + ((t5[i2 + 3] & 127) << 24), o >= 214e7 ? crypto.randomBytes(4).copy(t5, i2) : (a4.push(o % 1e7), i2 += 4);
            i2 = n3 / 4;
          } else
            throw Error(ia);
        else
          for (; i2 < n3; )
            a4[i2++] = Math.random() * 1e7 | 0;
        for (n3 = a4[--i2], e8 %= I, n3 && e8 && (o = X(10, I - e8), a4[i2] = (n3 / o | 0) * o); a4[i2] === 0; i2--)
          a4.pop();
        if (i2 < 0)
          r6 = 0, a4 = [0];
        else {
          for (r6 = -1; a4[0] === 0; r6 -= I)
            a4.shift();
          for (n3 = 1, o = a4[0]; o >= 10; o /= 10)
            n3++;
          n3 < I && (r6 -= I - n3);
        }
        return s3.e = r6, s3.d = a4, s3;
      }
      function $p(e8) {
        return F(e8 = new this(e8), e8.e + 1, this.rounding);
      }
      function qp(e8) {
        return e8 = new this(e8), e8.d ? e8.d[0] ? e8.s : 0 * e8.s : e8.s || NaN;
      }
      function Vp(e8) {
        return new this(e8).sin();
      }
      function Kp(e8) {
        return new this(e8).sinh();
      }
      function Gp(e8) {
        return new this(e8).sqrt();
      }
      function Jp(e8, t5) {
        return new this(e8).sub(t5);
      }
      function Qp() {
        var e8 = 0, t5 = arguments, r6 = new this(t5[e8]);
        for (D = false; r6.s && ++e8 < t5.length; )
          r6 = r6.plus(t5[e8]);
        return D = true, F(r6, this.precision, this.rounding);
      }
      function Wp(e8) {
        return new this(e8).tan();
      }
      function Hp(e8) {
        return new this(e8).tanh();
      }
      function zp(e8) {
        return F(e8 = new this(e8), e8.e + 1, 1);
      }
      v[Symbol.for("nodejs.util.inspect.custom")] = v.toString;
      v[Symbol.toStringTag] = "Decimal";
      var wt = v.constructor = da(jo);
      hn = new wt(hn);
      xn = new wt(xn);
      var je = wt;
      function Gt(e8) {
        return wt.isDecimal(e8) ? true : e8 !== null && typeof e8 == "object" && typeof e8.s == "number" && typeof e8.e == "number" && typeof e8.toFixed == "function" && Array.isArray(e8.d);
      }
      d2();
      p2();
      f();
      var xr = class {
        constructor(t5, r6, n3, o, i2) {
          this.modelName = t5, this.name = r6, this.typeName = n3, this.isList = o, this.isEnum = i2;
        }
        _toGraphQLInputType() {
          let t5 = this.isList ? "List" : "", r6 = this.isEnum ? "Enum" : "";
          return `${t5}${r6}${this.typeName}FieldRefInput<${this.modelName}>`;
        }
      };
      function Jt(e8) {
        return e8 instanceof xr;
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var vn = class {
        constructor(t5) {
          this.value = t5;
        }
        write(t5) {
          t5.write(this.value);
        }
        markAsError() {
          this.value.markAsError();
        }
      };
      d2();
      p2();
      f();
      var An = (e8) => e8;
      var Tn = { bold: An, red: An, green: An, dim: An, enabled: false };
      var ma = { bold: tt, red: _t, green: on3, dim: nn, enabled: true };
      var Qt = { write(e8) {
        e8.writeLine(",");
      } };
      d2();
      p2();
      f();
      var Ue = class {
        constructor(t5) {
          this.contents = t5;
          this.isUnderlined = false;
          this.color = (t6) => t6;
        }
        underline() {
          return this.isUnderlined = true, this;
        }
        setColor(t5) {
          return this.color = t5, this;
        }
        write(t5) {
          let r6 = t5.getCurrentLineLength();
          t5.write(this.color(this.contents)), this.isUnderlined && t5.afterNextNewline(() => {
            t5.write(" ".repeat(r6)).writeLine(this.color("~".repeat(this.contents.length)));
          });
        }
      };
      d2();
      p2();
      f();
      var ut = class {
        constructor() {
          this.hasError = false;
        }
        markAsError() {
          return this.hasError = true, this;
        }
      };
      var Wt = class extends ut {
        constructor() {
          super(...arguments);
          this.items = [];
        }
        addItem(r6) {
          return this.items.push(new vn(r6)), this;
        }
        getField(r6) {
          return this.items[r6];
        }
        getPrintWidth() {
          return this.items.length === 0 ? 2 : Math.max(...this.items.map((n3) => n3.value.getPrintWidth())) + 2;
        }
        write(r6) {
          if (this.items.length === 0) {
            this.writeEmpty(r6);
            return;
          }
          this.writeWithItems(r6);
        }
        writeEmpty(r6) {
          let n3 = new Ue("[]");
          this.hasError && n3.setColor(r6.context.colors.red).underline(), r6.write(n3);
        }
        writeWithItems(r6) {
          let { colors: n3 } = r6.context;
          r6.writeLine("[").withIndent(() => r6.writeJoined(Qt, this.items).newLine()).write("]"), this.hasError && r6.afterNextNewline(() => {
            r6.writeLine(n3.red("~".repeat(this.getPrintWidth())));
          });
        }
      };
      d2();
      p2();
      f();
      var ga = ": ";
      var Cn = class {
        constructor(t5, r6) {
          this.name = t5;
          this.value = r6;
          this.hasError = false;
        }
        markAsError() {
          this.hasError = true;
        }
        getPrintWidth() {
          return this.name.length + this.value.getPrintWidth() + ga.length;
        }
        write(t5) {
          let r6 = new Ue(this.name);
          this.hasError && r6.underline().setColor(t5.context.colors.red), t5.write(r6).write(ga).write(this.value);
        }
      };
      d2();
      p2();
      f();
      var ne = class e8 extends ut {
        constructor() {
          super(...arguments);
          this.fields = {};
          this.suggestions = [];
        }
        addField(r6) {
          this.fields[r6.name] = r6;
        }
        addSuggestion(r6) {
          this.suggestions.push(r6);
        }
        getField(r6) {
          return this.fields[r6];
        }
        getDeepField(r6) {
          let [n3, ...o] = r6, i2 = this.getField(n3);
          if (!i2)
            return;
          let s3 = i2;
          for (let a4 of o) {
            let u2;
            if (s3.value instanceof e8 ? u2 = s3.value.getField(a4) : s3.value instanceof Wt && (u2 = s3.value.getField(Number(a4))), !u2)
              return;
            s3 = u2;
          }
          return s3;
        }
        getDeepFieldValue(r6) {
          var n3;
          return r6.length === 0 ? this : (n3 = this.getDeepField(r6)) == null ? void 0 : n3.value;
        }
        hasField(r6) {
          return !!this.getField(r6);
        }
        removeAllFields() {
          this.fields = {};
        }
        removeField(r6) {
          delete this.fields[r6];
        }
        getFields() {
          return this.fields;
        }
        isEmpty() {
          return Object.keys(this.fields).length === 0;
        }
        getFieldValue(r6) {
          var n3;
          return (n3 = this.getField(r6)) == null ? void 0 : n3.value;
        }
        getDeepSubSelectionValue(r6) {
          let n3 = this;
          for (let o of r6) {
            if (!(n3 instanceof e8))
              return;
            let i2 = n3.getSubSelectionValue(o);
            if (!i2)
              return;
            n3 = i2;
          }
          return n3;
        }
        getDeepSelectionParent(r6) {
          let n3 = this.getSelectionParent();
          if (!n3)
            return;
          let o = n3;
          for (let i2 of r6) {
            let s3 = o.value.getFieldValue(i2);
            if (!s3 || !(s3 instanceof e8))
              return;
            let a4 = s3.getSelectionParent();
            if (!a4)
              return;
            o = a4;
          }
          return o;
        }
        getSelectionParent() {
          let r6 = this.getField("select");
          if ((r6 == null ? void 0 : r6.value) instanceof e8)
            return { kind: "select", value: r6.value };
          let n3 = this.getField("include");
          if ((n3 == null ? void 0 : n3.value) instanceof e8)
            return { kind: "include", value: n3.value };
        }
        getSubSelectionValue(r6) {
          var n3;
          return (n3 = this.getSelectionParent()) == null ? void 0 : n3.value.fields[r6].value;
        }
        getPrintWidth() {
          let r6 = Object.values(this.fields);
          return r6.length == 0 ? 2 : Math.max(...r6.map((o) => o.getPrintWidth())) + 2;
        }
        write(r6) {
          let n3 = Object.values(this.fields);
          if (n3.length === 0 && this.suggestions.length === 0) {
            this.writeEmpty(r6);
            return;
          }
          this.writeWithContents(r6, n3);
        }
        writeEmpty(r6) {
          let n3 = new Ue("{}");
          this.hasError && n3.setColor(r6.context.colors.red).underline(), r6.write(n3);
        }
        writeWithContents(r6, n3) {
          r6.writeLine("{").withIndent(() => {
            r6.writeJoined(Qt, [...n3, ...this.suggestions]).newLine();
          }), r6.write("}"), this.hasError && r6.afterNextNewline(() => {
            r6.writeLine(r6.context.colors.red("~".repeat(this.getPrintWidth())));
          });
        }
      };
      d2();
      p2();
      f();
      var oe = class extends ut {
        constructor(r6) {
          super();
          this.text = r6;
        }
        getPrintWidth() {
          return this.text.length;
        }
        write(r6) {
          let n3 = new Ue(this.text);
          this.hasError && n3.underline().setColor(r6.context.colors.red), r6.write(n3);
        }
      };
      var Ko = class {
        constructor(t5) {
          this.errorMessages = [];
          this.arguments = t5;
        }
        write(t5) {
          t5.write(this.arguments);
        }
        addErrorMessage(t5) {
          this.errorMessages.push(t5);
        }
        renderAllMessages(t5) {
          return this.errorMessages.map((r6) => r6(t5)).join(`
`);
        }
      };
      function Mn(e8) {
        return new Ko(ya(e8));
      }
      function ya(e8) {
        let t5 = new ne();
        for (let [r6, n3] of Object.entries(e8)) {
          let o = new Cn(r6, ha(n3));
          t5.addField(o);
        }
        return t5;
      }
      function ha(e8) {
        if (typeof e8 == "string")
          return new oe(JSON.stringify(e8));
        if (typeof e8 == "number" || typeof e8 == "boolean")
          return new oe(String(e8));
        if (typeof e8 == "bigint")
          return new oe(`${e8}n`);
        if (e8 === null)
          return new oe("null");
        if (e8 === void 0)
          return new oe("undefined");
        if (Gt(e8))
          return new oe(`new Prisma.Decimal("${e8.toFixed()}")`);
        if (e8 instanceof Uint8Array)
          return x2.Buffer.isBuffer(e8) ? new oe(`Buffer.alloc(${e8.byteLength})`) : new oe(`new Uint8Array(${e8.byteLength})`);
        if (e8 instanceof Date) {
          let t5 = gn(e8) ? e8.toISOString() : "Invalid Date";
          return new oe(`new Date("${t5}")`);
        }
        return e8 instanceof _e ? new oe(`Prisma.${e8._getName()}`) : Jt(e8) ? new oe(`prisma.${Zi(e8.modelName)}.$fields.${e8.name}`) : Array.isArray(e8) ? Yp(e8) : typeof e8 == "object" ? ya(e8) : new oe(Object.prototype.toString.call(e8));
      }
      function Yp(e8) {
        let t5 = new Wt();
        for (let r6 of e8)
          t5.addItem(ha(r6));
        return t5;
      }
      function xa(e8) {
        if (e8 === void 0)
          return "";
        let t5 = Mn(e8);
        return new $t(0, { colors: Tn }).write(t5).toString();
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var br = "<unknown>";
      function ba(e8) {
        var t5 = e8.split(`
`);
        return t5.reduce(function(r6, n3) {
          var o = tf(n3) || nf(n3) || af(n3) || pf(n3) || lf(n3);
          return o && r6.push(o), r6;
        }, []);
      }
      var Xp = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
      var ef = /\((\S*)(?::(\d+))(?::(\d+))\)/;
      function tf(e8) {
        var t5 = Xp.exec(e8);
        if (!t5)
          return null;
        var r6 = t5[2] && t5[2].indexOf("native") === 0, n3 = t5[2] && t5[2].indexOf("eval") === 0, o = ef.exec(t5[2]);
        return n3 && o != null && (t5[2] = o[1], t5[3] = o[2], t5[4] = o[3]), { file: r6 ? null : t5[2], methodName: t5[1] || br, arguments: r6 ? [t5[2]] : [], lineNumber: t5[3] ? +t5[3] : null, column: t5[4] ? +t5[4] : null };
      }
      var rf = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
      function nf(e8) {
        var t5 = rf.exec(e8);
        return t5 ? { file: t5[2], methodName: t5[1] || br, arguments: [], lineNumber: +t5[3], column: t5[4] ? +t5[4] : null } : null;
      }
      var of = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
      var sf = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
      function af(e8) {
        var t5 = of.exec(e8);
        if (!t5)
          return null;
        var r6 = t5[3] && t5[3].indexOf(" > eval") > -1, n3 = sf.exec(t5[3]);
        return r6 && n3 != null && (t5[3] = n3[1], t5[4] = n3[2], t5[5] = null), { file: t5[3], methodName: t5[1] || br, arguments: t5[2] ? t5[2].split(",") : [], lineNumber: t5[4] ? +t5[4] : null, column: t5[5] ? +t5[5] : null };
      }
      var uf = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
      function lf(e8) {
        var t5 = uf.exec(e8);
        return t5 ? { file: t5[3], methodName: t5[1] || br, arguments: [], lineNumber: +t5[4], column: t5[5] ? +t5[5] : null } : null;
      }
      var cf = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
      function pf(e8) {
        var t5 = cf.exec(e8);
        return t5 ? { file: t5[2], methodName: t5[1] || br, arguments: [], lineNumber: +t5[3], column: t5[4] ? +t5[4] : null } : null;
      }
      var Go = class {
        getLocation() {
          return null;
        }
      };
      var Jo = class {
        constructor() {
          this._error = new Error();
        }
        getLocation() {
          let t5 = this._error.stack;
          if (!t5)
            return null;
          let n3 = ba(t5).find((o) => {
            if (!o.file)
              return false;
            let i2 = Mo(o.file);
            return i2 !== "<anonymous>" && !i2.includes("@prisma") && !i2.includes("/packages/client/src/runtime/") && !i2.endsWith("/runtime/binary.js") && !i2.endsWith("/runtime/library.js") && !i2.endsWith("/runtime/edge.js") && !i2.endsWith("/runtime/edge-esm.js") && !i2.startsWith("internal/") && !o.methodName.includes("new ") && !o.methodName.includes("getCallSite") && !o.methodName.includes("Proxy.") && o.methodName.split(".").length < 4;
          });
          return !n3 || !n3.file ? null : { fileName: n3.file, lineNumber: n3.lineNumber, columnNumber: n3.column };
        }
      };
      function lt(e8) {
        return e8 === "minimal" ? new Go() : new Jo();
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var wa = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
      function Ht(e8 = {}) {
        let t5 = df(e8);
        return Object.entries(t5).reduce((n3, [o, i2]) => (wa[o] !== void 0 ? n3.select[o] = { select: i2 } : n3[o] = i2, n3), { select: {} });
      }
      function df(e8 = {}) {
        return typeof e8._count == "boolean" ? { ...e8, _count: { _all: e8._count } } : e8;
      }
      function Sn(e8 = {}) {
        return (t5) => (typeof e8._count == "boolean" && (t5._count = t5._count._all), t5);
      }
      function Ea(e8, t5) {
        let r6 = Sn(e8);
        return t5({ action: "aggregate", unpacker: r6, argsMapper: Ht })(e8);
      }
      d2();
      p2();
      f();
      function mf(e8 = {}) {
        let { select: t5, ...r6 } = e8;
        return typeof t5 == "object" ? Ht({ ...r6, _count: t5 }) : Ht({ ...r6, _count: { _all: true } });
      }
      function gf(e8 = {}) {
        return typeof e8.select == "object" ? (t5) => Sn(e8)(t5)._count : (t5) => Sn(e8)(t5)._count._all;
      }
      function Pa(e8, t5) {
        return t5({ action: "count", unpacker: gf(e8), argsMapper: mf })(e8);
      }
      d2();
      p2();
      f();
      function yf(e8 = {}) {
        let t5 = Ht(e8);
        if (Array.isArray(t5.by))
          for (let r6 of t5.by)
            typeof r6 == "string" && (t5.select[r6] = true);
        else
          typeof t5.by == "string" && (t5.select[t5.by] = true);
        return t5;
      }
      function hf(e8 = {}) {
        return (t5) => (typeof (e8 == null ? void 0 : e8._count) == "boolean" && t5.forEach((r6) => {
          r6._count = r6._count._all;
        }), t5);
      }
      function va(e8, t5) {
        return t5({ action: "groupBy", unpacker: hf(e8), argsMapper: yf })(e8);
      }
      function Aa(e8, t5, r6) {
        if (t5 === "aggregate")
          return (n3) => Ea(n3, r6);
        if (t5 === "count")
          return (n3) => Pa(n3, r6);
        if (t5 === "groupBy")
          return (n3) => va(n3, r6);
      }
      d2();
      p2();
      f();
      function Ta(e8, t5) {
        let r6 = t5.fields.filter((o) => !o.relationName), n3 = Fo(r6, (o) => o.name);
        return new Proxy({}, { get(o, i2) {
          if (i2 in o || typeof i2 == "symbol")
            return o[i2];
          let s3 = n3[i2];
          if (s3)
            return new xr(e8, i2, s3.type, s3.isList, s3.kind === "enum");
        }, ...mn(Object.keys(n3)) });
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Ca = (e8) => Array.isArray(e8) ? e8 : e8.split(".");
      var Qo = (e8, t5) => Ca(t5).reduce((r6, n3) => r6 && r6[n3], e8);
      var Ma = (e8, t5, r6) => Ca(t5).reduceRight((n3, o, i2, s3) => Object.assign({}, Qo(e8, s3.slice(0, i2)), { [o]: n3 }), r6);
      function xf(e8, t5) {
        return e8 === void 0 || t5 === void 0 ? [] : [...t5, "select", e8];
      }
      function bf(e8, t5, r6) {
        return t5 === void 0 ? e8 != null ? e8 : {} : Ma(t5, r6, e8 || true);
      }
      function Wo(e8, t5, r6, n3, o, i2) {
        let a4 = e8._runtimeDataModel.models[t5].fields.reduce((u2, l) => ({ ...u2, [l.name]: l }), {});
        return (u2) => {
          let l = lt(e8._errorFormat), c2 = xf(n3, o), m2 = bf(u2, i2, c2), g2 = r6({ dataPath: c2, callsite: l })(m2), w = wf(e8, t5);
          return new Proxy(g2, { get(E, b2) {
            if (!w.includes(b2))
              return E[b2];
            let S = [a4[b2].type, r6, b2], R = [c2, m2];
            return Wo(e8, ...S, ...R);
          }, ...mn([...w, ...Object.getOwnPropertyNames(g2)]) });
        };
      }
      function wf(e8, t5) {
        return e8._runtimeDataModel.models[t5].fields.filter((r6) => r6.kind === "object").map((r6) => r6.name);
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Ia = ve(Bs());
      d2();
      p2();
      f();
      Ao();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Sa = { keyword: rt, entity: rt, value: (e8) => tt(Nt(e8)), punctuation: Nt, directive: rt, function: rt, variable: (e8) => tt(Nt(e8)), string: (e8) => tt(on3(e8)), boolean: sn, number: rt, comment: an };
      var Ef = (e8) => e8;
      var Rn = {};
      var Pf = 0;
      var _ = { manual: Rn.Prism && Rn.Prism.manual, disableWorkerMessageHandler: Rn.Prism && Rn.Prism.disableWorkerMessageHandler, util: { encode: function(e8) {
        if (e8 instanceof Fe) {
          let t5 = e8;
          return new Fe(t5.type, _.util.encode(t5.content), t5.alias);
        } else
          return Array.isArray(e8) ? e8.map(_.util.encode) : e8.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
      }, type: function(e8) {
        return Object.prototype.toString.call(e8).slice(8, -1);
      }, objId: function(e8) {
        return e8.__id || Object.defineProperty(e8, "__id", { value: ++Pf }), e8.__id;
      }, clone: function e8(t5, r6) {
        let n3, o, i2 = _.util.type(t5);
        switch (r6 = r6 || {}, i2) {
          case "Object":
            if (o = _.util.objId(t5), r6[o])
              return r6[o];
            n3 = {}, r6[o] = n3;
            for (let s3 in t5)
              t5.hasOwnProperty(s3) && (n3[s3] = e8(t5[s3], r6));
            return n3;
          case "Array":
            return o = _.util.objId(t5), r6[o] ? r6[o] : (n3 = [], r6[o] = n3, t5.forEach(function(s3, a4) {
              n3[a4] = e8(s3, r6);
            }), n3);
          default:
            return t5;
        }
      } }, languages: { extend: function(e8, t5) {
        let r6 = _.util.clone(_.languages[e8]);
        for (let n3 in t5)
          r6[n3] = t5[n3];
        return r6;
      }, insertBefore: function(e8, t5, r6, n3) {
        n3 = n3 || _.languages;
        let o = n3[e8], i2 = {};
        for (let a4 in o)
          if (o.hasOwnProperty(a4)) {
            if (a4 == t5)
              for (let u2 in r6)
                r6.hasOwnProperty(u2) && (i2[u2] = r6[u2]);
            r6.hasOwnProperty(a4) || (i2[a4] = o[a4]);
          }
        let s3 = n3[e8];
        return n3[e8] = i2, _.languages.DFS(_.languages, function(a4, u2) {
          u2 === s3 && a4 != e8 && (this[a4] = i2);
        }), i2;
      }, DFS: function e8(t5, r6, n3, o) {
        o = o || {};
        let i2 = _.util.objId;
        for (let s3 in t5)
          if (t5.hasOwnProperty(s3)) {
            r6.call(t5, s3, t5[s3], n3 || s3);
            let a4 = t5[s3], u2 = _.util.type(a4);
            u2 === "Object" && !o[i2(a4)] ? (o[i2(a4)] = true, e8(a4, r6, null, o)) : u2 === "Array" && !o[i2(a4)] && (o[i2(a4)] = true, e8(a4, r6, s3, o));
          }
      } }, plugins: {}, highlight: function(e8, t5, r6) {
        let n3 = { code: e8, grammar: t5, language: r6 };
        return _.hooks.run("before-tokenize", n3), n3.tokens = _.tokenize(n3.code, n3.grammar), _.hooks.run("after-tokenize", n3), Fe.stringify(_.util.encode(n3.tokens), n3.language);
      }, matchGrammar: function(e8, t5, r6, n3, o, i2, s3) {
        for (let b2 in r6) {
          if (!r6.hasOwnProperty(b2) || !r6[b2])
            continue;
          if (b2 == s3)
            return;
          let T = r6[b2];
          T = _.util.type(T) === "Array" ? T : [T];
          for (let S = 0; S < T.length; ++S) {
            let R = T[S], C = R.inside, M = !!R.lookbehind, N = !!R.greedy, L = 0, Te = R.alias;
            if (N && !R.pattern.global) {
              let V = R.pattern.toString().match(/[imuy]*$/)[0];
              R.pattern = RegExp(R.pattern.source, V + "g");
            }
            R = R.pattern || R;
            for (let V = n3, H = o; V < t5.length; H += t5[V].length, ++V) {
              let Ee = t5[V];
              if (t5.length > e8.length)
                return;
              if (Ee instanceof Fe)
                continue;
              if (N && V != t5.length - 1) {
                R.lastIndex = H;
                var m2 = R.exec(e8);
                if (!m2)
                  break;
                var c2 = m2.index + (M ? m2[1].length : 0), g2 = m2.index + m2[0].length, a4 = V, u2 = H;
                for (let O = t5.length; a4 < O && (u2 < g2 || !t5[a4].type && !t5[a4 - 1].greedy); ++a4)
                  u2 += t5[a4].length, c2 >= u2 && (++V, H = u2);
                if (t5[V] instanceof Fe)
                  continue;
                l = a4 - V, Ee = e8.slice(H, u2), m2.index -= H;
              } else {
                R.lastIndex = 0;
                var m2 = R.exec(Ee), l = 1;
              }
              if (!m2) {
                if (i2)
                  break;
                continue;
              }
              M && (L = m2[1] ? m2[1].length : 0);
              var c2 = m2.index + L, m2 = m2[0].slice(L), g2 = c2 + m2.length, w = Ee.slice(0, c2), E = Ee.slice(g2);
              let z2 = [V, l];
              w && (++V, H += w.length, z2.push(w));
              let Pe = new Fe(b2, C ? _.tokenize(m2, C) : m2, Te, m2, N);
              if (z2.push(Pe), E && z2.push(E), Array.prototype.splice.apply(t5, z2), l != 1 && _.matchGrammar(e8, t5, r6, V, H, true, b2), i2)
                break;
            }
          }
        }
      }, tokenize: function(e8, t5) {
        let r6 = [e8], n3 = t5.rest;
        if (n3) {
          for (let o in n3)
            t5[o] = n3[o];
          delete t5.rest;
        }
        return _.matchGrammar(e8, r6, t5, 0, 0, false), r6;
      }, hooks: { all: {}, add: function(e8, t5) {
        let r6 = _.hooks.all;
        r6[e8] = r6[e8] || [], r6[e8].push(t5);
      }, run: function(e8, t5) {
        let r6 = _.hooks.all[e8];
        if (!(!r6 || !r6.length))
          for (var n3 = 0, o; o = r6[n3++]; )
            o(t5);
      } }, Token: Fe };
      _.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
      _.languages.javascript = _.languages.extend("clike", { "class-name": [_.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
      _.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
      _.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: _.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: _.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: _.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: _.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
      _.languages.markup && _.languages.markup.tag.addInlined("script", "javascript");
      _.languages.js = _.languages.javascript;
      _.languages.typescript = _.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
      _.languages.ts = _.languages.typescript;
      function Fe(e8, t5, r6, n3, o) {
        this.type = e8, this.content = t5, this.alias = r6, this.length = (n3 || "").length | 0, this.greedy = !!o;
      }
      Fe.stringify = function(e8, t5) {
        return typeof e8 == "string" ? e8 : Array.isArray(e8) ? e8.map(function(r6) {
          return Fe.stringify(r6, t5);
        }).join("") : vf(e8.type)(e8.content);
      };
      function vf(e8) {
        return Sa[e8] || Ef;
      }
      function Ra(e8) {
        return Af(e8, _.languages.javascript);
      }
      function Af(e8, t5) {
        return _.tokenize(e8, t5).map((n3) => Fe.stringify(n3)).join("");
      }
      d2();
      p2();
      f();
      var Oa = ve(Ds());
      function Fa(e8) {
        return (0, Oa.default)(e8);
      }
      var On = class e8 {
        static read(t5) {
          let r6;
          try {
            r6 = un.readFileSync(t5, "utf-8");
          } catch (n3) {
            return null;
          }
          return e8.fromContent(r6);
        }
        static fromContent(t5) {
          let r6 = t5.split(/\r?\n/);
          return new e8(1, r6);
        }
        constructor(t5, r6) {
          this.firstLineNumber = t5, this.lines = r6;
        }
        get lastLineNumber() {
          return this.firstLineNumber + this.lines.length - 1;
        }
        mapLineAt(t5, r6) {
          if (t5 < this.firstLineNumber || t5 > this.lines.length + this.firstLineNumber)
            return this;
          let n3 = t5 - this.firstLineNumber, o = [...this.lines];
          return o[n3] = r6(o[n3]), new e8(this.firstLineNumber, o);
        }
        mapLines(t5) {
          return new e8(this.firstLineNumber, this.lines.map((r6, n3) => t5(r6, this.firstLineNumber + n3)));
        }
        lineAt(t5) {
          return this.lines[t5 - this.firstLineNumber];
        }
        prependSymbolAt(t5, r6) {
          return this.mapLines((n3, o) => o === t5 ? `${r6} ${n3}` : `  ${n3}`);
        }
        slice(t5, r6) {
          let n3 = this.lines.slice(t5 - 1, r6).join(`
`);
          return new e8(t5, Fa(n3).split(`
`));
        }
        highlight() {
          let t5 = Ra(this.toString());
          return new e8(this.firstLineNumber, t5.split(`
`));
        }
        toString() {
          return this.lines.join(`
`);
        }
      };
      var Tf = { red: _t, gray: an, dim: nn, bold: tt, underline: Ms, highlightSource: (e8) => e8.highlight() };
      var Cf = { red: (e8) => e8, gray: (e8) => e8, dim: (e8) => e8, bold: (e8) => e8, underline: (e8) => e8, highlightSource: (e8) => e8 };
      function Mf({ callsite: e8, message: t5, originalMethod: r6, isPanic: n3, callArguments: o }, i2) {
        var m2;
        let s3 = { functionName: `prisma.${r6}()`, message: t5, isPanic: n3 != null ? n3 : false, callArguments: o };
        if (!e8 || typeof window != "undefined" || y2.env.NODE_ENV === "production")
          return s3;
        let a4 = e8.getLocation();
        if (!a4 || !a4.lineNumber || !a4.columnNumber)
          return s3;
        let u2 = Math.max(1, a4.lineNumber - 3), l = (m2 = On.read(a4.fileName)) == null ? void 0 : m2.slice(u2, a4.lineNumber), c2 = l == null ? void 0 : l.lineAt(a4.lineNumber);
        if (l && c2) {
          let g2 = Rf(c2), w = Sf(c2);
          if (!w)
            return s3;
          s3.functionName = `${w.code})`, s3.location = a4, n3 || (l = l.mapLineAt(a4.lineNumber, (b2) => b2.slice(0, w.openingBraceIndex))), l = i2.highlightSource(l);
          let E = String(l.lastLineNumber).length;
          if (s3.contextLines = l.mapLines((b2, T) => i2.gray(String(T).padStart(E)) + " " + b2).mapLines((b2) => i2.dim(b2)).prependSymbolAt(a4.lineNumber, i2.bold(i2.red("\u2192"))), o) {
            let b2 = g2 + E + 1;
            b2 += 2, s3.callArguments = (0, Ia.default)(o, b2).slice(b2);
          }
        }
        return s3;
      }
      function Sf(e8) {
        let t5 = Object.keys(Ce.ModelAction).join("|"), n3 = new RegExp(String.raw`\.(${t5})\(`).exec(e8);
        if (n3) {
          let o = n3.index + n3[0].length, i2 = e8.lastIndexOf(" ", n3.index) + 1;
          return { code: e8.slice(i2, o), openingBraceIndex: o };
        }
        return null;
      }
      function Rf(e8) {
        let t5 = 0;
        for (let r6 = 0; r6 < e8.length; r6++) {
          if (e8.charAt(r6) !== " ")
            return t5;
          t5++;
        }
        return t5;
      }
      function Of({ functionName: e8, location: t5, message: r6, isPanic: n3, contextLines: o, callArguments: i2 }, s3) {
        let a4 = [""], u2 = t5 ? " in" : ":";
        if (n3 ? (a4.push(s3.red(`Oops, an unknown error occurred! This is ${s3.bold("on us")}, you did nothing wrong.`)), a4.push(s3.red(`It occurred in the ${s3.bold(`\`${e8}\``)} invocation${u2}`))) : a4.push(s3.red(`Invalid ${s3.bold(`\`${e8}\``)} invocation${u2}`)), t5 && a4.push(s3.underline(Ff(t5))), o) {
          a4.push("");
          let l = [o.toString()];
          i2 && (l.push(i2), l.push(s3.dim(")"))), a4.push(l.join("")), i2 && a4.push("");
        } else
          a4.push(""), i2 && a4.push(i2), a4.push("");
        return a4.push(r6), a4.join(`
`);
      }
      function Ff(e8) {
        let t5 = [e8.fileName];
        return e8.lineNumber && t5.push(String(e8.lineNumber)), e8.columnNumber && t5.push(String(e8.columnNumber)), t5.join(":");
      }
      function zt(e8) {
        let t5 = e8.showColors ? Tf : Cf, r6 = Mf(e8, t5);
        return Of(r6, t5);
      }
      function ka(e8, t5, r6, n3) {
        return e8 === Ce.ModelAction.findFirstOrThrow || e8 === Ce.ModelAction.findUniqueOrThrow ? If(t5, r6, n3) : n3;
      }
      function If(e8, t5, r6) {
        return async (n3) => {
          if ("rejectOnNotFound" in n3.args) {
            let i2 = zt({ originalMethod: n3.clientMethod, callsite: n3.callsite, message: "'rejectOnNotFound' option is not supported" });
            throw new pe(i2, { clientVersion: t5 });
          }
          return await r6(n3).catch((i2) => {
            throw i2 instanceof ce && i2.code === "P2025" ? new Ke(`No ${e8} found`, t5) : i2;
          });
        };
      }
      d2();
      p2();
      f();
      function $e(e8) {
        return e8.replace(/^./, (t5) => t5.toLowerCase());
      }
      var kf = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
      var Df = ["aggregate", "count", "groupBy"];
      function Ho(e8, t5) {
        var o;
        let r6 = (o = e8._extensions.getAllModelExtensions(t5)) != null ? o : {}, n3 = [_f(e8, t5), Lf(e8, t5), gr(r6), ge("name", () => t5), ge("$name", () => t5), ge("$parent", () => e8._appliedParent)];
        return Le({}, n3);
      }
      function _f(e8, t5) {
        let r6 = $e(t5), n3 = Object.keys(Ce.ModelAction).concat("count");
        return { getKeys() {
          return n3;
        }, getPropertyValue(o) {
          let i2 = o, s3 = (u2) => e8._request(u2);
          s3 = ka(i2, t5, e8._clientVersion, s3);
          let a4 = (u2) => (l) => {
            let c2 = lt(e8._errorFormat);
            return e8._createPrismaPromise((m2) => {
              let g2 = { args: l, dataPath: [], action: i2, model: t5, clientMethod: `${r6}.${o}`, jsModelName: r6, transaction: m2, callsite: c2 };
              return s3({ ...g2, ...u2 });
            });
          };
          return kf.includes(i2) ? Wo(e8, t5, a4) : Nf(o) ? Aa(e8, o, a4) : a4({});
        } };
      }
      function Nf(e8) {
        return Df.includes(e8);
      }
      function Lf(e8, t5) {
        return bt(ge("fields", () => {
          let r6 = e8._runtimeDataModel.models[t5];
          return Ta(t5, r6);
        }));
      }
      d2();
      p2();
      f();
      function Da(e8) {
        return e8.replace(/^./, (t5) => t5.toUpperCase());
      }
      var zo = Symbol();
      function wr(e8) {
        let t5 = [Bf(e8), ge(zo, () => e8), ge("$parent", () => e8._appliedParent)], r6 = e8._extensions.getAllClientExtensions();
        return r6 && t5.push(gr(r6)), Le(e8, t5);
      }
      function Bf(e8) {
        let t5 = Object.keys(e8._runtimeDataModel.models), r6 = t5.map($e), n3 = [...new Set(t5.concat(r6))];
        return bt({ getKeys() {
          return n3;
        }, getPropertyValue(o) {
          let i2 = Da(o);
          if (e8._runtimeDataModel.models[i2] !== void 0)
            return Ho(e8, i2);
          if (e8._runtimeDataModel.models[o] !== void 0)
            return Ho(e8, o);
        }, getPropertyDescriptor(o) {
          if (!r6.includes(o))
            return { enumerable: false };
        } });
      }
      function Fn(e8) {
        return e8[zo] ? e8[zo] : e8;
      }
      function _a(e8) {
        if (typeof e8 == "function")
          return e8(this);
        let t5 = Fn(this), r6 = Object.create(t5, { _extensions: { value: this._extensions.append(e8) }, _appliedParent: { value: this, configurable: true }, $use: { value: void 0 }, $on: { value: void 0 } });
        return wr(r6);
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function Na({ result: e8, modelName: t5, select: r6, extensions: n3 }) {
        let o = n3.getAllComputedFields(t5);
        if (!o)
          return e8;
        let i2 = [], s3 = [];
        for (let a4 of Object.values(o)) {
          if (r6) {
            if (!r6[a4.name])
              continue;
            let u2 = a4.needs.filter((l) => !r6[l]);
            u2.length > 0 && s3.push(yr(u2));
          }
          jf(e8, a4.needs) && i2.push(Uf(a4, Le(e8, i2)));
        }
        return i2.length > 0 || s3.length > 0 ? Le(e8, [...i2, ...s3]) : e8;
      }
      function jf(e8, t5) {
        return t5.every((r6) => Oo(e8, r6));
      }
      function Uf(e8, t5) {
        return bt(ge(e8.name, () => e8.compute(t5)));
      }
      d2();
      p2();
      f();
      function In({ visitor: e8, result: t5, args: r6, runtimeDataModel: n3, modelName: o }) {
        var s3;
        if (Array.isArray(t5)) {
          for (let a4 = 0; a4 < t5.length; a4++)
            t5[a4] = In({ result: t5[a4], args: r6, modelName: o, runtimeDataModel: n3, visitor: e8 });
          return t5;
        }
        let i2 = (s3 = e8(t5, o, r6)) != null ? s3 : t5;
        return r6.include && La({ includeOrSelect: r6.include, result: i2, parentModelName: o, runtimeDataModel: n3, visitor: e8 }), r6.select && La({ includeOrSelect: r6.select, result: i2, parentModelName: o, runtimeDataModel: n3, visitor: e8 }), i2;
      }
      function La({ includeOrSelect: e8, result: t5, parentModelName: r6, runtimeDataModel: n3, visitor: o }) {
        for (let [i2, s3] of Object.entries(e8)) {
          if (!s3 || t5[i2] == null)
            continue;
          let u2 = n3.models[r6].fields.find((c2) => c2.name === i2);
          if (!u2 || u2.kind !== "object" || !u2.relationName)
            continue;
          let l = typeof s3 == "object" ? s3 : {};
          t5[i2] = In({ visitor: o, result: t5[i2], args: l, modelName: u2.type, runtimeDataModel: n3 });
        }
      }
      function Ba({ result: e8, modelName: t5, args: r6, extensions: n3, runtimeDataModel: o }) {
        return n3.isEmpty() || e8 == null || typeof e8 != "object" || !o.models[t5] ? e8 : In({ result: e8, args: r6 != null ? r6 : {}, modelName: t5, runtimeDataModel: o, visitor: (s3, a4, u2) => Na({ result: s3, modelName: $e(a4), select: u2.select, extensions: n3 }) });
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function ja(e8) {
        if (e8 instanceof xe)
          return $f(e8);
        if (Array.isArray(e8)) {
          let r6 = [e8[0]];
          for (let n3 = 1; n3 < e8.length; n3++)
            r6[n3] = Er(e8[n3]);
          return r6;
        }
        let t5 = {};
        for (let r6 in e8)
          t5[r6] = Er(e8[r6]);
        return t5;
      }
      function $f(e8) {
        return new xe(e8.strings, e8.values);
      }
      function Er(e8) {
        if (typeof e8 != "object" || e8 == null || e8 instanceof _e || Jt(e8))
          return e8;
        if (Gt(e8))
          return new je(e8.toFixed());
        if (qt(e8))
          return /* @__PURE__ */ new Date(+e8);
        if (ArrayBuffer.isView(e8))
          return e8.slice(0);
        if (Array.isArray(e8)) {
          let t5 = e8.length, r6;
          for (r6 = Array(t5); t5--; )
            r6[t5] = Er(e8[t5]);
          return r6;
        }
        if (typeof e8 == "object") {
          let t5 = {};
          for (let r6 in e8)
            r6 === "__proto__" ? Object.defineProperty(t5, r6, { value: Er(e8[r6]), configurable: true, enumerable: true, writable: true }) : t5[r6] = Er(e8[r6]);
          return t5;
        }
        xt(e8, "Unknown value");
      }
      function $a(e8, t5, r6, n3 = 0) {
        return e8._createPrismaPromise((o) => {
          var s3, a4;
          let i2 = t5.customDataProxyFetch;
          return "transaction" in t5 && o !== void 0 && (((s3 = t5.transaction) == null ? void 0 : s3.kind) === "batch" && t5.transaction.lock.then(), t5.transaction = o), n3 === r6.length ? e8._executeRequest(t5) : r6[n3]({ model: t5.model, operation: t5.model ? t5.action : t5.clientMethod, args: ja((a4 = t5.args) != null ? a4 : {}), __internalParams: t5, query: (u2, l = t5) => {
            let c2 = l.customDataProxyFetch;
            return l.customDataProxyFetch = Ga(i2, c2), l.args = u2, $a(e8, l, r6, n3 + 1);
          } });
        });
      }
      function qa(e8, t5) {
        let { jsModelName: r6, action: n3, clientMethod: o } = t5, i2 = r6 ? n3 : o;
        if (e8._extensions.isEmpty())
          return e8._executeRequest(t5);
        let s3 = e8._extensions.getAllQueryCallbacks(r6 != null ? r6 : "$none", i2);
        return $a(e8, t5, s3);
      }
      function Va(e8) {
        return (t5) => {
          let r6 = { requests: t5 }, n3 = t5[0].extensions.getAllBatchQueryCallbacks();
          return n3.length ? Ka(r6, n3, 0, e8) : e8(r6);
        };
      }
      function Ka(e8, t5, r6, n3) {
        if (r6 === t5.length)
          return n3(e8);
        let o = e8.customDataProxyFetch, i2 = e8.requests[0].transaction;
        return t5[r6]({ args: { queries: e8.requests.map((s3) => ({ model: s3.modelName, operation: s3.action, args: s3.args })), transaction: i2 ? { isolationLevel: i2.kind === "batch" ? i2.isolationLevel : void 0 } : void 0 }, __internalParams: e8, query(s3, a4 = e8) {
          let u2 = a4.customDataProxyFetch;
          return a4.customDataProxyFetch = Ga(o, u2), Ka(a4, t5, r6 + 1, n3);
        } });
      }
      var Ua = (e8) => e8;
      function Ga(e8 = Ua, t5 = Ua) {
        return (r6) => e8(t5(r6));
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function Qa(e8, t5, r6) {
        let n3 = $e(r6);
        return !t5.result || !(t5.result.$allModels || t5.result[n3]) ? e8 : qf({ ...e8, ...Ja(t5.name, e8, t5.result.$allModels), ...Ja(t5.name, e8, t5.result[n3]) });
      }
      function qf(e8) {
        let t5 = new Ne(), r6 = (n3, o) => t5.getOrCreate(n3, () => o.has(n3) ? [n3] : (o.add(n3), e8[n3] ? e8[n3].needs.flatMap((i2) => r6(i2, o)) : [n3]));
        return jt(e8, (n3) => ({ ...n3, needs: r6(n3.name, /* @__PURE__ */ new Set()) }));
      }
      function Ja(e8, t5, r6) {
        return r6 ? jt(r6, ({ needs: n3, compute: o }, i2) => ({ name: i2, needs: n3 ? Object.keys(n3).filter((s3) => n3[s3]) : [], compute: Vf(t5, i2, o) })) : {};
      }
      function Vf(e8, t5, r6) {
        var o;
        let n3 = (o = e8 == null ? void 0 : e8[t5]) == null ? void 0 : o.compute;
        return n3 ? (i2) => r6({ ...i2, [t5]: n3(i2) }) : r6;
      }
      function Wa(e8, t5) {
        if (!t5)
          return e8;
        let r6 = { ...e8 };
        for (let n3 of Object.values(t5))
          if (e8[n3.name])
            for (let o of n3.needs)
              r6[o] = true;
        return r6;
      }
      var kn = class {
        constructor(t5, r6) {
          this.extension = t5;
          this.previous = r6;
          this.computedFieldsCache = new Ne();
          this.modelExtensionsCache = new Ne();
          this.queryCallbacksCache = new Ne();
          this.clientExtensions = cr(() => {
            var t6, r7;
            return this.extension.client ? { ...(r7 = this.previous) == null ? void 0 : r7.getAllClientExtensions(), ...this.extension.client } : (t6 = this.previous) == null ? void 0 : t6.getAllClientExtensions();
          });
          this.batchCallbacks = cr(() => {
            var n3, o, i2;
            let t6 = (o = (n3 = this.previous) == null ? void 0 : n3.getAllBatchQueryCallbacks()) != null ? o : [], r7 = (i2 = this.extension.query) == null ? void 0 : i2.$__internalBatch;
            return r7 ? t6.concat(r7) : t6;
          });
        }
        getAllComputedFields(t5) {
          return this.computedFieldsCache.getOrCreate(t5, () => {
            var r6;
            return Qa((r6 = this.previous) == null ? void 0 : r6.getAllComputedFields(t5), this.extension, t5);
          });
        }
        getAllClientExtensions() {
          return this.clientExtensions.get();
        }
        getAllModelExtensions(t5) {
          return this.modelExtensionsCache.getOrCreate(t5, () => {
            var n3, o;
            let r6 = $e(t5);
            return !this.extension.model || !(this.extension.model[r6] || this.extension.model.$allModels) ? (n3 = this.previous) == null ? void 0 : n3.getAllModelExtensions(t5) : { ...(o = this.previous) == null ? void 0 : o.getAllModelExtensions(t5), ...this.extension.model.$allModels, ...this.extension.model[r6] };
          });
        }
        getAllQueryCallbacks(t5, r6) {
          return this.queryCallbacksCache.getOrCreate(`${t5}:${r6}`, () => {
            var s3, a4;
            let n3 = (a4 = (s3 = this.previous) == null ? void 0 : s3.getAllQueryCallbacks(t5, r6)) != null ? a4 : [], o = [], i2 = this.extension.query;
            return !i2 || !(i2[t5] || i2.$allModels || i2[r6] || i2.$allOperations) ? n3 : (i2[t5] !== void 0 && (i2[t5][r6] !== void 0 && o.push(i2[t5][r6]), i2[t5].$allOperations !== void 0 && o.push(i2[t5].$allOperations)), t5 !== "$none" && i2.$allModels !== void 0 && (i2.$allModels[r6] !== void 0 && o.push(i2.$allModels[r6]), i2.$allModels.$allOperations !== void 0 && o.push(i2.$allModels.$allOperations)), i2[r6] !== void 0 && o.push(i2[r6]), i2.$allOperations !== void 0 && o.push(i2.$allOperations), n3.concat(o));
          });
        }
        getAllBatchQueryCallbacks() {
          return this.batchCallbacks.get();
        }
      };
      var Dn = class e8 {
        constructor(t5) {
          this.head = t5;
        }
        static empty() {
          return new e8();
        }
        static single(t5) {
          return new e8(new kn(t5));
        }
        isEmpty() {
          return this.head === void 0;
        }
        append(t5) {
          return new e8(new kn(t5, this.head));
        }
        getAllComputedFields(t5) {
          var r6;
          return (r6 = this.head) == null ? void 0 : r6.getAllComputedFields(t5);
        }
        getAllClientExtensions() {
          var t5;
          return (t5 = this.head) == null ? void 0 : t5.getAllClientExtensions();
        }
        getAllModelExtensions(t5) {
          var r6;
          return (r6 = this.head) == null ? void 0 : r6.getAllModelExtensions(t5);
        }
        getAllQueryCallbacks(t5, r6) {
          var n3, o;
          return (o = (n3 = this.head) == null ? void 0 : n3.getAllQueryCallbacks(t5, r6)) != null ? o : [];
        }
        getAllBatchQueryCallbacks() {
          var t5, r6;
          return (r6 = (t5 = this.head) == null ? void 0 : t5.getAllBatchQueryCallbacks()) != null ? r6 : [];
        }
      };
      d2();
      p2();
      f();
      var Ha = he("prisma:client");
      var za = { Vercel: "vercel", "Netlify CI": "netlify" };
      function Za({ postinstall: e8, ciName: t5, clientVersion: r6 }) {
        if (Ha("checkPlatformCaching:postinstall", e8), Ha("checkPlatformCaching:ciName", t5), e8 === true && t5 && t5 in za) {
          let n3 = `Prisma has detected that this project was built on ${t5}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${za[t5]}-build`;
          throw console.error(n3), new re(n3, r6);
        }
      }
      d2();
      p2();
      f();
      function Ya(e8, t5) {
        return e8 ? e8.datasources ? e8.datasources : e8.datasourceUrl ? { [t5[0]]: { url: e8.datasourceUrl } } : {} : {};
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function Zo({ error: e8, user_facing_error: t5 }, r6) {
        return t5.error_code ? new ce(t5.message, { code: t5.error_code, clientVersion: r6, meta: t5.meta, batchRequestIdx: t5.batch_request_idx }) : new Se(e8, { clientVersion: r6, batchRequestIdx: t5.batch_request_idx });
      }
      d2();
      p2();
      f();
      var _n = class {
      };
      d2();
      p2();
      f();
      function Xa(e8, t5) {
        return { batch: e8, transaction: (t5 == null ? void 0 : t5.kind) === "batch" ? { isolationLevel: t5.options.isolationLevel } : void 0 };
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Kf = "Cloudflare-Workers";
      var Gf = "node";
      function eu() {
        var e8, t5, r6;
        return typeof Netlify == "object" ? "netlify" : typeof EdgeRuntime == "string" ? "edge-light" : ((e8 = globalThis.navigator) == null ? void 0 : e8.userAgent) === Kf ? "workerd" : globalThis.Deno ? "deno" : globalThis.__lagon__ ? "lagon" : ((r6 = (t5 = globalThis.process) == null ? void 0 : t5.release) == null ? void 0 : r6.name) === Gf ? "node" : globalThis.Bun ? "bun" : globalThis.fastly ? "fastly" : "unknown";
      }
      function Nn({ inlineDatasources: e8, overrideDatasources: t5, env: r6, clientVersion: n3 }) {
        var u2, l;
        let o, i2 = Object.keys(e8)[0], s3 = (u2 = e8[i2]) == null ? void 0 : u2.url, a4 = (l = t5[i2]) == null ? void 0 : l.url;
        if (i2 === void 0 ? o = void 0 : a4 ? o = a4 : s3 != null && s3.value ? o = s3.value : s3 != null && s3.fromEnvVar && (o = r6[s3.fromEnvVar]), (s3 == null ? void 0 : s3.fromEnvVar) !== void 0 && o === void 0)
          throw eu() === "workerd" ? new re(`error: Environment variable not found: ${s3.fromEnvVar}.

In Cloudflare module Workers, environment variables are available only in the Worker's \`env\` parameter of \`fetch\`.
To solve this, provide the connection string directly: https://pris.ly/d/cloudflare-datasource-url`, n3) : new re(`error: Environment variable not found: ${s3.fromEnvVar}.`, n3);
        if (o === void 0)
          throw new re("error: Missing URL environment variable, value, or override.", n3);
        return o;
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Ln = class extends Error {
        constructor(r6, n3) {
          super(r6);
          this.clientVersion = n3.clientVersion, this.cause = n3.cause;
        }
        get [Symbol.toStringTag]() {
          return this.name;
        }
      };
      var we = class extends Ln {
        constructor(r6, n3) {
          var o;
          super(r6, n3);
          this.isRetryable = (o = n3.isRetryable) != null ? o : true;
        }
      };
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      function q(e8, t5) {
        return { ...e8, isRetryable: t5 };
      }
      var Zt = class extends we {
        constructor(r6) {
          super("This request must be retried", q(r6, true));
          this.name = "ForcedRetryError";
          this.code = "P5001";
        }
      };
      k2(Zt, "ForcedRetryError");
      d2();
      p2();
      f();
      var Et = class extends we {
        constructor(r6, n3) {
          super(r6, q(n3, false));
          this.name = "InvalidDatasourceError";
          this.code = "P5002";
        }
      };
      k2(Et, "InvalidDatasourceError");
      d2();
      p2();
      f();
      var Pt = class extends we {
        constructor(r6, n3) {
          super(r6, q(n3, false));
          this.name = "NotImplementedYetError";
          this.code = "P5004";
        }
      };
      k2(Pt, "NotImplementedYetError");
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var J = class extends we {
        constructor(r6, n3) {
          super(r6, n3);
          this.response = n3.response;
          let o = this.response.headers.get("prisma-request-id");
          if (o) {
            let i2 = `(The request id was: ${o})`;
            this.message = this.message + " " + i2;
          }
        }
      };
      var vt = class extends J {
        constructor(r6) {
          super("Schema needs to be uploaded", q(r6, true));
          this.name = "SchemaMissingError";
          this.code = "P5005";
        }
      };
      k2(vt, "SchemaMissingError");
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Yo = "This request could not be understood by the server";
      var Pr = class extends J {
        constructor(r6, n3, o) {
          super(n3 || Yo, q(r6, false));
          this.name = "BadRequestError";
          this.code = "P5000";
          o && (this.code = o);
        }
      };
      k2(Pr, "BadRequestError");
      d2();
      p2();
      f();
      var vr = class extends J {
        constructor(r6, n3) {
          super("Engine not started: healthcheck timeout", q(r6, true));
          this.name = "HealthcheckTimeoutError";
          this.code = "P5013";
          this.logs = n3;
        }
      };
      k2(vr, "HealthcheckTimeoutError");
      d2();
      p2();
      f();
      var Ar = class extends J {
        constructor(r6, n3, o) {
          super(n3, q(r6, true));
          this.name = "EngineStartupError";
          this.code = "P5014";
          this.logs = o;
        }
      };
      k2(Ar, "EngineStartupError");
      d2();
      p2();
      f();
      var Tr = class extends J {
        constructor(r6) {
          super("Engine version is not supported", q(r6, false));
          this.name = "EngineVersionNotSupportedError";
          this.code = "P5012";
        }
      };
      k2(Tr, "EngineVersionNotSupportedError");
      d2();
      p2();
      f();
      var Xo = "Request timed out";
      var Cr = class extends J {
        constructor(r6, n3 = Xo) {
          super(n3, q(r6, false));
          this.name = "GatewayTimeoutError";
          this.code = "P5009";
        }
      };
      k2(Cr, "GatewayTimeoutError");
      d2();
      p2();
      f();
      var Jf = "Interactive transaction error";
      var Mr = class extends J {
        constructor(r6, n3 = Jf) {
          super(n3, q(r6, false));
          this.name = "InteractiveTransactionError";
          this.code = "P5015";
        }
      };
      k2(Mr, "InteractiveTransactionError");
      d2();
      p2();
      f();
      var Qf = "Request parameters are invalid";
      var Sr = class extends J {
        constructor(r6, n3 = Qf) {
          super(n3, q(r6, false));
          this.name = "InvalidRequestError";
          this.code = "P5011";
        }
      };
      k2(Sr, "InvalidRequestError");
      d2();
      p2();
      f();
      var ei = "Requested resource does not exist";
      var Rr = class extends J {
        constructor(r6, n3 = ei) {
          super(n3, q(r6, false));
          this.name = "NotFoundError";
          this.code = "P5003";
        }
      };
      k2(Rr, "NotFoundError");
      d2();
      p2();
      f();
      var ti = "Unknown server error";
      var Yt = class extends J {
        constructor(r6, n3, o) {
          super(n3 || ti, q(r6, true));
          this.name = "ServerError";
          this.code = "P5006";
          this.logs = o;
        }
      };
      k2(Yt, "ServerError");
      d2();
      p2();
      f();
      var ri = "Unauthorized, check your connection string";
      var Or = class extends J {
        constructor(r6, n3 = ri) {
          super(n3, q(r6, false));
          this.name = "UnauthorizedError";
          this.code = "P5007";
        }
      };
      k2(Or, "UnauthorizedError");
      d2();
      p2();
      f();
      var ni = "Usage exceeded, retry again later";
      var Fr = class extends J {
        constructor(r6, n3 = ni) {
          super(n3, q(r6, true));
          this.name = "UsageExceededError";
          this.code = "P5008";
        }
      };
      k2(Fr, "UsageExceededError");
      async function Wf(e8) {
        let t5;
        try {
          t5 = await e8.text();
        } catch (r6) {
          return { type: "EmptyError" };
        }
        try {
          let r6 = JSON.parse(t5);
          if (typeof r6 == "string")
            switch (r6) {
              case "InternalDataProxyError":
                return { type: "DataProxyError", body: r6 };
              default:
                return { type: "UnknownTextError", body: r6 };
            }
          if (typeof r6 == "object" && r6 !== null) {
            if ("is_panic" in r6 && "message" in r6 && "error_code" in r6)
              return { type: "QueryEngineError", body: r6 };
            if ("EngineNotStarted" in r6 || "InteractiveTransactionMisrouted" in r6 || "InvalidRequestError" in r6) {
              let n3 = Object.values(r6)[0].reason;
              return typeof n3 == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n3) ? { type: "UnknownJsonError", body: r6 } : { type: "DataProxyError", body: r6 };
            }
          }
          return { type: "UnknownJsonError", body: r6 };
        } catch (r6) {
          return t5 === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t5 };
        }
      }
      async function Ir(e8, t5) {
        if (e8.ok)
          return;
        let r6 = { clientVersion: t5, response: e8 }, n3 = await Wf(e8);
        if (n3.type === "QueryEngineError")
          throw new ce(n3.body.message, { code: n3.body.error_code, clientVersion: t5 });
        if (n3.type === "DataProxyError") {
          if (n3.body === "InternalDataProxyError")
            throw new Yt(r6, "Internal Data Proxy error");
          if ("EngineNotStarted" in n3.body) {
            if (n3.body.EngineNotStarted.reason === "SchemaMissing")
              return new vt(r6);
            if (n3.body.EngineNotStarted.reason === "EngineVersionNotSupported")
              throw new Tr(r6);
            if ("EngineStartupError" in n3.body.EngineNotStarted.reason) {
              let { msg: o, logs: i2 } = n3.body.EngineNotStarted.reason.EngineStartupError;
              throw new Ar(r6, o, i2);
            }
            if ("KnownEngineStartupError" in n3.body.EngineNotStarted.reason) {
              let { msg: o, error_code: i2 } = n3.body.EngineNotStarted.reason.KnownEngineStartupError;
              throw new re(o, t5, i2);
            }
            if ("HealthcheckTimeout" in n3.body.EngineNotStarted.reason) {
              let { logs: o } = n3.body.EngineNotStarted.reason.HealthcheckTimeout;
              throw new vr(r6, o);
            }
          }
          if ("InteractiveTransactionMisrouted" in n3.body) {
            let o = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
            throw new Mr(r6, o[n3.body.InteractiveTransactionMisrouted.reason]);
          }
          if ("InvalidRequestError" in n3.body)
            throw new Sr(r6, n3.body.InvalidRequestError.reason);
        }
        if (e8.status === 401 || e8.status === 403)
          throw new Or(r6, Xt(ri, n3));
        if (e8.status === 404)
          return new Rr(r6, Xt(ei, n3));
        if (e8.status === 429)
          throw new Fr(r6, Xt(ni, n3));
        if (e8.status === 504)
          throw new Cr(r6, Xt(Xo, n3));
        if (e8.status >= 500)
          throw new Yt(r6, Xt(ti, n3));
        if (e8.status >= 400)
          throw new Pr(r6, Xt(Yo, n3));
      }
      function Xt(e8, t5) {
        return t5.type === "EmptyError" ? e8 : `${e8}: ${JSON.stringify(t5)}`;
      }
      d2();
      p2();
      f();
      function tu(e8) {
        let t5 = Math.pow(2, e8) * 50, r6 = Math.ceil(Math.random() * t5) - Math.ceil(t5 / 2), n3 = t5 + r6;
        return new Promise((o) => setTimeout(() => o(n3), n3));
      }
      d2();
      p2();
      f();
      function ru(e8) {
        var r6;
        if (!!((r6 = e8.generator) != null && r6.previewFeatures.some((n3) => n3.toLowerCase().includes("metrics"))))
          throw new re("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e8.clientVersion);
      }
      d2();
      p2();
      f();
      var nu = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.5.1-1.aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*", "@swc/core": "1.3.95", "@swc/jest": "0.2.29", "@types/jest": "29.5.5", "@types/node": "18.18.3", execa: "5.1.1", jest: "29.7.0", typescript: "5.2.2" };
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var kr = class extends we {
        constructor(r6, n3) {
          super(`Cannot fetch data from service:
${r6}`, q(n3, true));
          this.name = "RequestError";
          this.code = "P5010";
        }
      };
      k2(kr, "RequestError");
      async function At(e8, t5, r6 = (n3) => n3) {
        var o;
        let n3 = t5.clientVersion;
        try {
          return typeof fetch == "function" ? await r6(fetch)(e8, t5) : await r6(oi)(e8, t5);
        } catch (i2) {
          console.log(e8);
          let s3 = (o = i2.message) != null ? o : "Unknown error";
          throw new kr(s3, { clientVersion: n3 });
        }
      }
      function zf(e8) {
        return { ...e8.headers, "Content-Type": "application/json" };
      }
      function Zf(e8) {
        return { method: e8.method, headers: zf(e8) };
      }
      function Yf(e8, t5) {
        return { text: () => Promise.resolve(x2.Buffer.concat(e8).toString()), json: () => Promise.resolve().then(() => JSON.parse(x2.Buffer.concat(e8).toString())), ok: t5.statusCode >= 200 && t5.statusCode <= 299, status: t5.statusCode, url: t5.url, headers: new ii(t5.headers) };
      }
      async function oi(e8, t5 = {}) {
        let r6 = Xf("https"), n3 = Zf(t5), o = [], { origin: i2 } = new URL(e8);
        return new Promise((s3, a4) => {
          var l;
          let u2 = r6.request(e8, n3, (c2) => {
            let { statusCode: m2, headers: { location: g2 } } = c2;
            m2 >= 301 && m2 <= 399 && g2 && (g2.startsWith("http") === false ? s3(oi(`${i2}${g2}`, t5)) : s3(oi(g2, t5))), c2.on("data", (w) => o.push(w)), c2.on("end", () => s3(Yf(o, c2))), c2.on("error", a4);
          });
          u2.on("error", a4), u2.end((l = t5.body) != null ? l : "");
        });
      }
      var Xf = typeof __require != "undefined" ? __require : () => {
      };
      var ii = class {
        constructor(t5 = {}) {
          this.headers = /* @__PURE__ */ new Map();
          for (let [r6, n3] of Object.entries(t5))
            if (typeof n3 == "string")
              this.headers.set(r6, n3);
            else if (Array.isArray(n3))
              for (let o of n3)
                this.headers.set(r6, o);
        }
        append(t5, r6) {
          this.headers.set(t5, r6);
        }
        delete(t5) {
          this.headers.delete(t5);
        }
        get(t5) {
          var r6;
          return (r6 = this.headers.get(t5)) != null ? r6 : null;
        }
        has(t5) {
          return this.headers.has(t5);
        }
        set(t5, r6) {
          this.headers.set(t5, r6);
        }
        forEach(t5, r6) {
          for (let [n3, o] of this.headers)
            t5.call(r6, o, n3, this);
        }
      };
      var ed = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
      var ou = he("prisma:client:dataproxyEngine");
      async function td(e8, t5) {
        var s3, a4, u2;
        let r6 = nu["@prisma/engines-version"], n3 = (s3 = t5.clientVersion) != null ? s3 : "unknown";
        if (y2.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
          return y2.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
        if (e8.includes("accelerate") && n3 !== "0.0.0" && n3 !== "in-memory")
          return n3;
        let [o, i2] = (a4 = n3 == null ? void 0 : n3.split("-")) != null ? a4 : [];
        if (i2 === void 0 && ed.test(o))
          return o;
        if (i2 !== void 0 || n3 === "0.0.0" || n3 === "in-memory") {
          if (e8.startsWith("localhost") || e8.startsWith("127.0.0.1"))
            return "0.0.0";
          let [l] = (u2 = r6.split("-")) != null ? u2 : [], [c2, m2, g2] = l.split("."), w = rd(`<=${c2}.${m2}.${g2}`), E = await At(w, { clientVersion: n3 });
          if (!E.ok)
            throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${E.status} ${E.statusText}, response body: ${await E.text() || "<empty body>"}`);
          let b2 = await E.text();
          ou("length of body fetched from unpkg.com", b2.length);
          let T;
          try {
            T = JSON.parse(b2);
          } catch (S) {
            throw console.error("JSON.parse error: body fetched from unpkg.com: ", b2), S;
          }
          return T.version;
        }
        throw new Pt("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n3 });
      }
      async function iu(e8, t5) {
        let r6 = await td(e8, t5);
        return ou("version", r6), r6;
      }
      function rd(e8) {
        return encodeURI(`https://unpkg.com/prisma@${e8}/package.json`);
      }
      var su = 3;
      var si = he("prisma:client:dataproxyEngine");
      var ai = class {
        constructor({ apiKey: t5, tracingHelper: r6, logLevel: n3, logQueries: o, engineHash: i2 }) {
          this.apiKey = t5, this.tracingHelper = r6, this.logLevel = n3, this.logQueries = o, this.engineHash = i2;
        }
        build({ traceparent: t5, interactiveTransaction: r6 } = {}) {
          let n3 = { Authorization: `Bearer ${this.apiKey}`, "Prisma-Engine-Hash": this.engineHash };
          this.tracingHelper.isEnabled() && (n3.traceparent = t5 != null ? t5 : this.tracingHelper.getTraceParent()), r6 && (n3["X-transaction-id"] = r6.id);
          let o = this.buildCaptureSettings();
          return o.length > 0 && (n3["X-capture-telemetry"] = o.join(", ")), n3;
        }
        buildCaptureSettings() {
          let t5 = [];
          return this.tracingHelper.isEnabled() && t5.push("tracing"), this.logLevel && t5.push(this.logLevel), this.logQueries && t5.push("query"), t5;
        }
      };
      var Dr = class extends _n {
        constructor(r6) {
          super();
          ru(r6), this.config = r6, this.env = { ...this.config.env, ...y2.env }, this.inlineSchema = r6.inlineSchema, this.inlineDatasources = r6.inlineDatasources, this.inlineSchemaHash = r6.inlineSchemaHash, this.clientVersion = r6.clientVersion, this.engineHash = r6.engineVersion, this.logEmitter = r6.logEmitter, this.tracingHelper = this.config.tracingHelper;
        }
        apiKey() {
          return this.headerBuilder.apiKey;
        }
        version() {
          return this.engineHash;
        }
        async start() {
          this.startPromise !== void 0 && await this.startPromise, this.startPromise = (async () => {
            let [r6, n3] = this.extractHostAndApiKey();
            this.host = r6, this.headerBuilder = new ai({ apiKey: n3, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await iu(r6, this.config), si("host", this.host);
          })(), await this.startPromise;
        }
        async stop() {
        }
        propagateResponseExtensions(r6) {
          var n3, o;
          (n3 = r6 == null ? void 0 : r6.logs) != null && n3.length && r6.logs.forEach((i2) => {
            switch (i2.level) {
              case "debug":
              case "error":
              case "trace":
              case "warn":
              case "info":
                break;
              case "query": {
                let s3 = typeof i2.attributes.query == "string" ? i2.attributes.query : "";
                if (!this.tracingHelper.isEnabled()) {
                  let [a4] = s3.split("/* traceparent");
                  s3 = a4;
                }
                this.logEmitter.emit("query", { query: s3, timestamp: i2.timestamp, duration: i2.attributes.duration_ms, params: i2.attributes.params, target: i2.attributes.target });
              }
            }
          }), (o = r6 == null ? void 0 : r6.traces) != null && o.length && this.tracingHelper.createEngineSpan({ span: true, spans: r6.traces });
        }
        on(r6, n3) {
          if (r6 === "beforeExit")
            throw new Error('"beforeExit" hook is not applicable to the remote query engine');
          this.logEmitter.on(r6, n3);
        }
        async url(r6) {
          return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r6}`;
        }
        async uploadSchema() {
          let r6 = { name: "schemaUpload", internal: true };
          return this.tracingHelper.runInChildSpan(r6, async () => {
            let n3 = await At(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
            n3.ok || si("schema response status", n3.status);
            let o = await Ir(n3, this.clientVersion);
            if (o)
              throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${o.message}` }), o;
            this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})` });
          });
        }
        request(r6, { traceparent: n3, interactiveTransaction: o, customDataProxyFetch: i2 }) {
          return this.requestInternal({ body: r6, traceparent: n3, interactiveTransaction: o, customDataProxyFetch: i2 });
        }
        async requestBatch(r6, { traceparent: n3, transaction: o, customDataProxyFetch: i2 }) {
          let s3 = (o == null ? void 0 : o.kind) === "itx" ? o.options : void 0, a4 = Xa(r6, o), { batchResult: u2, elapsed: l } = await this.requestInternal({ body: a4, customDataProxyFetch: i2, interactiveTransaction: s3, traceparent: n3 });
          return u2.map((c2) => "errors" in c2 && c2.errors.length > 0 ? Zo(c2.errors[0], this.clientVersion) : { data: c2, elapsed: l });
        }
        requestInternal({ body: r6, traceparent: n3, customDataProxyFetch: o, interactiveTransaction: i2 }) {
          return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: s3 }) => {
            let a4 = i2 ? `${i2.payload.endpoint}/graphql` : await this.url("graphql");
            s3(a4);
            let u2 = await At(a4, { method: "POST", headers: this.headerBuilder.build({ traceparent: n3, interactiveTransaction: i2 }), body: JSON.stringify(r6), clientVersion: this.clientVersion }, o);
            u2.ok || si("graphql response status", u2.status), await this.handleError(await Ir(u2, this.clientVersion));
            let l = await u2.json(), c2 = l.extensions;
            if (c2 && this.propagateResponseExtensions(c2), l.errors)
              throw l.errors.length === 1 ? Zo(l.errors[0], this.config.clientVersion) : new Se(l.errors, { clientVersion: this.config.clientVersion });
            return l;
          } });
        }
        async transaction(r6, n3, o) {
          let i2 = { start: "starting", commit: "committing", rollback: "rolling back" };
          return this.withRetry({ actionGerund: `${i2[r6]} transaction`, callback: async ({ logHttpCall: s3 }) => {
            var a4, u2;
            if (r6 === "start") {
              let l = JSON.stringify({ max_wait: (a4 = o == null ? void 0 : o.maxWait) != null ? a4 : 2e3, timeout: (u2 = o == null ? void 0 : o.timeout) != null ? u2 : 5e3, isolation_level: o == null ? void 0 : o.isolationLevel }), c2 = await this.url("transaction/start");
              s3(c2);
              let m2 = await At(c2, { method: "POST", headers: this.headerBuilder.build({ traceparent: n3.traceparent }), body: l, clientVersion: this.clientVersion });
              await this.handleError(await Ir(m2, this.clientVersion));
              let g2 = await m2.json(), w = g2.extensions;
              w && this.propagateResponseExtensions(w);
              let E = g2.id, b2 = g2["data-proxy"].endpoint;
              return { id: E, payload: { endpoint: b2 } };
            } else {
              let l = `${o.payload.endpoint}/${r6}`;
              s3(l);
              let c2 = await At(l, { method: "POST", headers: this.headerBuilder.build({ traceparent: n3.traceparent }), clientVersion: this.clientVersion });
              await this.handleError(await Ir(c2, this.clientVersion));
              let g2 = (await c2.json()).extensions;
              g2 && this.propagateResponseExtensions(g2);
              return;
            }
          } });
        }
        extractHostAndApiKey() {
          let r6 = { clientVersion: this.clientVersion }, n3 = Object.keys(this.inlineDatasources)[0], o = Nn({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), i2;
          try {
            i2 = new URL(o);
          } catch (c2) {
            throw new Et(`Error validating datasource \`${n3}\`: the URL must start with the protocol \`prisma://\``, r6);
          }
          let { protocol: s3, host: a4, searchParams: u2 } = i2;
          if (s3 !== "prisma:")
            throw new Et(`Error validating datasource \`${n3}\`: the URL must start with the protocol \`prisma://\``, r6);
          let l = u2.get("api_key");
          if (l === null || l.length < 1)
            throw new Et(`Error validating datasource \`${n3}\`: the URL must contain a valid API key`, r6);
          return [a4, l];
        }
        metrics() {
          throw new Pt("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
        }
        async withRetry(r6) {
          var n3;
          for (let o = 0; ; o++) {
            let i2 = (s3) => {
              this.logEmitter.emit("info", { message: `Calling ${s3} (n=${o})` });
            };
            try {
              return await r6.callback({ logHttpCall: i2 });
            } catch (s3) {
              if (!(s3 instanceof we) || !s3.isRetryable)
                throw s3;
              if (o >= su)
                throw s3 instanceof Zt ? s3.cause : s3;
              this.logEmitter.emit("warn", { message: `Attempt ${o + 1}/${su} failed for ${r6.actionGerund}: ${(n3 = s3.message) != null ? n3 : "(unknown)"}` });
              let a4 = await tu(o);
              this.logEmitter.emit("warn", { message: `Retrying after ${a4}ms` });
            }
          }
        }
        async handleError(r6) {
          if (r6 instanceof vt)
            throw await this.uploadSchema(), new Zt({ clientVersion: this.clientVersion, cause: r6 });
          if (r6)
            throw r6;
        }
      };
      function au(e8, t5) {
        let r6;
        try {
          r6 = Nn({ inlineDatasources: t5.inlineDatasources, overrideDatasources: t5.overrideDatasources, env: { ...t5.env, ...y2.env }, clientVersion: t5.clientVersion });
        } catch (o) {
        }
        e8.noEngine !== true && (r6 != null && r6.startsWith("prisma://")) && lr("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
        let n3 = Co(t5.generator);
        return r6 != null && r6.startsWith("prisma://") || e8.noEngine, new Dr(t5);
        throw new pe("Invalid client engine type, please use `library` or `binary`", { clientVersion: t5.clientVersion });
      }
      d2();
      p2();
      f();
      function Bn({ generator: e8 }) {
        var t5;
        return (t5 = e8 == null ? void 0 : e8.previewFeatures) != null ? t5 : [];
      }
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var du = ve(ui());
      d2();
      p2();
      f();
      function pu(e8, t5) {
        let r6 = fu(e8), n3 = nd(r6), o = id(n3);
        o ? jn(o, t5) : t5.addErrorMessage(() => "Unknown error");
      }
      function fu(e8) {
        return e8.errors.flatMap((t5) => t5.kind === "Union" ? fu(t5) : [t5]);
      }
      function nd(e8) {
        let t5 = /* @__PURE__ */ new Map(), r6 = [];
        for (let n3 of e8) {
          if (n3.kind !== "InvalidArgumentType") {
            r6.push(n3);
            continue;
          }
          let o = `${n3.selectionPath.join(".")}:${n3.argumentPath.join(".")}`, i2 = t5.get(o);
          i2 ? t5.set(o, { ...n3, argument: { ...n3.argument, typeNames: od(i2.argument.typeNames, n3.argument.typeNames) } }) : t5.set(o, n3);
        }
        return r6.push(...t5.values()), r6;
      }
      function od(e8, t5) {
        return [...new Set(e8.concat(t5))];
      }
      function id(e8) {
        return Io(e8, (t5, r6) => {
          let n3 = lu(t5), o = lu(r6);
          return n3 !== o ? n3 - o : cu(t5) - cu(r6);
        });
      }
      function lu(e8) {
        let t5 = 0;
        return Array.isArray(e8.selectionPath) && (t5 += e8.selectionPath.length), Array.isArray(e8.argumentPath) && (t5 += e8.argumentPath.length), t5;
      }
      function cu(e8) {
        switch (e8.kind) {
          case "InvalidArgumentValue":
          case "ValueTooLarge":
            return 20;
          case "InvalidArgumentType":
            return 10;
          case "RequiredArgumentMissing":
            return -10;
          default:
            return 0;
        }
      }
      d2();
      p2();
      f();
      var Qe = class {
        constructor(t5, r6) {
          this.name = t5;
          this.value = r6;
          this.isRequired = false;
        }
        makeRequired() {
          return this.isRequired = true, this;
        }
        write(t5) {
          let { colors: { green: r6 } } = t5.context;
          t5.addMarginSymbol(r6(this.isRequired ? "+" : "?")), t5.write(r6(this.name)), this.isRequired || t5.write(r6("?")), t5.write(r6(": ")), typeof this.value == "string" ? t5.write(r6(this.value)) : t5.write(this.value);
        }
      };
      d2();
      p2();
      f();
      var Un = class {
        constructor() {
          this.fields = [];
        }
        addField(t5, r6) {
          return this.fields.push({ write(n3) {
            let { green: o, dim: i2 } = n3.context.colors;
            n3.write(o(i2(`${t5}: ${r6}`))).addMarginSymbol(o(i2("+")));
          } }), this;
        }
        write(t5) {
          let { colors: { green: r6 } } = t5.context;
          t5.writeLine(r6("{")).withIndent(() => {
            t5.writeJoined(Qt, this.fields).newLine();
          }).write(r6("}")).addMarginSymbol(r6("+"));
        }
      };
      function jn(e8, t5) {
        switch (e8.kind) {
          case "IncludeAndSelect":
            sd(e8, t5);
            break;
          case "IncludeOnScalar":
            ad(e8, t5);
            break;
          case "EmptySelection":
            ud(e8, t5);
            break;
          case "UnknownSelectionField":
            ld(e8, t5);
            break;
          case "UnknownArgument":
            cd(e8, t5);
            break;
          case "UnknownInputField":
            pd(e8, t5);
            break;
          case "RequiredArgumentMissing":
            fd(e8, t5);
            break;
          case "InvalidArgumentType":
            dd(e8, t5);
            break;
          case "InvalidArgumentValue":
            md(e8, t5);
            break;
          case "ValueTooLarge":
            gd(e8, t5);
            break;
          case "SomeFieldsMissing":
            yd(e8, t5);
            break;
          case "TooManyFieldsGiven":
            hd(e8, t5);
            break;
          case "Union":
            pu(e8, t5);
            break;
          default:
            throw new Error("not implemented: " + e8.kind);
        }
      }
      function sd(e8, t5) {
        var n3, o;
        let r6 = t5.arguments.getDeepSubSelectionValue(e8.selectionPath);
        r6 && r6 instanceof ne && ((n3 = r6.getField("include")) == null || n3.markAsError(), (o = r6.getField("select")) == null || o.markAsError()), t5.addErrorMessage((i2) => `Please ${i2.bold("either")} use ${i2.green("`include`")} or ${i2.green("`select`")}, but ${i2.red("not both")} at the same time.`);
      }
      function ad(e8, t5) {
        var s3, a4;
        let [r6, n3] = $n(e8.selectionPath), o = e8.outputType, i2 = (s3 = t5.arguments.getDeepSelectionParent(r6)) == null ? void 0 : s3.value;
        if (i2 && ((a4 = i2.getField(n3)) == null || a4.markAsError(), o))
          for (let u2 of o.fields)
            u2.isRelation && i2.addSuggestion(new Qe(u2.name, "true"));
        t5.addErrorMessage((u2) => {
          let l = `Invalid scalar field ${u2.red(`\`${n3}\``)} for ${u2.bold("include")} statement`;
          return o ? l += ` on model ${u2.bold(o.name)}. ${_r(u2)}` : l += ".", l += `
Note that ${u2.bold("include")} statements only accept relation fields.`, l;
        });
      }
      function ud(e8, t5) {
        var i2, s3;
        let r6 = e8.outputType, n3 = (i2 = t5.arguments.getDeepSelectionParent(e8.selectionPath)) == null ? void 0 : i2.value, o = (s3 = n3 == null ? void 0 : n3.isEmpty()) != null ? s3 : false;
        n3 && (n3.removeAllFields(), yu(n3, r6)), t5.addErrorMessage((a4) => o ? `The ${a4.red("`select`")} statement for type ${a4.bold(r6.name)} must not be empty. ${_r(a4)}` : `The ${a4.red("`select`")} statement for type ${a4.bold(r6.name)} needs ${a4.bold("at least one truthy value")}.`);
      }
      function ld(e8, t5) {
        var i2;
        let [r6, n3] = $n(e8.selectionPath), o = t5.arguments.getDeepSelectionParent(r6);
        o && ((i2 = o.value.getField(n3)) == null || i2.markAsError(), yu(o.value, e8.outputType)), t5.addErrorMessage((s3) => {
          let a4 = [`Unknown field ${s3.red(`\`${n3}\``)}`];
          return o && a4.push(`for ${s3.bold(o.kind)} statement`), a4.push(`on model ${s3.bold(`\`${e8.outputType.name}\``)}.`), a4.push(_r(s3)), a4.join(" ");
        });
      }
      function cd(e8, t5) {
        var o;
        let r6 = e8.argumentPath[0], n3 = t5.arguments.getDeepSubSelectionValue(e8.selectionPath);
        n3 instanceof ne && ((o = n3.getField(r6)) == null || o.markAsError(), xd(n3, e8.arguments)), t5.addErrorMessage((i2) => mu(i2, r6, e8.arguments.map((s3) => s3.name)));
      }
      function pd(e8, t5) {
        var i2;
        let [r6, n3] = $n(e8.argumentPath), o = t5.arguments.getDeepSubSelectionValue(e8.selectionPath);
        if (o instanceof ne) {
          (i2 = o.getDeepField(e8.argumentPath)) == null || i2.markAsError();
          let s3 = o.getDeepFieldValue(r6);
          s3 instanceof ne && hu(s3, e8.inputType);
        }
        t5.addErrorMessage((s3) => mu(s3, n3, e8.inputType.fields.map((a4) => a4.name)));
      }
      function mu(e8, t5, r6) {
        let n3 = [`Unknown argument \`${e8.red(t5)}\`.`], o = wd(t5, r6);
        return o && n3.push(`Did you mean \`${e8.green(o)}\`?`), r6.length > 0 && n3.push(_r(e8)), n3.join(" ");
      }
      function fd(e8, t5) {
        let r6;
        t5.addErrorMessage((u2) => (r6 == null ? void 0 : r6.value) instanceof oe && r6.value.text === "null" ? `Argument \`${u2.green(i2)}\` must not be ${u2.red("null")}.` : `Argument \`${u2.green(i2)}\` is missing.`);
        let n3 = t5.arguments.getDeepSubSelectionValue(e8.selectionPath);
        if (!(n3 instanceof ne))
          return;
        let [o, i2] = $n(e8.argumentPath), s3 = new Un(), a4 = n3.getDeepFieldValue(o);
        if (a4 instanceof ne)
          if (r6 = a4.getField(i2), r6 && a4.removeField(i2), e8.inputTypes.length === 1 && e8.inputTypes[0].kind === "object") {
            for (let u2 of e8.inputTypes[0].fields)
              s3.addField(u2.name, u2.typeNames.join(" | "));
            a4.addSuggestion(new Qe(i2, s3).makeRequired());
          } else {
            let u2 = e8.inputTypes.map(gu).join(" | ");
            a4.addSuggestion(new Qe(i2, u2).makeRequired());
          }
      }
      function gu(e8) {
        return e8.kind === "list" ? `${gu(e8.elementType)}[]` : e8.name;
      }
      function dd(e8, t5) {
        var o;
        let r6 = e8.argument.name, n3 = t5.arguments.getDeepSubSelectionValue(e8.selectionPath);
        n3 instanceof ne && ((o = n3.getDeepFieldValue(e8.argumentPath)) == null || o.markAsError()), t5.addErrorMessage((i2) => {
          let s3 = qn("or", e8.argument.typeNames.map((a4) => i2.green(a4)));
          return `Argument \`${i2.bold(r6)}\`: Invalid value provided. Expected ${s3}, provided ${i2.red(e8.inferredType)}.`;
        });
      }
      function md(e8, t5) {
        var o;
        let r6 = e8.argument.name, n3 = t5.arguments.getDeepSubSelectionValue(e8.selectionPath);
        n3 instanceof ne && ((o = n3.getDeepFieldValue(e8.argumentPath)) == null || o.markAsError()), t5.addErrorMessage((i2) => {
          let s3 = [`Invalid value for argument \`${i2.bold(r6)}\``];
          if (e8.underlyingError && s3.push(`: ${e8.underlyingError}`), s3.push("."), e8.argument.typeNames.length > 0) {
            let a4 = qn("or", e8.argument.typeNames.map((u2) => i2.green(u2)));
            s3.push(` Expected ${a4}.`);
          }
          return s3.join("");
        });
      }
      function gd(e8, t5) {
        let r6 = e8.argument.name, n3 = t5.arguments.getDeepSubSelectionValue(e8.selectionPath), o;
        if (n3 instanceof ne) {
          let i2 = n3.getDeepField(e8.argumentPath), s3 = i2 == null ? void 0 : i2.value;
          s3 == null || s3.markAsError(), s3 instanceof oe && (o = s3.text);
        }
        t5.addErrorMessage((i2) => {
          let s3 = ["Unable to fit value"];
          return o && s3.push(i2.red(o)), s3.push(`into a 64-bit signed integer for field \`${i2.bold(r6)}\``), s3.join(" ");
        });
      }
      function yd(e8, t5) {
        let r6 = e8.argumentPath[e8.argumentPath.length - 1], n3 = t5.arguments.getDeepSubSelectionValue(e8.selectionPath);
        if (n3 instanceof ne) {
          let o = n3.getDeepFieldValue(e8.argumentPath);
          o instanceof ne && hu(o, e8.inputType);
        }
        t5.addErrorMessage((o) => {
          let i2 = [`Argument \`${o.bold(r6)}\` of type ${o.bold(e8.inputType.name)} needs`];
          return e8.constraints.minFieldCount === 1 ? e8.constraints.requiredFields ? i2.push(`${o.green("at least one of")} ${qn("or", e8.constraints.requiredFields.map((s3) => `\`${o.bold(s3)}\``))} arguments.`) : i2.push(`${o.green("at least one")} argument.`) : i2.push(`${o.green(`at least ${e8.constraints.minFieldCount}`)} arguments.`), i2.push(_r(o)), i2.join(" ");
        });
      }
      function hd(e8, t5) {
        let r6 = e8.argumentPath[e8.argumentPath.length - 1], n3 = t5.arguments.getDeepSubSelectionValue(e8.selectionPath), o = [];
        if (n3 instanceof ne) {
          let i2 = n3.getDeepFieldValue(e8.argumentPath);
          i2 instanceof ne && (i2.markAsError(), o = Object.keys(i2.getFields()));
        }
        t5.addErrorMessage((i2) => {
          let s3 = [`Argument \`${i2.bold(r6)}\` of type ${i2.bold(e8.inputType.name)} needs`];
          return e8.constraints.minFieldCount === 1 && e8.constraints.maxFieldCount == 1 ? s3.push(`${i2.green("exactly one")} argument,`) : e8.constraints.maxFieldCount == 1 ? s3.push(`${i2.green("at most one")} argument,`) : s3.push(`${i2.green(`at most ${e8.constraints.maxFieldCount}`)} arguments,`), s3.push(`but you provided ${qn("and", o.map((a4) => i2.red(a4)))}. Please choose`), e8.constraints.maxFieldCount === 1 ? s3.push("one.") : s3.push(`${e8.constraints.maxFieldCount}.`), s3.join(" ");
        });
      }
      function yu(e8, t5) {
        for (let r6 of t5.fields)
          e8.hasField(r6.name) || e8.addSuggestion(new Qe(r6.name, "true"));
      }
      function xd(e8, t5) {
        for (let r6 of t5)
          e8.hasField(r6.name) || e8.addSuggestion(new Qe(r6.name, r6.typeNames.join(" | ")));
      }
      function hu(e8, t5) {
        if (t5.kind === "object")
          for (let r6 of t5.fields)
            e8.hasField(r6.name) || e8.addSuggestion(new Qe(r6.name, r6.typeNames.join(" | ")));
      }
      function $n(e8) {
        let t5 = [...e8], r6 = t5.pop();
        if (!r6)
          throw new Error("unexpected empty path");
        return [t5, r6];
      }
      function _r({ green: e8, enabled: t5 }) {
        return "Available options are " + (t5 ? `listed in ${e8("green")}` : "marked with ?") + ".";
      }
      function qn(e8, t5) {
        if (t5.length === 1)
          return t5[0];
        let r6 = [...t5], n3 = r6.pop();
        return `${r6.join(", ")} ${e8} ${n3}`;
      }
      var bd = 3;
      function wd(e8, t5) {
        let r6 = 1 / 0, n3;
        for (let o of t5) {
          let i2 = (0, du.default)(e8, o);
          i2 > bd || i2 < r6 && (r6 = i2, n3 = o);
        }
        return n3;
      }
      function Vn({ args: e8, errors: t5, errorFormat: r6, callsite: n3, originalMethod: o, clientVersion: i2 }) {
        let s3 = Mn(e8);
        for (let m2 of t5)
          jn(m2, s3);
        let a4 = r6 === "pretty" ? ma : Tn, u2 = s3.renderAllMessages(a4), l = new $t(0, { colors: a4 }).write(s3).toString(), c2 = zt({ message: u2, callsite: n3, originalMethod: o, showColors: r6 === "pretty", callArguments: l });
        throw new pe(c2, { clientVersion: i2 });
      }
      var Ed = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
      function xu({ modelName: e8, action: t5, args: r6, runtimeDataModel: n3, extensions: o, callsite: i2, clientMethod: s3, errorFormat: a4, clientVersion: u2 }) {
        let l = new li({ runtimeDataModel: n3, modelName: e8, action: t5, rootArgs: r6, callsite: i2, extensions: o, selectionPath: [], argumentPath: [], originalMethod: s3, errorFormat: a4, clientVersion: u2 });
        return { modelName: e8, action: Ed[t5], query: ci(r6, l) };
      }
      function ci({ select: e8, include: t5, ...r6 } = {}, n3) {
        return { arguments: wu(r6, n3), selection: Pd(e8, t5, n3) };
      }
      function Pd(e8, t5, r6) {
        return e8 && t5 && r6.throwValidationError({ kind: "IncludeAndSelect", selectionPath: r6.getSelectionPath() }), e8 ? Td(e8, r6) : vd(r6, t5);
      }
      function vd(e8, t5) {
        let r6 = {};
        return e8.model && !e8.isRawAction() && (r6.$composites = true, r6.$scalars = true), t5 && Ad(r6, t5, e8), r6;
      }
      function Ad(e8, t5, r6) {
        for (let [n3, o] of Object.entries(t5)) {
          let i2 = r6.findField(n3);
          i2 && (i2 == null ? void 0 : i2.kind) !== "object" && r6.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r6.getSelectionPath().concat(n3), outputType: r6.getOutputTypeDescription() }), o === true ? e8[n3] = true : typeof o == "object" && (e8[n3] = ci(o, r6.nestSelection(n3)));
        }
      }
      function Td(e8, t5) {
        let r6 = {}, n3 = t5.getComputedFields(), o = Wa(e8, n3);
        for (let [i2, s3] of Object.entries(o)) {
          let a4 = t5.findField(i2);
          n3 != null && n3[i2] && !a4 || (s3 === true ? r6[i2] = true : typeof s3 == "object" && (r6[i2] = ci(s3, t5.nestSelection(i2))));
        }
        return r6;
      }
      function bu(e8, t5) {
        if (e8 === null)
          return null;
        if (typeof e8 == "string" || typeof e8 == "number" || typeof e8 == "boolean")
          return e8;
        if (typeof e8 == "bigint")
          return { $type: "BigInt", value: String(e8) };
        if (qt(e8)) {
          if (gn(e8))
            return { $type: "DateTime", value: e8.toISOString() };
          t5.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t5.getSelectionPath(), argumentPath: t5.getArgumentPath(), argument: { name: t5.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
        }
        if (Jt(e8))
          return { $type: "FieldRef", value: { _ref: e8.name, _container: e8.modelName } };
        if (Array.isArray(e8))
          return Cd(e8, t5);
        if (ArrayBuffer.isView(e8))
          return { $type: "Bytes", value: x2.Buffer.from(e8).toString("base64") };
        if (Md(e8))
          return e8.values;
        if (Gt(e8))
          return { $type: "Decimal", value: e8.toFixed() };
        if (e8 instanceof _e) {
          if (e8 !== pn.instances[e8._getName()])
            throw new Error("Invalid ObjectEnumValue");
          return { $type: "Enum", value: e8._getName() };
        }
        if (Sd(e8))
          return e8.toJSON();
        if (typeof e8 == "object")
          return wu(e8, t5);
        t5.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t5.getSelectionPath(), argumentPath: t5.getArgumentPath(), argument: { name: t5.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e8)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
      }
      function wu(e8, t5) {
        if (e8.$type)
          return { $type: "Json", value: JSON.stringify(e8) };
        let r6 = {};
        for (let n3 in e8) {
          let o = e8[n3];
          o !== void 0 && (r6[n3] = bu(o, t5.nestArgument(n3)));
        }
        return r6;
      }
      function Cd(e8, t5) {
        let r6 = [];
        for (let n3 = 0; n3 < e8.length; n3++) {
          let o = t5.nestArgument(String(n3)), i2 = e8[n3];
          i2 === void 0 && t5.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: o.getSelectionPath(), argumentPath: o.getArgumentPath(), argument: { name: `${t5.getArgumentName()}[${n3}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), r6.push(bu(i2, o));
        }
        return r6;
      }
      function Md(e8) {
        return typeof e8 == "object" && e8 !== null && e8.__prismaRawParameters__ === true;
      }
      function Sd(e8) {
        return typeof e8 == "object" && e8 !== null && typeof e8.toJSON == "function";
      }
      var li = class e8 {
        constructor(t5) {
          this.params = t5;
          this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
        }
        throwValidationError(t5) {
          var r6;
          Vn({ errors: [t5], originalMethod: this.params.originalMethod, args: (r6 = this.params.rootArgs) != null ? r6 : {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
        }
        getSelectionPath() {
          return this.params.selectionPath;
        }
        getArgumentPath() {
          return this.params.argumentPath;
        }
        getArgumentName() {
          return this.params.argumentPath[this.params.argumentPath.length - 1];
        }
        getOutputTypeDescription() {
          if (!(!this.params.modelName || !this.model))
            return { name: this.params.modelName, fields: this.model.fields.map((t5) => ({ name: t5.name, typeName: "boolean", isRelation: t5.kind === "object" })) };
        }
        isRawAction() {
          return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
        }
        getComputedFields() {
          if (this.params.modelName)
            return this.params.extensions.getAllComputedFields(this.params.modelName);
        }
        findField(t5) {
          var r6;
          return (r6 = this.model) == null ? void 0 : r6.fields.find((n3) => n3.name === t5);
        }
        nestSelection(t5) {
          let r6 = this.findField(t5), n3 = (r6 == null ? void 0 : r6.kind) === "object" ? r6.type : void 0;
          return new e8({ ...this.params, modelName: n3, selectionPath: this.params.selectionPath.concat(t5) });
        }
        nestArgument(t5) {
          return new e8({ ...this.params, argumentPath: this.params.argumentPath.concat(t5) });
        }
      };
      d2();
      p2();
      f();
      var Eu = (e8) => ({ command: e8 });
      d2();
      p2();
      f();
      d2();
      p2();
      f();
      var Pu = (e8) => e8.strings.reduce((t5, r6, n3) => `${t5}@P${n3}${r6}`);
      d2();
      p2();
      f();
      function Nr(e8) {
        try {
          return vu(e8, "fast");
        } catch (t5) {
          return vu(e8, "slow");
        }
      }
      function vu(e8, t5) {
        return JSON.stringify(e8.map((r6) => Rd(r6, t5)));
      }
      function Rd(e8, t5) {
        return typeof e8 == "bigint" ? { prisma__type: "bigint", prisma__value: e8.toString() } : qt(e8) ? { prisma__type: "date", prisma__value: e8.toJSON() } : je.isDecimal(e8) ? { prisma__type: "decimal", prisma__value: e8.toJSON() } : x2.Buffer.isBuffer(e8) ? { prisma__type: "bytes", prisma__value: e8.toString("base64") } : Od(e8) || ArrayBuffer.isView(e8) ? { prisma__type: "bytes", prisma__value: x2.Buffer.from(e8).toString("base64") } : typeof e8 == "object" && t5 === "slow" ? Tu(e8) : e8;
      }
      function Od(e8) {
        return e8 instanceof ArrayBuffer || e8 instanceof SharedArrayBuffer ? true : typeof e8 == "object" && e8 !== null ? e8[Symbol.toStringTag] === "ArrayBuffer" || e8[Symbol.toStringTag] === "SharedArrayBuffer" : false;
      }
      function Tu(e8) {
        if (typeof e8 != "object" || e8 === null)
          return e8;
        if (typeof e8.toJSON == "function")
          return e8.toJSON();
        if (Array.isArray(e8))
          return e8.map(Au);
        let t5 = {};
        for (let r6 of Object.keys(e8))
          t5[r6] = Au(e8[r6]);
        return t5;
      }
      function Au(e8) {
        return typeof e8 == "bigint" ? e8.toString() : Tu(e8);
      }
      var Fd = /^(\s*alter\s)/i;
      var Cu = he("prisma:client");
      function pi(e8, t5, r6, n3) {
        if (!(e8 !== "postgresql" && e8 !== "cockroachdb") && r6.length > 0 && Fd.exec(t5))
          throw new Error(`Running ALTER using ${n3} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
      }
      var fi = ({ clientMethod: e8, activeProvider: t5, activeProviderFlavour: r6 }) => (n3) => {
        r6 !== void 0 && (t5 = r6);
        let o = "", i2;
        if (Array.isArray(n3)) {
          let [s3, ...a4] = n3;
          o = s3, i2 = { values: Nr(a4 || []), __prismaRawParameters__: true };
        } else
          switch (t5) {
            case "sqlite":
            case "mysql": {
              o = n3.sql, i2 = { values: Nr(n3.values), __prismaRawParameters__: true };
              break;
            }
            case "cockroachdb":
            case "postgresql":
            case "postgres": {
              o = n3.text, i2 = { values: Nr(n3.values), __prismaRawParameters__: true };
              break;
            }
            case "sqlserver": {
              o = Pu(n3), i2 = { values: Nr(n3.values), __prismaRawParameters__: true };
              break;
            }
            default:
              throw new Error(`The ${t5} provider does not support ${e8}`);
          }
        return i2 != null && i2.values ? Cu(`prisma.${e8}(${o}, ${i2.values})`) : Cu(`prisma.${e8}(${o})`), { query: o, parameters: i2 };
      };
      var Mu = { requestArgsToMiddlewareArgs(e8) {
        return [e8.strings, ...e8.values];
      }, middlewareArgsToRequestArgs(e8) {
        let [t5, ...r6] = e8;
        return new xe(t5, r6);
      } };
      var Su = { requestArgsToMiddlewareArgs(e8) {
        return [e8];
      }, middlewareArgsToRequestArgs(e8) {
        return e8[0];
      } };
      d2();
      p2();
      f();
      function di(e8) {
        return function(r6) {
          let n3, o = (i2 = e8) => {
            try {
              return i2 === void 0 || (i2 == null ? void 0 : i2.kind) === "itx" ? n3 != null ? n3 : n3 = Ru(r6(i2)) : Ru(r6(i2));
            } catch (s3) {
              return Promise.reject(s3);
            }
          };
          return { then(i2, s3) {
            return o().then(i2, s3);
          }, catch(i2) {
            return o().catch(i2);
          }, finally(i2) {
            return o().finally(i2);
          }, requestTransaction(i2) {
            let s3 = o(i2);
            return s3.requestTransaction ? s3.requestTransaction(i2) : s3;
          }, [Symbol.toStringTag]: "PrismaPromise" };
        };
      }
      function Ru(e8) {
        return typeof e8.then == "function" ? e8 : Promise.resolve(e8);
      }
      d2();
      p2();
      f();
      var Ou = { isEnabled() {
        return false;
      }, getTraceParent() {
        return "00-10-10-00";
      }, async createEngineSpan() {
      }, getActiveContext() {
      }, runInChildSpan(e8, t5) {
        return t5();
      } };
      var mi = class {
        isEnabled() {
          return this.getGlobalTracingHelper().isEnabled();
        }
        getTraceParent(t5) {
          return this.getGlobalTracingHelper().getTraceParent(t5);
        }
        createEngineSpan(t5) {
          return this.getGlobalTracingHelper().createEngineSpan(t5);
        }
        getActiveContext() {
          return this.getGlobalTracingHelper().getActiveContext();
        }
        runInChildSpan(t5, r6) {
          return this.getGlobalTracingHelper().runInChildSpan(t5, r6);
        }
        getGlobalTracingHelper() {
          var t5, r6;
          return (r6 = (t5 = globalThis.PRISMA_INSTRUMENTATION) == null ? void 0 : t5.helper) != null ? r6 : Ou;
        }
      };
      function Fu(e8) {
        return e8.includes("tracing") ? new mi() : Ou;
      }
      d2();
      p2();
      f();
      function Iu(e8, t5 = () => {
      }) {
        let r6, n3 = new Promise((o) => r6 = o);
        return { then(o) {
          return --e8 === 0 && r6(t5()), o == null ? void 0 : o(n3);
        } };
      }
      d2();
      p2();
      f();
      var Id = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
      var gi = Id;
      d2();
      p2();
      f();
      function ku(e8) {
        return typeof e8 == "string" ? e8 : e8.reduce((t5, r6) => {
          let n3 = typeof r6 == "string" ? r6 : r6.level;
          return n3 === "query" ? t5 : t5 && (r6 === "info" || t5 === "info") ? "info" : n3;
        }, void 0);
      }
      d2();
      p2();
      f();
      var Kn = class {
        constructor() {
          this._middlewares = [];
        }
        use(t5) {
          this._middlewares.push(t5);
        }
        get(t5) {
          return this._middlewares[t5];
        }
        has(t5) {
          return !!this._middlewares[t5];
        }
        length() {
          return this._middlewares.length;
        }
      };
      d2();
      p2();
      f();
      var _u = ve(Vs());
      d2();
      p2();
      f();
      function Gn(e8) {
        return typeof e8.batchRequestIdx == "number";
      }
      d2();
      p2();
      f();
      function Jn(e8) {
        return e8 === null ? e8 : Array.isArray(e8) ? e8.map(Jn) : typeof e8 == "object" ? kd(e8) ? Dd(e8) : jt(e8, Jn) : e8;
      }
      function kd(e8) {
        return e8 !== null && typeof e8 == "object" && typeof e8.$type == "string";
      }
      function Dd({ $type: e8, value: t5 }) {
        switch (e8) {
          case "BigInt":
            return BigInt(t5);
          case "Bytes":
            return x2.Buffer.from(t5, "base64");
          case "DateTime":
            return new Date(t5);
          case "Decimal":
            return new je(t5);
          case "Json":
            return JSON.parse(t5);
          default:
            xt(t5, "Unknown tagged value");
        }
      }
      d2();
      p2();
      f();
      function Du(e8) {
        if (e8.action !== "findUnique" && e8.action !== "findUniqueOrThrow")
          return;
        let t5 = [];
        return e8.modelName && t5.push(e8.modelName), e8.query.arguments && t5.push(yi(e8.query.arguments)), t5.push(yi(e8.query.selection)), t5.join("");
      }
      function yi(e8) {
        return `(${Object.keys(e8).sort().map((r6) => {
          let n3 = e8[r6];
          return typeof n3 == "object" && n3 !== null ? `(${r6} ${yi(n3)})` : r6;
        }).join(" ")})`;
      }
      d2();
      p2();
      f();
      var _d = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
      function hi(e8) {
        return _d[e8];
      }
      d2();
      p2();
      f();
      var Qn = class {
        constructor(t5) {
          this.options = t5;
          this.tickActive = false;
          this.batches = {};
        }
        request(t5) {
          let r6 = this.options.batchBy(t5);
          return r6 ? (this.batches[r6] || (this.batches[r6] = [], this.tickActive || (this.tickActive = true, y2.nextTick(() => {
            this.dispatchBatches(), this.tickActive = false;
          }))), new Promise((n3, o) => {
            this.batches[r6].push({ request: t5, resolve: n3, reject: o });
          })) : this.options.singleLoader(t5);
        }
        dispatchBatches() {
          for (let t5 in this.batches) {
            let r6 = this.batches[t5];
            delete this.batches[t5], r6.length === 1 ? this.options.singleLoader(r6[0].request).then((n3) => {
              n3 instanceof Error ? r6[0].reject(n3) : r6[0].resolve(n3);
            }).catch((n3) => {
              r6[0].reject(n3);
            }) : (r6.sort((n3, o) => this.options.batchOrder(n3.request, o.request)), this.options.batchLoader(r6.map((n3) => n3.request)).then((n3) => {
              if (n3 instanceof Error)
                for (let o = 0; o < r6.length; o++)
                  r6[o].reject(n3);
              else
                for (let o = 0; o < r6.length; o++) {
                  let i2 = n3[o];
                  i2 instanceof Error ? r6[o].reject(i2) : r6[o].resolve(i2);
                }
            }).catch((n3) => {
              for (let o = 0; o < r6.length; o++)
                r6[o].reject(n3);
            }));
          }
        }
        get [Symbol.toStringTag]() {
          return "DataLoader";
        }
      };
      var Nd = he("prisma:client:request_handler");
      var Wn = class {
        constructor(t5, r6) {
          this.logEmitter = r6, this.client = t5, this.dataloader = new Qn({ batchLoader: Va(async ({ requests: n3, customDataProxyFetch: o }) => {
            let { transaction: i2, otelParentCtx: s3 } = n3[0], a4 = n3.map((m2) => m2.protocolQuery), u2 = this.client._tracingHelper.getTraceParent(s3), l = n3.some((m2) => hi(m2.protocolQuery.action));
            return (await this.client._engine.requestBatch(a4, { traceparent: u2, transaction: Ld(i2), containsWrite: l, customDataProxyFetch: o })).map((m2, g2) => {
              if (m2 instanceof Error)
                return m2;
              try {
                return this.mapQueryEngineResult(n3[g2], m2);
              } catch (w) {
                return w;
              }
            });
          }), singleLoader: async (n3) => {
            var s3;
            let o = ((s3 = n3.transaction) == null ? void 0 : s3.kind) === "itx" ? Nu(n3.transaction) : void 0, i2 = await this.client._engine.request(n3.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: o, isWrite: hi(n3.protocolQuery.action), customDataProxyFetch: n3.customDataProxyFetch });
            return this.mapQueryEngineResult(n3, i2);
          }, batchBy: (n3) => {
            var o;
            return (o = n3.transaction) != null && o.id ? `transaction-${n3.transaction.id}` : Du(n3.protocolQuery);
          }, batchOrder(n3, o) {
            var i2, s3;
            return ((i2 = n3.transaction) == null ? void 0 : i2.kind) === "batch" && ((s3 = o.transaction) == null ? void 0 : s3.kind) === "batch" ? n3.transaction.index - o.transaction.index : 0;
          } });
        }
        async request(t5) {
          try {
            return await this.dataloader.request(t5);
          } catch (r6) {
            let { clientMethod: n3, callsite: o, transaction: i2, args: s3 } = t5;
            this.handleAndLogRequestError({ error: r6, clientMethod: n3, callsite: o, transaction: i2, args: s3 });
          }
        }
        mapQueryEngineResult({ dataPath: t5, unpacker: r6 }, n3) {
          let o = n3 == null ? void 0 : n3.data, i2 = n3 == null ? void 0 : n3.elapsed, s3 = this.unpack(o, t5, r6);
          return y2.env.PRISMA_CLIENT_GET_TIME ? { data: s3, elapsed: i2 } : s3;
        }
        handleAndLogRequestError(t5) {
          try {
            this.handleRequestError(t5);
          } catch (r6) {
            throw this.logEmitter && this.logEmitter.emit("error", { message: r6.message, target: t5.clientMethod, timestamp: /* @__PURE__ */ new Date() }), r6;
          }
        }
        handleRequestError({ error: t5, clientMethod: r6, callsite: n3, transaction: o, args: i2 }) {
          if (Nd(t5), Bd(t5, o) || t5 instanceof Ke)
            throw t5;
          if (t5 instanceof ce && jd(t5)) {
            let a4 = Lu(t5.meta);
            Vn({ args: i2, errors: [a4], callsite: n3, errorFormat: this.client._errorFormat, originalMethod: r6, clientVersion: this.client._clientVersion });
          }
          let s3 = t5.message;
          throw n3 && (s3 = zt({ callsite: n3, originalMethod: r6, isPanic: t5.isPanic, showColors: this.client._errorFormat === "pretty", message: s3 })), s3 = this.sanitizeMessage(s3), t5.code ? new ce(s3, { code: t5.code, clientVersion: this.client._clientVersion, meta: t5.meta, batchRequestIdx: t5.batchRequestIdx }) : t5.isPanic ? new Ge(s3, this.client._clientVersion) : t5 instanceof Se ? new Se(s3, { clientVersion: this.client._clientVersion, batchRequestIdx: t5.batchRequestIdx }) : t5 instanceof re ? new re(s3, this.client._clientVersion) : t5 instanceof Ge ? new Ge(s3, this.client._clientVersion) : (t5.clientVersion = this.client._clientVersion, t5);
        }
        sanitizeMessage(t5) {
          return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, _u.default)(t5) : t5;
        }
        unpack(t5, r6, n3) {
          if (!t5 || (t5.data && (t5 = t5.data), !t5))
            return t5;
          let o = Object.values(t5)[0], i2 = r6.filter((a4) => a4 !== "select" && a4 !== "include"), s3 = Jn(Qo(o, i2));
          return n3 ? n3(s3) : s3;
        }
        get [Symbol.toStringTag]() {
          return "RequestHandler";
        }
      };
      function Ld(e8) {
        if (e8) {
          if (e8.kind === "batch")
            return { kind: "batch", options: { isolationLevel: e8.isolationLevel } };
          if (e8.kind === "itx")
            return { kind: "itx", options: Nu(e8) };
          xt(e8, "Unknown transaction kind");
        }
      }
      function Nu(e8) {
        return { id: e8.id, payload: e8.payload };
      }
      function Bd(e8, t5) {
        return Gn(e8) && (t5 == null ? void 0 : t5.kind) === "batch" && e8.batchRequestIdx !== t5.index;
      }
      function jd(e8) {
        return e8.code === "P2009" || e8.code === "P2012";
      }
      function Lu(e8) {
        if (e8.kind === "Union")
          return { kind: "Union", errors: e8.errors.map(Lu) };
        if (Array.isArray(e8.selectionPath)) {
          let [, ...t5] = e8.selectionPath;
          return { ...e8, selectionPath: t5 };
        }
        return e8;
      }
      d2();
      p2();
      f();
      var Bu = "5.5.2";
      var ju = Bu;
      d2();
      p2();
      f();
      function Uu(e8) {
        return e8.map((t5) => {
          let r6 = {};
          for (let n3 of Object.keys(t5))
            r6[n3] = $u(t5[n3]);
          return r6;
        });
      }
      function $u({ prisma__type: e8, prisma__value: t5 }) {
        switch (e8) {
          case "bigint":
            return BigInt(t5);
          case "bytes":
            return x2.Buffer.from(t5, "base64");
          case "decimal":
            return new je(t5);
          case "datetime":
          case "date":
            return new Date(t5);
          case "time":
            return /* @__PURE__ */ new Date(`1970-01-01T${t5}Z`);
          case "array":
            return t5.map($u);
          default:
            return t5;
        }
      }
      d2();
      p2();
      f();
      var Gu = ve(ui());
      d2();
      p2();
      f();
      var Q = class extends Error {
        constructor(t5) {
          super(t5 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
        }
        get [Symbol.toStringTag]() {
          return "PrismaClientConstructorValidationError";
        }
      };
      k2(Q, "PrismaClientConstructorValidationError");
      var qu = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "__internal"];
      var Vu = ["pretty", "colorless", "minimal"];
      var Ku = ["info", "query", "warn", "error"];
      var $d = { datasources: (e8, { datasourceNames: t5 }) => {
        if (e8) {
          if (typeof e8 != "object" || Array.isArray(e8))
            throw new Q(`Invalid value ${JSON.stringify(e8)} for "datasources" provided to PrismaClient constructor`);
          for (let [r6, n3] of Object.entries(e8)) {
            if (!t5.includes(r6)) {
              let o = er(r6, t5) || ` Available datasources: ${t5.join(", ")}`;
              throw new Q(`Unknown datasource ${r6} provided to PrismaClient constructor.${o}`);
            }
            if (typeof n3 != "object" || Array.isArray(n3))
              throw new Q(`Invalid value ${JSON.stringify(e8)} for datasource "${r6}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (n3 && typeof n3 == "object")
              for (let [o, i2] of Object.entries(n3)) {
                if (o !== "url")
                  throw new Q(`Invalid value ${JSON.stringify(e8)} for datasource "${r6}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
                if (typeof i2 != "string")
                  throw new Q(`Invalid value ${JSON.stringify(i2)} for datasource "${r6}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
              }
          }
        }
      }, adapter: (e8, t5) => {
        if (e8 === null)
          return;
        if (e8 === void 0)
          throw new Q('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
        if (!Bn(t5).includes("driverAdapters"))
          throw new Q('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
      }, datasourceUrl: (e8) => {
        if (typeof e8 != "undefined" && typeof e8 != "string")
          throw new Q(`Invalid value ${JSON.stringify(e8)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
      }, errorFormat: (e8) => {
        if (e8) {
          if (typeof e8 != "string")
            throw new Q(`Invalid value ${JSON.stringify(e8)} for "errorFormat" provided to PrismaClient constructor.`);
          if (!Vu.includes(e8)) {
            let t5 = er(e8, Vu);
            throw new Q(`Invalid errorFormat ${e8} provided to PrismaClient constructor.${t5}`);
          }
        }
      }, log: (e8) => {
        if (!e8)
          return;
        if (!Array.isArray(e8))
          throw new Q(`Invalid value ${JSON.stringify(e8)} for "log" provided to PrismaClient constructor.`);
        function t5(r6) {
          if (typeof r6 == "string" && !Ku.includes(r6)) {
            let n3 = er(r6, Ku);
            throw new Q(`Invalid log level "${r6}" provided to PrismaClient constructor.${n3}`);
          }
        }
        for (let r6 of e8) {
          t5(r6);
          let n3 = { level: t5, emit: (o) => {
            let i2 = ["stdout", "event"];
            if (!i2.includes(o)) {
              let s3 = er(o, i2);
              throw new Q(`Invalid value ${JSON.stringify(o)} for "emit" in logLevel provided to PrismaClient constructor.${s3}`);
            }
          } };
          if (r6 && typeof r6 == "object")
            for (let [o, i2] of Object.entries(r6))
              if (n3[o])
                n3[o](i2);
              else
                throw new Q(`Invalid property ${o} for "log" provided to PrismaClient constructor`);
        }
      }, __internal: (e8) => {
        if (!e8)
          return;
        let t5 = ["debug", "hooks", "engine", "measurePerformance"];
        if (typeof e8 != "object")
          throw new Q(`Invalid value ${JSON.stringify(e8)} for "__internal" to PrismaClient constructor`);
        for (let [r6] of Object.entries(e8))
          if (!t5.includes(r6)) {
            let n3 = er(r6, t5);
            throw new Q(`Invalid property ${JSON.stringify(r6)} for "__internal" provided to PrismaClient constructor.${n3}`);
          }
      } };
      function Ju(e8, t5) {
        for (let [r6, n3] of Object.entries(e8)) {
          if (!qu.includes(r6)) {
            let o = er(r6, qu);
            throw new Q(`Unknown property ${r6} provided to PrismaClient constructor.${o}`);
          }
          $d[r6](n3, t5);
        }
        if (e8.datasourceUrl && e8.datasources)
          throw new Q('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
      }
      function er(e8, t5) {
        if (t5.length === 0 || typeof e8 != "string")
          return "";
        let r6 = qd(e8, t5);
        return r6 ? ` Did you mean "${r6}"?` : "";
      }
      function qd(e8, t5) {
        if (t5.length === 0)
          return null;
        let r6 = t5.map((o) => ({ value: o, distance: (0, Gu.default)(e8, o) }));
        r6.sort((o, i2) => o.distance < i2.distance ? -1 : 1);
        let n3 = r6[0];
        return n3.distance < 3 ? n3.value : null;
      }
      d2();
      p2();
      f();
      function Qu(e8) {
        return e8.length === 0 ? Promise.resolve([]) : new Promise((t5, r6) => {
          let n3 = new Array(e8.length), o = null, i2 = false, s3 = 0, a4 = () => {
            i2 || (s3++, s3 === e8.length && (i2 = true, o ? r6(o) : t5(n3)));
          }, u2 = (l) => {
            i2 || (i2 = true, r6(l));
          };
          for (let l = 0; l < e8.length; l++)
            e8[l].then((c2) => {
              n3[l] = c2, a4();
            }, (c2) => {
              if (!Gn(c2)) {
                u2(c2);
                return;
              }
              c2.batchRequestIdx === l ? u2(c2) : (o || (o = c2), a4());
            });
        });
      }
      var ct = he("prisma:client");
      typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
      var Vd = { requestArgsToMiddlewareArgs: (e8) => e8, middlewareArgsToRequestArgs: (e8) => e8 };
      var Kd = Symbol.for("prisma.client.transaction.id");
      var Gd = { id: 0, nextId() {
        return ++this.id;
      } };
      function zu(e8) {
        class t5 {
          constructor(n3) {
            this._middlewares = new Kn();
            this._createPrismaPromise = di();
            this.$extends = _a;
            var u2, l, c2, m2, g2, w;
            Za(e8), n3 && Ju(n3, e8);
            let o = n3 != null && n3.adapter ? Qs(n3.adapter) : void 0, i2 = new Hu.EventEmitter().on("error", () => {
            });
            this._extensions = Dn.empty(), this._previewFeatures = Bn(e8), this._clientVersion = (u2 = e8.clientVersion) != null ? u2 : ju, this._activeProvider = e8.activeProvider, this._tracingHelper = Fu(this._previewFeatures);
            let s3 = { rootEnvPath: e8.relativeEnvPaths.rootEnvPath && Lr.default.resolve(e8.dirname, e8.relativeEnvPaths.rootEnvPath), schemaEnvPath: e8.relativeEnvPaths.schemaEnvPath && Lr.default.resolve(e8.dirname, e8.relativeEnvPaths.schemaEnvPath) }, a4 = (l = e8.injectableEdgeEnv) == null ? void 0 : l.call(e8);
            try {
              let E = n3 != null ? n3 : {}, b2 = (c2 = E.__internal) != null ? c2 : {}, T = b2.debug === true;
              T && he.enable("prisma:client");
              let S = Lr.default.resolve(e8.dirname, e8.relativePath);
              un.existsSync(S) || (S = e8.dirname), ct("dirname", e8.dirname), ct("relativePath", e8.relativePath), ct("cwd", S);
              let R = b2.engine || {};
              if (E.errorFormat ? this._errorFormat = E.errorFormat : y2.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : y2.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e8.runtimeDataModel, this._engineConfig = { cwd: S, dirname: e8.dirname, enableDebugLogs: T, allowTriggerPanic: R.allowTriggerPanic, datamodelPath: Lr.default.join(e8.dirname, (m2 = e8.filename) != null ? m2 : "schema.prisma"), prismaPath: (g2 = R.binaryPath) != null ? g2 : void 0, engineEndpoint: R.endpoint, generator: e8.generator, showColors: this._errorFormat === "pretty", logLevel: E.log && ku(E.log), logQueries: E.log && !!(typeof E.log == "string" ? E.log === "query" : E.log.find((C) => typeof C == "string" ? C === "query" : C.level === "query")), env: (w = a4 == null ? void 0 : a4.parsed) != null ? w : {}, flags: [], clientVersion: e8.clientVersion, engineVersion: e8.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e8.activeProvider, inlineSchema: e8.inlineSchema, overrideDatasources: Ya(E, e8.datasourceNames), inlineDatasources: e8.inlineDatasources, inlineSchemaHash: e8.inlineSchemaHash, tracingHelper: this._tracingHelper, logEmitter: i2, isBundled: e8.isBundled, adapter: o }, ct("clientVersion", e8.clientVersion), this._engine = au(e8, this._engineConfig), this._requestHandler = new Wn(this, i2), E.log)
                for (let C of E.log) {
                  let M = typeof C == "string" ? C : C.emit === "stdout" ? C.level : null;
                  M && this.$on(M, (N) => {
                    var L;
                    Bt.log(`${(L = Bt.tags[M]) != null ? L : ""}`, N.message || N.query);
                  });
                }
              this._metrics = new Ut(this._engine);
            } catch (E) {
              throw E.clientVersion = this._clientVersion, E;
            }
            return this._appliedParent = wr(this);
          }
          get [Symbol.toStringTag]() {
            return "PrismaClient";
          }
          $use(n3) {
            this._middlewares.use(n3);
          }
          $on(n3, o) {
            n3 === "beforeExit" ? this._engine.on("beforeExit", o) : this._engine.on(n3, (i2) => {
              var a4, u2, l, c2;
              let s3 = i2.fields;
              return o(n3 === "query" ? { timestamp: i2.timestamp, query: (a4 = s3 == null ? void 0 : s3.query) != null ? a4 : i2.query, params: (u2 = s3 == null ? void 0 : s3.params) != null ? u2 : i2.params, duration: (l = s3 == null ? void 0 : s3.duration_ms) != null ? l : i2.duration, target: i2.target } : { timestamp: i2.timestamp, message: (c2 = s3 == null ? void 0 : s3.message) != null ? c2 : i2.message, target: i2.target });
            });
          }
          $connect() {
            try {
              return this._engine.start();
            } catch (n3) {
              throw n3.clientVersion = this._clientVersion, n3;
            }
          }
          async $disconnect() {
            try {
              await this._engine.stop();
            } catch (n3) {
              throw n3.clientVersion = this._clientVersion, n3;
            } finally {
              Ps();
            }
          }
          $executeRawInternal(n3, o, i2, s3) {
            var l;
            let a4 = this._activeProvider, u2 = (l = this._engineConfig.adapter) == null ? void 0 : l.flavour;
            return this._request({ action: "executeRaw", args: i2, transaction: n3, clientMethod: o, argsMapper: fi({ clientMethod: o, activeProvider: a4, activeProviderFlavour: u2 }), callsite: lt(this._errorFormat), dataPath: [], middlewareArgsMapper: s3 });
          }
          $executeRaw(n3, ...o) {
            return this._createPrismaPromise((i2) => {
              if (n3.raw !== void 0 || n3.sql !== void 0) {
                let [s3, a4] = Wu(n3, o);
                return pi(this._activeProvider, s3.text, s3.values, Array.isArray(n3) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(i2, "$executeRaw", s3, a4);
              }
              throw new pe("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
            });
          }
          $executeRawUnsafe(n3, ...o) {
            return this._createPrismaPromise((i2) => (pi(this._activeProvider, n3, o, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(i2, "$executeRawUnsafe", [n3, ...o])));
          }
          $runCommandRaw(n3) {
            if (e8.activeProvider !== "mongodb")
              throw new pe(`The ${e8.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
            return this._createPrismaPromise((o) => this._request({ args: n3, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: Eu, callsite: lt(this._errorFormat), transaction: o }));
          }
          async $queryRawInternal(n3, o, i2, s3) {
            var l;
            let a4 = this._activeProvider, u2 = (l = this._engineConfig.adapter) == null ? void 0 : l.flavour;
            return this._request({ action: "queryRaw", args: i2, transaction: n3, clientMethod: o, argsMapper: fi({ clientMethod: o, activeProvider: a4, activeProviderFlavour: u2 }), callsite: lt(this._errorFormat), dataPath: [], middlewareArgsMapper: s3 }).then(Uu);
          }
          $queryRaw(n3, ...o) {
            return this._createPrismaPromise((i2) => {
              if (n3.raw !== void 0 || n3.sql !== void 0)
                return this.$queryRawInternal(i2, "$queryRaw", ...Wu(n3, o));
              throw new pe("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
            });
          }
          $queryRawUnsafe(n3, ...o) {
            return this._createPrismaPromise((i2) => this.$queryRawInternal(i2, "$queryRawUnsafe", [n3, ...o]));
          }
          _transactionWithArray({ promises: n3, options: o }) {
            let i2 = Gd.nextId(), s3 = Iu(n3.length), a4 = n3.map((u2, l) => {
              var g2, w;
              if ((u2 == null ? void 0 : u2[Symbol.toStringTag]) !== "PrismaPromise")
                throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
              let c2 = o == null ? void 0 : o.isolationLevel, m2 = { kind: "batch", id: i2, index: l, isolationLevel: c2, lock: s3 };
              return (w = (g2 = u2.requestTransaction) == null ? void 0 : g2.call(u2, m2)) != null ? w : u2;
            });
            return Qu(a4);
          }
          async _transactionWithCallback({ callback: n3, options: o }) {
            let i2 = { traceparent: this._tracingHelper.getTraceParent() }, s3 = await this._engine.transaction("start", i2, o), a4;
            try {
              let u2 = { kind: "itx", ...s3 };
              a4 = await n3(this._createItxClient(u2)), await this._engine.transaction("commit", i2, s3);
            } catch (u2) {
              throw await this._engine.transaction("rollback", i2, s3).catch(() => {
              }), u2;
            }
            return a4;
          }
          _createItxClient(n3) {
            return wr(Le(Fn(this), [ge("_appliedParent", () => this._appliedParent._createItxClient(n3)), ge("_createPrismaPromise", () => di(n3)), ge(Kd, () => n3.id), yr(gi)]));
          }
          $transaction(n3, o) {
            let i2;
            typeof n3 == "function" ? i2 = () => this._transactionWithCallback({ callback: n3, options: o }) : i2 = () => this._transactionWithArray({ promises: n3, options: o });
            let s3 = { name: "transaction", attributes: { method: "$transaction" } };
            return this._tracingHelper.runInChildSpan(s3, i2);
          }
          _request(n3) {
            var l;
            n3.otelParentCtx = this._tracingHelper.getActiveContext();
            let o = (l = n3.middlewareArgsMapper) != null ? l : Vd, i2 = { args: o.requestArgsToMiddlewareArgs(n3.args), dataPath: n3.dataPath, runInTransaction: !!n3.transaction, action: n3.action, model: n3.model }, s3 = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: i2.action, model: i2.model, name: i2.model ? `${i2.model}.${i2.action}` : i2.action } } }, a4 = -1, u2 = async (c2) => {
              let m2 = this._middlewares.get(++a4);
              if (m2)
                return this._tracingHelper.runInChildSpan(s3.middleware, (S) => m2(c2, (R) => (S == null || S.end(), u2(R))));
              let { runInTransaction: g2, args: w, ...E } = c2, b2 = { ...n3, ...E };
              w && (b2.args = o.middlewareArgsToRequestArgs(w)), n3.transaction !== void 0 && g2 === false && delete b2.transaction;
              let T = await qa(this, b2);
              return b2.model ? Ba({ result: T, modelName: b2.model, args: b2.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : T;
            };
            return this._tracingHelper.runInChildSpan(s3.operation, () => u2(i2));
          }
          async _executeRequest({ args: n3, clientMethod: o, dataPath: i2, callsite: s3, action: a4, model: u2, argsMapper: l, transaction: c2, unpacker: m2, otelParentCtx: g2, customDataProxyFetch: w }) {
            try {
              n3 = l ? l(n3) : n3;
              let E = { name: "serialize" }, b2 = this._tracingHelper.runInChildSpan(E, () => xu({ modelName: u2, runtimeDataModel: this._runtimeDataModel, action: a4, args: n3, clientMethod: o, callsite: s3, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
              return he.enabled("prisma:client") && (ct("Prisma Client call:"), ct(`prisma.${o}(${xa(n3)})`), ct("Generated request:"), ct(JSON.stringify(b2, null, 2) + `
`)), (c2 == null ? void 0 : c2.kind) === "batch" && await c2.lock, this._requestHandler.request({ protocolQuery: b2, modelName: u2, action: a4, clientMethod: o, dataPath: i2, callsite: s3, args: n3, extensions: this._extensions, transaction: c2, unpacker: m2, otelParentCtx: g2, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: w });
            } catch (E) {
              throw E.clientVersion = this._clientVersion, E;
            }
          }
          get $metrics() {
            if (!this._hasPreviewFlag("metrics"))
              throw new pe("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
            return this._metrics;
          }
          _hasPreviewFlag(n3) {
            var o;
            return !!((o = this._engineConfig.previewFeatures) != null && o.includes(n3));
          }
        }
        return t5;
      }
      function Wu(e8, t5) {
        return Jd(e8) ? [new xe(e8, t5), Mu] : [e8, Su];
      }
      function Jd(e8) {
        return Array.isArray(e8) && Array.isArray(e8.raw);
      }
      d2();
      p2();
      f();
      var Qd = /* @__PURE__ */ new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
      function Zu(e8) {
        return new Proxy(e8, { get(t5, r6) {
          if (r6 in t5)
            return t5[r6];
          if (!Qd.has(r6))
            throw new TypeError(`Invalid enum value: ${String(r6)}`);
        } });
      }
      d2();
      p2();
      f();
    }
  });

  // ../node_modules/.prisma/client/edge.js
  var require_edge2 = __commonJS({
    "../node_modules/.prisma/client/edge.js"(exports) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      var {
        PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
        PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
        PrismaClientRustPanicError: PrismaClientRustPanicError2,
        PrismaClientInitializationError: PrismaClientInitializationError2,
        PrismaClientValidationError: PrismaClientValidationError2,
        NotFoundError: NotFoundError3,
        getPrismaClient: getPrismaClient2,
        sqltag: sqltag2,
        empty: empty2,
        join: join3,
        raw: raw2,
        Decimal: Decimal2,
        Debug: Debug2,
        objectEnumValues: objectEnumValues2,
        makeStrictEnum: makeStrictEnum2,
        Extensions: Extensions2,
        warnOnce: warnOnce2,
        defineDmmfProperty: defineDmmfProperty2,
        Public: Public2
      } = require_edge();
      var Prisma = {};
      exports.Prisma = Prisma;
      exports.$Enums = {};
      Prisma.prismaVersion = {
        client: "5.5.2",
        engine: "aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a"
      };
      Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
      Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
      Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
      Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
      Prisma.PrismaClientValidationError = PrismaClientValidationError2;
      Prisma.NotFoundError = NotFoundError3;
      Prisma.Decimal = Decimal2;
      Prisma.sql = sqltag2;
      Prisma.empty = empty2;
      Prisma.join = join3;
      Prisma.raw = raw2;
      Prisma.validator = Public2.validator;
      Prisma.getExtensionContext = Extensions2.getExtensionContext;
      Prisma.defineExtension = Extensions2.defineExtension;
      Prisma.DbNull = objectEnumValues2.instances.DbNull;
      Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
      Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
      Prisma.NullTypes = {
        DbNull: objectEnumValues2.classes.DbNull,
        JsonNull: objectEnumValues2.classes.JsonNull,
        AnyNull: objectEnumValues2.classes.AnyNull
      };
      exports.Prisma.GeoJSONScalarFieldEnum = {
        id: "id",
        type: "type",
        id_: "id_",
        properties: "properties",
        createdAt: "createdAt",
        updatedAt: "updatedAt",
        trip_id: "trip_id"
      };
      exports.Prisma.ItemCategoryScalarFieldEnum = {
        id: "id",
        name: "name",
        createdAt: "createdAt",
        updatedAt: "updatedAt"
      };
      exports.Prisma.ItemScalarFieldEnum = {
        id: "id",
        name: "name",
        weight: "weight",
        quantity: "quantity",
        unit: "unit",
        global: "global",
        pack_ids: "pack_ids",
        itemCategoryId: "itemCategoryId",
        createdAt: "createdAt",
        updatedAt: "updatedAt"
      };
      exports.Prisma.PackScalarFieldEnum = {
        id: "id",
        name: "name",
        owner_id: "owner_id",
        owner_ids: "owner_ids",
        is_public: "is_public",
        type: "type",
        item_ids: "item_ids",
        favourited_by_ids: "favourited_by_ids",
        createdAt: "createdAt",
        updatedAt: "updatedAt",
        total_weight: "total_weight",
        total_scores: "total_scores",
        favorites_count: "favorites_count"
      };
      exports.Prisma.TemplateScalarFieldEnum = {
        id: "id",
        type: "type",
        templateId: "templateId",
        isGlobalTemplate: "isGlobalTemplate",
        createdById: "createdById",
        createdAt: "createdAt",
        updatedAt: "updatedAt"
      };
      exports.Prisma.TripScalarFieldEnum = {
        id: "id",
        name: "name",
        description: "description",
        duration: "duration",
        weather: "weather",
        start_date: "start_date",
        end_date: "end_date",
        destination: "destination",
        owner_id: "owner_id",
        is_public: "is_public",
        type: "type",
        pack_id: "pack_id",
        createdAt: "createdAt",
        updatedAt: "updatedAt"
      };
      exports.Prisma.UserScalarFieldEnum = {
        id: "id",
        name: "name",
        password: "password",
        email: "email",
        token: "token",
        code: "code",
        googleId: "googleId",
        is_certified_guide: "is_certified_guide",
        passwordResetToken: "passwordResetToken",
        passwordResetTokenExpiration: "passwordResetTokenExpiration",
        role: "role",
        username: "username",
        profileImage: "profileImage",
        preferredWeather: "preferredWeather",
        preferredWeight: "preferredWeight",
        favourite_ids: "favourite_ids",
        pack_ids: "pack_ids",
        item_id: "item_id",
        createdAt: "createdAt",
        updatedAt: "updatedAt"
      };
      exports.Prisma.ConversationScalarFieldEnum = {
        id: "id",
        userId: "userId",
        history: "history",
        createdAt: "createdAt",
        updatedAt: "updatedAt"
      };
      exports.Prisma.WayScalarFieldEnum = {
        id: "id",
        osm_id: "osm_id",
        osm_type: "osm_type",
        tags: "tags",
        geoJSON: "geoJSON",
        createdAt: "createdAt",
        updated_at: "updated_at"
      };
      exports.Prisma.NodeScalarFieldEnum = {
        id: "id",
        osm_id: "osm_id",
        lat: "lat",
        lon: "lon",
        osm_type: "osm_type",
        tags: "tags",
        createdAt: "createdAt",
        updated_at: "updated_at",
        wayId: "wayId"
      };
      exports.Prisma.RelationScalarFieldEnum = {
        id: "id",
        osm_id: "osm_id",
        osm_type: "osm_type",
        tags: "tags",
        geoJSON: "geoJSON",
        createdAt: "createdAt",
        updated_at: "updated_at"
      };
      exports.Prisma.SortOrder = {
        asc: "asc",
        desc: "desc"
      };
      exports.Prisma.QueryMode = {
        default: "default",
        insensitive: "insensitive"
      };
      exports.ItemCategoryName = exports.$Enums.ItemCategoryName = {
        Food: "Food",
        Water: "Water",
        Essentials: "Essentials"
      };
      exports.TemplateType = exports.$Enums.TemplateType = {
        pack: "pack",
        trip: "trip",
        item: "item"
      };
      exports.Role = exports.$Enums.Role = {
        user: "user",
        admin: "admin"
      };
      exports.GeoJSONGeometryType = exports.$Enums.GeoJSONGeometryType = {
        Point: "Point",
        LineString: "LineString",
        Polygon: "Polygon",
        MultiPoint: "MultiPoint",
        MultiPolygon: "MultiPolygon",
        MultiLineString: "MultiLineString"
      };
      exports.MemberType = exports.$Enums.MemberType = {
        way: "way",
        node: "node",
        relation: "relation"
      };
      exports.Prisma.ModelName = {
        GeoJSON: "GeoJSON",
        ItemCategory: "ItemCategory",
        Item: "Item",
        Pack: "Pack",
        Template: "Template",
        Trip: "Trip",
        User: "User",
        Conversation: "Conversation",
        Way: "Way",
        Node: "Node",
        Relation: "Relation"
      };
      var config4 = {
        "generator": {
          "name": "client",
          "provider": {
            "fromEnvVar": null,
            "value": "prisma-client-js"
          },
          "output": {
            "value": "/home/awais/PackRat/node_modules/@prisma/client",
            "fromEnvVar": null
          },
          "config": {
            "engineType": "library"
          },
          "binaryTargets": [
            {
              "fromEnvVar": null,
              "value": "debian-openssl-1.1.x",
              "native": true
            }
          ],
          "previewFeatures": []
        },
        "relativeEnvPaths": {
          "rootEnvPath": null,
          "schemaEnvPath": "../../../server/src/prisma/.env"
        },
        "relativePath": "../../../server/src/prisma",
        "clientVersion": "5.5.2",
        "engineVersion": "aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a",
        "datasourceNames": [
          "db"
        ],
        "activeProvider": "mongodb",
        "postinstall": false,
        "inlineDatasources": {
          "db": {
            "url": {
              "fromEnvVar": "MONGODB_URI",
              "value": null
            }
          }
        },
        "inlineSchema": "Z2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgPSAicHJpc21hLWNsaWVudC1qcyIKfQoKZGF0YXNvdXJjZSBkYiB7CiAgcHJvdmlkZXIgPSAibW9uZ29kYiIKICB1cmwgICAgICA9IGVudigiTU9OR09EQl9VUkkiKQp9CgovLyAg4paI4paI4paIICAgIOKWiOKWiOKWiCAg4paI4paI4paI4paI4paI4paIICDilojilojilojilojilojiloggIOKWiOKWiOKWiOKWiOKWiOKWiOKWiCDilojiloggICAgICDilojilojilojilojilojilojilogKLy8gIOKWiOKWiOKWiOKWiCAg4paI4paI4paI4paIIOKWiOKWiCAgICDilojilogg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAgIOKWiOKWiCAgICAgIOKWiOKWiAovLyAg4paI4paIIOKWiOKWiOKWiOKWiCDilojilogg4paI4paIICAgIOKWiOKWiCDilojiloggICDilojilogg4paI4paI4paI4paI4paIICAg4paI4paIICAgICAg4paI4paI4paI4paI4paI4paI4paICi8vICDilojiloggIOKWiOKWiCAg4paI4paIIOKWiOKWiCAgICDilojilogg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAgIOKWiOKWiCAgICAgICAgICAg4paI4paICi8vICDilojiloggICAgICDilojiloggIOKWiOKWiOKWiOKWiOKWiOKWiCAg4paI4paI4paI4paI4paI4paIICDilojilojilojilojilojilojilogg4paI4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAoKbW9kZWwgR2VvSlNPTiB7CiAgaWQgICAgICAgICBTdHJpbmcgICAgICAgICAgQGlkIEBkZWZhdWx0KGF1dG8oKSkgQG1hcCgiX2lkIikgQGRiLk9iamVjdElkCiAgdHlwZSAgICAgICBTdHJpbmcKICBpZF8gICAgICAgIFN0cmluZyAgICAgICAgICBAdW5pcXVlKG1hcDogImlkXzEiKSBAbWFwKCJpZCIpCiAgcHJvcGVydGllcyBKc29uCiAgZ2VvbWV0cnkgICBHZW9KU09OR2VvbWV0cnkKICBjcmVhdGVkQXQgIERhdGVUaW1lPyAgICAgICBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkQXQgIERhdGVUaW1lPyAgICAgICBAdXBkYXRlZEF0CiAgdHJpcF9pZCAgICBTdHJpbmcgICAgICAgICAgQGRiLk9iamVjdElkCiAgVHJpcCAgICAgICBUcmlwPyAgICAgICAgICAgQHJlbGF0aW9uKGZpZWxkczogW3RyaXBfaWRdLCByZWZlcmVuY2VzOiBbaWRdKQoKICBAQG1hcCgiZ2VvanNvbnMiKQp9Cgptb2RlbCBJdGVtQ2F0ZWdvcnkgewogIGlkICAgICAgICBTdHJpbmcgICAgICAgICAgIEBpZCBAZGVmYXVsdChhdXRvKCkpIEBtYXAoIl9pZCIpIEBkYi5PYmplY3RJZAogIG5hbWUgICAgICBJdGVtQ2F0ZWdvcnlOYW1lCiAgY3JlYXRlZEF0IERhdGVUaW1lPyAgICAgICAgQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZEF0IERhdGVUaW1lPyAgICAgICAgQHVwZGF0ZWRBdAogIEl0ZW0gICAgICBJdGVtW10KCiAgQEBpbmRleChbbmFtZV0sIG1hcDogIm5hbWVfMSIpCiAgQEBtYXAoIml0ZW1jYXRlZ29yaWVzIikKfQoKbW9kZWwgSXRlbSB7CiAgaWQgICAgICAgICAgICAgU3RyaW5nICAgICAgICBAaWQgQGRlZmF1bHQoYXV0bygpKSBAbWFwKCJfaWQiKSBAZGIuT2JqZWN0SWQKICBuYW1lICAgICAgICAgICBTdHJpbmc/CiAgd2VpZ2h0ICAgICAgICAgRmxvYXQ/CiAgcXVhbnRpdHkgICAgICAgSW50PwogIHVuaXQgICAgICAgICAgIFN0cmluZz8KICBnbG9iYWwgICAgICAgICBCb29sZWFuPyAgICAgIEBkZWZhdWx0KGZhbHNlKQogIHBhY2tfaWRzICAgICAgIFN0cmluZ1tdICAgICAgQGRiLk9iamVjdElkCiAgaXRlbUNhdGVnb3J5SWQgU3RyaW5nPyAgICAgICBAZGIuT2JqZWN0SWQKICBjcmVhdGVkQXQgICAgICBEYXRlVGltZT8gICAgIEBkZWZhdWx0KG5vdygpKQogIHVwZGF0ZWRBdCAgICAgIERhdGVUaW1lPyAgICAgQHVwZGF0ZWRBdAogIGNhdGVnb3J5ICAgICAgIEl0ZW1DYXRlZ29yeT8gQHJlbGF0aW9uKGZpZWxkczogW2l0ZW1DYXRlZ29yeUlkXSwgcmVmZXJlbmNlczogW2lkXSkKICBvd25lcnMgICAgICAgICBVc2VyW10KICBwYWNrcyAgICAgICAgICBQYWNrW10gICAgICAgIEByZWxhdGlvbihmaWVsZHM6IFtwYWNrX2lkc10sIHJlZmVyZW5jZXM6IFtpZF0pCgogIEBAaW5kZXgoW25hbWVdLCBtYXA6ICJuYW1lXzEiKQogIEBAaW5kZXgoW3dlaWdodF0sIG1hcDogIndlaWdodF8xIikKICBAQGluZGV4KFt1bml0XSwgbWFwOiAidW5pdF8xIikKICBAQG1hcCgiaXRlbXMiKQp9Cgptb2RlbCBQYWNrIHsKICBpZCAgICAgICAgICAgICAgICBTdHJpbmcgICAgICAgQGlkIEBkZWZhdWx0KGF1dG8oKSkgQG1hcCgiX2lkIikgQGRiLk9iamVjdElkCiAgbmFtZSAgICAgICAgICAgICAgU3RyaW5nPwogIG93bmVyX2lkICAgICAgICAgIFN0cmluZz8gICAgICBAZGIuT2JqZWN0SWQKICBvd25lcl9pZHMgICAgICAgICBTdHJpbmdbXSAgICAgQGRiLk9iamVjdElkCiAgaXNfcHVibGljICAgICAgICAgQm9vbGVhbj8KICBncmFkZXMgICAgICAgICAgICBQYWNrc0dyYWRlcz8KICBzY29yZXMgICAgICAgICAgICBQYWNrc1Njb3Jlcz8KICB0eXBlICAgICAgICAgICAgICBTdHJpbmc/ICAgICAgQGRlZmF1bHQoInBhY2siKQogIGl0ZW1faWRzICAgICAgICAgIFN0cmluZ1tdICAgICBAZGIuT2JqZWN0SWQKICBmYXZvdXJpdGVkX2J5X2lkcyBTdHJpbmdbXSAgICAgQGRiLk9iamVjdElkCiAgY3JlYXRlZEF0ICAgICAgICAgU3RyaW5nPwogIHVwZGF0ZWRBdCAgICAgICAgIERhdGVUaW1lPyAgICBAdXBkYXRlZEF0CiAgaXRlbXMgICAgICAgICAgICAgSXRlbVtdICAgICAgIEByZWxhdGlvbihmaWVsZHM6IFtpdGVtX2lkc10sIHJlZmVyZW5jZXM6IFtpZF0pCiAgZmF2b3JpdGVkX2J5ICAgICAgVXNlcltdICAgICAgIEByZWxhdGlvbihuYW1lOiAiRmF2b3VyaXRlcyIsIGZpZWxkczogW2Zhdm91cml0ZWRfYnlfaWRzXSwgcmVmZXJlbmNlczogW2lkXSkKICBvd25lcnMgICAgICAgICAgICBVc2VyW10gICAgICAgQHJlbGF0aW9uKG5hbWU6ICJPd25lcnMiLCBmaWVsZHM6IFtvd25lcl9pZHNdLCByZWZlcmVuY2VzOiBbaWRdKQogIG93bmVyICAgICAgICAgICAgIFVzZXI/ICAgICAgICBAcmVsYXRpb24oZmllbGRzOiBbb3duZXJfaWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIHRyaXBzICAgICAgICAgICAgIFRyaXBbXQoKICAvLyBWaXJ0dWFscwogIHRvdGFsX3dlaWdodCAgICBGbG9hdD8KICB0b3RhbF9zY29yZXMgICAgSW50PwogIGZhdm9yaXRlc19jb3VudCBJbnQ/CgogIEBAaW5kZXgoW25hbWVdLCBtYXA6ICJuYW1lXzEiKQogIEBAaW5kZXgoW2lzX3B1YmxpY10sIG1hcDogImlzX3B1YmxpY18xIikKICBAQG1hcCgicGFja3MiKQp9Cgptb2RlbCBUZW1wbGF0ZSB7CiAgaWQgICAgICAgICAgICAgICBTdHJpbmcgICAgICAgQGlkIEBkZWZhdWx0KGF1dG8oKSkgQG1hcCgiX2lkIikgQGRiLk9iamVjdElkCiAgdHlwZSAgICAgICAgICAgICBUZW1wbGF0ZVR5cGUKICB0ZW1wbGF0ZUlkICAgICAgIFN0cmluZz8gICAgICBAZGIuT2JqZWN0SWQKICBpc0dsb2JhbFRlbXBsYXRlIEJvb2xlYW4/ICAgICBAZGVmYXVsdChmYWxzZSkKICBjcmVhdGVkQnlJZCAgICAgIFN0cmluZz8gICAgICBAZGIuT2JqZWN0SWQKICBjcmVhdGVkQXQgICAgICAgIERhdGVUaW1lPyAgICBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkQXQgICAgICAgIERhdGVUaW1lPyAgICBAdXBkYXRlZEF0CiAgY3JlYXRlZEJ5ICAgICAgICBVc2VyPyAgICAgICAgQHJlbGF0aW9uKGZpZWxkczogW2NyZWF0ZWRCeUlkXSwgcmVmZXJlbmNlczogW2lkXSkKCiAgQEBpbmRleChbdHlwZV0sIG1hcDogInR5cGVfMSIpCiAgQEBpbmRleChbdGVtcGxhdGVJZF0sIG1hcDogInRlbXBsYXRlSWRfMSIpCiAgQEBpbmRleChbY3JlYXRlZEJ5SWRdLCBtYXA6ICJjcmVhdGVkQnlfMSIpCiAgQEBtYXAoInRlbXBsYXRlcyIpCn0KCm1vZGVsIFRyaXAgewogIGlkICAgICAgICAgIFN0cmluZyAgICBAaWQgQGRlZmF1bHQoYXV0bygpKSBAbWFwKCJfaWQiKSBAZGIuT2JqZWN0SWQKICBuYW1lICAgICAgICBTdHJpbmcKICBkZXNjcmlwdGlvbiBTdHJpbmcKICBkdXJhdGlvbiAgICBTdHJpbmcKICB3ZWF0aGVyICAgICBTdHJpbmcKICBzdGFydF9kYXRlICBEYXRlVGltZQogIGVuZF9kYXRlICAgIERhdGVUaW1lCiAgZGVzdGluYXRpb24gU3RyaW5nCiAgb3duZXJfaWQgICAgU3RyaW5nICAgIEBkYi5PYmplY3RJZAogIGlzX3B1YmxpYyAgIEJvb2xlYW4/CiAgdHlwZSAgICAgICAgU3RyaW5nICAgIEBkZWZhdWx0KCJ0cmlwIikKICBwYWNrX2lkICAgICBTdHJpbmc/ICAgQGRiLk9iamVjdElkCiAgY3JlYXRlZEF0ICAgRGF0ZVRpbWU/IEBkZWZhdWx0KG5vdygpKQogIHVwZGF0ZWRBdCAgIERhdGVUaW1lPyBAdXBkYXRlZEF0CiAgb3duZXIgICAgICAgVXNlciAgICAgIEByZWxhdGlvbihmaWVsZHM6IFtvd25lcl9pZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgcGFja3MgICAgICAgUGFjaz8gICAgIEByZWxhdGlvbihmaWVsZHM6IFtwYWNrX2lkXSwgcmVmZXJlbmNlczogW2lkXSkKICBnZW9qc29uICAgICBHZW9KU09OW10KCiAgQEBpbmRleChbZGVzdGluYXRpb25dLCBtYXA6ICJkZXN0aW5hdGlvbl8xIikKICBAQGluZGV4KFtzdGFydF9kYXRlXSwgbWFwOiAic3RhcnRfZGF0ZV8xIikKICBAQGluZGV4KFtlbmRfZGF0ZV0sIG1hcDogImVuZF9kYXRlXzEiKQogIEBAaW5kZXgoW2lzX3B1YmxpY10sIG1hcDogImlzX3B1YmxpY18xIikKICBAQGluZGV4KFt0eXBlXSwgbWFwOiAidHlwZV8xIikKICBAQG1hcCgidHJpcHMiKQp9Cgptb2RlbCBVc2VyIHsKICBpZCAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZyAgICAgQGlkIEBkZWZhdWx0KGF1dG8oKSkgQG1hcCgiX2lkIikgQGRiLk9iamVjdElkCiAgbmFtZSAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcKICBwYXNzd29yZCAgICAgICAgICAgICAgICAgICAgIFN0cmluZwogIGVtYWlsICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nICAgICBAdW5pcXVlCiAgdG9rZW4gICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmc/CiAgY29kZSAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmc/CiAgZ29vZ2xlSWQgICAgICAgICAgICAgICAgICAgICBTdHJpbmc/CiAgaXNfY2VydGlmaWVkX2d1aWRlICAgICAgICAgICBCb29sZWFuPwogIHBhc3N3b3JkUmVzZXRUb2tlbiAgICAgICAgICAgU3RyaW5nPwogIHBhc3N3b3JkUmVzZXRUb2tlbkV4cGlyYXRpb24gRGF0ZVRpbWU/ICBAZGIuRGF0ZQogIHJvbGUgICAgICAgICAgICAgICAgICAgICAgICAgUm9sZSAgICAgICBAZGVmYXVsdCh1c2VyKQogIHVzZXJuYW1lICAgICAgICAgICAgICAgICAgICAgU3RyaW5nPyAgICBAdW5pcXVlKG1hcDogInVzZXJuYW1lXzEiKQogIHByb2ZpbGVJbWFnZSAgICAgICAgICAgICAgICAgU3RyaW5nPwogIHByZWZlcnJlZFdlYXRoZXIgICAgICAgICAgICAgU3RyaW5nPwogIHByZWZlcnJlZFdlaWdodCAgICAgICAgICAgICAgU3RyaW5nPwogIGZhdm91cml0ZV9pZHMgICAgICAgICAgICAgICAgU3RyaW5nW10gICBAZGIuT2JqZWN0SWQKICBwYWNrX2lkcyAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1tdICAgQGRiLk9iamVjdElkCiAgaXRlbV9pZCAgICAgICAgICAgICAgICAgICAgICBTdHJpbmc/ICAgIEBkYi5PYmplY3RJZAogIGNyZWF0ZWRBdCAgICAgICAgICAgICAgICAgICAgRGF0ZVRpbWU/ICBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkQXQgICAgICAgICAgICAgICAgICAgIERhdGVUaW1lPyAgQHVwZGF0ZWRBdAogIGZhdm9yaXRlcyAgICAgICAgICAgICAgICAgICAgUGFja1tdICAgICBAcmVsYXRpb24obmFtZTogIkZhdm91cml0ZXMiLCBmaWVsZHM6IFtmYXZvdXJpdGVfaWRzXSwgcmVmZXJlbmNlczogW2lkXSkKICBwYWNrcyAgICAgICAgICAgICAgICAgICAgICAgIFBhY2tbXSAgICAgQHJlbGF0aW9uKG5hbWU6ICJPd25lcnMiLCBmaWVsZHM6IFtwYWNrX2lkc10sIHJlZmVyZW5jZXM6IFtpZF0pCiAgaXRlbSAgICAgICAgICAgICAgICAgICAgICAgICBJdGVtPyAgICAgIEByZWxhdGlvbihmaWVsZHM6IFtpdGVtX2lkXSwgcmVmZXJlbmNlczogW2lkXSkKICB0ZW1wbGF0ZXMgICAgICAgICAgICAgICAgICAgIFRlbXBsYXRlW10KICB0cmlwcyAgICAgICAgICAgICAgICAgICAgICAgIFRyaXBbXQogIFBhY2sgICAgICAgICAgICAgICAgICAgICAgICAgUGFja1tdCgogIEBAaW5kZXgoW3JvbGVdLCBtYXA6ICJyb2xlXzEiKQogIEBAaW5kZXgoW2NvZGVdLCBtYXA6ICJjb2RlXzEiKQogIEBAbWFwKCJ1c2VycyIpCn0KCm1vZGVsIENvbnZlcnNhdGlvbiB7CiAgaWQgICAgICAgIFN0cmluZyAgICBAaWQgQGRlZmF1bHQoYXV0bygpKSBAbWFwKCJfaWQiKSBAZGIuT2JqZWN0SWQKICB1c2VySWQgICAgU3RyaW5nCiAgaGlzdG9yeSAgIFN0cmluZwogIGNyZWF0ZWRBdCBEYXRlVGltZT8gQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZEF0IERhdGVUaW1lPyBAdXBkYXRlZEF0CgogIEBAbWFwKCJjb252ZXJzYXRpb25zIikKfQoKbW9kZWwgV2F5IHsKICBpZCAgICAgICAgIFN0cmluZyAgICBAaWQgQGRlZmF1bHQoYXV0bygpKSBAbWFwKCJfaWQiKSBAZGIuT2JqZWN0SWQKICBvc21faWQgICAgIEludD8KICBvc21fdHlwZSAgIFN0cmluZz8gICBAZGVmYXVsdCgid2F5IikKICB0YWdzICAgICAgIEpzb24/CiAgbm9kZXMgICAgICBOb2RlW10KICBnZW9KU09OICAgIEpzb24/CiAgY3JlYXRlZEF0ICBEYXRlVGltZT8gQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZF9hdCBEYXRlVGltZT8gQHVwZGF0ZWRBdAoKICBAQG1hcCgid2F5cyIpCn0KCm1vZGVsIE5vZGUgewogIGlkICAgICAgICAgU3RyaW5nICAgIEBpZCBAZGVmYXVsdChhdXRvKCkpIEBtYXAoIl9pZCIpIEBkYi5PYmplY3RJZAogIG9zbV9pZCAgICAgSW50PyAgICAgIEBtYXAoImlkIikKICBsYXQgICAgICAgIEZsb2F0PwogIGxvbiAgICAgICAgRmxvYXQ/CiAgb3NtX3R5cGUgICBTdHJpbmcgICAgQGRlZmF1bHQoIm5vZGUiKQogIHRhZ3MgICAgICAgSnNvbj8KICBjcmVhdGVkQXQgIERhdGVUaW1lPyBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkX2F0IERhdGVUaW1lPyBAdXBkYXRlZEF0CiAgV2F5ICAgICAgICBXYXk/ICAgICAgQHJlbGF0aW9uKGZpZWxkczogW3dheUlkXSwgcmVmZXJlbmNlczogW2lkXSkKICB3YXlJZCAgICAgIFN0cmluZz8gICBAZGIuT2JqZWN0SWQKCiAgQEBtYXAoIm5vZGVzIikKfQoKbW9kZWwgUmVsYXRpb24gewogIGlkICAgICAgICAgU3RyaW5nICAgIEBpZCBAZGVmYXVsdChhdXRvKCkpIEBtYXAoIl9pZCIpIEBkYi5PYmplY3RJZAogIG9zbV9pZCAgICAgSW50PwogIG9zbV90eXBlICAgU3RyaW5nPyAgIEBkZWZhdWx0KCJyZWxhdGlvbiIpCiAgdGFncyAgICAgICBKc29uPwogIG1lbWJlcnMgICAgTWVtYmVyW10KICBnZW9KU09OICAgIEpzb24/CiAgY3JlYXRlZEF0ICBEYXRlVGltZT8gQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZF9hdCBEYXRlVGltZT8gQHVwZGF0ZWRBdAoKICBAQG1hcCgicmVsYXRpb25zIikKfQoKLy8gIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiCDilojiloggICAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCAg4paI4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAovLyAgICAg4paI4paIICAgICDilojiloggIOKWiOKWiCAg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAgIOKWiOKWiAovLyAgICAg4paI4paIICAgICAg4paI4paI4paI4paIICAg4paI4paI4paI4paI4paI4paIICDilojilojilojilojiloggICDilojilojilojilojilojilojilogKLy8gICAgIOKWiOKWiCAgICAgICDilojiloggICAg4paI4paIICAgICAg4paI4paIICAgICAgICAgICDilojilogKLy8gICAgIOKWiOKWiCAgICAgICDilojiloggICAg4paI4paIICAgICAg4paI4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAoKdHlwZSBNZW1iZXIgewogIHR5cGUgIE1lbWJlclR5cGUKICByZWZJZCBTdHJpbmcgICAgIEBkYi5PYmplY3RJZAogIHJvbGUgIFN0cmluZwp9Cgp0eXBlIEdlb0pTT05HZW9tZXRyeSB7CiAgY29vcmRpbmF0ZXMgSnNvbgogIHR5cGUgICAgICAgIEdlb0pTT05HZW9tZXRyeVR5cGUKfQoKdHlwZSBQYWNrc0dyYWRlcyB7CiAgZXNzZW50aWFsSXRlbXMgICAgICAgICAgIFN0cmluZz8gQGRlZmF1bHQoIiIpCiAgcmVkdW5kYW5jeUFuZFZlcnNhdGlsaXR5IFN0cmluZz8gQGRlZmF1bHQoIiIpCiAgd2VpZ2h0ICAgICAgICAgICAgICAgICAgIFN0cmluZz8gQGRlZmF1bHQoIiIpCn0KCnR5cGUgUGFja3NTY29yZXMgewogIGVzc2VudGlhbEl0ZW1zU2NvcmUgICAgICAgICAgIEludD8gQGRlZmF1bHQoMCkKICByZWR1bmRhbmN5QW5kVmVyc2F0aWxpdHlTY29yZSBJbnQ/IEBkZWZhdWx0KDApCiAgd2VpZ2h0U2NvcmUgICAgICAgICAgICAgICAgICAgSW50PyBAZGVmYXVsdCgwKQp9CgovLyAg4paI4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiCAgICDilojilogg4paI4paIICAgIOKWiOKWiCDilojilojiloggICAg4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAovLyAg4paI4paIICAgICAg4paI4paI4paI4paIICAg4paI4paIIOKWiOKWiCAgICDilojilogg4paI4paI4paI4paIICDilojilojilojilogg4paI4paICi8vICDilojilojilojilojiloggICDilojilogg4paI4paIICDilojilogg4paI4paIICAgIOKWiOKWiCDilojilogg4paI4paI4paI4paIIOKWiOKWiCDilojilojilojilojilojilojilogKLy8gIOKWiOKWiCAgICAgIOKWiOKWiCAg4paI4paIIOKWiOKWiCDilojiloggICAg4paI4paIIOKWiOKWiCAg4paI4paIICDilojiloggICAgICDilojilogKLy8gIOKWiOKWiOKWiOKWiOKWiOKWiOKWiCDilojiloggICDilojilojilojiloggIOKWiOKWiOKWiOKWiOKWiOKWiCAg4paI4paIICAgICAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiAoKZW51bSBNZW1iZXJUeXBlIHsKICB3YXkKICBub2RlCiAgcmVsYXRpb24KfQoKZW51bSBSb2xlIHsKICB1c2VyCiAgYWRtaW4KfQoKZW51bSBJdGVtQ2F0ZWdvcnlOYW1lIHsKICBGb29kCiAgV2F0ZXIKICBFc3NlbnRpYWxzCn0KCmVudW0gVGVtcGxhdGVUeXBlIHsKICBwYWNrCiAgdHJpcAogIGl0ZW0KfQoKZW51bSBHZW9KU09OR2VvbWV0cnlUeXBlIHsKICBQb2ludAogIExpbmVTdHJpbmcKICBQb2x5Z29uCiAgTXVsdGlQb2ludAogIE11bHRpUG9seWdvbgogIE11bHRpTGluZVN0cmluZwp9Cg==",
        "inlineSchemaHash": "68736a86926db8013b590479e33b7d2cdd9adc9e78c086b0a446b596c0fb6400",
        "noEngine": true
      };
      config4.dirname = "/";
      config4.runtimeDataModel = JSON.parse('{"models":{"GeoJSON":{"dbName":"geojsons","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"id_","dbName":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"properties","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"geometry","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"GeoJSONGeometry","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"trip_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"Trip","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Trip","relationName":"GeoJSONToTrip","relationFromFields":["trip_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ItemCategory":{"dbName":"itemcategories","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ItemCategoryName","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"Item","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Item","relationName":"ItemToItemCategory","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Item":{"dbName":"items","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"weight","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"unit","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"global","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"pack_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"itemCategoryId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"category","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ItemCategory","relationName":"ItemToItemCategory","relationFromFields":["itemCategoryId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"owners","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"ItemToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"packs","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"ItemToPack","relationFromFields":["pack_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Pack":{"dbName":"packs","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"owner_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"owner_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"is_public","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","isGenerated":false,"isUpdatedAt":false},{"name":"grades","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PacksGrades","isGenerated":false,"isUpdatedAt":false},{"name":"scores","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PacksScores","isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"pack","isGenerated":false,"isUpdatedAt":false},{"name":"item_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"favourited_by_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"items","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Item","relationName":"ItemToPack","relationFromFields":["item_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"favorited_by","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"Favourites","relationFromFields":["favourited_by_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"owners","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"Owners","relationFromFields":["owner_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"owner","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"PackToUser","relationFromFields":["owner_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"trips","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Trip","relationName":"PackToTrip","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"total_weight","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","isGenerated":false,"isUpdatedAt":false},{"name":"total_scores","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"favorites_count","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Template":{"dbName":"templates","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"TemplateType","isGenerated":false,"isUpdatedAt":false},{"name":"templateId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"isGlobalTemplate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"createdById","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"createdBy","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"TemplateToUser","relationFromFields":["createdById"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Trip":{"dbName":"trips","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"duration","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"weather","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"start_date","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"end_date","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"destination","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"owner_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"is_public","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"trip","isGenerated":false,"isUpdatedAt":false},{"name":"pack_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"owner","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"TripToUser","relationFromFields":["owner_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"packs","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"PackToTrip","relationFromFields":["pack_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"geojson","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"GeoJSON","relationName":"GeoJSONToTrip","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"User":{"dbName":"users","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"token","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"code","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"googleId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"is_certified_guide","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","isGenerated":false,"isUpdatedAt":false},{"name":"passwordResetToken","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"passwordResetTokenExpiration","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"role","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Role","default":"user","isGenerated":false,"isUpdatedAt":false},{"name":"username","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"profileImage","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"preferredWeather","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"preferredWeight","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"favourite_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"pack_ids","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"item_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"favorites","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"Favourites","relationFromFields":["favourite_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"packs","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"Owners","relationFromFields":["pack_ids"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"item","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Item","relationName":"ItemToUser","relationFromFields":["item_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"templates","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Template","relationName":"TemplateToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"trips","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Trip","relationName":"TripToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"Pack","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Pack","relationName":"PackToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Conversation":{"dbName":"conversations","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"history","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Way":{"dbName":"ways","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"osm_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"osm_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"way","isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"nodes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Node","relationName":"NodeToWay","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"geoJSON","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Node":{"dbName":"nodes","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"osm_id","dbName":"id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"lat","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","isGenerated":false,"isUpdatedAt":false},{"name":"lon","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","isGenerated":false,"isUpdatedAt":false},{"name":"osm_type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"node","isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"Way","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Way","relationName":"NodeToWay","relationFromFields":["wayId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"wayId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Relation":{"dbName":"relations","fields":[{"name":"id","dbName":"_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"auto","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"osm_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"osm_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"relation","isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"members","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Member","isGenerated":false,"isUpdatedAt":false},{"name":"geoJSON","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}},"enums":{"MemberType":{"values":[{"name":"way","dbName":null},{"name":"node","dbName":null},{"name":"relation","dbName":null}],"dbName":null},"Role":{"values":[{"name":"user","dbName":null},{"name":"admin","dbName":null}],"dbName":null},"ItemCategoryName":{"values":[{"name":"Food","dbName":null},{"name":"Water","dbName":null},{"name":"Essentials","dbName":null}],"dbName":null},"TemplateType":{"values":[{"name":"pack","dbName":null},{"name":"trip","dbName":null},{"name":"item","dbName":null}],"dbName":null},"GeoJSONGeometryType":{"values":[{"name":"Point","dbName":null},{"name":"LineString","dbName":null},{"name":"Polygon","dbName":null},{"name":"MultiPoint","dbName":null},{"name":"MultiPolygon","dbName":null},{"name":"MultiLineString","dbName":null}],"dbName":null}},"types":{"Member":{"dbName":null,"fields":[{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MemberType"},{"name":"refId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String"},{"name":"role","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String"}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[]},"GeoJSONGeometry":{"dbName":null,"fields":[{"name":"coordinates","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json"},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"GeoJSONGeometryType"}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[]},"PacksGrades":{"dbName":null,"fields":[{"name":"essentialItems","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":""},{"name":"redundancyAndVersatility","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":""},{"name":"weight","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":""}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[]},"PacksScores":{"dbName":null,"fields":[{"name":"essentialItemsScore","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","default":0},{"name":"redundancyAndVersatilityScore","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","default":0},{"name":"weightScore","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","default":0}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[]}}}');
      defineDmmfProperty2(exports.Prisma, config4.runtimeDataModel);
      config4.injectableEdgeEnv = () => ({
        parsed: {
          MONGODB_URI: typeof globalThis !== "undefined" && globalThis["MONGODB_URI"] || typeof process !== "undefined" && process.env && process.env.MONGODB_URI || void 0
        }
      });
      if (typeof globalThis !== "undefined" && globalThis["DEBUG"] || typeof process !== "undefined" && process.env && process.env.DEBUG || void 0) {
        Debug2.enable(typeof globalThis !== "undefined" && globalThis["DEBUG"] || typeof process !== "undefined" && process.env && process.env.DEBUG || void 0);
      }
      var PrismaClient2 = getPrismaClient2(config4);
      exports.PrismaClient = PrismaClient2;
      Object.assign(exports, Prisma);
    }
  });

  // ../node_modules/@prisma/client/edge.js
  var require_edge3 = __commonJS({
    "../node_modules/@prisma/client/edge.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = {
        ...require_edge2()
      };
    }
  });

  // node-modules-polyfills:fs
  var fs_exports = {};
  __export(fs_exports, {
    default: () => fs_default
  });
  var fs_default;
  var init_fs = __esm({
    "node-modules-polyfills:fs"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      fs_default = {};
    }
  });

  // node-modules-polyfills-commonjs:fs
  var require_fs = __commonJS({
    "node-modules-polyfills-commonjs:fs"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var polyfill = (init_fs(), __toCommonJS(fs_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k2 in polyfill) {
          module.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills:path
  var path_exports = {};
  __export(path_exports, {
    basename: () => basename,
    default: () => path_default,
    delimiter: () => delimiter,
    dirname: () => dirname,
    extname: () => extname,
    isAbsolute: () => isAbsolute,
    join: () => join2,
    normalize: () => normalize,
    relative: () => relative,
    resolve: () => resolve,
    sep: () => sep
  });
  function normalizeArray(parts, allowAboveRoot) {
    var up = 0;
    for (var i2 = parts.length - 1; i2 >= 0; i2--) {
      var last = parts[i2];
      if (last === ".") {
        parts.splice(i2, 1);
      } else if (last === "..") {
        parts.splice(i2, 1);
        up++;
      } else if (up) {
        parts.splice(i2, 1);
        up--;
      }
    }
    if (allowAboveRoot) {
      for (; up--; up) {
        parts.unshift("..");
      }
    }
    return parts;
  }
  function resolve() {
    var resolvedPath = "", resolvedAbsolute = false;
    for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
      var path = i2 >= 0 ? arguments[i2] : "/";
      if (typeof path !== "string") {
        throw new TypeError("Arguments to path.resolve must be strings");
      } else if (!path) {
        continue;
      }
      resolvedPath = path + "/" + resolvedPath;
      resolvedAbsolute = path.charAt(0) === "/";
    }
    resolvedPath = normalizeArray(filter2(resolvedPath.split("/"), function(p2) {
      return !!p2;
    }), !resolvedAbsolute).join("/");
    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
  }
  function normalize(path) {
    var isPathAbsolute = isAbsolute(path), trailingSlash = substr(path, -1) === "/";
    path = normalizeArray(filter2(path.split("/"), function(p2) {
      return !!p2;
    }), !isPathAbsolute).join("/");
    if (!path && !isPathAbsolute) {
      path = ".";
    }
    if (path && trailingSlash) {
      path += "/";
    }
    return (isPathAbsolute ? "/" : "") + path;
  }
  function isAbsolute(path) {
    return path.charAt(0) === "/";
  }
  function join2() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return normalize(filter2(paths, function(p2, index) {
      if (typeof p2 !== "string") {
        throw new TypeError("Arguments to path.join must be strings");
      }
      return p2;
    }).join("/"));
  }
  function relative(from3, to) {
    from3 = resolve(from3).substr(1);
    to = resolve(to).substr(1);
    function trim2(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "")
          break;
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "")
          break;
      }
      if (start > end)
        return [];
      return arr.slice(start, end - start + 1);
    }
    var fromParts = trim2(from3.split("/"));
    var toParts = trim2(to.split("/"));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i2 = 0; i2 < length; i2++) {
      if (fromParts[i2] !== toParts[i2]) {
        samePartsLength = i2;
        break;
      }
    }
    var outputParts = [];
    for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
      outputParts.push("..");
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join("/");
  }
  function dirname(path) {
    var result = splitPath(path), root = result[0], dir = result[1];
    if (!root && !dir) {
      return ".";
    }
    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
  }
  function basename(path, ext) {
    var f = splitPath(path)[2];
    if (ext && f.substr(-1 * ext.length) === ext) {
      f = f.substr(0, f.length - ext.length);
    }
    return f;
  }
  function extname(path) {
    return splitPath(path)[3];
  }
  function filter2(xs, f) {
    if (xs.filter)
      return xs.filter(f);
    var res = [];
    for (var i2 = 0; i2 < xs.length; i2++) {
      if (f(xs[i2], i2, xs))
        res.push(xs[i2]);
    }
    return res;
  }
  var splitPathRe, splitPath, sep, delimiter, path_default, substr;
  var init_path = __esm({
    "node-modules-polyfills:path"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      splitPath = function(filename) {
        return splitPathRe.exec(filename).slice(1);
      };
      sep = "/";
      delimiter = ":";
      path_default = {
        extname,
        basename,
        dirname,
        sep,
        delimiter,
        relative,
        join: join2,
        isAbsolute,
        normalize,
        resolve
      };
      substr = "ab".substr(-1) === "b" ? function(str, start, len) {
        return str.substr(start, len);
      } : function(str, start, len) {
        if (start < 0)
          start = str.length + start;
        return str.substr(start, len);
      };
    }
  });

  // node-modules-polyfills-commonjs:path
  var require_path = __commonJS({
    "node-modules-polyfills-commonjs:path"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var polyfill = (init_path(), __toCommonJS(path_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k2 in polyfill) {
          module.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills:os
  var os_exports = {};
  __export(os_exports, {
    EOL: () => EOL,
    arch: () => arch,
    cpus: () => cpus,
    default: () => os_default,
    endianness: () => endianness,
    freemem: () => freemem,
    getNetworkInterfaces: () => getNetworkInterfaces,
    hostname: () => hostname,
    loadavg: () => loadavg,
    networkInterfaces: () => networkInterfaces,
    platform: () => platform2,
    release: () => release2,
    tmpDir: () => tmpDir,
    tmpdir: () => tmpdir,
    totalmem: () => totalmem,
    type: () => type,
    uptime: () => uptime2
  });
  function endianness() {
    if (typeof _endianness === "undefined") {
      var a4 = new ArrayBuffer(2);
      var b2 = new Uint8Array(a4);
      var c2 = new Uint16Array(a4);
      b2[0] = 1;
      b2[1] = 2;
      if (c2[0] === 258) {
        _endianness = "BE";
      } else if (c2[0] === 513) {
        _endianness = "LE";
      } else {
        throw new Error("unable to figure out endianess");
      }
    }
    return _endianness;
  }
  function hostname() {
    if (typeof globalThis.location !== "undefined") {
      return globalThis.location.hostname;
    } else
      return "";
  }
  function loadavg() {
    return [];
  }
  function uptime2() {
    return 0;
  }
  function freemem() {
    return Number.MAX_VALUE;
  }
  function totalmem() {
    return Number.MAX_VALUE;
  }
  function cpus() {
    return [];
  }
  function type() {
    return "Browser";
  }
  function release2() {
    if (typeof globalThis.navigator !== "undefined") {
      return globalThis.navigator.appVersion;
    }
    return "";
  }
  function networkInterfaces() {
  }
  function getNetworkInterfaces() {
  }
  function arch() {
    return "javascript";
  }
  function platform2() {
    return "browser";
  }
  function tmpDir() {
    return "/tmp";
  }
  var _endianness, tmpdir, EOL, os_default;
  var init_os = __esm({
    "node-modules-polyfills:os"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      tmpdir = tmpDir;
      EOL = "\n";
      os_default = {
        EOL,
        tmpdir,
        tmpDir,
        networkInterfaces,
        getNetworkInterfaces,
        release: release2,
        type,
        cpus,
        totalmem,
        freemem,
        uptime: uptime2,
        loadavg,
        hostname,
        endianness
      };
    }
  });

  // node-modules-polyfills-commonjs:os
  var require_os = __commonJS({
    "node-modules-polyfills-commonjs:os"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var polyfill = (init_os(), __toCommonJS(os_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k2 in polyfill) {
          module.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills:crypto
  var crypto_exports = {};
  __export(crypto_exports, {
    default: () => crypto_default
  });
  var crypto_default;
  var init_crypto = __esm({
    "node-modules-polyfills:crypto"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      crypto_default = {};
    }
  });

  // node-modules-polyfills-commonjs:crypto
  var require_crypto = __commonJS({
    "node-modules-polyfills-commonjs:crypto"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var polyfill = (init_crypto(), __toCommonJS(crypto_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k2 in polyfill) {
          module.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // ../node_modules/dotenv/package.json
  var require_package = __commonJS({
    "../node_modules/dotenv/package.json"(exports, module) {
      module.exports = {
        name: "dotenv",
        version: "16.3.1",
        description: "Loads environment variables from .env file",
        main: "lib/main.js",
        types: "lib/main.d.ts",
        exports: {
          ".": {
            types: "./lib/main.d.ts",
            require: "./lib/main.js",
            default: "./lib/main.js"
          },
          "./config": "./config.js",
          "./config.js": "./config.js",
          "./lib/env-options": "./lib/env-options.js",
          "./lib/env-options.js": "./lib/env-options.js",
          "./lib/cli-options": "./lib/cli-options.js",
          "./lib/cli-options.js": "./lib/cli-options.js",
          "./package.json": "./package.json"
        },
        scripts: {
          "dts-check": "tsc --project tests/types/tsconfig.json",
          lint: "standard",
          "lint-readme": "standard-markdown",
          pretest: "npm run lint && npm run dts-check",
          test: "tap tests/*.js --100 -Rspec",
          prerelease: "npm test",
          release: "standard-version"
        },
        repository: {
          type: "git",
          url: "git://github.com/motdotla/dotenv.git"
        },
        funding: "https://github.com/motdotla/dotenv?sponsor=1",
        keywords: [
          "dotenv",
          "env",
          ".env",
          "environment",
          "variables",
          "config",
          "settings"
        ],
        readmeFilename: "README.md",
        license: "BSD-2-Clause",
        devDependencies: {
          "@definitelytyped/dtslint": "^0.0.133",
          "@types/node": "^18.11.3",
          decache: "^4.6.1",
          sinon: "^14.0.1",
          standard: "^17.0.0",
          "standard-markdown": "^7.1.0",
          "standard-version": "^9.5.0",
          tap: "^16.3.0",
          tar: "^6.1.11",
          typescript: "^4.8.4"
        },
        engines: {
          node: ">=12"
        },
        browser: {
          fs: false
        }
      };
    }
  });

  // ../node_modules/dotenv/lib/main.js
  var require_main = __commonJS({
    "../node_modules/dotenv/lib/main.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var fs = require_fs();
      var path = require_path();
      var os = require_os();
      var crypto2 = require_crypto();
      var packageJson = require_package();
      var version3 = packageJson.version;
      var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
      function parse(src) {
        const obj = {};
        let lines = src.toString();
        lines = lines.replace(/\r\n?/mg, "\n");
        let match;
        while ((match = LINE.exec(lines)) != null) {
          const key = match[1];
          let value = match[2] || "";
          value = value.trim();
          const maybeQuote = value[0];
          value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
          if (maybeQuote === '"') {
            value = value.replace(/\\n/g, "\n");
            value = value.replace(/\\r/g, "\r");
          }
          obj[key] = value;
        }
        return obj;
      }
      function _parseVault(options) {
        const vaultPath = _vaultPath(options);
        const result = DotenvModule.configDotenv({ path: vaultPath });
        if (!result.parsed) {
          throw new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        }
        const keys2 = _dotenvKey(options).split(",");
        const length = keys2.length;
        let decrypted;
        for (let i2 = 0; i2 < length; i2++) {
          try {
            const key = keys2[i2].trim();
            const attrs = _instructions(result, key);
            decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
            break;
          } catch (error) {
            if (i2 + 1 >= length) {
              throw error;
            }
          }
        }
        return DotenvModule.parse(decrypted);
      }
      function _log(message) {
        console.log(`[dotenv@${version3}][INFO] ${message}`);
      }
      function _warn(message) {
        console.log(`[dotenv@${version3}][WARN] ${message}`);
      }
      function _debug(message) {
        console.log(`[dotenv@${version3}][DEBUG] ${message}`);
      }
      function _dotenvKey(options) {
        if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
          return options.DOTENV_KEY;
        }
        if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
          return process.env.DOTENV_KEY;
        }
        return "";
      }
      function _instructions(result, dotenvKey) {
        let uri;
        try {
          uri = new URL(dotenvKey);
        } catch (error) {
          if (error.code === "ERR_INVALID_URL") {
            throw new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
          }
          throw error;
        }
        const key = uri.password;
        if (!key) {
          throw new Error("INVALID_DOTENV_KEY: Missing key part");
        }
        const environment = uri.searchParams.get("environment");
        if (!environment) {
          throw new Error("INVALID_DOTENV_KEY: Missing environment part");
        }
        const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
        const ciphertext = result.parsed[environmentKey];
        if (!ciphertext) {
          throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        }
        return { ciphertext, key };
      }
      function _vaultPath(options) {
        let dotenvPath = path.resolve(process.cwd(), ".env");
        if (options && options.path && options.path.length > 0) {
          dotenvPath = options.path;
        }
        return dotenvPath.endsWith(".vault") ? dotenvPath : `${dotenvPath}.vault`;
      }
      function _resolveHome(envPath) {
        return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
      }
      function _configVault(options) {
        _log("Loading env from encrypted .env.vault");
        const parsed = DotenvModule._parseVault(options);
        let processEnv = process.env;
        if (options && options.processEnv != null) {
          processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsed, options);
        return { parsed };
      }
      function configDotenv(options) {
        let dotenvPath = path.resolve(process.cwd(), ".env");
        let encoding = "utf8";
        const debug2 = Boolean(options && options.debug);
        if (options) {
          if (options.path != null) {
            dotenvPath = _resolveHome(options.path);
          }
          if (options.encoding != null) {
            encoding = options.encoding;
          }
        }
        try {
          const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
          let processEnv = process.env;
          if (options && options.processEnv != null) {
            processEnv = options.processEnv;
          }
          DotenvModule.populate(processEnv, parsed, options);
          return { parsed };
        } catch (e8) {
          if (debug2) {
            _debug(`Failed to load ${dotenvPath} ${e8.message}`);
          }
          return { error: e8 };
        }
      }
      function config4(options) {
        const vaultPath = _vaultPath(options);
        if (_dotenvKey(options).length === 0) {
          return DotenvModule.configDotenv(options);
        }
        if (!fs.existsSync(vaultPath)) {
          _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
          return DotenvModule.configDotenv(options);
        }
        return DotenvModule._configVault(options);
      }
      function decrypt(encrypted, keyStr) {
        const key = Buffer2.from(keyStr.slice(-64), "hex");
        let ciphertext = Buffer2.from(encrypted, "base64");
        const nonce = ciphertext.slice(0, 12);
        const authTag = ciphertext.slice(-16);
        ciphertext = ciphertext.slice(12, -16);
        try {
          const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
          aesgcm.setAuthTag(authTag);
          return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
        } catch (error) {
          const isRange = error instanceof RangeError;
          const invalidKeyLength = error.message === "Invalid key length";
          const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
          if (isRange || invalidKeyLength) {
            const msg = "INVALID_DOTENV_KEY: It must be 64 characters long (or more)";
            throw new Error(msg);
          } else if (decryptionFailed) {
            const msg = "DECRYPTION_FAILED: Please check your DOTENV_KEY";
            throw new Error(msg);
          } else {
            console.error("Error: ", error.code);
            console.error("Error: ", error.message);
            throw error;
          }
        }
      }
      function populate(processEnv, parsed, options = {}) {
        const debug2 = Boolean(options && options.debug);
        const override = Boolean(options && options.override);
        if (typeof parsed !== "object") {
          throw new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        }
        for (const key of Object.keys(parsed)) {
          if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
            if (override === true) {
              processEnv[key] = parsed[key];
            }
            if (debug2) {
              if (override === true) {
                _debug(`"${key}" is already defined and WAS overwritten`);
              } else {
                _debug(`"${key}" is already defined and was NOT overwritten`);
              }
            }
          } else {
            processEnv[key] = parsed[key];
          }
        }
      }
      var DotenvModule = {
        configDotenv,
        _configVault,
        _parseVault,
        config: config4,
        decrypt,
        parse,
        populate
      };
      module.exports.configDotenv = DotenvModule.configDotenv;
      module.exports._configVault = DotenvModule._configVault;
      module.exports._parseVault = DotenvModule._parseVault;
      module.exports.config = DotenvModule.config;
      module.exports.decrypt = DotenvModule.decrypt;
      module.exports.parse = DotenvModule.parse;
      module.exports.populate = DotenvModule.populate;
      module.exports = DotenvModule;
    }
  });

  // node-modules-polyfills:buffer
  var buffer_exports = {};
  __export(buffer_exports, {
    Buffer: () => Buffer3,
    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
    SlowBuffer: () => SlowBuffer,
    isBuffer: () => isBuffer3,
    kMaxLength: () => _kMaxLength
  });
  function init2() {
    inited2 = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup2[i2] = code[i2];
      revLookup2[code.charCodeAt(i2)] = i2;
    }
    revLookup2["-".charCodeAt(0)] = 62;
    revLookup2["_".charCodeAt(0)] = 63;
  }
  function toByteArray(b64) {
    if (!inited2) {
      init2();
    }
    var i2, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr2(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i2 = 0, j = 0; i2 < l; i2 += 4, j += 3) {
      tmp = revLookup2[b64.charCodeAt(i2)] << 18 | revLookup2[b64.charCodeAt(i2 + 1)] << 12 | revLookup2[b64.charCodeAt(i2 + 2)] << 6 | revLookup2[b64.charCodeAt(i2 + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup2[b64.charCodeAt(i2)] << 2 | revLookup2[b64.charCodeAt(i2 + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup2[b64.charCodeAt(i2)] << 10 | revLookup2[b64.charCodeAt(i2 + 1)] << 4 | revLookup2[b64.charCodeAt(i2 + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase642(num) {
    return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
  }
  function encodeChunk2(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
      output.push(tripletToBase642(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    if (!inited2) {
      init2();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
      parts.push(encodeChunk2(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup2[tmp >> 2];
      output += lookup2[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup2[tmp >> 10];
      output += lookup2[tmp >> 4 & 63];
      output += lookup2[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  function read(buffer, offset, isLE, mLen, nBytes) {
    var e8, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d2 = isLE ? -1 : 1;
    var s3 = buffer[offset + i2];
    i2 += d2;
    e8 = s3 & (1 << -nBits) - 1;
    s3 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e8 = e8 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
    }
    m2 = e8 & (1 << -nBits) - 1;
    e8 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
    }
    if (e8 === 0) {
      e8 = 1 - eBias;
    } else if (e8 === eMax) {
      return m2 ? NaN : (s3 ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e8 = e8 - eBias;
    }
    return (s3 ? -1 : 1) * m2 * Math.pow(2, e8 - mLen);
  }
  function write2(buffer, value, offset, isLE, mLen, nBytes) {
    var e8, m2, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d2 = isLE ? 1 : -1;
    var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e8 = eMax;
    } else {
      e8 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e8)) < 1) {
        e8--;
        c2 *= 2;
      }
      if (e8 + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e8++;
        c2 /= 2;
      }
      if (e8 + eBias >= eMax) {
        m2 = 0;
        e8 = eMax;
      } else if (e8 + eBias >= 1) {
        m2 = (value * c2 - 1) * Math.pow(2, mLen);
        e8 = e8 + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e8 = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
    }
    e8 = e8 << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e8 & 255, i2 += d2, e8 /= 256, eLen -= 8) {
    }
    buffer[offset + i2 - d2] |= s3 * 128;
  }
  function kMaxLength2() {
    return Buffer3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer2(that, length) {
    if (kMaxLength2() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer3.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer3.prototype;
    } else {
      if (that === null) {
        that = new Buffer3(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (!Buffer3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer3)) {
      return new Buffer3(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe2(this, arg);
    }
    return from2(this, arg, encodingOrOffset, length);
  }
  function from2(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer2(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString2(that, value, encodingOrOffset);
    }
    return fromObject2(that, value);
  }
  function assertSize2(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc2(that, size, fill3, encoding) {
    assertSize2(size);
    if (size <= 0) {
      return createBuffer2(that, size);
    }
    if (fill3 !== void 0) {
      return typeof encoding === "string" ? createBuffer2(that, size).fill(fill3, encoding) : createBuffer2(that, size).fill(fill3);
    }
    return createBuffer2(that, size);
  }
  function allocUnsafe2(that, size) {
    assertSize2(size);
    that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
    if (!Buffer3.TYPED_ARRAY_SUPPORT) {
      for (var i2 = 0; i2 < size; ++i2) {
        that[i2] = 0;
      }
    }
    return that;
  }
  function fromString2(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength2(string, encoding) | 0;
    that = createBuffer2(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike2(that, array) {
    var length = array.length < 0 ? 0 : checked2(array.length) | 0;
    that = createBuffer2(that, length);
    for (var i2 = 0; i2 < length; i2 += 1) {
      that[i2] = array[i2] & 255;
    }
    return that;
  }
  function fromArrayBuffer2(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array = new Uint8Array(array);
    } else if (length === void 0) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }
    if (Buffer3.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer3.prototype;
    } else {
      that = fromArrayLike2(that, array);
    }
    return that;
  }
  function fromObject2(that, obj) {
    if (internalIsBuffer2(obj)) {
      var len = checked2(obj.length) | 0;
      that = createBuffer2(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan2(obj.length)) {
          return createBuffer2(that, 0);
        }
        return fromArrayLike2(that, obj);
      }
      if (obj.type === "Buffer" && isArray2(obj.data)) {
        return fromArrayLike2(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked2(length) {
    if (length >= kMaxLength2()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  function internalIsBuffer2(b2) {
    return !!(b2 != null && b2._isBuffer);
  }
  function byteLength2(string, encoding) {
    if (internalIsBuffer2(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes2(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes2(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes2(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  function slowToString2(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice2(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end);
        case "ascii":
          return asciiSlice2(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice2(this, start, end);
        case "base64":
          return base64Slice2(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice2(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  function swap2(b2, n3, m2) {
    var i2 = b2[n3];
    b2[n3] = b2[m2];
    b2[m2] = i2;
  }
  function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (internalIsBuffer2(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf2(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer3.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  function hexWrite2(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (isNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write2(buf, string, offset, length) {
    return blitBuffer2(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite2(buf, string, offset, length) {
    return blitBuffer2(asciiToBytes2(string), buf, offset, length);
  }
  function latin1Write2(buf, string, offset, length) {
    return asciiWrite2(buf, string, offset, length);
  }
  function base64Write2(buf, string, offset, length) {
    return blitBuffer2(base64ToBytes2(string), buf, offset, length);
  }
  function ucs2Write2(buf, string, offset, length) {
    return blitBuffer2(utf16leToBytes2(string, buf.length - offset), buf, offset, length);
  }
  function base64Slice2(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice2(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  function decodeCodePointsArray2(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice2(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice2(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice2(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += toHex2(buf[i2]);
    }
    return out;
  }
  function utf16leSlice2(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes.length; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  function checkOffset2(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt2(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer2(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  function objectWriteUInt162(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 2); i2 < j; ++i2) {
      buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
    }
  }
  function objectWriteUInt322(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 4); i2 < j; ++i2) {
      buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
    }
  }
  function checkIEEE7542(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat2(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE7542(buf, value, offset, 4);
    }
    write2(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  function writeDouble2(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE7542(buf, value, offset, 8);
    }
    write2(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  function base64clean2(str) {
    str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim2(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex2(n3) {
    if (n3 < 16)
      return "0" + n3.toString(16);
    return n3.toString(16);
  }
  function utf8ToBytes2(string, units2) {
    units2 = units2 || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units2 -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units2 -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units2 -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units2 -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units2 -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units2 -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units2 -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units2 -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes2(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes2(str, units2) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units2 -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes2(str) {
    return toByteArray(base64clean2(str));
  }
  function blitBuffer2(src, dst, offset, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isnan2(val) {
    return val !== val;
  }
  function isBuffer3(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
  }
  function isFastBuffer2(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer2(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
  }
  var lookup2, revLookup2, Arr2, inited2, toString4, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH2, INVALID_BASE64_RE2;
  var init_buffer2 = __esm({
    "node-modules-polyfills:buffer"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      lookup2 = [];
      revLookup2 = [];
      Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      inited2 = false;
      toString4 = {}.toString;
      isArray2 = Array.isArray || function(arr) {
        return toString4.call(arr) == "[object Array]";
      };
      INSPECT_MAX_BYTES = 50;
      Buffer3.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
      _kMaxLength = kMaxLength2();
      Buffer3.poolSize = 8192;
      Buffer3._augment = function(arr) {
        arr.__proto__ = Buffer3.prototype;
        return arr;
      };
      Buffer3.from = function(value, encodingOrOffset, length) {
        return from2(null, value, encodingOrOffset, length);
      };
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        Buffer3.prototype.__proto__ = Uint8Array.prototype;
        Buffer3.__proto__ = Uint8Array;
      }
      Buffer3.alloc = function(size, fill3, encoding) {
        return alloc2(null, size, fill3, encoding);
      };
      Buffer3.allocUnsafe = function(size) {
        return allocUnsafe2(null, size);
      };
      Buffer3.allocUnsafeSlow = function(size) {
        return allocUnsafe2(null, size);
      };
      Buffer3.isBuffer = isBuffer3;
      Buffer3.compare = function compare3(a4, b2) {
        if (!internalIsBuffer2(a4) || !internalIsBuffer2(b2)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a4 === b2)
          return 0;
        var x2 = a4.length;
        var y2 = b2.length;
        for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
          if (a4[i2] !== b2[i2]) {
            x2 = a4[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer3.isEncoding = function isEncoding2(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer3.concat = function concat2(list, length) {
        if (!isArray2(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer3.alloc(0);
        }
        var i2;
        if (length === void 0) {
          length = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length += list[i2].length;
          }
        }
        var buffer = Buffer3.allocUnsafe(length);
        var pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          var buf = list[i2];
          if (!internalIsBuffer2(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      Buffer3.byteLength = byteLength2;
      Buffer3.prototype._isBuffer = true;
      Buffer3.prototype.swap16 = function swap162() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 2) {
          swap2(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer3.prototype.swap32 = function swap322() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 4) {
          swap2(this, i2, i2 + 3);
          swap2(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer3.prototype.swap64 = function swap642() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 8) {
          swap2(this, i2, i2 + 7);
          swap2(this, i2 + 1, i2 + 6);
          swap2(this, i2 + 2, i2 + 5);
          swap2(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer3.prototype.toString = function toString5() {
        var length = this.length | 0;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice2(this, 0, length);
        return slowToString2.apply(this, arguments);
      };
      Buffer3.prototype.equals = function equals2(b2) {
        if (!internalIsBuffer2(b2))
          throw new TypeError("Argument must be a Buffer");
        if (this === b2)
          return true;
        return Buffer3.compare(this, b2) === 0;
      };
      Buffer3.prototype.inspect = function inspect() {
        var str = "";
        var max = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
          if (this.length > max)
            str += " ... ";
        }
        return "<Buffer " + str + ">";
      };
      Buffer3.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer2(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x2 = thisEnd - thisStart;
        var y2 = end - start;
        var len = Math.min(x2, y2);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i2 = 0; i2 < len; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x2 = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
      };
      Buffer3.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
      };
      Buffer3.prototype.write = function write3(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite2(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write2(this, string, offset, length);
            case "ascii":
              return asciiWrite2(this, string, offset, length);
            case "latin1":
            case "binary":
              return latin1Write2(this, string, offset, length);
            case "base64":
              return base64Write2(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write2(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer3.prototype.toJSON = function toJSON3() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      MAX_ARGUMENTS_LENGTH2 = 4096;
      Buffer3.prototype.slice = function slice2(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer3.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer3.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer3(sliceLen, void 0);
          for (var i2 = 0; i2 < sliceLen; ++i2) {
            newBuf[i2] = this[i2 + start];
          }
        }
        return newBuf;
      };
      Buffer3.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert)
          checkOffset2(offset, byteLength3, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUIntBE = function readUIntBE2(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          checkOffset2(offset, byteLength3, this.length);
        }
        var val = this[offset + --byteLength3];
        var mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength3] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUInt8 = function readUInt82(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 1, this.length);
        return this[offset];
      };
      Buffer3.prototype.readUInt16LE = function readUInt16LE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer3.prototype.readUInt16BE = function readUInt16BE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer3.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer3.prototype.readUInt32BE = function readUInt32BE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer3.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert)
          checkOffset2(offset, byteLength3, this.length);
        var val = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer3.prototype.readIntBE = function readIntBE2(offset, byteLength3, noAssert) {
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert)
          checkOffset2(offset, byteLength3, this.length);
        var i2 = byteLength3;
        var mul = 1;
        var val = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer3.prototype.readInt8 = function readInt82(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer3.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer3.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer3.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 4, this.length);
        return read(this, offset, true, 23, 4);
      };
      Buffer3.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 4, this.length);
        return read(this, offset, false, 23, 4);
      };
      Buffer3.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 8, this.length);
        return read(this, offset, true, 52, 8);
      };
      Buffer3.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
        if (!noAssert)
          checkOffset2(offset, 8, this.length);
        return read(this, offset, false, 52, 8);
      };
      Buffer3.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt2(this, value, offset, byteLength3, maxBytes, 0);
        }
        var mul = 1;
        var i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer3.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt2(this, value, offset, byteLength3, maxBytes, 0);
        }
        var i2 = byteLength3 - 1;
        var mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 1, 255, 0);
        if (!Buffer3.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeUInt16LE = function writeUInt16LE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 2, 65535, 0);
        if (Buffer3.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt162(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer3.prototype.writeUInt16BE = function writeUInt16BE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 2, 65535, 0);
        if (Buffer3.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt162(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer3.prototype.writeUInt32LE = function writeUInt32LE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 4, 4294967295, 0);
        if (Buffer3.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt322(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 4, 4294967295, 0);
        if (Buffer3.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt322(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer3.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i2 = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer3.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i2 = byteLength3 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer3.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 1, 127, -128);
        if (!Buffer3.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 2, 32767, -32768);
        if (Buffer3.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt162(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer3.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 2, 32767, -32768);
        if (Buffer3.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt162(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer3.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer3.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt322(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer3.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt2(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer3.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt322(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer3.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
        return writeFloat2(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
        return writeFloat2(this, value, offset, false, noAssert);
      };
      Buffer3.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
        return writeDouble2(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
        return writeDouble2(this, value, offset, false, noAssert);
      };
      Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i2;
        if (this === target && start < targetStart && targetStart < end) {
          for (i2 = len - 1; i2 >= 0; --i2) {
            target[i2 + targetStart] = this[i2 + start];
          }
        } else if (len < 1e3 || !Buffer3.TYPED_ARRAY_SUPPORT) {
          for (i2 = 0; i2 < len; ++i2) {
            target[i2 + targetStart] = this[i2 + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      };
      Buffer3.prototype.fill = function fill2(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i2;
        if (typeof val === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val;
          }
        } else {
          var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer3(val, encoding).toString());
          var len = bytes.length;
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes[i2 % len];
          }
        }
        return this;
      };
      INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
    }
  });

  // node-modules-polyfills-commonjs:buffer
  var require_buffer = __commonJS({
    "node-modules-polyfills-commonjs:buffer"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var polyfill = (init_buffer2(), __toCommonJS(buffer_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k2 in polyfill) {
          module.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // ../node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "../node_modules/safe-buffer/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var buffer = require_buffer();
      var Buffer4 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer4(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer4.prototype);
      copyProps(Buffer4, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer4(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill3, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer4(size);
        if (fill3 !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill3, encoding);
          } else {
            buf.fill(fill3);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer4(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node-modules-polyfills:events
  function EventHandlers() {
  }
  function EventEmitter2() {
    EventEmitter2.init.call(this);
  }
  function $getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter2.defaultMaxListeners;
    return that._maxListeners;
  }
  function emitNone(handler, isFn, self2) {
    if (isFn)
      handler.call(self2);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].call(self2);
    }
  }
  function emitOne(handler, isFn, self2, arg1) {
    if (isFn)
      handler.call(self2, arg1);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].call(self2, arg1);
    }
  }
  function emitTwo(handler, isFn, self2, arg1, arg2) {
    if (isFn)
      handler.call(self2, arg1, arg2);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].call(self2, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self2, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].call(self2, arg1, arg2, arg3);
    }
  }
  function emitMany(handler, isFn, self2, args) {
    if (isFn)
      handler.apply(self2, args);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        listeners2[i2].apply(self2, args);
    }
  }
  function _addListener(target, type2, listener, prepend) {
    var m2;
    var events;
    var existing;
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      if (events.newListener) {
        target.emit(
          "newListener",
          type2,
          listener.listener ? listener.listener : listener
        );
        events = target._events;
      }
      existing = events[type2];
    }
    if (!existing) {
      existing = events[type2] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
      } else {
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }
      if (!existing.warned) {
        m2 = $getMaxListeners(target);
        if (m2 && m2 > 0 && existing.length > m2) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type2;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }
    return target;
  }
  function emitWarning(e8) {
    typeof console.warn === "function" ? console.warn(e8) : console.log(e8);
  }
  function _onceWrap(target, type2, listener) {
    var fired = false;
    function g2() {
      target.removeListener(type2, g2);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g2.listener = listener;
    return g2;
  }
  function listenerCount(type2) {
    var events = this._events;
    if (events) {
      var evlistener = events[type2];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }
    return 0;
  }
  function spliceOne(list, index) {
    for (var i2 = index, k2 = i2 + 1, n3 = list.length; k2 < n3; i2 += 1, k2 += 1)
      list[i2] = list[k2];
    list.pop();
  }
  function arrayClone(arr, i2) {
    var copy3 = new Array(i2);
    while (i2--)
      copy3[i2] = arr[i2];
    return copy3;
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i2 = 0; i2 < ret.length; ++i2) {
      ret[i2] = arr[i2].listener || arr[i2];
    }
    return ret;
  }
  var domain, events_default;
  var init_events = __esm({
    "node-modules-polyfills:events"() {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
      events_default = EventEmitter2;
      EventEmitter2.EventEmitter = EventEmitter2;
      EventEmitter2.usingDomains = false;
      EventEmitter2.prototype.domain = void 0;
      EventEmitter2.prototype._events = void 0;
      EventEmitter2.prototype._maxListeners = void 0;
      EventEmitter2.defaultMaxListeners = 10;
      EventEmitter2.init = function() {
        this.domain = null;
        if (EventEmitter2.usingDomains) {
          if (domain.active && !(this instanceof domain.Domain)) {
            this.domain = domain.active;
          }
        }
        if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n3) {
        if (typeof n3 !== "number" || n3 < 0 || isNaN(n3))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n3;
        return this;
      };
      EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      EventEmitter2.prototype.emit = function emit2(type2) {
        var er, handler, len, args, i2, events, domain2;
        var needDomainExit = false;
        var doError = type2 === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        domain2 = this.domain;
        if (doError) {
          er = arguments[1];
          if (domain2) {
            if (!er)
              er = new Error('Uncaught, unspecified "error" event');
            er.domainEmitter = this;
            er.domain = domain2;
            er.domainThrown = false;
            domain2.emit("error", er);
          } else if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
          return false;
        }
        handler = events[type2];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i2 = 1; i2 < len; i2++)
              args[i2 - 1] = arguments[i2];
            emitMany(handler, isFn, this, args);
        }
        if (needDomainExit)
          domain2.exit();
        return true;
      };
      EventEmitter2.prototype.addListener = function addListener2(type2, listener) {
        return _addListener(this, type2, listener, false);
      };
      EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
      EventEmitter2.prototype.prependListener = function prependListener(type2, listener) {
        return _addListener(this, type2, listener, true);
      };
      EventEmitter2.prototype.once = function once2(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter2.prototype.removeListener = function removeListener2(type2, listener) {
        var list, events, position, i2, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type2];
        if (!list)
          return this;
        if (list === listener || list.listener && list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type2];
            if (events.removeListener)
              this.emit("removeListener", type2, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i2 = list.length; i2-- > 0; ) {
            if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
              originalListener = list[i2].listener;
              position = i2;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list.length === 1) {
            list[0] = void 0;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type2];
            }
          } else {
            spliceOne(list, position);
          }
          if (events.removeListener)
            this.emit("removeListener", type2, originalListener || listener);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(type2) {
        var listeners2, events;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type2]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type2];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys2 = Object.keys(events);
          for (var i2 = 0, key; i2 < keys2.length; ++i2) {
            key = keys2[i2];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }
        listeners2 = events[type2];
        if (typeof listeners2 === "function") {
          this.removeListener(type2, listeners2);
        } else if (listeners2) {
          do {
            this.removeListener(type2, listeners2[listeners2.length - 1]);
          } while (listeners2[0]);
        }
        return this;
      };
      EventEmitter2.prototype.listeners = function listeners(type2) {
        var evlistener;
        var ret;
        var events = this._events;
        if (!events)
          ret = [];
        else {
          evlistener = events[type2];
          if (!evlistener)
            ret = [];
          else if (typeof evlistener === "function")
            ret = [evlistener.listener || evlistener];
          else
            ret = unwrapListeners(evlistener);
        }
        return ret;
      };
      EventEmitter2.listenerCount = function(emitter, type2) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type2);
        } else {
          return listenerCount.call(emitter, type2);
        }
      };
      EventEmitter2.prototype.listenerCount = listenerCount;
      EventEmitter2.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
    }
  });

  // node-modules-polyfills:process
  function defaultSetTimout2() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout2() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout2(fun) {
    if (cachedSetTimeout2 === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
      cachedSetTimeout2 = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout2(fun, 0);
    } catch (e8) {
      try {
        return cachedSetTimeout2.call(null, fun, 0);
      } catch (e9) {
        return cachedSetTimeout2.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout2(marker) {
    if (cachedClearTimeout2 === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
      cachedClearTimeout2 = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout2(marker);
    } catch (e8) {
      try {
        return cachedClearTimeout2.call(null, marker);
      } catch (e9) {
        return cachedClearTimeout2.call(this, marker);
      }
    }
  }
  function cleanUpNextTick2() {
    if (!draining2 || !currentQueue2) {
      return;
    }
    draining2 = false;
    if (currentQueue2.length) {
      queue2 = currentQueue2.concat(queue2);
    } else {
      queueIndex2 = -1;
    }
    if (queue2.length) {
      drainQueue2();
    }
  }
  function drainQueue2() {
    if (draining2) {
      return;
    }
    var timeout = runTimeout2(cleanUpNextTick2);
    draining2 = true;
    var len = queue2.length;
    while (len) {
      currentQueue2 = queue2;
      queue2 = [];
      while (++queueIndex2 < len) {
        if (currentQueue2) {
          currentQueue2[queueIndex2].run();
        }
      }
      queueIndex2 = -1;
      len = queue2.length;
    }
    currentQueue2 = null;
    draining2 = false;
    runClearTimeout2(timeout);
  }
  function nextTick2(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        args[i2 - 1] = arguments[i2];
      }
    }
    queue2.push(new Item2(fun, args));
    if (queue2.length === 1 && !draining2) {
      runTimeout2(drainQueue2);
    }
  }
  function Item2(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop4() {
  }
  function binding2(name) {
    throw new Error("process.binding is not supported");
  }
  function cwd2() {
    return "/";
  }
  function chdir2(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask2() {
    return 0;
  }
  function hrtime2(previousTimestamp) {
    var clocktime = performanceNow2.call(performance3) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  function uptime3() {
    var currentTime = /* @__PURE__ */ new Date();
    var dif = currentTime - startTime2;
    return dif / 1e3;
  }
  var cachedSetTimeout2, cachedClearTimeout2, queue2, draining2, currentQueue2, queueIndex2, title2, platform3, browser2, env2, argv2, version2, versions2, release3, config3, on2, addListener3, once3, off2, removeListener3, removeAllListeners3, emit3, performance3, performanceNow2, startTime2, browser$1, process_default;
  var init_process2 = __esm({
    "node-modules-polyfills:process"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      cachedSetTimeout2 = defaultSetTimout2;
      cachedClearTimeout2 = defaultClearTimeout2;
      if (typeof globalThis.setTimeout === "function") {
        cachedSetTimeout2 = setTimeout;
      }
      if (typeof globalThis.clearTimeout === "function") {
        cachedClearTimeout2 = clearTimeout;
      }
      queue2 = [];
      draining2 = false;
      queueIndex2 = -1;
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title2 = "browser";
      platform3 = "browser";
      browser2 = true;
      env2 = {};
      argv2 = [];
      version2 = "";
      versions2 = {};
      release3 = {};
      config3 = {};
      on2 = noop4;
      addListener3 = noop4;
      once3 = noop4;
      off2 = noop4;
      removeListener3 = noop4;
      removeAllListeners3 = noop4;
      emit3 = noop4;
      performance3 = globalThis.performance || {};
      performanceNow2 = performance3.now || performance3.mozNow || performance3.msNow || performance3.oNow || performance3.webkitNow || function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      startTime2 = /* @__PURE__ */ new Date();
      browser$1 = {
        nextTick: nextTick2,
        title: title2,
        browser: browser2,
        env: env2,
        argv: argv2,
        version: version2,
        versions: versions2,
        on: on2,
        addListener: addListener3,
        once: once3,
        off: off2,
        removeListener: removeListener3,
        removeAllListeners: removeAllListeners3,
        emit: emit3,
        binding: binding2,
        cwd: cwd2,
        chdir: chdir2,
        umask: umask2,
        hrtime: hrtime2,
        platform: platform3,
        release: release3,
        config: config3,
        uptime: uptime3
      };
      process_default = browser$1;
    }
  });

  // ../node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
  var inherits2, inherits_default;
  var init_inherits = __esm({
    "../node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      if (typeof Object.create === "function") {
        inherits2 = function inherits3(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits2 = function inherits3(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      inherits_default = inherits2;
    }
  });

  // node-modules-polyfills:util
  var util_exports = {};
  __export(util_exports, {
    _extend: () => _extend,
    debuglog: () => debuglog,
    default: () => util_default,
    deprecate: () => deprecate,
    format: () => format,
    inherits: () => inherits_default,
    inspect: () => inspect2,
    isArray: () => isArray3,
    isBoolean: () => isBoolean2,
    isBuffer: () => isBuffer4,
    isDate: () => isDate2,
    isError: () => isError,
    isFunction: () => isFunction2,
    isNull: () => isNull,
    isNullOrUndefined: () => isNullOrUndefined,
    isNumber: () => isNumber2,
    isObject: () => isObject3,
    isPrimitive: () => isPrimitive,
    isRegExp: () => isRegExp2,
    isString: () => isString2,
    isSymbol: () => isSymbol,
    isUndefined: () => isUndefined2,
    log: () => log
  });
  function format(f) {
    if (!isString2(f)) {
      var objects = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        objects.push(inspect2(arguments[i2]));
      }
      return objects.join(" ");
    }
    var i2 = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x3) {
      if (x3 === "%%")
        return "%";
      if (i2 >= len)
        return x3;
      switch (x3) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x3;
      }
    });
    for (var x2 = args[i2]; i2 < len; x2 = args[++i2]) {
      if (isNull(x2) || !isObject3(x2)) {
        str += " " + x2;
      } else {
        str += " " + inspect2(x2);
      }
    }
    return str;
  }
  function deprecate(fn, msg) {
    if (isUndefined2(globalThis.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }
    if (process_default.noDeprecation === true) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process_default.throwDeprecation) {
          throw new Error(msg);
        } else if (process_default.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function debuglog(set) {
    if (isUndefined2(debugEnviron))
      debugEnviron = process_default.env.NODE_DEBUG || "";
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format.apply(null, arguments);
          console.error("%s %d: %s", set, pid, msg);
        };
      } else {
        debugs[set] = function() {
        };
      }
    }
    return debugs[set];
  }
  function inspect2(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean2(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      _extend(ctx, opts);
    }
    if (isUndefined2(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined2(ctx.depth))
      ctx.depth = 2;
    if (isUndefined2(ctx.colors))
      ctx.colors = false;
    if (isUndefined2(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  function stylizeWithColor(str, styleType) {
    var style = inspect2.styles[styleType];
    if (style) {
      return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== inspect2 && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString2(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys2 = Object.keys(value);
    var visibleKeys = arrayToHash(keys2);
    if (ctx.showHidden) {
      keys2 = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys2.length === 0) {
      if (isFunction2(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp2(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate2(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base = "", array = false, braces = ["{", "}"];
    if (isArray3(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction2(value)) {
      var n3 = value.name ? ": " + value.name : "";
      base = " [Function" + n3 + "]";
    }
    if (isRegExp2(value)) {
      base = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate2(value)) {
      base = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base = " " + formatError(value);
    }
    if (keys2.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp2(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
    } else {
      output = keys2.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined2(value))
      return ctx.stylize("undefined", "undefined");
    if (isString2(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber2(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean2(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
    var output = [];
    for (var i2 = 0, l = value.length; i2 < l; ++i2) {
      if (hasOwnProperty2(value, String(i2))) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i2),
          true
        ));
      } else {
        output.push("");
      }
    }
    keys2.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          true
        ));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty2(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined2(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str;
  }
  function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf("\n") >= 0)
        numLinesEst++;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
  }
  function isArray3(ar) {
    return Array.isArray(ar);
  }
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  function isString2(arg) {
    return typeof arg === "string";
  }
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  function isUndefined2(arg) {
    return arg === void 0;
  }
  function isRegExp2(re) {
    return isObject3(re) && objectToString(re) === "[object RegExp]";
  }
  function isObject3(arg) {
    return typeof arg === "object" && arg !== null;
  }
  function isDate2(d2) {
    return isObject3(d2) && objectToString(d2) === "[object Date]";
  }
  function isError(e8) {
    return isObject3(e8) && (objectToString(e8) === "[object Error]" || e8 instanceof Error);
  }
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  function isBuffer4(maybeBuf) {
    return Buffer2.isBuffer(maybeBuf);
  }
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  function pad(n3) {
    return n3 < 10 ? "0" + n3.toString(10) : n3.toString(10);
  }
  function timestamp() {
    var d2 = /* @__PURE__ */ new Date();
    var time = [
      pad(d2.getHours()),
      pad(d2.getMinutes()),
      pad(d2.getSeconds())
    ].join(":");
    return [d2.getDate(), months[d2.getMonth()], time].join(" ");
  }
  function log() {
    console.log("%s - %s", timestamp(), format.apply(null, arguments));
  }
  function _extend(origin, add) {
    if (!add || !isObject3(add))
      return origin;
    var keys2 = Object.keys(add);
    var i2 = keys2.length;
    while (i2--) {
      origin[keys2[i2]] = add[keys2[i2]];
    }
    return origin;
  }
  function hasOwnProperty2(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var formatRegExp, debugs, debugEnviron, months, util_default;
  var init_util = __esm({
    "node-modules-polyfills:util"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_process2();
      init_inherits();
      formatRegExp = /%[sdj%]/g;
      debugs = {};
      inspect2.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect2.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      util_default = {
        inherits: inherits_default,
        _extend,
        log,
        isBuffer: isBuffer4,
        isPrimitive,
        isFunction: isFunction2,
        isError,
        isDate: isDate2,
        isObject: isObject3,
        isRegExp: isRegExp2,
        isUndefined: isUndefined2,
        isSymbol,
        isString: isString2,
        isNumber: isNumber2,
        isNullOrUndefined,
        isNull,
        isBoolean: isBoolean2,
        isArray: isArray3,
        inspect: inspect2,
        deprecate,
        format,
        debuglog
      };
    }
  });

  // ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  var buffer_list_default;
  var init_buffer_list = __esm({
    "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_buffer2();
      buffer_list_default = BufferList;
      BufferList.prototype.push = function(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function(s3) {
        if (this.length === 0)
          return "";
        var p2 = this.head;
        var ret = "" + p2.data;
        while (p2 = p2.next) {
          ret += s3 + p2.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function(n3) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer3.allocUnsafe(n3 >>> 0);
        var p2 = this.head;
        var i2 = 0;
        while (p2) {
          p2.data.copy(ret, i2);
          i2 += p2.data.length;
          p2 = p2.next;
        }
        return ret;
      };
    }
  });

  // node-modules-polyfills:string_decoder
  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
      throw new Error("Unknown encoding: " + encoding);
    }
  }
  function StringDecoder(encoding) {
    this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
    assertEncoding(encoding);
    switch (this.encoding) {
      case "utf8":
        this.surrogateSize = 3;
        break;
      case "ucs2":
      case "utf16le":
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
      case "base64":
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
      default:
        this.write = passThroughWrite;
        return;
    }
    this.charBuffer = new Buffer3(6);
    this.charReceived = 0;
    this.charLength = 0;
  }
  function passThroughWrite(buffer) {
    return buffer.toString(this.encoding);
  }
  function utf16DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }
  function base64DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }
  var isBufferEncoding;
  var init_string_decoder = __esm({
    "node-modules-polyfills:string_decoder"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_buffer2();
      isBufferEncoding = Buffer3.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
          var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;
          if (this.charReceived < this.charLength) {
            return "";
          }
          buffer = buffer.slice(available, buffer.length);
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = "";
            continue;
          }
          this.charReceived = this.charLength = 0;
          if (buffer.length === 0) {
            return charStr;
          }
          break;
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end);
        }
        return charStr;
      };
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i2 = buffer.length >= 3 ? 3 : buffer.length;
        for (; i2 > 0; i2--) {
          var c2 = buffer[buffer.length - i2];
          if (i2 == 1 && c2 >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (i2 <= 2 && c2 >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (i2 <= 3 && c2 >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = i2;
      };
      StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length)
          res = this.write(buffer);
        if (this.charReceived) {
          var cr = this.charReceived;
          var buf = this.charBuffer;
          var enc = this.encoding;
          res += buf.slice(0, cr).toString(enc);
        }
        return res;
      };
    }
  });

  // ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
  function prependListener2(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
      return emitter.prependListener(event, fn);
    } else {
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
  }
  function listenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  }
  function ReadableState(options, stream) {
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.buffer = new buffer_list_default();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.ranOut = false;
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options && typeof options.read === "function")
      this._read = options.read;
    events_default.call(this);
  }
  function readableAddChunk(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit("error", er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e8 = new Error("stream.push() after EOF");
        stream.emit("error", e8);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error("stream.unshift() after end event");
        stream.emit("error", _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }
        if (!addToFront)
          state.reading = false;
        if (!skipAdd) {
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit("data", chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
        }
        maybeReadMore(stream, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }
    return needMoreData(state);
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  function computeNewHighWaterMark(n3) {
    if (n3 >= MAX_HWM) {
      n3 = MAX_HWM;
    } else {
      n3--;
      n3 |= n3 >>> 1;
      n3 |= n3 >>> 2;
      n3 |= n3 >>> 4;
      n3 |= n3 >>> 8;
      n3 |= n3 >>> 16;
      n3++;
    }
    return n3;
  }
  function howMuchToRead(n3, state) {
    if (n3 <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n3 !== n3) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n3 > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n3);
    if (n3 <= state.length)
      return n3;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  function chunkInvalid(state, chunk) {
    var er = null;
    if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        nextTick2(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick2(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && src.listeners("data").length) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick2(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  function fromList(n3, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n3 || n3 >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n3, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n3, list, hasStrings) {
    var ret;
    if (n3 < list.head.data.length) {
      ret = list.head.data.slice(0, n3);
      list.head.data = list.head.data.slice(n3);
    } else if (n3 === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n3, list) : copyFromBuffer(n3, list);
    }
    return ret;
  }
  function copyFromBufferString(n3, list) {
    var p2 = list.head;
    var c2 = 1;
    var ret = p2.data;
    n3 -= ret.length;
    while (p2 = p2.next) {
      var str = p2.data;
      var nb = n3 > str.length ? str.length : n3;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n3);
      n3 -= nb;
      if (n3 === 0) {
        if (nb === str.length) {
          ++c2;
          if (p2.next)
            list.head = p2.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p2;
          p2.data = str.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function copyFromBuffer(n3, list) {
    var ret = Buffer2.allocUnsafe(n3);
    var p2 = list.head;
    var c2 = 1;
    p2.data.copy(ret);
    n3 -= p2.data.length;
    while (p2 = p2.next) {
      var buf = p2.data;
      var nb = n3 > buf.length ? buf.length : n3;
      buf.copy(ret, ret.length - n3, 0, nb);
      n3 -= nb;
      if (n3 === 0) {
        if (nb === buf.length) {
          ++c2;
          if (p2.next)
            list.head = p2.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p2;
          p2.data = buf.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      nextTick2(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function forEach2(xs, f) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      f(xs[i2], i2);
    }
  }
  function indexOf3(xs, x2) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x2)
        return i2;
    }
    return -1;
  }
  var debug, MAX_HWM;
  var init_readable = __esm({
    "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_events();
      init_util();
      init_buffer_list();
      init_string_decoder();
      init_duplex();
      init_process2();
      Readable.ReadableState = ReadableState;
      debug = debuglog("stream");
      inherits_default(Readable, events_default);
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        if (!state.objectMode && typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
        }
        return readableAddChunk(this, state, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, "", true);
      };
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      MAX_HWM = 8388608;
      Readable.prototype.read = function(n3) {
        debug("read", n3);
        n3 = parseInt(n3, 10);
        var state = this._readableState;
        var nOrig = n3;
        if (n3 !== 0)
          state.emittedReadable = false;
        if (n3 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n3 = howMuchToRead(n3, state);
        if (n3 === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n3 < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n3 = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n3 > 0)
          ret = fromList(n3, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = true;
          n3 = 0;
        } else {
          state.length -= n3;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n3 && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      Readable.prototype._read = function(n3) {
        this.emit("error", new Error("not implemented"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = !pipeOpts || pipeOpts.end !== false;
        var endFn = doEnd ? onend2 : cleanup;
        if (state.endEmitted)
          nextTick2(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable) {
          debug("onunpipe");
          if (readable === src) {
            cleanup();
          }
        }
        function onend2() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", cleanup);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        var increasedAwaitDrain = false;
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (false === ret && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (listenerCount2(dest, "error") === 0)
            dest.emit("error", er);
        }
        prependListener2(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var _i = 0; _i < len; _i++) {
            dests[_i].emit("unpipe", this);
          }
          return this;
        }
        var i2 = indexOf3(state.pipes, dest);
        if (i2 === -1)
          return this;
        state.pipes.splice(i2, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = events_default.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              nextTick2(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this, state);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (false !== this._readableState.flowing) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      Readable.prototype.wrap = function(stream) {
        var state = this._readableState;
        var paused = false;
        var self2 = this;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              self2.push(chunk);
          }
          self2.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = self2.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i2 in stream) {
          if (this[i2] === void 0 && typeof stream[i2] === "function") {
            this[i2] = function(method) {
              return function() {
                return stream[method].apply(stream, arguments);
              };
            }(i2);
          }
        }
        var events = ["error", "close", "destroy", "pause", "resume"];
        forEach2(events, function(ev) {
          stream.on(ev, self2.emit.bind(self2, ev));
        });
        self2._read = function(n3) {
          debug("wrapped _read", n3);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return self2;
      };
      Readable._fromList = fromList;
    }
  });

  // ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
  function nop() {
  }
  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }
  function WritableState(options, stream) {
    Object.defineProperty(this, "buffer", {
      get: deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
    });
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  function Writable(options) {
    if (!(this instanceof Writable) && !(this instanceof Duplex))
      return new Writable(options);
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
    }
    EventEmitter2.call(this);
  }
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    nextTick2(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (!Buffer3.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      nextTick2(cb, er);
      valid = false;
    }
    return valid;
  }
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer3.from(chunk, encoding);
    }
    return chunk;
  }
  function writeOrBuffer(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer3.isBuffer(chunk))
      encoding = "buffer";
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync)
      nextTick2(cb, er);
    else
      cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit("error", er);
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        nextTick2(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function prefinish(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream, state);
        state.finished = true;
        stream.emit("finish");
      } else {
        prefinish(stream, state);
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        nextTick2(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function(err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }
  var init_writable = __esm({
    "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_util();
      init_buffer2();
      init_events();
      init_duplex();
      init_process2();
      Writable.WritableState = WritableState;
      inherits_default(Writable, EventEmitter2);
      WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (Buffer3.isBuffer(chunk))
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ended)
          writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished)
          endWritable(this, state, cb);
      };
    }
  });

  // ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    nextTick2(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  var keys, method, v;
  var init_duplex = __esm({
    "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_util();
      init_process2();
      init_readable();
      init_writable();
      inherits_default(Duplex, Readable);
      keys = Object.keys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
  });

  // ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
  function TransformState(stream) {
    this.afterTransform = function(er, data) {
      return afterTransform(stream, er, data);
    };
    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }
  function afterTransform(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb)
      return stream.emit("error", new Error("no writecb in Transform class"));
    ts.writechunk = null;
    ts.writecb = null;
    if (data !== null && data !== void 0)
      stream.push(data);
    cb(er);
    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = new TransformState(this);
    var stream = this;
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.once("prefinish", function() {
      if (typeof this._flush === "function")
        this._flush(function(er) {
          done(stream, er);
        });
      else
        done(stream);
    });
  }
  function done(stream, er) {
    if (er)
      return stream.emit("error", er);
    var ws = stream._writableState;
    var ts = stream._transformState;
    if (ws.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (ts.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
  var init_transform = __esm({
    "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_duplex();
      init_util();
      inherits_default(Transform, Duplex);
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("Not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n3) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
    }
  });

  // ../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  var init_passthrough = __esm({
    "../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_transform();
      init_util();
      inherits_default(PassThrough, Transform);
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node-modules-polyfills:stream
  var stream_exports = {};
  __export(stream_exports, {
    Duplex: () => Duplex,
    PassThrough: () => PassThrough,
    Readable: () => Readable,
    Stream: () => Stream,
    Transform: () => Transform,
    Writable: () => Writable,
    default: () => stream_default
  });
  function Stream() {
    events_default.call(this);
  }
  var stream_default;
  var init_stream = __esm({
    "node-modules-polyfills:stream"() {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      init_events();
      init_util();
      init_duplex();
      init_readable();
      init_writable();
      init_transform();
      init_passthrough();
      inherits_default(Stream, events_default);
      Stream.Readable = Readable;
      Stream.Writable = Writable;
      Stream.Duplex = Duplex;
      Stream.Transform = Transform;
      Stream.PassThrough = PassThrough;
      Stream.Stream = Stream;
      stream_default = Stream;
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend2);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend2() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (events_default.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend2);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }
  });

  // node-modules-polyfills-commonjs:stream
  var require_stream = __commonJS({
    "node-modules-polyfills-commonjs:stream"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var polyfill = (init_stream(), __toCommonJS(stream_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k2 in polyfill) {
          module.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills-commonjs:util
  var require_util = __commonJS({
    "node-modules-polyfills-commonjs:util"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var polyfill = (init_util(), __toCommonJS(util_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k2 in polyfill) {
          module.exports[k2] = polyfill[k2];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // ../node_modules/jsonwebtoken/node_modules/jws/lib/data-stream.js
  var require_data_stream = __commonJS({
    "../node_modules/jsonwebtoken/node_modules/jws/lib/data-stream.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Buffer4 = require_safe_buffer().Buffer;
      var Stream2 = require_stream();
      var util2 = require_util();
      function DataStream(data) {
        this.buffer = null;
        this.writable = true;
        this.readable = true;
        if (!data) {
          this.buffer = Buffer4.alloc(0);
          return this;
        }
        if (typeof data.pipe === "function") {
          this.buffer = Buffer4.alloc(0);
          data.pipe(this);
          return this;
        }
        if (data.length || typeof data === "object") {
          this.buffer = data;
          this.writable = false;
          process.nextTick(function() {
            this.emit("end", data);
            this.readable = false;
            this.emit("close");
          }.bind(this));
          return this;
        }
        throw new TypeError("Unexpected data type (" + typeof data + ")");
      }
      util2.inherits(DataStream, Stream2);
      DataStream.prototype.write = function write4(data) {
        this.buffer = Buffer4.concat([this.buffer, Buffer4.from(data)]);
        this.emit("data", data);
      };
      DataStream.prototype.end = function end(data) {
        if (data)
          this.write(data);
        this.emit("end", data);
        this.emit("close");
        this.writable = false;
        this.readable = false;
      };
      module.exports = DataStream;
    }
  });

  // ../node_modules/buffer-equal-constant-time/index.js
  var require_buffer_equal_constant_time = __commonJS({
    "../node_modules/buffer-equal-constant-time/index.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Buffer4 = require_buffer().Buffer;
      var SlowBuffer2 = require_buffer().SlowBuffer;
      module.exports = bufferEq;
      function bufferEq(a4, b2) {
        if (!Buffer4.isBuffer(a4) || !Buffer4.isBuffer(b2)) {
          return false;
        }
        if (a4.length !== b2.length) {
          return false;
        }
        var c2 = 0;
        for (var i2 = 0; i2 < a4.length; i2++) {
          c2 |= a4[i2] ^ b2[i2];
        }
        return c2 === 0;
      }
      bufferEq.install = function() {
        Buffer4.prototype.equal = SlowBuffer2.prototype.equal = function equal(that) {
          return bufferEq(this, that);
        };
      };
      var origBufEqual = Buffer4.prototype.equal;
      var origSlowBufEqual = SlowBuffer2.prototype.equal;
      bufferEq.restore = function() {
        Buffer4.prototype.equal = origBufEqual;
        SlowBuffer2.prototype.equal = origSlowBufEqual;
      };
    }
  });

  // ../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
  var require_param_bytes_for_alg = __commonJS({
    "../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      function getParamSize(keySize) {
        var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
        return result;
      }
      var paramBytesForAlg = {
        ES256: getParamSize(256),
        ES384: getParamSize(384),
        ES512: getParamSize(521)
      };
      function getParamBytesForAlg(alg) {
        var paramBytes = paramBytesForAlg[alg];
        if (paramBytes) {
          return paramBytes;
        }
        throw new Error('Unknown algorithm "' + alg + '"');
      }
      module.exports = getParamBytesForAlg;
    }
  });

  // ../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
  var require_ecdsa_sig_formatter = __commonJS({
    "../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Buffer4 = require_safe_buffer().Buffer;
      var getParamBytesForAlg = require_param_bytes_for_alg();
      var MAX_OCTET = 128;
      var CLASS_UNIVERSAL = 0;
      var PRIMITIVE_BIT = 32;
      var TAG_SEQ = 16;
      var TAG_INT = 2;
      var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
      var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
      function base64Url(base64) {
        return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
      }
      function signatureAsBuffer(signature) {
        if (Buffer4.isBuffer(signature)) {
          return signature;
        } else if ("string" === typeof signature) {
          return Buffer4.from(signature, "base64");
        }
        throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
      }
      function derToJose(signature, alg) {
        signature = signatureAsBuffer(signature);
        var paramBytes = getParamBytesForAlg(alg);
        var maxEncodedParamLength = paramBytes + 1;
        var inputLength = signature.length;
        var offset = 0;
        if (signature[offset++] !== ENCODED_TAG_SEQ) {
          throw new Error('Could not find expected "seq"');
        }
        var seqLength = signature[offset++];
        if (seqLength === (MAX_OCTET | 1)) {
          seqLength = signature[offset++];
        }
        if (inputLength - offset < seqLength) {
          throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
        }
        if (signature[offset++] !== ENCODED_TAG_INT) {
          throw new Error('Could not find expected "int" for "r"');
        }
        var rLength = signature[offset++];
        if (inputLength - offset - 2 < rLength) {
          throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
        }
        if (maxEncodedParamLength < rLength) {
          throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
        }
        var rOffset = offset;
        offset += rLength;
        if (signature[offset++] !== ENCODED_TAG_INT) {
          throw new Error('Could not find expected "int" for "s"');
        }
        var sLength = signature[offset++];
        if (inputLength - offset !== sLength) {
          throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
        }
        if (maxEncodedParamLength < sLength) {
          throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
        }
        var sOffset = offset;
        offset += sLength;
        if (offset !== inputLength) {
          throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
        }
        var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
        var dst = Buffer4.allocUnsafe(rPadding + rLength + sPadding + sLength);
        for (offset = 0; offset < rPadding; ++offset) {
          dst[offset] = 0;
        }
        signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
        offset = paramBytes;
        for (var o = offset; offset < o + sPadding; ++offset) {
          dst[offset] = 0;
        }
        signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
        dst = dst.toString("base64");
        dst = base64Url(dst);
        return dst;
      }
      function countPadding(buf, start, stop) {
        var padding = 0;
        while (start + padding < stop && buf[start + padding] === 0) {
          ++padding;
        }
        var needsSign = buf[start + padding] >= MAX_OCTET;
        if (needsSign) {
          --padding;
        }
        return padding;
      }
      function joseToDer(signature, alg) {
        signature = signatureAsBuffer(signature);
        var paramBytes = getParamBytesForAlg(alg);
        var signatureBytes = signature.length;
        if (signatureBytes !== paramBytes * 2) {
          throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
        }
        var rPadding = countPadding(signature, 0, paramBytes);
        var sPadding = countPadding(signature, paramBytes, signature.length);
        var rLength = paramBytes - rPadding;
        var sLength = paramBytes - sPadding;
        var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
        var shortLength = rsBytes < MAX_OCTET;
        var dst = Buffer4.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
        var offset = 0;
        dst[offset++] = ENCODED_TAG_SEQ;
        if (shortLength) {
          dst[offset++] = rsBytes;
        } else {
          dst[offset++] = MAX_OCTET | 1;
          dst[offset++] = rsBytes & 255;
        }
        dst[offset++] = ENCODED_TAG_INT;
        dst[offset++] = rLength;
        if (rPadding < 0) {
          dst[offset++] = 0;
          offset += signature.copy(dst, offset, 0, paramBytes);
        } else {
          offset += signature.copy(dst, offset, rPadding, paramBytes);
        }
        dst[offset++] = ENCODED_TAG_INT;
        dst[offset++] = sLength;
        if (sPadding < 0) {
          dst[offset++] = 0;
          signature.copy(dst, offset, paramBytes);
        } else {
          signature.copy(dst, offset, paramBytes + sPadding);
        }
        return dst;
      }
      module.exports = {
        derToJose,
        joseToDer
      };
    }
  });

  // ../node_modules/jsonwebtoken/node_modules/jwa/index.js
  var require_jwa = __commonJS({
    "../node_modules/jsonwebtoken/node_modules/jwa/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var bufferEqual = require_buffer_equal_constant_time();
      var Buffer4 = require_safe_buffer().Buffer;
      var crypto2 = require_crypto();
      var formatEcdsa = require_ecdsa_sig_formatter();
      var util2 = require_util();
      var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
      var MSG_INVALID_SECRET = "secret must be a string or buffer";
      var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
      var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
      var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
      if (supportsKeyObjects) {
        MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
        MSG_INVALID_SECRET += "or a KeyObject";
      }
      function checkIsPublicKey(key) {
        if (Buffer4.isBuffer(key)) {
          return;
        }
        if (typeof key === "string") {
          return;
        }
        if (!supportsKeyObjects) {
          throw typeError(MSG_INVALID_VERIFIER_KEY);
        }
        if (typeof key !== "object") {
          throw typeError(MSG_INVALID_VERIFIER_KEY);
        }
        if (typeof key.type !== "string") {
          throw typeError(MSG_INVALID_VERIFIER_KEY);
        }
        if (typeof key.asymmetricKeyType !== "string") {
          throw typeError(MSG_INVALID_VERIFIER_KEY);
        }
        if (typeof key.export !== "function") {
          throw typeError(MSG_INVALID_VERIFIER_KEY);
        }
      }
      function checkIsPrivateKey(key) {
        if (Buffer4.isBuffer(key)) {
          return;
        }
        if (typeof key === "string") {
          return;
        }
        if (typeof key === "object") {
          return;
        }
        throw typeError(MSG_INVALID_SIGNER_KEY);
      }
      function checkIsSecretKey(key) {
        if (Buffer4.isBuffer(key)) {
          return;
        }
        if (typeof key === "string") {
          return key;
        }
        if (!supportsKeyObjects) {
          throw typeError(MSG_INVALID_SECRET);
        }
        if (typeof key !== "object") {
          throw typeError(MSG_INVALID_SECRET);
        }
        if (key.type !== "secret") {
          throw typeError(MSG_INVALID_SECRET);
        }
        if (typeof key.export !== "function") {
          throw typeError(MSG_INVALID_SECRET);
        }
      }
      function fromBase64(base64) {
        return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
      }
      function toBase64(base64url) {
        base64url = base64url.toString();
        var padding = 4 - base64url.length % 4;
        if (padding !== 4) {
          for (var i2 = 0; i2 < padding; ++i2) {
            base64url += "=";
          }
        }
        return base64url.replace(/\-/g, "+").replace(/_/g, "/");
      }
      function typeError(template) {
        var args = [].slice.call(arguments, 1);
        var errMsg = util2.format.bind(util2, template).apply(null, args);
        return new TypeError(errMsg);
      }
      function bufferOrString(obj) {
        return Buffer4.isBuffer(obj) || typeof obj === "string";
      }
      function normalizeInput(thing) {
        if (!bufferOrString(thing))
          thing = JSON.stringify(thing);
        return thing;
      }
      function createHmacSigner(bits) {
        return function sign(thing, secret) {
          checkIsSecretKey(secret);
          thing = normalizeInput(thing);
          var hmac = crypto2.createHmac("sha" + bits, secret);
          var sig = (hmac.update(thing), hmac.digest("base64"));
          return fromBase64(sig);
        };
      }
      function createHmacVerifier(bits) {
        return function verify(thing, signature, secret) {
          var computedSig = createHmacSigner(bits)(thing, secret);
          return bufferEqual(Buffer4.from(signature), Buffer4.from(computedSig));
        };
      }
      function createKeySigner(bits) {
        return function sign(thing, privateKey) {
          checkIsPrivateKey(privateKey);
          thing = normalizeInput(thing);
          var signer = crypto2.createSign("RSA-SHA" + bits);
          var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
          return fromBase64(sig);
        };
      }
      function createKeyVerifier(bits) {
        return function verify(thing, signature, publicKey) {
          checkIsPublicKey(publicKey);
          thing = normalizeInput(thing);
          signature = toBase64(signature);
          var verifier = crypto2.createVerify("RSA-SHA" + bits);
          verifier.update(thing);
          return verifier.verify(publicKey, signature, "base64");
        };
      }
      function createPSSKeySigner(bits) {
        return function sign(thing, privateKey) {
          checkIsPrivateKey(privateKey);
          thing = normalizeInput(thing);
          var signer = crypto2.createSign("RSA-SHA" + bits);
          var sig = (signer.update(thing), signer.sign({
            key: privateKey,
            padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
          }, "base64"));
          return fromBase64(sig);
        };
      }
      function createPSSKeyVerifier(bits) {
        return function verify(thing, signature, publicKey) {
          checkIsPublicKey(publicKey);
          thing = normalizeInput(thing);
          signature = toBase64(signature);
          var verifier = crypto2.createVerify("RSA-SHA" + bits);
          verifier.update(thing);
          return verifier.verify({
            key: publicKey,
            padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
          }, signature, "base64");
        };
      }
      function createECDSASigner(bits) {
        var inner = createKeySigner(bits);
        return function sign() {
          var signature = inner.apply(null, arguments);
          signature = formatEcdsa.derToJose(signature, "ES" + bits);
          return signature;
        };
      }
      function createECDSAVerifer(bits) {
        var inner = createKeyVerifier(bits);
        return function verify(thing, signature, publicKey) {
          signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
          var result = inner(thing, signature, publicKey);
          return result;
        };
      }
      function createNoneSigner() {
        return function sign() {
          return "";
        };
      }
      function createNoneVerifier() {
        return function verify(thing, signature) {
          return signature === "";
        };
      }
      module.exports = function jwa(algorithm) {
        var signerFactories = {
          hs: createHmacSigner,
          rs: createKeySigner,
          ps: createPSSKeySigner,
          es: createECDSASigner,
          none: createNoneSigner
        };
        var verifierFactories = {
          hs: createHmacVerifier,
          rs: createKeyVerifier,
          ps: createPSSKeyVerifier,
          es: createECDSAVerifer,
          none: createNoneVerifier
        };
        var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
        if (!match)
          throw typeError(MSG_INVALID_ALGORITHM, algorithm);
        var algo = (match[1] || match[3]).toLowerCase();
        var bits = match[2];
        return {
          sign: signerFactories[algo](bits),
          verify: verifierFactories[algo](bits)
        };
      };
    }
  });

  // ../node_modules/jsonwebtoken/node_modules/jws/lib/tostring.js
  var require_tostring = __commonJS({
    "../node_modules/jsonwebtoken/node_modules/jws/lib/tostring.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Buffer4 = require_buffer().Buffer;
      module.exports = function toString6(obj) {
        if (typeof obj === "string")
          return obj;
        if (typeof obj === "number" || Buffer4.isBuffer(obj))
          return obj.toString();
        return JSON.stringify(obj);
      };
    }
  });

  // ../node_modules/jsonwebtoken/node_modules/jws/lib/sign-stream.js
  var require_sign_stream = __commonJS({
    "../node_modules/jsonwebtoken/node_modules/jws/lib/sign-stream.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Buffer4 = require_safe_buffer().Buffer;
      var DataStream = require_data_stream();
      var jwa = require_jwa();
      var Stream2 = require_stream();
      var toString6 = require_tostring();
      var util2 = require_util();
      function base64url(string, encoding) {
        return Buffer4.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
      }
      function jwsSecuredInput(header, payload, encoding) {
        encoding = encoding || "utf8";
        var encodedHeader = base64url(toString6(header), "binary");
        var encodedPayload = base64url(toString6(payload), encoding);
        return util2.format("%s.%s", encodedHeader, encodedPayload);
      }
      function jwsSign(opts) {
        var header = opts.header;
        var payload = opts.payload;
        var secretOrKey = opts.secret || opts.privateKey;
        var encoding = opts.encoding;
        var algo = jwa(header.alg);
        var securedInput = jwsSecuredInput(header, payload, encoding);
        var signature = algo.sign(securedInput, secretOrKey);
        return util2.format("%s.%s", securedInput, signature);
      }
      function SignStream(opts) {
        var secret = opts.secret || opts.privateKey || opts.key;
        var secretStream = new DataStream(secret);
        this.readable = true;
        this.header = opts.header;
        this.encoding = opts.encoding;
        this.secret = this.privateKey = this.key = secretStream;
        this.payload = new DataStream(opts.payload);
        this.secret.once("close", function() {
          if (!this.payload.writable && this.readable)
            this.sign();
        }.bind(this));
        this.payload.once("close", function() {
          if (!this.secret.writable && this.readable)
            this.sign();
        }.bind(this));
      }
      util2.inherits(SignStream, Stream2);
      SignStream.prototype.sign = function sign() {
        try {
          var signature = jwsSign({
            header: this.header,
            payload: this.payload.buffer,
            secret: this.secret.buffer,
            encoding: this.encoding
          });
          this.emit("done", signature);
          this.emit("data", signature);
          this.emit("end");
          this.readable = false;
          return signature;
        } catch (e8) {
          this.readable = false;
          this.emit("error", e8);
          this.emit("close");
        }
      };
      SignStream.sign = jwsSign;
      module.exports = SignStream;
    }
  });

  // ../node_modules/jsonwebtoken/node_modules/jws/lib/verify-stream.js
  var require_verify_stream = __commonJS({
    "../node_modules/jsonwebtoken/node_modules/jws/lib/verify-stream.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Buffer4 = require_safe_buffer().Buffer;
      var DataStream = require_data_stream();
      var jwa = require_jwa();
      var Stream2 = require_stream();
      var toString6 = require_tostring();
      var util2 = require_util();
      var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
      function isObject4(thing) {
        return Object.prototype.toString.call(thing) === "[object Object]";
      }
      function safeJsonParse(thing) {
        if (isObject4(thing))
          return thing;
        try {
          return JSON.parse(thing);
        } catch (e8) {
          return void 0;
        }
      }
      function headerFromJWS(jwsSig) {
        var encodedHeader = jwsSig.split(".", 1)[0];
        return safeJsonParse(Buffer4.from(encodedHeader, "base64").toString("binary"));
      }
      function securedInputFromJWS(jwsSig) {
        return jwsSig.split(".", 2).join(".");
      }
      function signatureFromJWS(jwsSig) {
        return jwsSig.split(".")[2];
      }
      function payloadFromJWS(jwsSig, encoding) {
        encoding = encoding || "utf8";
        var payload = jwsSig.split(".")[1];
        return Buffer4.from(payload, "base64").toString(encoding);
      }
      function isValidJws(string) {
        return JWS_REGEX.test(string) && !!headerFromJWS(string);
      }
      function jwsVerify(jwsSig, algorithm, secretOrKey) {
        if (!algorithm) {
          var err = new Error("Missing algorithm parameter for jws.verify");
          err.code = "MISSING_ALGORITHM";
          throw err;
        }
        jwsSig = toString6(jwsSig);
        var signature = signatureFromJWS(jwsSig);
        var securedInput = securedInputFromJWS(jwsSig);
        var algo = jwa(algorithm);
        return algo.verify(securedInput, signature, secretOrKey);
      }
      function jwsDecode(jwsSig, opts) {
        opts = opts || {};
        jwsSig = toString6(jwsSig);
        if (!isValidJws(jwsSig))
          return null;
        var header = headerFromJWS(jwsSig);
        if (!header)
          return null;
        var payload = payloadFromJWS(jwsSig);
        if (header.typ === "JWT" || opts.json)
          payload = JSON.parse(payload, opts.encoding);
        return {
          header,
          payload,
          signature: signatureFromJWS(jwsSig)
        };
      }
      function VerifyStream(opts) {
        opts = opts || {};
        var secretOrKey = opts.secret || opts.publicKey || opts.key;
        var secretStream = new DataStream(secretOrKey);
        this.readable = true;
        this.algorithm = opts.algorithm;
        this.encoding = opts.encoding;
        this.secret = this.publicKey = this.key = secretStream;
        this.signature = new DataStream(opts.signature);
        this.secret.once("close", function() {
          if (!this.signature.writable && this.readable)
            this.verify();
        }.bind(this));
        this.signature.once("close", function() {
          if (!this.secret.writable && this.readable)
            this.verify();
        }.bind(this));
      }
      util2.inherits(VerifyStream, Stream2);
      VerifyStream.prototype.verify = function verify() {
        try {
          var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
          var obj = jwsDecode(this.signature.buffer, this.encoding);
          this.emit("done", valid, obj);
          this.emit("data", valid);
          this.emit("end");
          this.readable = false;
          return valid;
        } catch (e8) {
          this.readable = false;
          this.emit("error", e8);
          this.emit("close");
        }
      };
      VerifyStream.decode = jwsDecode;
      VerifyStream.isValid = isValidJws;
      VerifyStream.verify = jwsVerify;
      module.exports = VerifyStream;
    }
  });

  // ../node_modules/jsonwebtoken/node_modules/jws/index.js
  var require_jws = __commonJS({
    "../node_modules/jsonwebtoken/node_modules/jws/index.js"(exports) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SignStream = require_sign_stream();
      var VerifyStream = require_verify_stream();
      var ALGORITHMS = [
        "HS256",
        "HS384",
        "HS512",
        "RS256",
        "RS384",
        "RS512",
        "PS256",
        "PS384",
        "PS512",
        "ES256",
        "ES384",
        "ES512"
      ];
      exports.ALGORITHMS = ALGORITHMS;
      exports.sign = SignStream.sign;
      exports.verify = VerifyStream.verify;
      exports.decode = VerifyStream.decode;
      exports.isValid = VerifyStream.isValid;
      exports.createSign = function createSign(opts) {
        return new SignStream(opts);
      };
      exports.createVerify = function createVerify(opts) {
        return new VerifyStream(opts);
      };
    }
  });

  // ../node_modules/jsonwebtoken/decode.js
  var require_decode = __commonJS({
    "../node_modules/jsonwebtoken/decode.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var jws = require_jws();
      module.exports = function(jwt5, options) {
        options = options || {};
        var decoded = jws.decode(jwt5, options);
        if (!decoded) {
          return null;
        }
        var payload = decoded.payload;
        if (typeof payload === "string") {
          try {
            var obj = JSON.parse(payload);
            if (obj !== null && typeof obj === "object") {
              payload = obj;
            }
          } catch (e8) {
          }
        }
        if (options.complete === true) {
          return {
            header: decoded.header,
            payload,
            signature: decoded.signature
          };
        }
        return payload;
      };
    }
  });

  // ../node_modules/jsonwebtoken/lib/JsonWebTokenError.js
  var require_JsonWebTokenError = __commonJS({
    "../node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var JsonWebTokenError = function(message, error) {
        Error.call(this, message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "JsonWebTokenError";
        this.message = message;
        if (error)
          this.inner = error;
      };
      JsonWebTokenError.prototype = Object.create(Error.prototype);
      JsonWebTokenError.prototype.constructor = JsonWebTokenError;
      module.exports = JsonWebTokenError;
    }
  });

  // ../node_modules/jsonwebtoken/lib/NotBeforeError.js
  var require_NotBeforeError = __commonJS({
    "../node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var JsonWebTokenError = require_JsonWebTokenError();
      var NotBeforeError = function(message, date) {
        JsonWebTokenError.call(this, message);
        this.name = "NotBeforeError";
        this.date = date;
      };
      NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
      NotBeforeError.prototype.constructor = NotBeforeError;
      module.exports = NotBeforeError;
    }
  });

  // ../node_modules/jsonwebtoken/lib/TokenExpiredError.js
  var require_TokenExpiredError = __commonJS({
    "../node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var JsonWebTokenError = require_JsonWebTokenError();
      var TokenExpiredError = function(message, expiredAt) {
        JsonWebTokenError.call(this, message);
        this.name = "TokenExpiredError";
        this.expiredAt = expiredAt;
      };
      TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
      TokenExpiredError.prototype.constructor = TokenExpiredError;
      module.exports = TokenExpiredError;
    }
  });

  // ../node_modules/ms/index.js
  var require_ms = __commonJS({
    "../node_modules/ms/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var s3 = 1e3;
      var m2 = s3 * 60;
      var h2 = m2 * 60;
      var d2 = h2 * 24;
      var w = d2 * 7;
      var y2 = d2 * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type2 = typeof val;
        if (type2 === "string" && val.length > 0) {
          return parse(val);
        } else if (type2 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n3 = parseFloat(match[1]);
        var type2 = (match[2] || "ms").toLowerCase();
        switch (type2) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n3 * y2;
          case "weeks":
          case "week":
          case "w":
            return n3 * w;
          case "days":
          case "day":
          case "d":
            return n3 * d2;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n3 * h2;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n3 * m2;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n3 * s3;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n3;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d2) {
          return Math.round(ms / d2) + "d";
        }
        if (msAbs >= h2) {
          return Math.round(ms / h2) + "h";
        }
        if (msAbs >= m2) {
          return Math.round(ms / m2) + "m";
        }
        if (msAbs >= s3) {
          return Math.round(ms / s3) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d2) {
          return plural(ms, msAbs, d2, "day");
        }
        if (msAbs >= h2) {
          return plural(ms, msAbs, h2, "hour");
        }
        if (msAbs >= m2) {
          return plural(ms, msAbs, m2, "minute");
        }
        if (msAbs >= s3) {
          return plural(ms, msAbs, s3, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n3, name) {
        var isPlural = msAbs >= n3 * 1.5;
        return Math.round(ms / n3) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../node_modules/jsonwebtoken/lib/timespan.js
  var require_timespan = __commonJS({
    "../node_modules/jsonwebtoken/lib/timespan.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var ms = require_ms();
      module.exports = function(time, iat) {
        var timestamp2 = iat || Math.floor(Date.now() / 1e3);
        if (typeof time === "string") {
          var milliseconds = ms(time);
          if (typeof milliseconds === "undefined") {
            return;
          }
          return Math.floor(timestamp2 + milliseconds / 1e3);
        } else if (typeof time === "number") {
          return timestamp2 + time;
        } else {
          return;
        }
      };
    }
  });

  // ../node_modules/semver/internal/constants.js
  var require_constants = __commonJS({
    "../node_modules/semver/internal/constants.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
      9007199254740991;
      var MAX_SAFE_COMPONENT_LENGTH = 16;
      var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
      var RELEASE_TYPES = [
        "major",
        "premajor",
        "minor",
        "preminor",
        "patch",
        "prepatch",
        "prerelease"
      ];
      module.exports = {
        MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER,
        RELEASE_TYPES,
        SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
      };
    }
  });

  // ../node_modules/semver/internal/debug.js
  var require_debug = __commonJS({
    "../node_modules/semver/internal/debug.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
      module.exports = debug2;
    }
  });

  // ../node_modules/semver/internal/re.js
  var require_re = __commonJS({
    "../node_modules/semver/internal/re.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var {
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_LENGTH
      } = require_constants();
      var debug2 = require_debug();
      exports = module.exports = {};
      var re = exports.re = [];
      var safeRe = exports.safeRe = [];
      var src = exports.src = [];
      var t5 = exports.t = {};
      var R = 0;
      var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
      var safeRegexReplacements = [
        ["\\s", 1],
        ["\\d", MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
      ];
      var makeSafeRegex = (value) => {
        for (const [token, max] of safeRegexReplacements) {
          value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
        }
        return value;
      };
      var createToken = (name, value, isGlobal) => {
        const safe = makeSafeRegex(value);
        const index = R++;
        debug2(name, index, value);
        t5[name] = index;
        src[index] = value;
        re[index] = new RegExp(value, isGlobal ? "g" : void 0);
        safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken("MAINVERSION", `(${src[t5.NUMERICIDENTIFIER]})\\.(${src[t5.NUMERICIDENTIFIER]})\\.(${src[t5.NUMERICIDENTIFIER]})`);
      createToken("MAINVERSIONLOOSE", `(${src[t5.NUMERICIDENTIFIERLOOSE]})\\.(${src[t5.NUMERICIDENTIFIERLOOSE]})\\.(${src[t5.NUMERICIDENTIFIERLOOSE]})`);
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t5.NUMERICIDENTIFIER]}|${src[t5.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t5.NUMERICIDENTIFIERLOOSE]}|${src[t5.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASE", `(?:-(${src[t5.PRERELEASEIDENTIFIER]}(?:\\.${src[t5.PRERELEASEIDENTIFIER]})*))`);
      createToken("PRERELEASELOOSE", `(?:-?(${src[t5.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t5.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
      createToken("BUILD", `(?:\\+(${src[t5.BUILDIDENTIFIER]}(?:\\.${src[t5.BUILDIDENTIFIER]})*))`);
      createToken("FULLPLAIN", `v?${src[t5.MAINVERSION]}${src[t5.PRERELEASE]}?${src[t5.BUILD]}?`);
      createToken("FULL", `^${src[t5.FULLPLAIN]}$`);
      createToken("LOOSEPLAIN", `[v=\\s]*${src[t5.MAINVERSIONLOOSE]}${src[t5.PRERELEASELOOSE]}?${src[t5.BUILD]}?`);
      createToken("LOOSE", `^${src[t5.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t5.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken("XRANGEIDENTIFIER", `${src[t5.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken("XRANGEPLAIN", `[v=\\s]*(${src[t5.XRANGEIDENTIFIER]})(?:\\.(${src[t5.XRANGEIDENTIFIER]})(?:\\.(${src[t5.XRANGEIDENTIFIER]})(?:${src[t5.PRERELEASE]})?${src[t5.BUILD]}?)?)?`);
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t5.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t5.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t5.XRANGEIDENTIFIERLOOSE]})(?:${src[t5.PRERELEASELOOSE]})?${src[t5.BUILD]}?)?)?`);
      createToken("XRANGE", `^${src[t5.GTLT]}\\s*${src[t5.XRANGEPLAIN]}$`);
      createToken("XRANGELOOSE", `^${src[t5.GTLT]}\\s*${src[t5.XRANGEPLAINLOOSE]}$`);
      createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
      createToken("COERCERTL", src[t5.COERCE], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t5.LONETILDE]}\\s+`, true);
      exports.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t5.LONETILDE]}${src[t5.XRANGEPLAIN]}$`);
      createToken("TILDELOOSE", `^${src[t5.LONETILDE]}${src[t5.XRANGEPLAINLOOSE]}$`);
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t5.LONECARET]}\\s+`, true);
      exports.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t5.LONECARET]}${src[t5.XRANGEPLAIN]}$`);
      createToken("CARETLOOSE", `^${src[t5.LONECARET]}${src[t5.XRANGEPLAINLOOSE]}$`);
      createToken("COMPARATORLOOSE", `^${src[t5.GTLT]}\\s*(${src[t5.LOOSEPLAIN]})$|^$`);
      createToken("COMPARATOR", `^${src[t5.GTLT]}\\s*(${src[t5.FULLPLAIN]})$|^$`);
      createToken("COMPARATORTRIM", `(\\s*)${src[t5.GTLT]}\\s*(${src[t5.LOOSEPLAIN]}|${src[t5.XRANGEPLAIN]})`, true);
      exports.comparatorTrimReplace = "$1$2$3";
      createToken("HYPHENRANGE", `^\\s*(${src[t5.XRANGEPLAIN]})\\s+-\\s+(${src[t5.XRANGEPLAIN]})\\s*$`);
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t5.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t5.XRANGEPLAINLOOSE]})\\s*$`);
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    }
  });

  // ../node_modules/semver/internal/parse-options.js
  var require_parse_options = __commonJS({
    "../node_modules/semver/internal/parse-options.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var looseOption = Object.freeze({ loose: true });
      var emptyOpts = Object.freeze({});
      var parseOptions = (options) => {
        if (!options) {
          return emptyOpts;
        }
        if (typeof options !== "object") {
          return looseOption;
        }
        return options;
      };
      module.exports = parseOptions;
    }
  });

  // ../node_modules/semver/internal/identifiers.js
  var require_identifiers = __commonJS({
    "../node_modules/semver/internal/identifiers.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var numeric = /^[0-9]+$/;
      var compareIdentifiers = (a4, b2) => {
        const anum = numeric.test(a4);
        const bnum = numeric.test(b2);
        if (anum && bnum) {
          a4 = +a4;
          b2 = +b2;
        }
        return a4 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a4 < b2 ? -1 : 1;
      };
      var rcompareIdentifiers = (a4, b2) => compareIdentifiers(b2, a4);
      module.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    }
  });

  // ../node_modules/semver/classes/semver.js
  var require_semver = __commonJS({
    "../node_modules/semver/classes/semver.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var debug2 = require_debug();
      var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
      var { safeRe: re, t: t5 } = require_re();
      var parseOptions = require_parse_options();
      var { compareIdentifiers } = require_identifiers();
      var SemVer = class {
        constructor(version3, options) {
          options = parseOptions(options);
          if (version3 instanceof SemVer) {
            if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
              return version3;
            } else {
              version3 = version3.version;
            }
          } else if (typeof version3 !== "string") {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
          }
          if (version3.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`
            );
          }
          debug2("SemVer", version3, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m2 = version3.trim().match(options.loose ? re[t5.LOOSE] : re[t5.FULL]);
          if (!m2) {
            throw new TypeError(`Invalid Version: ${version3}`);
          }
          this.raw = version3;
          this.major = +m2[1];
          this.minor = +m2[2];
          this.patch = +m2[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m2[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m2[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m2[5] ? m2[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug2("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i2 = 0;
          do {
            const a4 = this.prerelease[i2];
            const b2 = other.prerelease[i2];
            debug2("prerelease compare", i2, a4, b2);
            if (a4 === void 0 && b2 === void 0) {
              return 0;
            } else if (b2 === void 0) {
              return 1;
            } else if (a4 === void 0) {
              return -1;
            } else if (a4 === b2) {
              continue;
            } else {
              return compareIdentifiers(a4, b2);
            }
          } while (++i2);
        }
        compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          let i2 = 0;
          do {
            const a4 = this.build[i2];
            const b2 = other.build[i2];
            debug2("prerelease compare", i2, a4, b2);
            if (a4 === void 0 && b2 === void 0) {
              return 0;
            } else if (b2 === void 0) {
              return 1;
            } else if (a4 === void 0) {
              return -1;
            } else if (a4 === b2) {
              continue;
            } else {
              return compareIdentifiers(a4, b2);
            }
          } while (++i2);
        }
        // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.
        inc(release4, identifier, identifierBase) {
          switch (release4) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier, identifierBase);
              this.inc("pre", identifier, identifierBase);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier, identifierBase);
              }
              this.inc("pre", identifier, identifierBase);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre": {
              const base = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === false) {
                throw new Error("invalid increment argument: identifier is empty");
              }
              if (this.prerelease.length === 0) {
                this.prerelease = [base];
              } else {
                let i2 = this.prerelease.length;
                while (--i2 >= 0) {
                  if (typeof this.prerelease[i2] === "number") {
                    this.prerelease[i2]++;
                    i2 = -2;
                  }
                }
                if (i2 === -1) {
                  if (identifier === this.prerelease.join(".") && identifierBase === false) {
                    throw new Error("invalid increment argument: identifier already exists");
                  }
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                let prerelease = [identifier, base];
                if (identifierBase === false) {
                  prerelease = [identifier];
                }
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = prerelease;
                  }
                } else {
                  this.prerelease = prerelease;
                }
              }
              break;
            }
            default:
              throw new Error(`invalid increment argument: ${release4}`);
          }
          this.raw = this.format();
          if (this.build.length) {
            this.raw += `+${this.build.join(".")}`;
          }
          return this;
        }
      };
      module.exports = SemVer;
    }
  });

  // ../node_modules/semver/functions/parse.js
  var require_parse2 = __commonJS({
    "../node_modules/semver/functions/parse.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var parse = (version3, options, throwErrors = false) => {
        if (version3 instanceof SemVer) {
          return version3;
        }
        try {
          return new SemVer(version3, options);
        } catch (er) {
          if (!throwErrors) {
            return null;
          }
          throw er;
        }
      };
      module.exports = parse;
    }
  });

  // ../node_modules/semver/functions/valid.js
  var require_valid = __commonJS({
    "../node_modules/semver/functions/valid.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var parse = require_parse2();
      var valid = (version3, options) => {
        const v = parse(version3, options);
        return v ? v.version : null;
      };
      module.exports = valid;
    }
  });

  // ../node_modules/semver/functions/clean.js
  var require_clean = __commonJS({
    "../node_modules/semver/functions/clean.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var parse = require_parse2();
      var clean = (version3, options) => {
        const s3 = parse(version3.trim().replace(/^[=v]+/, ""), options);
        return s3 ? s3.version : null;
      };
      module.exports = clean;
    }
  });

  // ../node_modules/semver/functions/inc.js
  var require_inc = __commonJS({
    "../node_modules/semver/functions/inc.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var inc = (version3, release4, options, identifier, identifierBase) => {
        if (typeof options === "string") {
          identifierBase = identifier;
          identifier = options;
          options = void 0;
        }
        try {
          return new SemVer(
            version3 instanceof SemVer ? version3.version : version3,
            options
          ).inc(release4, identifier, identifierBase).version;
        } catch (er) {
          return null;
        }
      };
      module.exports = inc;
    }
  });

  // ../node_modules/semver/functions/diff.js
  var require_diff = __commonJS({
    "../node_modules/semver/functions/diff.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var parse = require_parse2();
      var diff = (version1, version22) => {
        const v1 = parse(version1, null, true);
        const v2 = parse(version22, null, true);
        const comparison = v1.compare(v2);
        if (comparison === 0) {
          return null;
        }
        const v1Higher = comparison > 0;
        const highVersion = v1Higher ? v1 : v2;
        const lowVersion = v1Higher ? v2 : v1;
        const highHasPre = !!highVersion.prerelease.length;
        const lowHasPre = !!lowVersion.prerelease.length;
        if (lowHasPre && !highHasPre) {
          if (!lowVersion.patch && !lowVersion.minor) {
            return "major";
          }
          if (highVersion.patch) {
            return "patch";
          }
          if (highVersion.minor) {
            return "minor";
          }
          return "major";
        }
        const prefix = highHasPre ? "pre" : "";
        if (v1.major !== v2.major) {
          return prefix + "major";
        }
        if (v1.minor !== v2.minor) {
          return prefix + "minor";
        }
        if (v1.patch !== v2.patch) {
          return prefix + "patch";
        }
        return "prerelease";
      };
      module.exports = diff;
    }
  });

  // ../node_modules/semver/functions/major.js
  var require_major = __commonJS({
    "../node_modules/semver/functions/major.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var major = (a4, loose) => new SemVer(a4, loose).major;
      module.exports = major;
    }
  });

  // ../node_modules/semver/functions/minor.js
  var require_minor = __commonJS({
    "../node_modules/semver/functions/minor.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var minor = (a4, loose) => new SemVer(a4, loose).minor;
      module.exports = minor;
    }
  });

  // ../node_modules/semver/functions/patch.js
  var require_patch = __commonJS({
    "../node_modules/semver/functions/patch.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var patch = (a4, loose) => new SemVer(a4, loose).patch;
      module.exports = patch;
    }
  });

  // ../node_modules/semver/functions/prerelease.js
  var require_prerelease = __commonJS({
    "../node_modules/semver/functions/prerelease.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var parse = require_parse2();
      var prerelease = (version3, options) => {
        const parsed = parse(version3, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
      };
      module.exports = prerelease;
    }
  });

  // ../node_modules/semver/functions/compare.js
  var require_compare = __commonJS({
    "../node_modules/semver/functions/compare.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var compare5 = (a4, b2, loose) => new SemVer(a4, loose).compare(new SemVer(b2, loose));
      module.exports = compare5;
    }
  });

  // ../node_modules/semver/functions/rcompare.js
  var require_rcompare = __commonJS({
    "../node_modules/semver/functions/rcompare.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compare5 = require_compare();
      var rcompare = (a4, b2, loose) => compare5(b2, a4, loose);
      module.exports = rcompare;
    }
  });

  // ../node_modules/semver/functions/compare-loose.js
  var require_compare_loose = __commonJS({
    "../node_modules/semver/functions/compare-loose.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compare5 = require_compare();
      var compareLoose = (a4, b2) => compare5(a4, b2, true);
      module.exports = compareLoose;
    }
  });

  // ../node_modules/semver/functions/compare-build.js
  var require_compare_build = __commonJS({
    "../node_modules/semver/functions/compare-build.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var compareBuild = (a4, b2, loose) => {
        const versionA = new SemVer(a4, loose);
        const versionB = new SemVer(b2, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
      };
      module.exports = compareBuild;
    }
  });

  // ../node_modules/semver/functions/sort.js
  var require_sort = __commonJS({
    "../node_modules/semver/functions/sort.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compareBuild = require_compare_build();
      var sort = (list, loose) => list.sort((a4, b2) => compareBuild(a4, b2, loose));
      module.exports = sort;
    }
  });

  // ../node_modules/semver/functions/rsort.js
  var require_rsort = __commonJS({
    "../node_modules/semver/functions/rsort.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compareBuild = require_compare_build();
      var rsort = (list, loose) => list.sort((a4, b2) => compareBuild(b2, a4, loose));
      module.exports = rsort;
    }
  });

  // ../node_modules/semver/functions/gt.js
  var require_gt = __commonJS({
    "../node_modules/semver/functions/gt.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compare5 = require_compare();
      var gt = (a4, b2, loose) => compare5(a4, b2, loose) > 0;
      module.exports = gt;
    }
  });

  // ../node_modules/semver/functions/lt.js
  var require_lt = __commonJS({
    "../node_modules/semver/functions/lt.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compare5 = require_compare();
      var lt = (a4, b2, loose) => compare5(a4, b2, loose) < 0;
      module.exports = lt;
    }
  });

  // ../node_modules/semver/functions/eq.js
  var require_eq = __commonJS({
    "../node_modules/semver/functions/eq.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compare5 = require_compare();
      var eq = (a4, b2, loose) => compare5(a4, b2, loose) === 0;
      module.exports = eq;
    }
  });

  // ../node_modules/semver/functions/neq.js
  var require_neq = __commonJS({
    "../node_modules/semver/functions/neq.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compare5 = require_compare();
      var neq = (a4, b2, loose) => compare5(a4, b2, loose) !== 0;
      module.exports = neq;
    }
  });

  // ../node_modules/semver/functions/gte.js
  var require_gte = __commonJS({
    "../node_modules/semver/functions/gte.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compare5 = require_compare();
      var gte = (a4, b2, loose) => compare5(a4, b2, loose) >= 0;
      module.exports = gte;
    }
  });

  // ../node_modules/semver/functions/lte.js
  var require_lte = __commonJS({
    "../node_modules/semver/functions/lte.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var compare5 = require_compare();
      var lte = (a4, b2, loose) => compare5(a4, b2, loose) <= 0;
      module.exports = lte;
    }
  });

  // ../node_modules/semver/functions/cmp.js
  var require_cmp = __commonJS({
    "../node_modules/semver/functions/cmp.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var eq = require_eq();
      var neq = require_neq();
      var gt = require_gt();
      var gte = require_gte();
      var lt = require_lt();
      var lte = require_lte();
      var cmp = (a4, op, b2, loose) => {
        switch (op) {
          case "===":
            if (typeof a4 === "object") {
              a4 = a4.version;
            }
            if (typeof b2 === "object") {
              b2 = b2.version;
            }
            return a4 === b2;
          case "!==":
            if (typeof a4 === "object") {
              a4 = a4.version;
            }
            if (typeof b2 === "object") {
              b2 = b2.version;
            }
            return a4 !== b2;
          case "":
          case "=":
          case "==":
            return eq(a4, b2, loose);
          case "!=":
            return neq(a4, b2, loose);
          case ">":
            return gt(a4, b2, loose);
          case ">=":
            return gte(a4, b2, loose);
          case "<":
            return lt(a4, b2, loose);
          case "<=":
            return lte(a4, b2, loose);
          default:
            throw new TypeError(`Invalid operator: ${op}`);
        }
      };
      module.exports = cmp;
    }
  });

  // ../node_modules/semver/functions/coerce.js
  var require_coerce = __commonJS({
    "../node_modules/semver/functions/coerce.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var parse = require_parse2();
      var { safeRe: re, t: t5 } = require_re();
      var coerce2 = (version3, options) => {
        if (version3 instanceof SemVer) {
          return version3;
        }
        if (typeof version3 === "number") {
          version3 = String(version3);
        }
        if (typeof version3 !== "string") {
          return null;
        }
        options = options || {};
        let match = null;
        if (!options.rtl) {
          match = version3.match(re[t5.COERCE]);
        } else {
          let next;
          while ((next = re[t5.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
              match = next;
            }
            re[t5.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
          }
          re[t5.COERCERTL].lastIndex = -1;
        }
        if (match === null) {
          return null;
        }
        return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
      };
      module.exports = coerce2;
    }
  });

  // ../node_modules/yallist/iterator.js
  var require_iterator = __commonJS({
    "../node_modules/yallist/iterator.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = function(Yallist) {
        Yallist.prototype[Symbol.iterator] = function* () {
          for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
          }
        };
      };
    }
  });

  // ../node_modules/yallist/yallist.js
  var require_yallist = __commonJS({
    "../node_modules/yallist/yallist.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = Yallist;
      Yallist.Node = Node;
      Yallist.create = Yallist;
      function Yallist(list) {
        var self2 = this;
        if (!(self2 instanceof Yallist)) {
          self2 = new Yallist();
        }
        self2.tail = null;
        self2.head = null;
        self2.length = 0;
        if (list && typeof list.forEach === "function") {
          list.forEach(function(item) {
            self2.push(item);
          });
        } else if (arguments.length > 0) {
          for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
            self2.push(arguments[i2]);
          }
        }
        return self2;
      }
      Yallist.prototype.removeNode = function(node) {
        if (node.list !== this) {
          throw new Error("removing node which does not belong to this list");
        }
        var next = node.next;
        var prev = node.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node === this.head) {
          this.head = next;
        }
        if (node === this.tail) {
          this.tail = prev;
        }
        node.list.length--;
        node.next = null;
        node.prev = null;
        node.list = null;
        return next;
      };
      Yallist.prototype.unshiftNode = function(node) {
        if (node === this.head) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
          head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        this.length++;
      };
      Yallist.prototype.pushNode = function(node) {
        if (node === this.tail) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var tail = this.tail;
        node.list = this;
        node.prev = tail;
        if (tail) {
          tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
          this.head = node;
        }
        this.length++;
      };
      Yallist.prototype.push = function() {
        for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
          push(this, arguments[i2]);
        }
        return this.length;
      };
      Yallist.prototype.unshift = function() {
        for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
          unshift(this, arguments[i2]);
        }
        return this.length;
      };
      Yallist.prototype.pop = function() {
        if (!this.tail) {
          return void 0;
        }
        var res = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.shift = function() {
        if (!this.head) {
          return void 0;
        }
        var res = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i2 = 0; walker !== null; i2++) {
          fn.call(thisp, walker.value, i2, this);
          walker = walker.next;
        }
      };
      Yallist.prototype.forEachReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
          fn.call(thisp, walker.value, i2, this);
          walker = walker.prev;
        }
      };
      Yallist.prototype.get = function(n3) {
        for (var i2 = 0, walker = this.head; walker !== null && i2 < n3; i2++) {
          walker = walker.next;
        }
        if (i2 === n3 && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.getReverse = function(n3) {
        for (var i2 = 0, walker = this.tail; walker !== null && i2 < n3; i2++) {
          walker = walker.prev;
        }
        if (i2 === n3 && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.map = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.head; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.next;
        }
        return res;
      };
      Yallist.prototype.mapReverse = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.tail; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.prev;
        }
        return res;
      };
      Yallist.prototype.reduce = function(fn, initial) {
        var acc;
        var walker = this.head;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.head) {
          walker = this.head.next;
          acc = this.head.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i2 = 0; walker !== null; i2++) {
          acc = fn(acc, walker.value, i2);
          walker = walker.next;
        }
        return acc;
      };
      Yallist.prototype.reduceReverse = function(fn, initial) {
        var acc;
        var walker = this.tail;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.tail) {
          walker = this.tail.prev;
          acc = this.tail.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i2 = this.length - 1; walker !== null; i2--) {
          acc = fn(acc, walker.value, i2);
          walker = walker.prev;
        }
        return acc;
      };
      Yallist.prototype.toArray = function() {
        var arr = new Array(this.length);
        for (var i2 = 0, walker = this.head; walker !== null; i2++) {
          arr[i2] = walker.value;
          walker = walker.next;
        }
        return arr;
      };
      Yallist.prototype.toArrayReverse = function() {
        var arr = new Array(this.length);
        for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
          arr[i2] = walker.value;
          walker = walker.prev;
        }
        return arr;
      };
      Yallist.prototype.slice = function(from3, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from3 = from3 || 0;
        if (from3 < 0) {
          from3 += this.length;
        }
        var ret = new Yallist();
        if (to < from3 || to < 0) {
          return ret;
        }
        if (from3 < 0) {
          from3 = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i2 = 0, walker = this.head; walker !== null && i2 < from3; i2++) {
          walker = walker.next;
        }
        for (; walker !== null && i2 < to; i2++, walker = walker.next) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.sliceReverse = function(from3, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from3 = from3 || 0;
        if (from3 < 0) {
          from3 += this.length;
        }
        var ret = new Yallist();
        if (to < from3 || to < 0) {
          return ret;
        }
        if (from3 < 0) {
          from3 = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
          walker = walker.prev;
        }
        for (; walker !== null && i2 > from3; i2--, walker = walker.prev) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
        if (start > this.length) {
          start = this.length - 1;
        }
        if (start < 0) {
          start = this.length + start;
        }
        for (var i2 = 0, walker = this.head; walker !== null && i2 < start; i2++) {
          walker = walker.next;
        }
        var ret = [];
        for (var i2 = 0; walker && i2 < deleteCount; i2++) {
          ret.push(walker.value);
          walker = this.removeNode(walker);
        }
        if (walker === null) {
          walker = this.tail;
        }
        if (walker !== this.head && walker !== this.tail) {
          walker = walker.prev;
        }
        for (var i2 = 0; i2 < nodes.length; i2++) {
          walker = insert(this, walker, nodes[i2]);
        }
        return ret;
      };
      Yallist.prototype.reverse = function() {
        var head = this.head;
        var tail = this.tail;
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p2 = walker.prev;
          walker.prev = walker.next;
          walker.next = p2;
        }
        this.head = tail;
        this.tail = head;
        return this;
      };
      function insert(self2, node, value) {
        var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
        if (inserted.next === null) {
          self2.tail = inserted;
        }
        if (inserted.prev === null) {
          self2.head = inserted;
        }
        self2.length++;
        return inserted;
      }
      function push(self2, item) {
        self2.tail = new Node(item, self2.tail, null, self2);
        if (!self2.head) {
          self2.head = self2.tail;
        }
        self2.length++;
      }
      function unshift(self2, item) {
        self2.head = new Node(item, null, self2.head, self2);
        if (!self2.tail) {
          self2.tail = self2.head;
        }
        self2.length++;
      }
      function Node(value, prev, next, list) {
        if (!(this instanceof Node)) {
          return new Node(value, prev, next, list);
        }
        this.list = list;
        this.value = value;
        if (prev) {
          prev.next = this;
          this.prev = prev;
        } else {
          this.prev = null;
        }
        if (next) {
          next.prev = this;
          this.next = next;
        } else {
          this.next = null;
        }
      }
      try {
        require_iterator()(Yallist);
      } catch (er) {
      }
    }
  });

  // ../node_modules/lru-cache/index.js
  var require_lru_cache = __commonJS({
    "../node_modules/lru-cache/index.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Yallist = require_yallist();
      var MAX = Symbol("max");
      var LENGTH = Symbol("length");
      var LENGTH_CALCULATOR = Symbol("lengthCalculator");
      var ALLOW_STALE = Symbol("allowStale");
      var MAX_AGE = Symbol("maxAge");
      var DISPOSE = Symbol("dispose");
      var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
      var LRU_LIST = Symbol("lruList");
      var CACHE = Symbol("cache");
      var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
      var naiveLength = () => 1;
      var LRUCache = class {
        constructor(options) {
          if (typeof options === "number")
            options = { max: options };
          if (!options)
            options = {};
          if (options.max && (typeof options.max !== "number" || options.max < 0))
            throw new TypeError("max must be a non-negative number");
          const max = this[MAX] = options.max || Infinity;
          const lc = options.length || naiveLength;
          this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
          this[ALLOW_STALE] = options.stale || false;
          if (options.maxAge && typeof options.maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          this[MAX_AGE] = options.maxAge || 0;
          this[DISPOSE] = options.dispose;
          this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
          this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
          this.reset();
        }
        // resize the cache when the max changes.
        set max(mL) {
          if (typeof mL !== "number" || mL < 0)
            throw new TypeError("max must be a non-negative number");
          this[MAX] = mL || Infinity;
          trim2(this);
        }
        get max() {
          return this[MAX];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if (typeof mA !== "number")
            throw new TypeError("maxAge must be a non-negative number");
          this[MAX_AGE] = mA;
          trim2(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        // resize the cache when the lengthCalculator changes.
        set lengthCalculator(lC) {
          if (typeof lC !== "function")
            lC = naiveLength;
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
              this[LENGTH] += hit.length;
            });
          }
          trim2(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; walker !== null; ) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; walker !== null; ) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map((k2) => k2.key);
        }
        values() {
          return this[LRU_LIST].toArray().map((k2) => k2.value);
        }
        reset() {
          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
          }
          this[CACHE] = /* @__PURE__ */ new Map();
          this[LRU_LIST] = new Yallist();
          this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter((h2) => h2);
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          if (maxAge && typeof maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          const now = maxAge ? Date.now() : 0;
          const len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
              del(this, this[CACHE].get(key));
              return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            if (this[DISPOSE]) {
              if (!this[NO_DISPOSE_ON_SET])
                this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim2(this);
            return true;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          if (hit.length > this[MAX]) {
            if (this[DISPOSE])
              this[DISPOSE](key, value);
            return false;
          }
          this[LENGTH] += hit.length;
          this[LRU_LIST].unshift(hit);
          this[CACHE].set(key, this[LRU_LIST].head);
          trim2(this);
          return true;
        }
        has(key) {
          if (!this[CACHE].has(key))
            return false;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get(this, key, true);
        }
        peek(key) {
          return get(this, key, false);
        }
        pop() {
          const node = this[LRU_LIST].tail;
          if (!node)
            return null;
          del(this, node);
          return node.value;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0)
              this.set(hit.k, hit.v);
            else {
              const maxAge = expiresAt - now;
              if (maxAge > 0) {
                this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        }
        prune() {
          this[CACHE].forEach((value, key) => get(this, key, false));
        }
      };
      var get = (self2, key, doUse) => {
        const node = self2[CACHE].get(key);
        if (node) {
          const hit = node.value;
          if (isStale(self2, hit)) {
            del(self2, node);
            if (!self2[ALLOW_STALE])
              return void 0;
          } else {
            if (doUse) {
              if (self2[UPDATE_AGE_ON_GET])
                node.value.now = Date.now();
              self2[LRU_LIST].unshiftNode(node);
            }
          }
          return hit.value;
        }
      };
      var isStale = (self2, hit) => {
        if (!hit || !hit.maxAge && !self2[MAX_AGE])
          return false;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
      };
      var trim2 = (self2) => {
        if (self2[LENGTH] > self2[MAX]) {
          for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
            const prev = walker.prev;
            del(self2, walker);
            walker = prev;
          }
        }
      };
      var del = (self2, node) => {
        if (node) {
          const hit = node.value;
          if (self2[DISPOSE])
            self2[DISPOSE](hit.key, hit.value);
          self2[LENGTH] -= hit.length;
          self2[CACHE].delete(hit.key);
          self2[LRU_LIST].removeNode(node);
        }
      };
      var Entry = class {
        constructor(key, value, length, now, maxAge) {
          this.key = key;
          this.value = value;
          this.length = length;
          this.now = now;
          this.maxAge = maxAge || 0;
        }
      };
      var forEachStep = (self2, fn, node, thisp) => {
        let hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        }
        if (hit)
          fn.call(thisp, hit.value, hit.key, self2);
      };
      module.exports = LRUCache;
    }
  });

  // ../node_modules/semver/classes/range.js
  var require_range = __commonJS({
    "../node_modules/semver/classes/range.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Range = class {
        constructor(range, options) {
          options = parseOptions(options);
          if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
              return range;
            } else {
              return new Range(range.raw, options);
            }
          }
          if (range instanceof Comparator) {
            this.raw = range.value;
            this.set = [[range]];
            this.format();
            return this;
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range.trim().split(/\s+/).join(" ");
          this.set = this.raw.split("||").map((r6) => this.parseRange(r6.trim())).filter((c2) => c2.length);
          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
          }
          if (this.set.length > 1) {
            const first = this.set[0];
            this.set = this.set.filter((c2) => !isNullSet(c2[0]));
            if (this.set.length === 0) {
              this.set = [first];
            } else if (this.set.length > 1) {
              for (const c2 of this.set) {
                if (c2.length === 1 && isAny(c2[0])) {
                  this.set = [c2];
                  break;
                }
              }
            }
          }
          this.format();
        }
        format() {
          this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
          return this.range;
        }
        toString() {
          return this.range;
        }
        parseRange(range) {
          const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
          const memoKey = memoOpts + ":" + range;
          const cached = cache.get(memoKey);
          if (cached) {
            return cached;
          }
          const loose = this.options.loose;
          const hr = loose ? re[t5.HYPHENRANGELOOSE] : re[t5.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
          debug2("hyphen replace", range);
          range = range.replace(re[t5.COMPARATORTRIM], comparatorTrimReplace);
          debug2("comparator trim", range);
          range = range.replace(re[t5.TILDETRIM], tildeTrimReplace);
          debug2("tilde trim", range);
          range = range.replace(re[t5.CARETTRIM], caretTrimReplace);
          debug2("caret trim", range);
          let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
          if (loose) {
            rangeList = rangeList.filter((comp) => {
              debug2("loose invalid filter", comp, this.options);
              return !!comp.match(re[t5.COMPARATORLOOSE]);
            });
          }
          debug2("range list", rangeList);
          const rangeMap = /* @__PURE__ */ new Map();
          const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
          for (const comp of comparators) {
            if (isNullSet(comp)) {
              return [comp];
            }
            rangeMap.set(comp.value, comp);
          }
          if (rangeMap.size > 1 && rangeMap.has("")) {
            rangeMap.delete("");
          }
          const result = [...rangeMap.values()];
          cache.set(memoKey, result);
          return result;
        }
        intersects(range, options) {
          if (!(range instanceof Range)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some((thisComparators) => {
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
              return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
                return rangeComparators.every((rangeComparator) => {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        }
        // if ANY of the sets match ALL of its comparators, then pass
        test(version3) {
          if (!version3) {
            return false;
          }
          if (typeof version3 === "string") {
            try {
              version3 = new SemVer(version3, this.options);
            } catch (er) {
              return false;
            }
          }
          for (let i2 = 0; i2 < this.set.length; i2++) {
            if (testSet(this.set[i2], version3, this.options)) {
              return true;
            }
          }
          return false;
        }
      };
      module.exports = Range;
      var LRU = require_lru_cache();
      var cache = new LRU({ max: 1e3 });
      var parseOptions = require_parse_options();
      var Comparator = require_comparator();
      var debug2 = require_debug();
      var SemVer = require_semver();
      var {
        safeRe: re,
        t: t5,
        comparatorTrimReplace,
        tildeTrimReplace,
        caretTrimReplace
      } = require_re();
      var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
      var isNullSet = (c2) => c2.value === "<0.0.0-0";
      var isAny = (c2) => c2.value === "";
      var isSatisfiable = (comparators, options) => {
        let result = true;
        const remainingComparators = comparators.slice();
        let testComparator = remainingComparators.pop();
        while (result && remainingComparators.length) {
          result = remainingComparators.every((otherComparator) => {
            return testComparator.intersects(otherComparator, options);
          });
          testComparator = remainingComparators.pop();
        }
        return result;
      };
      var parseComparator = (comp, options) => {
        debug2("comp", comp, options);
        comp = replaceCarets(comp, options);
        debug2("caret", comp);
        comp = replaceTildes(comp, options);
        debug2("tildes", comp);
        comp = replaceXRanges(comp, options);
        debug2("xrange", comp);
        comp = replaceStars(comp, options);
        debug2("stars", comp);
        return comp;
      };
      var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
      var replaceTildes = (comp, options) => {
        return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
      };
      var replaceTilde = (comp, options) => {
        const r6 = options.loose ? re[t5.TILDELOOSE] : re[t5.TILDE];
        return comp.replace(r6, (_, M, m2, p2, pr) => {
          debug2("tilde", comp, _, M, m2, p2, pr);
          let ret;
          if (isX(M)) {
            ret = "";
          } else if (isX(m2)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
          } else if (isX(p2)) {
            ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
          } else if (pr) {
            debug2("replaceTilde pr", pr);
            ret = `>=${M}.${m2}.${p2}-${pr} <${M}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M}.${m2}.${p2} <${M}.${+m2 + 1}.0-0`;
          }
          debug2("tilde return", ret);
          return ret;
        });
      };
      var replaceCarets = (comp, options) => {
        return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
      };
      var replaceCaret = (comp, options) => {
        debug2("caret", comp, options);
        const r6 = options.loose ? re[t5.CARETLOOSE] : re[t5.CARET];
        const z2 = options.includePrerelease ? "-0" : "";
        return comp.replace(r6, (_, M, m2, p2, pr) => {
          debug2("caret", comp, _, M, m2, p2, pr);
          let ret;
          if (isX(M)) {
            ret = "";
          } else if (isX(m2)) {
            ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
          } else if (isX(p2)) {
            if (M === "0") {
              ret = `>=${M}.${m2}.0${z2} <${M}.${+m2 + 1}.0-0`;
            } else {
              ret = `>=${M}.${m2}.0${z2} <${+M + 1}.0.0-0`;
            }
          } else if (pr) {
            debug2("replaceCaret pr", pr);
            if (M === "0") {
              if (m2 === "0") {
                ret = `>=${M}.${m2}.${p2}-${pr} <${M}.${m2}.${+p2 + 1}-0`;
              } else {
                ret = `>=${M}.${m2}.${p2}-${pr} <${M}.${+m2 + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m2}.${p2}-${pr} <${+M + 1}.0.0-0`;
            }
          } else {
            debug2("no pr");
            if (M === "0") {
              if (m2 === "0") {
                ret = `>=${M}.${m2}.${p2}${z2} <${M}.${m2}.${+p2 + 1}-0`;
              } else {
                ret = `>=${M}.${m2}.${p2}${z2} <${M}.${+m2 + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m2}.${p2} <${+M + 1}.0.0-0`;
            }
          }
          debug2("caret return", ret);
          return ret;
        });
      };
      var replaceXRanges = (comp, options) => {
        debug2("replaceXRanges", comp, options);
        return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
      };
      var replaceXRange = (comp, options) => {
        comp = comp.trim();
        const r6 = options.loose ? re[t5.XRANGELOOSE] : re[t5.XRANGE];
        return comp.replace(r6, (ret, gtlt, M, m2, p2, pr) => {
          debug2("xRange", comp, ret, gtlt, M, m2, p2, pr);
          const xM = isX(M);
          const xm = xM || isX(m2);
          const xp = xm || isX(p2);
          const anyX = xp;
          if (gtlt === "=" && anyX) {
            gtlt = "";
          }
          pr = options.includePrerelease ? "-0" : "";
          if (xM) {
            if (gtlt === ">" || gtlt === "<") {
              ret = "<0.0.0-0";
            } else {
              ret = "*";
            }
          } else if (gtlt && anyX) {
            if (xm) {
              m2 = 0;
            }
            p2 = 0;
            if (gtlt === ">") {
              gtlt = ">=";
              if (xm) {
                M = +M + 1;
                m2 = 0;
                p2 = 0;
              } else {
                m2 = +m2 + 1;
                p2 = 0;
              }
            } else if (gtlt === "<=") {
              gtlt = "<";
              if (xm) {
                M = +M + 1;
              } else {
                m2 = +m2 + 1;
              }
            }
            if (gtlt === "<") {
              pr = "-0";
            }
            ret = `${gtlt + M}.${m2}.${p2}${pr}`;
          } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
          } else if (xp) {
            ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
          }
          debug2("xRange return", ret);
          return ret;
        });
      };
      var replaceStars = (comp, options) => {
        debug2("replaceStars", comp, options);
        return comp.trim().replace(re[t5.STAR], "");
      };
      var replaceGTE0 = (comp, options) => {
        debug2("replaceGTE0", comp, options);
        return comp.trim().replace(re[options.includePrerelease ? t5.GTE0PRE : t5.GTE0], "");
      };
      var hyphenReplace = (incPr) => ($0, from3, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
        if (isX(fM)) {
          from3 = "";
        } else if (isX(fm)) {
          from3 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        } else if (isX(fp)) {
          from3 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        } else if (fpr) {
          from3 = `>=${from3}`;
        } else {
          from3 = `>=${from3}${incPr ? "-0" : ""}`;
        }
        if (isX(tM)) {
          to = "";
        } else if (isX(tm)) {
          to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
          to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
          to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
          to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
          to = `<=${to}`;
        }
        return `${from3} ${to}`.trim();
      };
      var testSet = (set, version3, options) => {
        for (let i2 = 0; i2 < set.length; i2++) {
          if (!set[i2].test(version3)) {
            return false;
          }
        }
        if (version3.prerelease.length && !options.includePrerelease) {
          for (let i2 = 0; i2 < set.length; i2++) {
            debug2(set[i2].semver);
            if (set[i2].semver === Comparator.ANY) {
              continue;
            }
            if (set[i2].semver.prerelease.length > 0) {
              const allowed = set[i2].semver;
              if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
                return true;
              }
            }
          }
          return false;
        }
        return true;
      };
    }
  });

  // ../node_modules/semver/classes/comparator.js
  var require_comparator = __commonJS({
    "../node_modules/semver/classes/comparator.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var ANY = Symbol("SemVer ANY");
      var Comparator = class {
        static get ANY() {
          return ANY;
        }
        constructor(comp, options) {
          options = parseOptions(options);
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          comp = comp.trim().split(/\s+/).join(" ");
          debug2("comparator", comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = "";
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug2("comp", this);
        }
        parse(comp) {
          const r6 = this.options.loose ? re[t5.COMPARATORLOOSE] : re[t5.COMPARATOR];
          const m2 = comp.match(r6);
          if (!m2) {
            throw new TypeError(`Invalid comparator: ${comp}`);
          }
          this.operator = m2[1] !== void 0 ? m2[1] : "";
          if (this.operator === "=") {
            this.operator = "";
          }
          if (!m2[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer(m2[2], this.options.loose);
          }
        }
        toString() {
          return this.value;
        }
        test(version3) {
          debug2("Comparator.test", version3, this.options.loose);
          if (this.semver === ANY || version3 === ANY) {
            return true;
          }
          if (typeof version3 === "string") {
            try {
              version3 = new SemVer(version3, this.options);
            } catch (er) {
              return false;
            }
          }
          return cmp(version3, this.operator, this.semver, this.options);
        }
        intersects(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (this.operator === "") {
            if (this.value === "") {
              return true;
            }
            return new Range(comp.value, options).test(this.value);
          } else if (comp.operator === "") {
            if (comp.value === "") {
              return true;
            }
            return new Range(this.value, options).test(comp.semver);
          }
          options = parseOptions(options);
          if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
            return false;
          }
          if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
            return false;
          }
          if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
            return true;
          }
          if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
            return true;
          }
          if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
            return true;
          }
          if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
            return true;
          }
          if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
            return true;
          }
          return false;
        }
      };
      module.exports = Comparator;
      var parseOptions = require_parse_options();
      var { safeRe: re, t: t5 } = require_re();
      var cmp = require_cmp();
      var debug2 = require_debug();
      var SemVer = require_semver();
      var Range = require_range();
    }
  });

  // ../node_modules/semver/functions/satisfies.js
  var require_satisfies = __commonJS({
    "../node_modules/semver/functions/satisfies.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Range = require_range();
      var satisfies = (version3, range, options) => {
        try {
          range = new Range(range, options);
        } catch (er) {
          return false;
        }
        return range.test(version3);
      };
      module.exports = satisfies;
    }
  });

  // ../node_modules/semver/ranges/to-comparators.js
  var require_to_comparators = __commonJS({
    "../node_modules/semver/ranges/to-comparators.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Range = require_range();
      var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
      module.exports = toComparators;
    }
  });

  // ../node_modules/semver/ranges/max-satisfying.js
  var require_max_satisfying = __commonJS({
    "../node_modules/semver/ranges/max-satisfying.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var Range = require_range();
      var maxSatisfying = (versions3, range, options) => {
        let max = null;
        let maxSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions3.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!max || maxSV.compare(v) === -1) {
              max = v;
              maxSV = new SemVer(max, options);
            }
          }
        });
        return max;
      };
      module.exports = maxSatisfying;
    }
  });

  // ../node_modules/semver/ranges/min-satisfying.js
  var require_min_satisfying = __commonJS({
    "../node_modules/semver/ranges/min-satisfying.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var Range = require_range();
      var minSatisfying = (versions3, range, options) => {
        let min = null;
        let minSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions3.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!min || minSV.compare(v) === 1) {
              min = v;
              minSV = new SemVer(min, options);
            }
          }
        });
        return min;
      };
      module.exports = minSatisfying;
    }
  });

  // ../node_modules/semver/ranges/min-version.js
  var require_min_version = __commonJS({
    "../node_modules/semver/ranges/min-version.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var Range = require_range();
      var gt = require_gt();
      var minVersion = (range, loose) => {
        range = new Range(range, loose);
        let minver = new SemVer("0.0.0");
        if (range.test(minver)) {
          return minver;
        }
        minver = new SemVer("0.0.0-0");
        if (range.test(minver)) {
          return minver;
        }
        minver = null;
        for (let i2 = 0; i2 < range.set.length; ++i2) {
          const comparators = range.set[i2];
          let setMin = null;
          comparators.forEach((comparator) => {
            const compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
              case ">":
                if (compver.prerelease.length === 0) {
                  compver.patch++;
                } else {
                  compver.prerelease.push(0);
                }
                compver.raw = compver.format();
              case "":
              case ">=":
                if (!setMin || gt(compver, setMin)) {
                  setMin = compver;
                }
                break;
              case "<":
              case "<=":
                break;
              default:
                throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
          });
          if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
          }
        }
        if (minver && range.test(minver)) {
          return minver;
        }
        return null;
      };
      module.exports = minVersion;
    }
  });

  // ../node_modules/semver/ranges/valid.js
  var require_valid2 = __commonJS({
    "../node_modules/semver/ranges/valid.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Range = require_range();
      var validRange = (range, options) => {
        try {
          return new Range(range, options).range || "*";
        } catch (er) {
          return null;
        }
      };
      module.exports = validRange;
    }
  });

  // ../node_modules/semver/ranges/outside.js
  var require_outside = __commonJS({
    "../node_modules/semver/ranges/outside.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var SemVer = require_semver();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var Range = require_range();
      var satisfies = require_satisfies();
      var gt = require_gt();
      var lt = require_lt();
      var lte = require_lte();
      var gte = require_gte();
      var outside = (version3, range, hilo, options) => {
        version3 = new SemVer(version3, options);
        range = new Range(range, options);
        let gtfn, ltefn, ltfn, comp, ecomp;
        switch (hilo) {
          case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
          case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (satisfies(version3, range, options)) {
          return false;
        }
        for (let i2 = 0; i2 < range.set.length; ++i2) {
          const comparators = range.set[i2];
          let high = null;
          let low = null;
          comparators.forEach((comparator) => {
            if (comparator.semver === ANY) {
              comparator = new Comparator(">=0.0.0");
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
              high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
              low = comparator;
            }
          });
          if (high.operator === comp || high.operator === ecomp) {
            return false;
          }
          if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
            return false;
          } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
            return false;
          }
        }
        return true;
      };
      module.exports = outside;
    }
  });

  // ../node_modules/semver/ranges/gtr.js
  var require_gtr = __commonJS({
    "../node_modules/semver/ranges/gtr.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var outside = require_outside();
      var gtr = (version3, range, options) => outside(version3, range, ">", options);
      module.exports = gtr;
    }
  });

  // ../node_modules/semver/ranges/ltr.js
  var require_ltr = __commonJS({
    "../node_modules/semver/ranges/ltr.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var outside = require_outside();
      var ltr = (version3, range, options) => outside(version3, range, "<", options);
      module.exports = ltr;
    }
  });

  // ../node_modules/semver/ranges/intersects.js
  var require_intersects = __commonJS({
    "../node_modules/semver/ranges/intersects.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Range = require_range();
      var intersects = (r1, r22, options) => {
        r1 = new Range(r1, options);
        r22 = new Range(r22, options);
        return r1.intersects(r22, options);
      };
      module.exports = intersects;
    }
  });

  // ../node_modules/semver/ranges/simplify.js
  var require_simplify = __commonJS({
    "../node_modules/semver/ranges/simplify.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var satisfies = require_satisfies();
      var compare5 = require_compare();
      module.exports = (versions3, range, options) => {
        const set = [];
        let first = null;
        let prev = null;
        const v = versions3.sort((a4, b2) => compare5(a4, b2, options));
        for (const version3 of v) {
          const included = satisfies(version3, range, options);
          if (included) {
            prev = version3;
            if (!first) {
              first = version3;
            }
          } else {
            if (prev) {
              set.push([first, prev]);
            }
            prev = null;
            first = null;
          }
        }
        if (first) {
          set.push([first, null]);
        }
        const ranges = [];
        for (const [min, max] of set) {
          if (min === max) {
            ranges.push(min);
          } else if (!max && min === v[0]) {
            ranges.push("*");
          } else if (!max) {
            ranges.push(`>=${min}`);
          } else if (min === v[0]) {
            ranges.push(`<=${max}`);
          } else {
            ranges.push(`${min} - ${max}`);
          }
        }
        const simplified = ranges.join(" || ");
        const original = typeof range.raw === "string" ? range.raw : String(range);
        return simplified.length < original.length ? simplified : range;
      };
    }
  });

  // ../node_modules/semver/ranges/subset.js
  var require_subset = __commonJS({
    "../node_modules/semver/ranges/subset.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Range = require_range();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var satisfies = require_satisfies();
      var compare5 = require_compare();
      var subset = (sub, dom, options = {}) => {
        if (sub === dom) {
          return true;
        }
        sub = new Range(sub, options);
        dom = new Range(dom, options);
        let sawNonNull = false;
        OUTER:
          for (const simpleSub of sub.set) {
            for (const simpleDom of dom.set) {
              const isSub = simpleSubset(simpleSub, simpleDom, options);
              sawNonNull = sawNonNull || isSub !== null;
              if (isSub) {
                continue OUTER;
              }
            }
            if (sawNonNull) {
              return false;
            }
          }
        return true;
      };
      var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
      var minimumVersion = [new Comparator(">=0.0.0")];
      var simpleSubset = (sub, dom, options) => {
        if (sub === dom) {
          return true;
        }
        if (sub.length === 1 && sub[0].semver === ANY) {
          if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
          } else if (options.includePrerelease) {
            sub = minimumVersionWithPreRelease;
          } else {
            sub = minimumVersion;
          }
        }
        if (dom.length === 1 && dom[0].semver === ANY) {
          if (options.includePrerelease) {
            return true;
          } else {
            dom = minimumVersion;
          }
        }
        const eqSet = /* @__PURE__ */ new Set();
        let gt, lt;
        for (const c2 of sub) {
          if (c2.operator === ">" || c2.operator === ">=") {
            gt = higherGT(gt, c2, options);
          } else if (c2.operator === "<" || c2.operator === "<=") {
            lt = lowerLT(lt, c2, options);
          } else {
            eqSet.add(c2.semver);
          }
        }
        if (eqSet.size > 1) {
          return null;
        }
        let gtltComp;
        if (gt && lt) {
          gtltComp = compare5(gt.semver, lt.semver, options);
          if (gtltComp > 0) {
            return null;
          } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
            return null;
          }
        }
        for (const eq of eqSet) {
          if (gt && !satisfies(eq, String(gt), options)) {
            return null;
          }
          if (lt && !satisfies(eq, String(lt), options)) {
            return null;
          }
          for (const c2 of dom) {
            if (!satisfies(eq, String(c2), options)) {
              return false;
            }
          }
          return true;
        }
        let higher, lower;
        let hasDomLT, hasDomGT;
        let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
        let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
        if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
          needDomLTPre = false;
        }
        for (const c2 of dom) {
          hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
          hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
          if (gt) {
            if (needDomGTPre) {
              if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
                needDomGTPre = false;
              }
            }
            if (c2.operator === ">" || c2.operator === ">=") {
              higher = higherGT(gt, c2, options);
              if (higher === c2 && higher !== gt) {
                return false;
              }
            } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c2), options)) {
              return false;
            }
          }
          if (lt) {
            if (needDomLTPre) {
              if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
                needDomLTPre = false;
              }
            }
            if (c2.operator === "<" || c2.operator === "<=") {
              lower = lowerLT(lt, c2, options);
              if (lower === c2 && lower !== lt) {
                return false;
              }
            } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c2), options)) {
              return false;
            }
          }
          if (!c2.operator && (lt || gt) && gtltComp !== 0) {
            return false;
          }
        }
        if (gt && hasDomLT && !lt && gtltComp !== 0) {
          return false;
        }
        if (lt && hasDomGT && !gt && gtltComp !== 0) {
          return false;
        }
        if (needDomGTPre || needDomLTPre) {
          return false;
        }
        return true;
      };
      var higherGT = (a4, b2, options) => {
        if (!a4) {
          return b2;
        }
        const comp = compare5(a4.semver, b2.semver, options);
        return comp > 0 ? a4 : comp < 0 ? b2 : b2.operator === ">" && a4.operator === ">=" ? b2 : a4;
      };
      var lowerLT = (a4, b2, options) => {
        if (!a4) {
          return b2;
        }
        const comp = compare5(a4.semver, b2.semver, options);
        return comp < 0 ? a4 : comp > 0 ? b2 : b2.operator === "<" && a4.operator === "<=" ? b2 : a4;
      };
      module.exports = subset;
    }
  });

  // ../node_modules/semver/index.js
  var require_semver2 = __commonJS({
    "../node_modules/semver/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var internalRe = require_re();
      var constants = require_constants();
      var SemVer = require_semver();
      var identifiers = require_identifiers();
      var parse = require_parse2();
      var valid = require_valid();
      var clean = require_clean();
      var inc = require_inc();
      var diff = require_diff();
      var major = require_major();
      var minor = require_minor();
      var patch = require_patch();
      var prerelease = require_prerelease();
      var compare5 = require_compare();
      var rcompare = require_rcompare();
      var compareLoose = require_compare_loose();
      var compareBuild = require_compare_build();
      var sort = require_sort();
      var rsort = require_rsort();
      var gt = require_gt();
      var lt = require_lt();
      var eq = require_eq();
      var neq = require_neq();
      var gte = require_gte();
      var lte = require_lte();
      var cmp = require_cmp();
      var coerce2 = require_coerce();
      var Comparator = require_comparator();
      var Range = require_range();
      var satisfies = require_satisfies();
      var toComparators = require_to_comparators();
      var maxSatisfying = require_max_satisfying();
      var minSatisfying = require_min_satisfying();
      var minVersion = require_min_version();
      var validRange = require_valid2();
      var outside = require_outside();
      var gtr = require_gtr();
      var ltr = require_ltr();
      var intersects = require_intersects();
      var simplifyRange = require_simplify();
      var subset = require_subset();
      module.exports = {
        parse,
        valid,
        clean,
        inc,
        diff,
        major,
        minor,
        patch,
        prerelease,
        compare: compare5,
        rcompare,
        compareLoose,
        compareBuild,
        sort,
        rsort,
        gt,
        lt,
        eq,
        neq,
        gte,
        lte,
        cmp,
        coerce: coerce2,
        Comparator,
        Range,
        satisfies,
        toComparators,
        maxSatisfying,
        minSatisfying,
        minVersion,
        validRange,
        outside,
        gtr,
        ltr,
        intersects,
        simplifyRange,
        subset,
        SemVer,
        re: internalRe.re,
        src: internalRe.src,
        tokens: internalRe.t,
        SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
        RELEASE_TYPES: constants.RELEASE_TYPES,
        compareIdentifiers: identifiers.compareIdentifiers,
        rcompareIdentifiers: identifiers.rcompareIdentifiers
      };
    }
  });

  // ../node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
  var require_asymmetricKeyDetailsSupported = __commonJS({
    "../node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var semver = require_semver2();
      module.exports = semver.satisfies(process.version, ">=15.7.0");
    }
  });

  // ../node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
  var require_rsaPssKeyDetailsSupported = __commonJS({
    "../node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var semver = require_semver2();
      module.exports = semver.satisfies(process.version, ">=16.9.0");
    }
  });

  // ../node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
  var require_validateAsymmetricKey = __commonJS({
    "../node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
      var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
      var allowedAlgorithmsForKeys = {
        "ec": ["ES256", "ES384", "ES512"],
        "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
        "rsa-pss": ["PS256", "PS384", "PS512"]
      };
      var allowedCurves = {
        ES256: "prime256v1",
        ES384: "secp384r1",
        ES512: "secp521r1"
      };
      module.exports = function(algorithm, key) {
        if (!algorithm || !key)
          return;
        const keyType = key.asymmetricKeyType;
        if (!keyType)
          return;
        const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
        if (!allowedAlgorithms) {
          throw new Error(`Unknown key type "${keyType}".`);
        }
        if (!allowedAlgorithms.includes(algorithm)) {
          throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
        }
        if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
          switch (keyType) {
            case "ec":
              const keyCurve = key.asymmetricKeyDetails.namedCurve;
              const allowedCurve = allowedCurves[algorithm];
              if (keyCurve !== allowedCurve) {
                throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
              }
              break;
            case "rsa-pss":
              if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
                const length = parseInt(algorithm.slice(-3), 10);
                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
                if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                  throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
                }
                if (saltLength !== void 0 && saltLength > length >> 3) {
                  throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
                }
              }
              break;
          }
        }
      };
    }
  });

  // ../node_modules/jsonwebtoken/lib/psSupported.js
  var require_psSupported = __commonJS({
    "../node_modules/jsonwebtoken/lib/psSupported.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var semver = require_semver2();
      module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
    }
  });

  // ../node_modules/jsonwebtoken/verify.js
  var require_verify = __commonJS({
    "../node_modules/jsonwebtoken/verify.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var JsonWebTokenError = require_JsonWebTokenError();
      var NotBeforeError = require_NotBeforeError();
      var TokenExpiredError = require_TokenExpiredError();
      var decode = require_decode();
      var timespan = require_timespan();
      var validateAsymmetricKey = require_validateAsymmetricKey();
      var PS_SUPPORTED = require_psSupported();
      var jws = require_jws();
      var { KeyObject, createSecretKey, createPublicKey } = require_crypto();
      var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
      var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
      var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
      var HS_ALGS = ["HS256", "HS384", "HS512"];
      if (PS_SUPPORTED) {
        PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
        RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      }
      module.exports = function(jwtString, secretOrPublicKey, options, callback) {
        if (typeof options === "function" && !callback) {
          callback = options;
          options = {};
        }
        if (!options) {
          options = {};
        }
        options = Object.assign({}, options);
        let done2;
        if (callback) {
          done2 = callback;
        } else {
          done2 = function(err, data) {
            if (err)
              throw err;
            return data;
          };
        }
        if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
          return done2(new JsonWebTokenError("clockTimestamp must be a number"));
        }
        if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
          return done2(new JsonWebTokenError("nonce must be a non-empty string"));
        }
        if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
          return done2(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
        }
        const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
        if (!jwtString) {
          return done2(new JsonWebTokenError("jwt must be provided"));
        }
        if (typeof jwtString !== "string") {
          return done2(new JsonWebTokenError("jwt must be a string"));
        }
        const parts = jwtString.split(".");
        if (parts.length !== 3) {
          return done2(new JsonWebTokenError("jwt malformed"));
        }
        let decodedToken;
        try {
          decodedToken = decode(jwtString, { complete: true });
        } catch (err) {
          return done2(err);
        }
        if (!decodedToken) {
          return done2(new JsonWebTokenError("invalid token"));
        }
        const header = decodedToken.header;
        let getSecret;
        if (typeof secretOrPublicKey === "function") {
          if (!callback) {
            return done2(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
          }
          getSecret = secretOrPublicKey;
        } else {
          getSecret = function(header2, secretCallback) {
            return secretCallback(null, secretOrPublicKey);
          };
        }
        return getSecret(header, function(err, secretOrPublicKey2) {
          if (err) {
            return done2(new JsonWebTokenError("error in secret or public key callback: " + err.message));
          }
          const hasSignature = parts[2].trim() !== "";
          if (!hasSignature && secretOrPublicKey2) {
            return done2(new JsonWebTokenError("jwt signature is required"));
          }
          if (hasSignature && !secretOrPublicKey2) {
            return done2(new JsonWebTokenError("secret or public key must be provided"));
          }
          if (!hasSignature && !options.algorithms) {
            return done2(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
          }
          if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
            try {
              secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
            } catch (_) {
              try {
                secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer2.from(secretOrPublicKey2) : secretOrPublicKey2);
              } catch (_2) {
                return done2(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
              }
            }
          }
          if (!options.algorithms) {
            if (secretOrPublicKey2.type === "secret") {
              options.algorithms = HS_ALGS;
            } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
              options.algorithms = RSA_KEY_ALGS;
            } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
              options.algorithms = EC_KEY_ALGS;
            } else {
              options.algorithms = PUB_KEY_ALGS;
            }
          }
          if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
            return done2(new JsonWebTokenError("invalid algorithm"));
          }
          if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
            return done2(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
          } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
            return done2(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
          }
          if (!options.allowInvalidAsymmetricKeyTypes) {
            try {
              validateAsymmetricKey(header.alg, secretOrPublicKey2);
            } catch (e8) {
              return done2(e8);
            }
          }
          let valid;
          try {
            valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
          } catch (e8) {
            return done2(e8);
          }
          if (!valid) {
            return done2(new JsonWebTokenError("invalid signature"));
          }
          const payload = decodedToken.payload;
          if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
            if (typeof payload.nbf !== "number") {
              return done2(new JsonWebTokenError("invalid nbf value"));
            }
            if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
              return done2(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
            }
          }
          if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
            if (typeof payload.exp !== "number") {
              return done2(new JsonWebTokenError("invalid exp value"));
            }
            if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
              return done2(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
            }
          }
          if (options.audience) {
            const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
            const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
            const match = target.some(function(targetAudience) {
              return audiences.some(function(audience) {
                return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
              });
            });
            if (!match) {
              return done2(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
            }
          }
          if (options.issuer) {
            const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
            if (invalid_issuer) {
              return done2(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
            }
          }
          if (options.subject) {
            if (payload.sub !== options.subject) {
              return done2(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
            }
          }
          if (options.jwtid) {
            if (payload.jti !== options.jwtid) {
              return done2(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
            }
          }
          if (options.nonce) {
            if (payload.nonce !== options.nonce) {
              return done2(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
            }
          }
          if (options.maxAge) {
            if (typeof payload.iat !== "number") {
              return done2(new JsonWebTokenError("iat required when maxAge is specified"));
            }
            const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
            if (typeof maxAgeTimestamp === "undefined") {
              return done2(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
            }
            if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
              return done2(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
            }
          }
          if (options.complete === true) {
            const signature = decodedToken.signature;
            return done2(null, {
              header,
              payload,
              signature
            });
          }
          return done2(null, payload);
        });
      };
    }
  });

  // ../node_modules/lodash.includes/index.js
  var require_lodash = __commonJS({
    "../node_modules/lodash.includes/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var INFINITY = 1 / 0;
      var MAX_SAFE_INTEGER = 9007199254740991;
      var MAX_INTEGER = 17976931348623157e292;
      var NAN = 0 / 0;
      var argsTag = "[object Arguments]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var freeParseInt = parseInt;
      function arrayMap(array, iteratee) {
        var index = -1, length = array ? array.length : 0, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return baseFindIndex(array, baseIsNaN, fromIndex);
        }
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseTimes(n3, iteratee) {
        var index = -1, result = Array(n3);
        while (++index < n3) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var objectProto = Object.prototype;
      var hasOwnProperty3 = objectProto.hasOwnProperty;
      var objectToString2 = objectProto.toString;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeKeys = overArg(Object.keys, Object);
      var nativeMax = Math.max;
      function arrayLikeKeys(value, inherited) {
        var result = isArray4(value) || isArguments(value) ? baseTimes(value.length, String) : [];
        var length = result.length, skipIndexes = !!length;
        for (var key in value) {
          if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty3.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function includes3(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      function isArguments(value) {
        return isArrayLikeObject(value) && hasOwnProperty3.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
      }
      var isArray4 = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction3(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isFunction3(value) {
        var tag = isObject4(value) ? objectToString2.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject4(value) {
        var type2 = typeof value;
        return !!value && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isString3(value) {
        return typeof value == "string" || !isArray4(value) && isObjectLike(value) && objectToString2.call(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject4(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject4(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function values(object) {
        return object ? baseValues(object, keys2(object)) : [];
      }
      module.exports = includes3;
    }
  });

  // ../node_modules/lodash.isboolean/index.js
  var require_lodash2 = __commonJS({
    "../node_modules/lodash.isboolean/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var boolTag = "[object Boolean]";
      var objectProto = Object.prototype;
      var objectToString2 = objectProto.toString;
      function isBoolean3(value) {
        return value === true || value === false || isObjectLike(value) && objectToString2.call(value) == boolTag;
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      module.exports = isBoolean3;
    }
  });

  // ../node_modules/lodash.isinteger/index.js
  var require_lodash3 = __commonJS({
    "../node_modules/lodash.isinteger/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var INFINITY = 1 / 0;
      var MAX_INTEGER = 17976931348623157e292;
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var objectProto = Object.prototype;
      var objectToString2 = objectProto.toString;
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isObject4(value) {
        var type2 = typeof value;
        return !!value && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject4(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject4(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = isInteger;
    }
  });

  // ../node_modules/lodash.isnumber/index.js
  var require_lodash4 = __commonJS({
    "../node_modules/lodash.isnumber/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var numberTag = "[object Number]";
      var objectProto = Object.prototype;
      var objectToString2 = objectProto.toString;
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isNumber3(value) {
        return typeof value == "number" || isObjectLike(value) && objectToString2.call(value) == numberTag;
      }
      module.exports = isNumber3;
    }
  });

  // ../node_modules/lodash.isplainobject/index.js
  var require_lodash5 = __commonJS({
    "../node_modules/lodash.isplainobject/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var objectTag = "[object Object]";
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e8) {
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty3 = objectProto.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      var objectToString2 = objectProto.toString;
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isPlainObject3(value) {
        if (!isObjectLike(value) || objectToString2.call(value) != objectTag || isHostObject(value)) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      module.exports = isPlainObject3;
    }
  });

  // ../node_modules/lodash.isstring/index.js
  var require_lodash6 = __commonJS({
    "../node_modules/lodash.isstring/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var stringTag = "[object String]";
      var objectProto = Object.prototype;
      var objectToString2 = objectProto.toString;
      var isArray4 = Array.isArray;
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isString3(value) {
        return typeof value == "string" || !isArray4(value) && isObjectLike(value) && objectToString2.call(value) == stringTag;
      }
      module.exports = isString3;
    }
  });

  // ../node_modules/lodash.once/index.js
  var require_lodash7 = __commonJS({
    "../node_modules/lodash.once/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var FUNC_ERROR_TEXT = "Expected a function";
      var INFINITY = 1 / 0;
      var MAX_INTEGER = 17976931348623157e292;
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var objectProto = Object.prototype;
      var objectToString2 = objectProto.toString;
      function before(n3, func) {
        var result;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        n3 = toInteger(n3);
        return function() {
          if (--n3 > 0) {
            result = func.apply(this, arguments);
          }
          if (n3 <= 1) {
            func = void 0;
          }
          return result;
        };
      }
      function once4(func) {
        return before(2, func);
      }
      function isObject4(value) {
        var type2 = typeof value;
        return !!value && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject4(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject4(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = once4;
    }
  });

  // ../node_modules/jsonwebtoken/sign.js
  var require_sign = __commonJS({
    "../node_modules/jsonwebtoken/sign.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var timespan = require_timespan();
      var PS_SUPPORTED = require_psSupported();
      var validateAsymmetricKey = require_validateAsymmetricKey();
      var jws = require_jws();
      var includes3 = require_lodash();
      var isBoolean3 = require_lodash2();
      var isInteger = require_lodash3();
      var isNumber3 = require_lodash4();
      var isPlainObject3 = require_lodash5();
      var isString3 = require_lodash6();
      var once4 = require_lodash7();
      var { KeyObject, createSecretKey, createPrivateKey } = require_crypto();
      var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
      if (PS_SUPPORTED) {
        SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
      }
      var sign_options_schema = {
        expiresIn: { isValid: function(value) {
          return isInteger(value) || isString3(value) && value;
        }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
        notBefore: { isValid: function(value) {
          return isInteger(value) || isString3(value) && value;
        }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
        audience: { isValid: function(value) {
          return isString3(value) || Array.isArray(value);
        }, message: '"audience" must be a string or array' },
        algorithm: { isValid: includes3.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
        header: { isValid: isPlainObject3, message: '"header" must be an object' },
        encoding: { isValid: isString3, message: '"encoding" must be a string' },
        issuer: { isValid: isString3, message: '"issuer" must be a string' },
        subject: { isValid: isString3, message: '"subject" must be a string' },
        jwtid: { isValid: isString3, message: '"jwtid" must be a string' },
        noTimestamp: { isValid: isBoolean3, message: '"noTimestamp" must be a boolean' },
        keyid: { isValid: isString3, message: '"keyid" must be a string' },
        mutatePayload: { isValid: isBoolean3, message: '"mutatePayload" must be a boolean' },
        allowInsecureKeySizes: { isValid: isBoolean3, message: '"allowInsecureKeySizes" must be a boolean' },
        allowInvalidAsymmetricKeyTypes: { isValid: isBoolean3, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
      };
      var registered_claims_schema = {
        iat: { isValid: isNumber3, message: '"iat" should be a number of seconds' },
        exp: { isValid: isNumber3, message: '"exp" should be a number of seconds' },
        nbf: { isValid: isNumber3, message: '"nbf" should be a number of seconds' }
      };
      function validate(schema, allowUnknown, object, parameterName) {
        if (!isPlainObject3(object)) {
          throw new Error('Expected "' + parameterName + '" to be a plain object.');
        }
        Object.keys(object).forEach(function(key) {
          const validator3 = schema[key];
          if (!validator3) {
            if (!allowUnknown) {
              throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
            }
            return;
          }
          if (!validator3.isValid(object[key])) {
            throw new Error(validator3.message);
          }
        });
      }
      function validateOptions(options) {
        return validate(sign_options_schema, false, options, "options");
      }
      function validatePayload(payload) {
        return validate(registered_claims_schema, true, payload, "payload");
      }
      var options_to_payload = {
        "audience": "aud",
        "issuer": "iss",
        "subject": "sub",
        "jwtid": "jti"
      };
      var options_for_objects = [
        "expiresIn",
        "notBefore",
        "noTimestamp",
        "audience",
        "issuer",
        "subject",
        "jwtid"
      ];
      module.exports = function(payload, secretOrPrivateKey, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else {
          options = options || {};
        }
        const isObjectPayload = typeof payload === "object" && !Buffer2.isBuffer(payload);
        const header = Object.assign({
          alg: options.algorithm || "HS256",
          typ: isObjectPayload ? "JWT" : void 0,
          kid: options.keyid
        }, options.header);
        function failure(err) {
          if (callback) {
            return callback(err);
          }
          throw err;
        }
        if (!secretOrPrivateKey && options.algorithm !== "none") {
          return failure(new Error("secretOrPrivateKey must have a value"));
        }
        if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
          try {
            secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
          } catch (_) {
            try {
              secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer2.from(secretOrPrivateKey) : secretOrPrivateKey);
            } catch (_2) {
              return failure(new Error("secretOrPrivateKey is not valid key material"));
            }
          }
        }
        if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
          return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
          if (secretOrPrivateKey.type !== "private") {
            return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
          }
          if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
          secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
            return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
        }
        if (typeof payload === "undefined") {
          return failure(new Error("payload is required"));
        } else if (isObjectPayload) {
          try {
            validatePayload(payload);
          } catch (error) {
            return failure(error);
          }
          if (!options.mutatePayload) {
            payload = Object.assign({}, payload);
          }
        } else {
          const invalid_options = options_for_objects.filter(function(opt) {
            return typeof options[opt] !== "undefined";
          });
          if (invalid_options.length > 0) {
            return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
          }
        }
        if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
          return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
        }
        if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
          return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
        }
        try {
          validateOptions(options);
        } catch (error) {
          return failure(error);
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPrivateKey);
          } catch (error) {
            return failure(error);
          }
        }
        const timestamp2 = payload.iat || Math.floor(Date.now() / 1e3);
        if (options.noTimestamp) {
          delete payload.iat;
        } else if (isObjectPayload) {
          payload.iat = timestamp2;
        }
        if (typeof options.notBefore !== "undefined") {
          try {
            payload.nbf = timespan(options.notBefore, timestamp2);
          } catch (err) {
            return failure(err);
          }
          if (typeof payload.nbf === "undefined") {
            return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
        }
        if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
          try {
            payload.exp = timespan(options.expiresIn, timestamp2);
          } catch (err) {
            return failure(err);
          }
          if (typeof payload.exp === "undefined") {
            return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
        }
        Object.keys(options_to_payload).forEach(function(key) {
          const claim = options_to_payload[key];
          if (typeof options[key] !== "undefined") {
            if (typeof payload[claim] !== "undefined") {
              return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
            }
            payload[claim] = options[key];
          }
        });
        const encoding = options.encoding || "utf8";
        if (typeof callback === "function") {
          callback = callback && once4(callback);
          jws.createSign({
            header,
            privateKey: secretOrPrivateKey,
            payload,
            encoding
          }).once("error", callback).once("done", function(signature) {
            if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
              return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
            }
            callback(null, signature);
          });
        } else {
          let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
          }
          return signature;
        }
      };
    }
  });

  // ../node_modules/jsonwebtoken/index.js
  var require_jsonwebtoken = __commonJS({
    "../node_modules/jsonwebtoken/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = {
        decode: require_decode(),
        verify: require_verify(),
        sign: require_sign(),
        JsonWebTokenError: require_JsonWebTokenError(),
        NotBeforeError: require_NotBeforeError(),
        TokenExpiredError: require_TokenExpiredError()
      };
    }
  });

  // ../node_modules/zod/lib/helpers/util.js
  var require_util2 = __commonJS({
    "../node_modules/zod/lib/helpers/util.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
      var util2;
      (function(util3) {
        util3.assertEqual = (val) => val;
        function assertIs(_arg) {
        }
        util3.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util3.assertNever = assertNever;
        util3.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util3.getValidEnumValues = (obj) => {
          const validKeys = util3.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
          const filtered = {};
          for (const k2 of validKeys) {
            filtered[k2] = obj[k2];
          }
          return util3.objectValues(filtered);
        };
        util3.objectValues = (obj) => {
          return util3.objectKeys(obj).map(function(e8) {
            return obj[e8];
          });
        };
        util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
          const keys2 = [];
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              keys2.push(key);
            }
          }
          return keys2;
        };
        util3.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
          return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util3.joinValues = joinValues;
        util3.jsonStringifyReplacer = (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util2 = exports.util || (exports.util = {}));
      var objectUtil2;
      (function(objectUtil3) {
        objectUtil3.mergeShapes = (first, second) => {
          return {
            ...first,
            ...second
            // second overwrites first
          };
        };
      })(objectUtil2 = exports.objectUtil || (exports.objectUtil = {}));
      exports.ZodParsedType = util2.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      var getParsedType2 = (data) => {
        const t5 = typeof data;
        switch (t5) {
          case "undefined":
            return exports.ZodParsedType.undefined;
          case "string":
            return exports.ZodParsedType.string;
          case "number":
            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
          case "boolean":
            return exports.ZodParsedType.boolean;
          case "function":
            return exports.ZodParsedType.function;
          case "bigint":
            return exports.ZodParsedType.bigint;
          case "symbol":
            return exports.ZodParsedType.symbol;
          case "object":
            if (Array.isArray(data)) {
              return exports.ZodParsedType.array;
            }
            if (data === null) {
              return exports.ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return exports.ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return exports.ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return exports.ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return exports.ZodParsedType.date;
            }
            return exports.ZodParsedType.object;
          default:
            return exports.ZodParsedType.unknown;
        }
      };
      exports.getParsedType = getParsedType2;
    }
  });

  // ../node_modules/zod/lib/ZodError.js
  var require_ZodError = __commonJS({
    "../node_modules/zod/lib/ZodError.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
      var util_1 = require_util2();
      exports.ZodIssueCode = util_1.util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite"
      ]);
      var quotelessJson2 = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
      };
      exports.quotelessJson = quotelessJson2;
      var ZodError2 = class extends Error {
        constructor(issues) {
          super();
          this.issues = [];
          this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
          };
          this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
          };
          const actualProto = new.target.prototype;
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
          } else {
            this.__proto__ = actualProto;
          }
          this.name = "ZodError";
          this.issues = issues;
        }
        get errors() {
          return this.issues;
        }
        format(_mapper) {
          const mapper = _mapper || function(issue) {
            return issue.message;
          };
          const fieldErrors = { _errors: [] };
          const processError = (error) => {
            for (const issue of error.issues) {
              if (issue.code === "invalid_union") {
                issue.unionErrors.map(processError);
              } else if (issue.code === "invalid_return_type") {
                processError(issue.returnTypeError);
              } else if (issue.code === "invalid_arguments") {
                processError(issue.argumentsError);
              } else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
              } else {
                let curr = fieldErrors;
                let i2 = 0;
                while (i2 < issue.path.length) {
                  const el = issue.path[i2];
                  const terminal = i2 === issue.path.length - 1;
                  if (!terminal) {
                    curr[el] = curr[el] || { _errors: [] };
                  } else {
                    curr[el] = curr[el] || { _errors: [] };
                    curr[el]._errors.push(mapper(issue));
                  }
                  curr = curr[el];
                  i2++;
                }
              }
            }
          };
          processError(this);
          return fieldErrors;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
          const fieldErrors = {};
          const formErrors = [];
          for (const sub of this.issues) {
            if (sub.path.length > 0) {
              fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
              fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
              formErrors.push(mapper(sub));
            }
          }
          return { formErrors, fieldErrors };
        }
        get formErrors() {
          return this.flatten();
        }
      };
      exports.ZodError = ZodError2;
      ZodError2.create = (issues) => {
        const error = new ZodError2(issues);
        return error;
      };
    }
  });

  // ../node_modules/zod/lib/locales/en.js
  var require_en = __commonJS({
    "../node_modules/zod/lib/locales/en.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      var util_1 = require_util2();
      var ZodError_1 = require_ZodError();
      var errorMap2 = (issue, _ctx) => {
        let message;
        switch (issue.code) {
          case ZodError_1.ZodIssueCode.invalid_type:
            if (issue.received === util_1.ZodParsedType.undefined) {
              message = "Required";
            } else {
              message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
          case ZodError_1.ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
            break;
          case ZodError_1.ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
            break;
          case ZodError_1.ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
          case ZodError_1.ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
            break;
          case ZodError_1.ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
          case ZodError_1.ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
          case ZodError_1.ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
          case ZodError_1.ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
          case ZodError_1.ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
              if ("includes" in issue.validation) {
                message = `Invalid input: must include "${issue.validation.includes}"`;
                if (typeof issue.validation.position === "number") {
                  message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                }
              } else if ("startsWith" in issue.validation) {
                message = `Invalid input: must start with "${issue.validation.startsWith}"`;
              } else if ("endsWith" in issue.validation) {
                message = `Invalid input: must end with "${issue.validation.endsWith}"`;
              } else {
                util_1.util.assertNever(issue.validation);
              }
            } else if (issue.validation !== "regex") {
              message = `Invalid ${issue.validation}`;
            } else {
              message = "Invalid";
            }
            break;
          case ZodError_1.ZodIssueCode.too_small:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
              message = "Invalid input";
            break;
          case ZodError_1.ZodIssueCode.too_big:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
              message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
              message = "Invalid input";
            break;
          case ZodError_1.ZodIssueCode.custom:
            message = `Invalid input`;
            break;
          case ZodError_1.ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
          case ZodError_1.ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
          case ZodError_1.ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
          default:
            message = _ctx.defaultError;
            util_1.util.assertNever(issue);
        }
        return { message };
      };
      exports.default = errorMap2;
    }
  });

  // ../node_modules/zod/lib/errors.js
  var require_errors3 = __commonJS({
    "../node_modules/zod/lib/errors.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
      var en_1 = __importDefault(require_en());
      exports.defaultErrorMap = en_1.default;
      var overrideErrorMap2 = en_1.default;
      function setErrorMap2(map) {
        overrideErrorMap2 = map;
      }
      exports.setErrorMap = setErrorMap2;
      function getErrorMap2() {
        return overrideErrorMap2;
      }
      exports.getErrorMap = getErrorMap2;
    }
  });

  // ../node_modules/zod/lib/helpers/parseUtil.js
  var require_parseUtil = __commonJS({
    "../node_modules/zod/lib/helpers/parseUtil.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
      var errors_1 = require_errors3();
      var en_1 = __importDefault(require_en());
      var makeIssue2 = (params) => {
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = {
          ...issueData,
          path: fullPath
        };
        let errorMessage = "";
        const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
        for (const map of maps) {
          errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message || errorMessage
        };
      };
      exports.makeIssue = makeIssue2;
      exports.EMPTY_PATH = [];
      function addIssueToContext2(ctx, issueData) {
        const issue = (0, exports.makeIssue)({
          issueData,
          data: ctx.data,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            en_1.default
            // then global default map
          ].filter((x2) => !!x2)
        });
        ctx.common.issues.push(issue);
      }
      exports.addIssueToContext = addIssueToContext2;
      var ParseStatus2 = class {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s3 of results) {
            if (s3.status === "aborted")
              return exports.INVALID;
            if (s3.status === "dirty")
              status.dirty();
            arrayValue.push(s3.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static async mergeObjectAsync(status, pairs) {
          const syncPairs = [];
          for (const pair of pairs) {
            syncPairs.push({
              key: await pair.key,
              value: await pair.value
            });
          }
          return ParseStatus2.mergeObjectSync(status, syncPairs);
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return exports.INVALID;
            if (value.status === "aborted")
              return exports.INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      };
      exports.ParseStatus = ParseStatus2;
      exports.INVALID = Object.freeze({
        status: "aborted"
      });
      var DIRTY2 = (value) => ({ status: "dirty", value });
      exports.DIRTY = DIRTY2;
      var OK2 = (value) => ({ status: "valid", value });
      exports.OK = OK2;
      var isAborted2 = (x2) => x2.status === "aborted";
      exports.isAborted = isAborted2;
      var isDirty2 = (x2) => x2.status === "dirty";
      exports.isDirty = isDirty2;
      var isValid2 = (x2) => x2.status === "valid";
      exports.isValid = isValid2;
      var isAsync3 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
      exports.isAsync = isAsync3;
    }
  });

  // ../node_modules/zod/lib/helpers/typeAliases.js
  var require_typeAliases = __commonJS({
    "../node_modules/zod/lib/helpers/typeAliases.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../node_modules/zod/lib/helpers/errorUtil.js
  var require_errorUtil = __commonJS({
    "../node_modules/zod/lib/helpers/errorUtil.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.errorUtil = void 0;
      var errorUtil2;
      (function(errorUtil3) {
        errorUtil3.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil3.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
      })(errorUtil2 = exports.errorUtil || (exports.errorUtil = {}));
    }
  });

  // ../node_modules/zod/lib/types.js
  var require_types = __commonJS({
    "../node_modules/zod/lib/types.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
      exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = void 0;
      var errors_1 = require_errors3();
      var errorUtil_1 = require_errorUtil();
      var parseUtil_1 = require_parseUtil();
      var util_1 = require_util2();
      var ZodError_1 = require_ZodError();
      var ParseInputLazyPath2 = class {
        constructor(parent, value, path, key) {
          this._cachedPath = [];
          this.parent = parent;
          this.data = value;
          this._path = path;
          this._key = key;
        }
        get path() {
          if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
              this._cachedPath.push(...this._path, ...this._key);
            } else {
              this._cachedPath.push(...this._path, this._key);
            }
          }
          return this._cachedPath;
        }
      };
      var handleResult2 = (ctx, result) => {
        if ((0, parseUtil_1.isValid)(result)) {
          return { success: true, data: result.value };
        } else {
          if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
          }
          return {
            success: false,
            get error() {
              if (this._error)
                return this._error;
              const error = new ZodError_1.ZodError(ctx.common.issues);
              this._error = error;
              return this._error;
            }
          };
        }
      };
      function processCreateParams2(params) {
        if (!params)
          return {};
        const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
        if (errorMap2 && (invalid_type_error || required_error)) {
          throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        }
        if (errorMap2)
          return { errorMap: errorMap2, description };
        const customMap = (iss, ctx) => {
          if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
          if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
          }
          return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
        };
        return { errorMap: customMap, description };
      }
      var ZodType2 = class {
        constructor(def) {
          this.spa = this.safeParseAsync;
          this._def = def;
          this.parse = this.parse.bind(this);
          this.safeParse = this.safeParse.bind(this);
          this.parseAsync = this.parseAsync.bind(this);
          this.safeParseAsync = this.safeParseAsync.bind(this);
          this.spa = this.spa.bind(this);
          this.refine = this.refine.bind(this);
          this.refinement = this.refinement.bind(this);
          this.superRefine = this.superRefine.bind(this);
          this.optional = this.optional.bind(this);
          this.nullable = this.nullable.bind(this);
          this.nullish = this.nullish.bind(this);
          this.array = this.array.bind(this);
          this.promise = this.promise.bind(this);
          this.or = this.or.bind(this);
          this.and = this.and.bind(this);
          this.transform = this.transform.bind(this);
          this.brand = this.brand.bind(this);
          this.default = this.default.bind(this);
          this.catch = this.catch.bind(this);
          this.describe = this.describe.bind(this);
          this.pipe = this.pipe.bind(this);
          this.readonly = this.readonly.bind(this);
          this.isNullable = this.isNullable.bind(this);
          this.isOptional = this.isOptional.bind(this);
        }
        get description() {
          return this._def.description;
        }
        _getType(input) {
          return (0, util_1.getParsedType)(input.data);
        }
        _getOrReturnCtx(input, ctx) {
          return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          };
        }
        _processInputParams(input) {
          return {
            status: new parseUtil_1.ParseStatus(),
            ctx: {
              common: input.parent.common,
              data: input.data,
              parsedType: (0, util_1.getParsedType)(input.data),
              schemaErrorMap: this._def.errorMap,
              path: input.path,
              parent: input.parent
            }
          };
        }
        _parseSync(input) {
          const result = this._parse(input);
          if ((0, parseUtil_1.isAsync)(result)) {
            throw new Error("Synchronous parse encountered promise.");
          }
          return result;
        }
        _parseAsync(input) {
          const result = this._parse(input);
          return Promise.resolve(result);
        }
        parse(data, params) {
          const result = this.safeParse(data, params);
          if (result.success)
            return result.data;
          throw result.error;
        }
        safeParse(data, params) {
          var _a;
          const ctx = {
            common: {
              issues: [],
              async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
              contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data)
          };
          const result = this._parseSync({ data, path: ctx.path, parent: ctx });
          return handleResult2(ctx, result);
        }
        async parseAsync(data, params) {
          const result = await this.safeParseAsync(data, params);
          if (result.success)
            return result.data;
          throw result.error;
        }
        async safeParseAsync(data, params) {
          const ctx = {
            common: {
              issues: [],
              contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
              async: true
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data)
          };
          const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
          const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
          return handleResult2(ctx, result);
        }
        refine(check, message) {
          const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
              return { message };
            } else if (typeof message === "function") {
              return message(val);
            } else {
              return message;
            }
          };
          return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
              code: ZodError_1.ZodIssueCode.custom,
              ...getIssueProperties(val)
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then((data) => {
                if (!data) {
                  setError();
                  return false;
                } else {
                  return true;
                }
              });
            }
            if (!result) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        refinement(check, refinementData) {
          return this._refinement((val, ctx) => {
            if (!check(val)) {
              ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
              return false;
            } else {
              return true;
            }
          });
        }
        _refinement(refinement) {
          return new ZodEffects2({
            schema: this,
            typeName: ZodFirstPartyTypeKind2.ZodEffects,
            effect: { type: "refinement", refinement }
          });
        }
        superRefine(refinement) {
          return this._refinement(refinement);
        }
        optional() {
          return ZodOptional2.create(this, this._def);
        }
        nullable() {
          return ZodNullable2.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return ZodArray2.create(this, this._def);
        }
        promise() {
          return ZodPromise2.create(this, this._def);
        }
        or(option) {
          return ZodUnion2.create([this, option], this._def);
        }
        and(incoming) {
          return ZodIntersection2.create(this, incoming, this._def);
        }
        transform(transform) {
          return new ZodEffects2({
            ...processCreateParams2(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind2.ZodEffects,
            effect: { type: "transform", transform }
          });
        }
        default(def) {
          const defaultValueFunc = typeof def === "function" ? def : () => def;
          return new ZodDefault2({
            ...processCreateParams2(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind2.ZodDefault
          });
        }
        brand() {
          return new ZodBranded2({
            typeName: ZodFirstPartyTypeKind2.ZodBranded,
            type: this,
            ...processCreateParams2(this._def)
          });
        }
        catch(def) {
          const catchValueFunc = typeof def === "function" ? def : () => def;
          return new ZodCatch2({
            ...processCreateParams2(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind2.ZodCatch
          });
        }
        describe(description) {
          const This = this.constructor;
          return new This({
            ...this._def,
            description
          });
        }
        pipe(target) {
          return ZodPipeline2.create(this, target);
        }
        readonly() {
          return ZodReadonly2.create(this);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      };
      exports.ZodType = ZodType2;
      exports.Schema = ZodType2;
      exports.ZodSchema = ZodType2;
      var cuidRegex2 = /^c[^\s-]{8,}$/i;
      var cuid2Regex2 = /^[a-z][a-z0-9]*$/;
      var ulidRegex2 = /^[0-9A-HJKMNP-TV-Z]{26}$/;
      var uuidRegex2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
      var emailRegex2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
      var _emojiRegex2 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
      var emojiRegex2;
      var ipv4Regex2 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
      var ipv6Regex2 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
      var datetimeRegex2 = (args) => {
        if (args.precision) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
          }
        } else if (args.precision === 0) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
          }
        } else {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
          }
        }
      };
      function isValidIP2(ip, version3) {
        if ((version3 === "v4" || !version3) && ipv4Regex2.test(ip)) {
          return true;
        }
        if ((version3 === "v6" || !version3) && ipv6Regex2.test(ip)) {
          return true;
        }
        return false;
      }
      var ZodString2 = class extends ZodType2 {
        _parse(input) {
          if (this._def.coerce) {
            input.data = String(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.string) {
            const ctx2 = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(
              ctx2,
              {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.string,
                received: ctx2.parsedType
              }
              //
            );
            return parseUtil_1.INVALID;
          }
          const status = new parseUtil_1.ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.length < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.length > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "length") {
              const tooBig = input.data.length > check.value;
              const tooSmall = input.data.length < check.value;
              if (tooBig || tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                if (tooBig) {
                  (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                } else if (tooSmall) {
                  (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                }
                status.dirty();
              }
            } else if (check.kind === "email") {
              if (!emailRegex2.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  validation: "email",
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "emoji") {
              if (!emojiRegex2) {
                emojiRegex2 = new RegExp(_emojiRegex2, "u");
              }
              if (!emojiRegex2.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  validation: "emoji",
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "uuid") {
              if (!uuidRegex2.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  validation: "uuid",
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid") {
              if (!cuidRegex2.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  validation: "cuid",
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid2") {
              if (!cuid2Regex2.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  validation: "cuid2",
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ulid") {
              if (!ulidRegex2.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  validation: "ulid",
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "url") {
              try {
                new URL(input.data);
              } catch (_a) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  validation: "url",
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "regex") {
              check.regex.lastIndex = 0;
              const testResult = check.regex.test(input.data);
              if (!testResult) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  validation: "regex",
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "trim") {
              input.data = input.data.trim();
            } else if (check.kind === "includes") {
              if (!input.data.includes(check.value, check.position)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  validation: { includes: check.value, position: check.position },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "toLowerCase") {
              input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
              input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
              if (!input.data.startsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  validation: { startsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "endsWith") {
              if (!input.data.endsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  validation: { endsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "datetime") {
              const regex = datetimeRegex2(check);
              if (!regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  validation: "datetime",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ip") {
              if (!isValidIP2(input.data, check.version)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  validation: "ip",
                  code: ZodError_1.ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util_1.util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        _regex(regex, validation, message) {
          return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodError_1.ZodIssueCode.invalid_string,
            ...errorUtil_1.errorUtil.errToObj(message)
          });
        }
        _addCheck(check) {
          return new ZodString2({
            ...this._def,
            checks: [...this._def.checks, check]
          });
        }
        email(message) {
          return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
        }
        url(message) {
          return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
        }
        emoji(message) {
          return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
        }
        uuid(message) {
          return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
        }
        cuid(message) {
          return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
        }
        cuid2(message) {
          return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
        }
        ulid(message) {
          return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
        }
        ip(options) {
          return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
        }
        datetime(options) {
          var _a;
          if (typeof options === "string") {
            return this._addCheck({
              kind: "datetime",
              precision: null,
              offset: false,
              message: options
            });
          }
          return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
          });
        }
        regex(regex, message) {
          return this._addCheck({
            kind: "regex",
            regex,
            ...errorUtil_1.errorUtil.errToObj(message)
          });
        }
        includes(value, options) {
          return this._addCheck({
            kind: "includes",
            value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
          });
        }
        startsWith(value, message) {
          return this._addCheck({
            kind: "startsWith",
            value,
            ...errorUtil_1.errorUtil.errToObj(message)
          });
        }
        endsWith(value, message) {
          return this._addCheck({
            kind: "endsWith",
            value,
            ...errorUtil_1.errorUtil.errToObj(message)
          });
        }
        min(minLength, message) {
          return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil_1.errorUtil.errToObj(message)
          });
        }
        max(maxLength, message) {
          return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil_1.errorUtil.errToObj(message)
          });
        }
        length(len, message) {
          return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil_1.errorUtil.errToObj(message)
          });
        }
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        nonempty(message) {
          return this.min(1, errorUtil_1.errorUtil.errToObj(message));
        }
        trim() {
          return new ZodString2({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }]
          });
        }
        toLowerCase() {
          return new ZodString2({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }]
          });
        }
        toUpperCase() {
          return new ZodString2({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }]
          });
        }
        get isDatetime() {
          return !!this._def.checks.find((ch) => ch.kind === "datetime");
        }
        get isEmail() {
          return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
          return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isEmoji() {
          return !!this._def.checks.find((ch) => ch.kind === "emoji");
        }
        get isUUID() {
          return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isCUID() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get isCUID2() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid2");
        }
        get isULID() {
          return !!this._def.checks.find((ch) => ch.kind === "ulid");
        }
        get isIP() {
          return !!this._def.checks.find((ch) => ch.kind === "ip");
        }
        get minLength() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxLength() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      exports.ZodString = ZodString2;
      ZodString2.create = (params) => {
        var _a;
        return new ZodString2({
          checks: [],
          typeName: ZodFirstPartyTypeKind2.ZodString,
          coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
          ...processCreateParams2(params)
        });
      };
      function floatSafeRemainder2(val, step) {
        const valDecCount = (val.toString().split(".")[1] || "").length;
        const stepDecCount = (step.toString().split(".")[1] || "").length;
        const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
        const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
        const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
        return valInt % stepInt / Math.pow(10, decCount);
      }
      var ZodNumber2 = class extends ZodType2 {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
          this.step = this.multipleOf;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = Number(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.number) {
            const ctx2 = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx2, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.number,
              received: ctx2.parsedType
            });
            return parseUtil_1.INVALID;
          }
          let ctx = void 0;
          const status = new parseUtil_1.ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "int") {
              if (!util_1.util.isInteger(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (floatSafeRemainder2(input.data, check.value) !== 0) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "finite") {
              if (!Number.isFinite(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.not_finite,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util_1.util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodNumber2({
            ...this._def,
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil_1.errorUtil.toString(message)
              }
            ]
          });
        }
        _addCheck(check) {
          return new ZodNumber2({
            ...this._def,
            checks: [...this._def.checks, check]
          });
        }
        int(message) {
          return this._addCheck({
            kind: "int",
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        finite(message) {
          return this._addCheck({
            kind: "finite",
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        safe(message) {
          return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message)
          })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
        get isInt() {
          return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
        }
        get isFinite() {
          let max = null, min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
              return true;
            } else if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            } else if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return Number.isFinite(min) && Number.isFinite(max);
        }
      };
      exports.ZodNumber = ZodNumber2;
      ZodNumber2.create = (params) => {
        return new ZodNumber2({
          checks: [],
          typeName: ZodFirstPartyTypeKind2.ZodNumber,
          coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
          ...processCreateParams2(params)
        });
      };
      var ZodBigInt2 = class extends ZodType2 {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = BigInt(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.bigint) {
            const ctx2 = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx2, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.bigint,
              received: ctx2.parsedType
            });
            return parseUtil_1.INVALID;
          }
          let ctx = void 0;
          const status = new parseUtil_1.ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  type: "bigint",
                  minimum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  type: "bigint",
                  maximum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (input.data % check.value !== BigInt(0)) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util_1.util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodBigInt2({
            ...this._def,
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil_1.errorUtil.toString(message)
              }
            ]
          });
        }
        _addCheck(check) {
          return new ZodBigInt2({
            ...this._def,
            checks: [...this._def.checks, check]
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      exports.ZodBigInt = ZodBigInt2;
      ZodBigInt2.create = (params) => {
        var _a;
        return new ZodBigInt2({
          checks: [],
          typeName: ZodFirstPartyTypeKind2.ZodBigInt,
          coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
          ...processCreateParams2(params)
        });
      };
      var ZodBoolean2 = class extends ZodType2 {
        _parse(input) {
          if (this._def.coerce) {
            input.data = Boolean(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.boolean,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          return (0, parseUtil_1.OK)(input.data);
        }
      };
      exports.ZodBoolean = ZodBoolean2;
      ZodBoolean2.create = (params) => {
        return new ZodBoolean2({
          typeName: ZodFirstPartyTypeKind2.ZodBoolean,
          coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
          ...processCreateParams2(params)
        });
      };
      var ZodDate2 = class extends ZodType2 {
        _parse(input) {
          if (this._def.coerce) {
            input.data = new Date(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.date) {
            const ctx2 = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx2, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.date,
              received: ctx2.parsedType
            });
            return parseUtil_1.INVALID;
          }
          if (isNaN(input.data.getTime())) {
            const ctx2 = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx2, {
              code: ZodError_1.ZodIssueCode.invalid_date
            });
            return parseUtil_1.INVALID;
          }
          const status = new parseUtil_1.ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.getTime() < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  minimum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.getTime() > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  maximum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else {
              util_1.util.assertNever(check);
            }
          }
          return {
            status: status.value,
            value: new Date(input.data.getTime())
          };
        }
        _addCheck(check) {
          return new ZodDate2({
            ...this._def,
            checks: [...this._def.checks, check]
          });
        }
        min(minDate, message) {
          return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        max(maxDate, message) {
          return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message)
          });
        }
        get minDate() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min != null ? new Date(min) : null;
        }
        get maxDate() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max != null ? new Date(max) : null;
        }
      };
      exports.ZodDate = ZodDate2;
      ZodDate2.create = (params) => {
        return new ZodDate2({
          checks: [],
          coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
          typeName: ZodFirstPartyTypeKind2.ZodDate,
          ...processCreateParams2(params)
        });
      };
      var ZodSymbol2 = class extends ZodType2 {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.symbol,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          return (0, parseUtil_1.OK)(input.data);
        }
      };
      exports.ZodSymbol = ZodSymbol2;
      ZodSymbol2.create = (params) => {
        return new ZodSymbol2({
          typeName: ZodFirstPartyTypeKind2.ZodSymbol,
          ...processCreateParams2(params)
        });
      };
      var ZodUndefined2 = class extends ZodType2 {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.undefined,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          return (0, parseUtil_1.OK)(input.data);
        }
      };
      exports.ZodUndefined = ZodUndefined2;
      ZodUndefined2.create = (params) => {
        return new ZodUndefined2({
          typeName: ZodFirstPartyTypeKind2.ZodUndefined,
          ...processCreateParams2(params)
        });
      };
      var ZodNull2 = class extends ZodType2 {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.null,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          return (0, parseUtil_1.OK)(input.data);
        }
      };
      exports.ZodNull = ZodNull2;
      ZodNull2.create = (params) => {
        return new ZodNull2({
          typeName: ZodFirstPartyTypeKind2.ZodNull,
          ...processCreateParams2(params)
        });
      };
      var ZodAny2 = class extends ZodType2 {
        constructor() {
          super(...arguments);
          this._any = true;
        }
        _parse(input) {
          return (0, parseUtil_1.OK)(input.data);
        }
      };
      exports.ZodAny = ZodAny2;
      ZodAny2.create = (params) => {
        return new ZodAny2({
          typeName: ZodFirstPartyTypeKind2.ZodAny,
          ...processCreateParams2(params)
        });
      };
      var ZodUnknown2 = class extends ZodType2 {
        constructor() {
          super(...arguments);
          this._unknown = true;
        }
        _parse(input) {
          return (0, parseUtil_1.OK)(input.data);
        }
      };
      exports.ZodUnknown = ZodUnknown2;
      ZodUnknown2.create = (params) => {
        return new ZodUnknown2({
          typeName: ZodFirstPartyTypeKind2.ZodUnknown,
          ...processCreateParams2(params)
        });
      };
      var ZodNever2 = class extends ZodType2 {
        _parse(input) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.never,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
      };
      exports.ZodNever = ZodNever2;
      ZodNever2.create = (params) => {
        return new ZodNever2({
          typeName: ZodFirstPartyTypeKind2.ZodNever,
          ...processCreateParams2(params)
        });
      };
      var ZodVoid2 = class extends ZodType2 {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.void,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          return (0, parseUtil_1.OK)(input.data);
        }
      };
      exports.ZodVoid = ZodVoid2;
      ZodVoid2.create = (params) => {
        return new ZodVoid2({
          typeName: ZodFirstPartyTypeKind2.ZodVoid,
          ...processCreateParams2(params)
        });
      };
      var ZodArray2 = class extends ZodType2 {
        _parse(input) {
          const { ctx, status } = this._processInputParams(input);
          const def = this._def;
          if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.array,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
                minimum: tooSmall ? def.exactLength.value : void 0,
                maximum: tooBig ? def.exactLength.value : void 0,
                type: "array",
                inclusive: true,
                exact: true,
                message: def.exactLength.message
              });
              status.dirty();
            }
          }
          if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: def.minLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def.minLength.message
              });
              status.dirty();
            }
          }
          if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: def.maxLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def.maxLength.message
              });
              status.dirty();
            }
          }
          if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i2) => {
              return def.type._parseAsync(new ParseInputLazyPath2(ctx, item, ctx.path, i2));
            })).then((result2) => {
              return parseUtil_1.ParseStatus.mergeArray(status, result2);
            });
          }
          const result = [...ctx.data].map((item, i2) => {
            return def.type._parseSync(new ParseInputLazyPath2(ctx, item, ctx.path, i2));
          });
          return parseUtil_1.ParseStatus.mergeArray(status, result);
        }
        get element() {
          return this._def.type;
        }
        min(minLength, message) {
          return new ZodArray2({
            ...this._def,
            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
          });
        }
        max(maxLength, message) {
          return new ZodArray2({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
          });
        }
        length(len, message) {
          return new ZodArray2({
            ...this._def,
            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
          });
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      exports.ZodArray = ZodArray2;
      ZodArray2.create = (schema, params) => {
        return new ZodArray2({
          type: schema,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: ZodFirstPartyTypeKind2.ZodArray,
          ...processCreateParams2(params)
        });
      };
      function deepPartialify2(schema) {
        if (schema instanceof ZodObject2) {
          const newShape = {};
          for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional2.create(deepPartialify2(fieldSchema));
          }
          return new ZodObject2({
            ...schema._def,
            shape: () => newShape
          });
        } else if (schema instanceof ZodArray2) {
          return new ZodArray2({
            ...schema._def,
            type: deepPartialify2(schema.element)
          });
        } else if (schema instanceof ZodOptional2) {
          return ZodOptional2.create(deepPartialify2(schema.unwrap()));
        } else if (schema instanceof ZodNullable2) {
          return ZodNullable2.create(deepPartialify2(schema.unwrap()));
        } else if (schema instanceof ZodTuple2) {
          return ZodTuple2.create(schema.items.map((item) => deepPartialify2(item)));
        } else {
          return schema;
        }
      }
      var ZodObject2 = class extends ZodType2 {
        constructor() {
          super(...arguments);
          this._cached = null;
          this.nonstrict = this.passthrough;
          this.augment = this.extend;
        }
        _getCached() {
          if (this._cached !== null)
            return this._cached;
          const shape = this._def.shape();
          const keys2 = util_1.util.objectKeys(shape);
          return this._cached = { shape, keys: keys2 };
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.object) {
            const ctx2 = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx2, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.object,
              received: ctx2.parsedType
            });
            return parseUtil_1.INVALID;
          }
          const { status, ctx } = this._processInputParams(input);
          const { shape, keys: shapeKeys } = this._getCached();
          const extraKeys = [];
          if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
              if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
              }
            }
          }
          const pairs = [];
          for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: keyValidator._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
          if (this._def.catchall instanceof ZodNever2) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
              for (const key of extraKeys) {
                pairs.push({
                  key: { status: "valid", value: key },
                  value: { status: "valid", value: ctx.data[key] }
                });
              }
            } else if (unknownKeys === "strict") {
              if (extraKeys.length > 0) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.unrecognized_keys,
                  keys: extraKeys
                });
                status.dirty();
              }
            } else if (unknownKeys === "strip") {
            } else {
              throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
          } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
              const value = ctx.data[key];
              pairs.push({
                key: { status: "valid", value: key },
                value: catchall._parse(
                  new ParseInputLazyPath2(ctx, value, ctx.path, key)
                  //, ctx.child(key), value, getParsedType(value)
                ),
                alwaysSet: key in ctx.data
              });
            }
          }
          if (ctx.common.async) {
            return Promise.resolve().then(async () => {
              const syncPairs = [];
              for (const pair of pairs) {
                const key = await pair.key;
                syncPairs.push({
                  key,
                  value: await pair.value,
                  alwaysSet: pair.alwaysSet
                });
              }
              return syncPairs;
            }).then((syncPairs) => {
              return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
            });
          } else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get shape() {
          return this._def.shape();
        }
        strict(message) {
          errorUtil_1.errorUtil.errToObj;
          return new ZodObject2({
            ...this._def,
            unknownKeys: "strict",
            ...message !== void 0 ? {
              errorMap: (issue, ctx) => {
                var _a, _b, _c, _d;
                const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                if (issue.code === "unrecognized_keys")
                  return {
                    message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                  };
                return {
                  message: defaultError
                };
              }
            } : {}
          });
        }
        strip() {
          return new ZodObject2({
            ...this._def,
            unknownKeys: "strip"
          });
        }
        passthrough() {
          return new ZodObject2({
            ...this._def,
            unknownKeys: "passthrough"
          });
        }
        // const AugmentFactory =
        //   <Def extends ZodObjectDef>(def: Def) =>
        //   <Augmentation extends ZodRawShape>(
        //     augmentation: Augmentation
        //   ): ZodObject<
        //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
        //     Def["unknownKeys"],
        //     Def["catchall"]
        //   > => {
        //     return new ZodObject({
        //       ...def,
        //       shape: () => ({
        //         ...def.shape(),
        //         ...augmentation,
        //       }),
        //     }) as any;
        //   };
        extend(augmentation) {
          return new ZodObject2({
            ...this._def,
            shape: () => ({
              ...this._def.shape(),
              ...augmentation
            })
          });
        }
        /**
         * Prior to zod@1.0.12 there was a bug in the
         * inferred type of merged objects. Please
         * upgrade if you are experiencing issues.
         */
        merge(merging) {
          const merged = new ZodObject2({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
              ...this._def.shape(),
              ...merging._def.shape()
            }),
            typeName: ZodFirstPartyTypeKind2.ZodObject
          });
          return merged;
        }
        // merge<
        //   Incoming extends AnyZodObject,
        //   Augmentation extends Incoming["shape"],
        //   NewOutput extends {
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   },
        //   NewInput extends {
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }
        // >(
        //   merging: Incoming
        // ): ZodObject<
        //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
        //   Incoming["_def"]["unknownKeys"],
        //   Incoming["_def"]["catchall"],
        //   NewOutput,
        //   NewInput
        // > {
        //   const merged: any = new ZodObject({
        //     unknownKeys: merging._def.unknownKeys,
        //     catchall: merging._def.catchall,
        //     shape: () =>
        //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
        //     typeName: ZodFirstPartyTypeKind.ZodObject,
        //   }) as any;
        //   return merged;
        // }
        setKey(key, schema) {
          return this.augment({ [key]: schema });
        }
        // merge<Incoming extends AnyZodObject>(
        //   merging: Incoming
        // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
        // ZodObject<
        //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
        //   Incoming["_def"]["unknownKeys"],
        //   Incoming["_def"]["catchall"]
        // > {
        //   // const mergedShape = objectUtil.mergeShapes(
        //   //   this._def.shape(),
        //   //   merging._def.shape()
        //   // );
        //   const merged: any = new ZodObject({
        //     unknownKeys: merging._def.unknownKeys,
        //     catchall: merging._def.catchall,
        //     shape: () =>
        //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
        //     typeName: ZodFirstPartyTypeKind.ZodObject,
        //   }) as any;
        //   return merged;
        // }
        catchall(index) {
          return new ZodObject2({
            ...this._def,
            catchall: index
          });
        }
        pick(mask) {
          const shape = {};
          util_1.util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject2({
            ...this._def,
            shape: () => shape
          });
        }
        omit(mask) {
          const shape = {};
          util_1.util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject2({
            ...this._def,
            shape: () => shape
          });
        }
        /**
         * @deprecated
         */
        deepPartial() {
          return deepPartialify2(this);
        }
        partial(mask) {
          const newShape = {};
          util_1.util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
              newShape[key] = fieldSchema;
            } else {
              newShape[key] = fieldSchema.optional();
            }
          });
          return new ZodObject2({
            ...this._def,
            shape: () => newShape
          });
        }
        required(mask) {
          const newShape = {};
          util_1.util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
              newShape[key] = this.shape[key];
            } else {
              const fieldSchema = this.shape[key];
              let newField = fieldSchema;
              while (newField instanceof ZodOptional2) {
                newField = newField._def.innerType;
              }
              newShape[key] = newField;
            }
          });
          return new ZodObject2({
            ...this._def,
            shape: () => newShape
          });
        }
        keyof() {
          return createZodEnum2(util_1.util.objectKeys(this.shape));
        }
      };
      exports.ZodObject = ZodObject2;
      ZodObject2.create = (shape, params) => {
        return new ZodObject2({
          shape: () => shape,
          unknownKeys: "strip",
          catchall: ZodNever2.create(),
          typeName: ZodFirstPartyTypeKind2.ZodObject,
          ...processCreateParams2(params)
        });
      };
      ZodObject2.strictCreate = (shape, params) => {
        return new ZodObject2({
          shape: () => shape,
          unknownKeys: "strict",
          catchall: ZodNever2.create(),
          typeName: ZodFirstPartyTypeKind2.ZodObject,
          ...processCreateParams2(params)
        });
      };
      ZodObject2.lazycreate = (shape, params) => {
        return new ZodObject2({
          shape,
          unknownKeys: "strip",
          catchall: ZodNever2.create(),
          typeName: ZodFirstPartyTypeKind2.ZodObject,
          ...processCreateParams2(params)
        });
      };
      var ZodUnion2 = class extends ZodType2 {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const options = this._def.options;
          function handleResults(results) {
            for (const result of results) {
              if (result.result.status === "valid") {
                return result.result;
              }
            }
            for (const result of results) {
              if (result.result.status === "dirty") {
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
              }
            }
            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_union,
              unionErrors
            });
            return parseUtil_1.INVALID;
          }
          if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
              const childCtx = {
                ...ctx,
                common: {
                  ...ctx.common,
                  issues: []
                },
                parent: null
              };
              return {
                result: await option._parseAsync({
                  data: ctx.data,
                  path: ctx.path,
                  parent: childCtx
                }),
                ctx: childCtx
              };
            })).then(handleResults);
          } else {
            let dirty = void 0;
            const issues = [];
            for (const option of options) {
              const childCtx = {
                ...ctx,
                common: {
                  ...ctx.common,
                  issues: []
                },
                parent: null
              };
              const result = option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              });
              if (result.status === "valid") {
                return result;
              } else if (result.status === "dirty" && !dirty) {
                dirty = { result, ctx: childCtx };
              }
              if (childCtx.common.issues.length) {
                issues.push(childCtx.common.issues);
              }
            }
            if (dirty) {
              ctx.common.issues.push(...dirty.ctx.common.issues);
              return dirty.result;
            }
            const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_union,
              unionErrors
            });
            return parseUtil_1.INVALID;
          }
        }
        get options() {
          return this._def.options;
        }
      };
      exports.ZodUnion = ZodUnion2;
      ZodUnion2.create = (types, params) => {
        return new ZodUnion2({
          options: types,
          typeName: ZodFirstPartyTypeKind2.ZodUnion,
          ...processCreateParams2(params)
        });
      };
      var getDiscriminator2 = (type2) => {
        if (type2 instanceof ZodLazy2) {
          return getDiscriminator2(type2.schema);
        } else if (type2 instanceof ZodEffects2) {
          return getDiscriminator2(type2.innerType());
        } else if (type2 instanceof ZodLiteral2) {
          return [type2.value];
        } else if (type2 instanceof ZodEnum2) {
          return type2.options;
        } else if (type2 instanceof ZodNativeEnum2) {
          return Object.keys(type2.enum);
        } else if (type2 instanceof ZodDefault2) {
          return getDiscriminator2(type2._def.innerType);
        } else if (type2 instanceof ZodUndefined2) {
          return [void 0];
        } else if (type2 instanceof ZodNull2) {
          return [null];
        } else {
          return null;
        }
      };
      var ZodDiscriminatedUnion2 = class extends ZodType2 {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.object,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          const discriminator = this.discriminator;
          const discriminatorValue = ctx.data[discriminator];
          const option = this.optionsMap.get(discriminatorValue);
          if (!option) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
              options: Array.from(this.optionsMap.keys()),
              path: [discriminator]
            });
            return parseUtil_1.INVALID;
          }
          if (ctx.common.async) {
            return option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          } else {
            return option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        /**
         * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
         * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
         * have a different value for each object in the union.
         * @param discriminator the name of the discriminator property
         * @param types an array of object schemas
         * @param params
         */
        static create(discriminator, options, params) {
          const optionsMap = /* @__PURE__ */ new Map();
          for (const type2 of options) {
            const discriminatorValues = getDiscriminator2(type2.shape[discriminator]);
            if (!discriminatorValues) {
              throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
              if (optionsMap.has(value)) {
                throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
              }
              optionsMap.set(value, type2);
            }
          }
          return new ZodDiscriminatedUnion2({
            typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams2(params)
          });
        }
      };
      exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion2;
      function mergeValues2(a4, b2) {
        const aType = (0, util_1.getParsedType)(a4);
        const bType = (0, util_1.getParsedType)(b2);
        if (a4 === b2) {
          return { valid: true, data: a4 };
        } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
          const bKeys = util_1.util.objectKeys(b2);
          const sharedKeys = util_1.util.objectKeys(a4).filter((key) => bKeys.indexOf(key) !== -1);
          const newObj = { ...a4, ...b2 };
          for (const key of sharedKeys) {
            const sharedValue = mergeValues2(a4[key], b2[key]);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newObj[key] = sharedValue.data;
          }
          return { valid: true, data: newObj };
        } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
          if (a4.length !== b2.length) {
            return { valid: false };
          }
          const newArray = [];
          for (let index = 0; index < a4.length; index++) {
            const itemA = a4[index];
            const itemB = b2[index];
            const sharedValue = mergeValues2(itemA, itemB);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newArray.push(sharedValue.data);
          }
          return { valid: true, data: newArray };
        } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a4 === +b2) {
          return { valid: true, data: a4 };
        } else {
          return { valid: false };
        }
      }
      var ZodIntersection2 = class extends ZodType2 {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const handleParsed = (parsedLeft, parsedRight) => {
            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
              return parseUtil_1.INVALID;
            }
            const merged = mergeValues2(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_intersection_types
              });
              return parseUtil_1.INVALID;
            }
            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
              status.dirty();
            }
            return { status: status.value, value: merged.data };
          };
          if (ctx.common.async) {
            return Promise.all([
              this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              }),
              this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              })
            ]).then(([left, right]) => handleParsed(left, right));
          } else {
            return handleParsed(this._def.left._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }), this._def.right._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }));
          }
        }
      };
      exports.ZodIntersection = ZodIntersection2;
      ZodIntersection2.create = (left, right, params) => {
        return new ZodIntersection2({
          left,
          right,
          typeName: ZodFirstPartyTypeKind2.ZodIntersection,
          ...processCreateParams2(params)
        });
      };
      var ZodTuple2 = class extends ZodType2 {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.array,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          if (ctx.data.length < this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            return parseUtil_1.INVALID;
          }
          const rest = this._def.rest;
          if (!rest && ctx.data.length > this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            status.dirty();
          }
          const items = [...ctx.data].map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
              return null;
            return schema._parse(new ParseInputLazyPath2(ctx, item, ctx.path, itemIndex));
          }).filter((x2) => !!x2);
          if (ctx.common.async) {
            return Promise.all(items).then((results) => {
              return parseUtil_1.ParseStatus.mergeArray(status, results);
            });
          } else {
            return parseUtil_1.ParseStatus.mergeArray(status, items);
          }
        }
        get items() {
          return this._def.items;
        }
        rest(rest) {
          return new ZodTuple2({
            ...this._def,
            rest
          });
        }
      };
      exports.ZodTuple = ZodTuple2;
      ZodTuple2.create = (schemas, params) => {
        if (!Array.isArray(schemas)) {
          throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple2({
          items: schemas,
          typeName: ZodFirstPartyTypeKind2.ZodTuple,
          rest: null,
          ...processCreateParams2(params)
        });
      };
      var ZodRecord2 = class extends ZodType2 {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.object,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          const pairs = [];
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          for (const key in ctx.data) {
            pairs.push({
              key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, key)),
              value: valueType._parse(new ParseInputLazyPath2(ctx, ctx.data[key], ctx.path, key))
            });
          }
          if (ctx.common.async) {
            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
          } else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get element() {
          return this._def.valueType;
        }
        static create(first, second, third) {
          if (second instanceof ZodType2) {
            return new ZodRecord2({
              keyType: first,
              valueType: second,
              typeName: ZodFirstPartyTypeKind2.ZodRecord,
              ...processCreateParams2(third)
            });
          }
          return new ZodRecord2({
            keyType: ZodString2.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind2.ZodRecord,
            ...processCreateParams2(second)
          });
        }
      };
      exports.ZodRecord = ZodRecord2;
      var ZodMap2 = class extends ZodType2 {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== util_1.ZodParsedType.map) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.map,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
              key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, [index, "key"])),
              value: valueType._parse(new ParseInputLazyPath2(ctx, value, ctx.path, [index, "value"]))
            };
          });
          if (ctx.common.async) {
            const finalMap = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async () => {
              for (const pair of pairs) {
                const key = await pair.key;
                const value = await pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                  return parseUtil_1.INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                  status.dirty();
                }
                finalMap.set(key.value, value.value);
              }
              return { status: status.value, value: finalMap };
            });
          } else {
            const finalMap = /* @__PURE__ */ new Map();
            for (const pair of pairs) {
              const key = pair.key;
              const value = pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          }
        }
      };
      exports.ZodMap = ZodMap2;
      ZodMap2.create = (keyType, valueType, params) => {
        return new ZodMap2({
          valueType,
          keyType,
          typeName: ZodFirstPartyTypeKind2.ZodMap,
          ...processCreateParams2(params)
        });
      };
      var ZodSet2 = class extends ZodType2 {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== util_1.ZodParsedType.set) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.set,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          const def = this._def;
          if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: def.minSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def.minSize.message
              });
              status.dirty();
            }
          }
          if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: def.maxSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def.maxSize.message
              });
              status.dirty();
            }
          }
          const valueType = this._def.valueType;
          function finalizeSet(elements2) {
            const parsedSet = /* @__PURE__ */ new Set();
            for (const element of elements2) {
              if (element.status === "aborted")
                return parseUtil_1.INVALID;
              if (element.status === "dirty")
                status.dirty();
              parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
          }
          const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath2(ctx, item, ctx.path, i2)));
          if (ctx.common.async) {
            return Promise.all(elements).then((elements2) => finalizeSet(elements2));
          } else {
            return finalizeSet(elements);
          }
        }
        min(minSize, message) {
          return new ZodSet2({
            ...this._def,
            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
          });
        }
        max(maxSize, message) {
          return new ZodSet2({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
          });
        }
        size(size, message) {
          return this.min(size, message).max(size, message);
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      exports.ZodSet = ZodSet2;
      ZodSet2.create = (valueType, params) => {
        return new ZodSet2({
          valueType,
          minSize: null,
          maxSize: null,
          typeName: ZodFirstPartyTypeKind2.ZodSet,
          ...processCreateParams2(params)
        });
      };
      var ZodFunction2 = class extends ZodType2 {
        constructor() {
          super(...arguments);
          this.validate = this.implement;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== util_1.ZodParsedType.function) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.function,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          function makeArgsIssue(args, error) {
            return (0, parseUtil_1.makeIssue)({
              data: args,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                (0, errors_1.getErrorMap)(),
                errors_1.defaultErrorMap
              ].filter((x2) => !!x2),
              issueData: {
                code: ZodError_1.ZodIssueCode.invalid_arguments,
                argumentsError: error
              }
            });
          }
          function makeReturnsIssue(returns, error) {
            return (0, parseUtil_1.makeIssue)({
              data: returns,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                (0, errors_1.getErrorMap)(),
                errors_1.defaultErrorMap
              ].filter((x2) => !!x2),
              issueData: {
                code: ZodError_1.ZodIssueCode.invalid_return_type,
                returnTypeError: error
              }
            });
          }
          const params = { errorMap: ctx.common.contextualErrorMap };
          const fn = ctx.data;
          if (this._def.returns instanceof ZodPromise2) {
            const me = this;
            return (0, parseUtil_1.OK)(async function(...args) {
              const error = new ZodError_1.ZodError([]);
              const parsedArgs = await me._def.args.parseAsync(args, params).catch((e8) => {
                error.addIssue(makeArgsIssue(args, e8));
                throw error;
              });
              const result = await Reflect.apply(fn, this, parsedArgs);
              const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e8) => {
                error.addIssue(makeReturnsIssue(result, e8));
                throw error;
              });
              return parsedReturns;
            });
          } else {
            const me = this;
            return (0, parseUtil_1.OK)(function(...args) {
              const parsedArgs = me._def.args.safeParse(args, params);
              if (!parsedArgs.success) {
                throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
              }
              const result = Reflect.apply(fn, this, parsedArgs.data);
              const parsedReturns = me._def.returns.safeParse(result, params);
              if (!parsedReturns.success) {
                throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
              }
              return parsedReturns.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...items) {
          return new ZodFunction2({
            ...this._def,
            args: ZodTuple2.create(items).rest(ZodUnknown2.create())
          });
        }
        returns(returnType) {
          return new ZodFunction2({
            ...this._def,
            returns: returnType
          });
        }
        implement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        strictImplement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        static create(args, returns, params) {
          return new ZodFunction2({
            args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
            returns: returns || ZodUnknown2.create(),
            typeName: ZodFirstPartyTypeKind2.ZodFunction,
            ...processCreateParams2(params)
          });
        }
      };
      exports.ZodFunction = ZodFunction2;
      var ZodLazy2 = class extends ZodType2 {
        get schema() {
          return this._def.getter();
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const lazySchema = this._def.getter();
          return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
      };
      exports.ZodLazy = ZodLazy2;
      ZodLazy2.create = (getter, params) => {
        return new ZodLazy2({
          getter,
          typeName: ZodFirstPartyTypeKind2.ZodLazy,
          ...processCreateParams2(params)
        });
      };
      var ZodLiteral2 = class extends ZodType2 {
        _parse(input) {
          if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              received: ctx.data,
              code: ZodError_1.ZodIssueCode.invalid_literal,
              expected: this._def.value
            });
            return parseUtil_1.INVALID;
          }
          return { status: "valid", value: input.data };
        }
        get value() {
          return this._def.value;
        }
      };
      exports.ZodLiteral = ZodLiteral2;
      ZodLiteral2.create = (value, params) => {
        return new ZodLiteral2({
          value,
          typeName: ZodFirstPartyTypeKind2.ZodLiteral,
          ...processCreateParams2(params)
        });
      };
      function createZodEnum2(values, params) {
        return new ZodEnum2({
          values,
          typeName: ZodFirstPartyTypeKind2.ZodEnum,
          ...processCreateParams2(params)
        });
      }
      var ZodEnum2 = class extends ZodType2 {
        _parse(input) {
          if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
              expected: util_1.util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodError_1.ZodIssueCode.invalid_type
            });
            return parseUtil_1.INVALID;
          }
          if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
              received: ctx.data,
              code: ZodError_1.ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return parseUtil_1.INVALID;
          }
          return (0, parseUtil_1.OK)(input.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Values() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        extract(values) {
          return ZodEnum2.create(values);
        }
        exclude(values) {
          return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)));
        }
      };
      exports.ZodEnum = ZodEnum2;
      ZodEnum2.create = createZodEnum2;
      var ZodNativeEnum2 = class extends ZodType2 {
        _parse(input) {
          const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
          const ctx = this._getOrReturnCtx(input);
          if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              expected: util_1.util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodError_1.ZodIssueCode.invalid_type
            });
            return parseUtil_1.INVALID;
          }
          if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              received: ctx.data,
              code: ZodError_1.ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return parseUtil_1.INVALID;
          }
          return (0, parseUtil_1.OK)(input.data);
        }
        get enum() {
          return this._def.values;
        }
      };
      exports.ZodNativeEnum = ZodNativeEnum2;
      ZodNativeEnum2.create = (values, params) => {
        return new ZodNativeEnum2({
          values,
          typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
          ...processCreateParams2(params)
        });
      };
      var ZodPromise2 = class extends ZodType2 {
        unwrap() {
          return this._def.type;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.promise,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
          return (0, parseUtil_1.OK)(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
              path: ctx.path,
              errorMap: ctx.common.contextualErrorMap
            });
          }));
        }
      };
      exports.ZodPromise = ZodPromise2;
      ZodPromise2.create = (schema, params) => {
        return new ZodPromise2({
          type: schema,
          typeName: ZodFirstPartyTypeKind2.ZodPromise,
          ...processCreateParams2(params)
        });
      };
      var ZodEffects2 = class extends ZodType2 {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const effect = this._def.effect || null;
          const checkCtx = {
            addIssue: (arg) => {
              (0, parseUtil_1.addIssueToContext)(ctx, arg);
              if (arg.fatal) {
                status.abort();
              } else {
                status.dirty();
              }
            },
            get path() {
              return ctx.path;
            }
          };
          checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
          if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.issues.length) {
              return {
                status: "dirty",
                value: ctx.data
              };
            }
            if (ctx.common.async) {
              return Promise.resolve(processed).then((processed2) => {
                return this._def.schema._parseAsync({
                  data: processed2,
                  path: ctx.path,
                  parent: ctx
                });
              });
            } else {
              return this._def.schema._parseSync({
                data: processed,
                path: ctx.path,
                parent: ctx
              });
            }
          }
          if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
              const result = effect.refinement(acc, checkCtx);
              if (ctx.common.async) {
                return Promise.resolve(result);
              }
              if (result instanceof Promise) {
                throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
              }
              return acc;
            };
            if (ctx.common.async === false) {
              const inner = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inner.status === "aborted")
                return parseUtil_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              executeRefinement(inner.value);
              return { status: status.value, value: inner.value };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                if (inner.status === "aborted")
                  return parseUtil_1.INVALID;
                if (inner.status === "dirty")
                  status.dirty();
                return executeRefinement(inner.value).then(() => {
                  return { status: status.value, value: inner.value };
                });
              });
            }
          }
          if (effect.type === "transform") {
            if (ctx.common.async === false) {
              const base = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (!(0, parseUtil_1.isValid)(base))
                return base;
              const result = effect.transform(base.value, checkCtx);
              if (result instanceof Promise) {
                throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
              }
              return { status: status.value, value: result };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
                if (!(0, parseUtil_1.isValid)(base))
                  return base;
                return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
              });
            }
          }
          util_1.util.assertNever(effect);
        }
      };
      exports.ZodEffects = ZodEffects2;
      exports.ZodTransformer = ZodEffects2;
      ZodEffects2.create = (schema, effect, params) => {
        return new ZodEffects2({
          schema,
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          effect,
          ...processCreateParams2(params)
        });
      };
      ZodEffects2.createWithPreprocess = (preprocess, schema, params) => {
        return new ZodEffects2({
          schema,
          effect: { type: "preprocess", transform: preprocess },
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          ...processCreateParams2(params)
        });
      };
      var ZodOptional2 = class extends ZodType2 {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === util_1.ZodParsedType.undefined) {
            return (0, parseUtil_1.OK)(void 0);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      exports.ZodOptional = ZodOptional2;
      ZodOptional2.create = (type2, params) => {
        return new ZodOptional2({
          innerType: type2,
          typeName: ZodFirstPartyTypeKind2.ZodOptional,
          ...processCreateParams2(params)
        });
      };
      var ZodNullable2 = class extends ZodType2 {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === util_1.ZodParsedType.null) {
            return (0, parseUtil_1.OK)(null);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      exports.ZodNullable = ZodNullable2;
      ZodNullable2.create = (type2, params) => {
        return new ZodNullable2({
          innerType: type2,
          typeName: ZodFirstPartyTypeKind2.ZodNullable,
          ...processCreateParams2(params)
        });
      };
      var ZodDefault2 = class extends ZodType2 {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          let data = ctx.data;
          if (ctx.parsedType === util_1.ZodParsedType.undefined) {
            data = this._def.defaultValue();
          }
          return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        removeDefault() {
          return this._def.innerType;
        }
      };
      exports.ZodDefault = ZodDefault2;
      ZodDefault2.create = (type2, params) => {
        return new ZodDefault2({
          innerType: type2,
          typeName: ZodFirstPartyTypeKind2.ZodDefault,
          defaultValue: typeof params.default === "function" ? params.default : () => params.default,
          ...processCreateParams2(params)
        });
      };
      var ZodCatch2 = class extends ZodType2 {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const newCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            }
          };
          const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
              ...newCtx
            }
          });
          if ((0, parseUtil_1.isAsync)(result)) {
            return result.then((result2) => {
              return {
                status: "valid",
                value: result2.status === "valid" ? result2.value : this._def.catchValue({
                  get error() {
                    return new ZodError_1.ZodError(newCtx.common.issues);
                  },
                  input: newCtx.data
                })
              };
            });
          } else {
            return {
              status: "valid",
              value: result.status === "valid" ? result.value : this._def.catchValue({
                get error() {
                  return new ZodError_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          }
        }
        removeCatch() {
          return this._def.innerType;
        }
      };
      exports.ZodCatch = ZodCatch2;
      ZodCatch2.create = (type2, params) => {
        return new ZodCatch2({
          innerType: type2,
          typeName: ZodFirstPartyTypeKind2.ZodCatch,
          catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
          ...processCreateParams2(params)
        });
      };
      var ZodNaN2 = class extends ZodType2 {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== util_1.ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.nan,
              received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
          }
          return { status: "valid", value: input.data };
        }
      };
      exports.ZodNaN = ZodNaN2;
      ZodNaN2.create = (params) => {
        return new ZodNaN2({
          typeName: ZodFirstPartyTypeKind2.ZodNaN,
          ...processCreateParams2(params)
        });
      };
      exports.BRAND = Symbol("zod_brand");
      var ZodBranded2 = class extends ZodType2 {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const data = ctx.data;
          return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        unwrap() {
          return this._def.type;
        }
      };
      exports.ZodBranded = ZodBranded2;
      var ZodPipeline2 = class extends ZodType2 {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.common.async) {
            const handleAsync = async () => {
              const inResult = await this._def.in._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inResult.status === "aborted")
                return parseUtil_1.INVALID;
              if (inResult.status === "dirty") {
                status.dirty();
                return (0, parseUtil_1.DIRTY)(inResult.value);
              } else {
                return this._def.out._parseAsync({
                  data: inResult.value,
                  path: ctx.path,
                  parent: ctx
                });
              }
            };
            return handleAsync();
          } else {
            const inResult = this._def.in._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return {
                status: "dirty",
                value: inResult.value
              };
            } else {
              return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }
        }
        static create(a4, b2) {
          return new ZodPipeline2({
            in: a4,
            out: b2,
            typeName: ZodFirstPartyTypeKind2.ZodPipeline
          });
        }
      };
      exports.ZodPipeline = ZodPipeline2;
      var ZodReadonly2 = class extends ZodType2 {
        _parse(input) {
          const result = this._def.innerType._parse(input);
          if ((0, parseUtil_1.isValid)(result)) {
            result.value = Object.freeze(result.value);
          }
          return result;
        }
      };
      exports.ZodReadonly = ZodReadonly2;
      ZodReadonly2.create = (type2, params) => {
        return new ZodReadonly2({
          innerType: type2,
          typeName: ZodFirstPartyTypeKind2.ZodReadonly,
          ...processCreateParams2(params)
        });
      };
      var custom2 = (check, params = {}, fatal) => {
        if (check)
          return ZodAny2.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
              const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
              const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
              const p22 = typeof p2 === "string" ? { message: p2 } : p2;
              ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
            }
          });
        return ZodAny2.create();
      };
      exports.custom = custom2;
      exports.late = {
        object: ZodObject2.lazycreate
      };
      var ZodFirstPartyTypeKind2;
      (function(ZodFirstPartyTypeKind3) {
        ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
        ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
      })(ZodFirstPartyTypeKind2 = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
      var instanceOfType2 = (cls, params = {
        message: `Input not instance of ${cls.name}`
      }) => (0, exports.custom)((data) => data instanceof cls, params);
      exports.instanceof = instanceOfType2;
      var stringType2 = ZodString2.create;
      exports.string = stringType2;
      var numberType2 = ZodNumber2.create;
      exports.number = numberType2;
      var nanType2 = ZodNaN2.create;
      exports.nan = nanType2;
      var bigIntType2 = ZodBigInt2.create;
      exports.bigint = bigIntType2;
      var booleanType2 = ZodBoolean2.create;
      exports.boolean = booleanType2;
      var dateType2 = ZodDate2.create;
      exports.date = dateType2;
      var symbolType2 = ZodSymbol2.create;
      exports.symbol = symbolType2;
      var undefinedType2 = ZodUndefined2.create;
      exports.undefined = undefinedType2;
      var nullType2 = ZodNull2.create;
      exports.null = nullType2;
      var anyType2 = ZodAny2.create;
      exports.any = anyType2;
      var unknownType2 = ZodUnknown2.create;
      exports.unknown = unknownType2;
      var neverType2 = ZodNever2.create;
      exports.never = neverType2;
      var voidType2 = ZodVoid2.create;
      exports.void = voidType2;
      var arrayType2 = ZodArray2.create;
      exports.array = arrayType2;
      var objectType2 = ZodObject2.create;
      exports.object = objectType2;
      var strictObjectType2 = ZodObject2.strictCreate;
      exports.strictObject = strictObjectType2;
      var unionType2 = ZodUnion2.create;
      exports.union = unionType2;
      var discriminatedUnionType2 = ZodDiscriminatedUnion2.create;
      exports.discriminatedUnion = discriminatedUnionType2;
      var intersectionType2 = ZodIntersection2.create;
      exports.intersection = intersectionType2;
      var tupleType2 = ZodTuple2.create;
      exports.tuple = tupleType2;
      var recordType2 = ZodRecord2.create;
      exports.record = recordType2;
      var mapType2 = ZodMap2.create;
      exports.map = mapType2;
      var setType2 = ZodSet2.create;
      exports.set = setType2;
      var functionType2 = ZodFunction2.create;
      exports.function = functionType2;
      var lazyType2 = ZodLazy2.create;
      exports.lazy = lazyType2;
      var literalType2 = ZodLiteral2.create;
      exports.literal = literalType2;
      var enumType2 = ZodEnum2.create;
      exports.enum = enumType2;
      var nativeEnumType2 = ZodNativeEnum2.create;
      exports.nativeEnum = nativeEnumType2;
      var promiseType2 = ZodPromise2.create;
      exports.promise = promiseType2;
      var effectsType2 = ZodEffects2.create;
      exports.effect = effectsType2;
      exports.transformer = effectsType2;
      var optionalType2 = ZodOptional2.create;
      exports.optional = optionalType2;
      var nullableType2 = ZodNullable2.create;
      exports.nullable = nullableType2;
      var preprocessType2 = ZodEffects2.createWithPreprocess;
      exports.preprocess = preprocessType2;
      var pipelineType2 = ZodPipeline2.create;
      exports.pipeline = pipelineType2;
      var ostring2 = () => stringType2().optional();
      exports.ostring = ostring2;
      var onumber2 = () => numberType2().optional();
      exports.onumber = onumber2;
      var oboolean2 = () => booleanType2().optional();
      exports.oboolean = oboolean2;
      exports.coerce = {
        string: (arg) => ZodString2.create({ ...arg, coerce: true }),
        number: (arg) => ZodNumber2.create({ ...arg, coerce: true }),
        boolean: (arg) => ZodBoolean2.create({
          ...arg,
          coerce: true
        }),
        bigint: (arg) => ZodBigInt2.create({ ...arg, coerce: true }),
        date: (arg) => ZodDate2.create({ ...arg, coerce: true })
      };
      exports.NEVER = parseUtil_1.INVALID;
    }
  });

  // ../node_modules/zod/lib/external.js
  var require_external = __commonJS({
    "../node_modules/zod/lib/external.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        Object.defineProperty(o, k22, { enumerable: true, get: function() {
          return m2[k2];
        } });
      } : function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m2[k2];
      });
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
            __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_errors3(), exports);
      __exportStar(require_parseUtil(), exports);
      __exportStar(require_typeAliases(), exports);
      __exportStar(require_util2(), exports);
      __exportStar(require_types(), exports);
      __exportStar(require_ZodError(), exports);
    }
  });

  // ../node_modules/zod/lib/index.js
  var require_lib2 = __commonJS({
    "../node_modules/zod/lib/index.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        Object.defineProperty(o, k22, { enumerable: true, get: function() {
          return m2[k2];
        } });
      } : function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m2[k2];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
            __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.z = void 0;
      var z2 = __importStar(require_external());
      exports.z = z2;
      __exportStar(require_external(), exports);
      exports.default = z2;
    }
  });

  // ../packages/validations/dist/validations/userRoutesValidator.js
  var require_userRoutesValidator = __commonJS({
    "../packages/validations/dist/validations/userRoutesValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.updatePassword = exports.emailExists = exports.checkCode = exports.login = exports.getFirebaseUserByEmail = exports.createMongoDBUser = exports.linkFirebaseAuth = exports.deleteUser = exports.editUser = exports.addToFavorite = exports.resetPassword = exports.sentEmail = exports.getUserById = exports.userSignIn = exports.userSignUp = void 0;
      var zod_1 = require_lib2();
      var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
      exports.userSignUp = zod_1.z.object({
        name: zod_1.z.string().min(1).nonempty(),
        email: zod_1.z.string().email().nonempty(),
        password: zod_1.z.string().nonempty(),
        username: zod_1.z.string().nonempty()
      });
      exports.userSignIn = zod_1.z.object({
        email: zod_1.z.string().email().nonempty(),
        password: zod_1.z.string().nonempty()
      });
      exports.getUserById = zod_1.z.object({
        userId: JoiObjectId6.nonempty()
      });
      exports.sentEmail = zod_1.z.object({
        email: zod_1.z.string().email().nonempty()
      });
      exports.resetPassword = zod_1.z.object({
        resetToken: zod_1.z.string().nonempty(),
        password: zod_1.z.string().nonempty()
      });
      exports.addToFavorite = zod_1.z.object({
        packId: JoiObjectId6.nonempty(),
        userId: JoiObjectId6.nonempty()
      });
      exports.editUser = zod_1.z.object({
        userId: JoiObjectId6.nonempty()
      });
      exports.deleteUser = zod_1.z.object({
        userId: JoiObjectId6.nonempty()
      });
      exports.linkFirebaseAuth = zod_1.z.object({
        firebaseAuthToken: zod_1.z.string().nonempty()
      });
      exports.createMongoDBUser = zod_1.z.object({
        email: zod_1.z.string().email().nonempty(),
        name: zod_1.z.string().min(1).nonempty(),
        password: zod_1.z.string().nonempty()
      });
      exports.getFirebaseUserByEmail = zod_1.z.object({
        email: zod_1.z.string().email().nonempty()
      });
      exports.login = zod_1.z.object({
        email: zod_1.z.string().email().nonempty(),
        password: zod_1.z.string().nonempty()
      });
      exports.checkCode = zod_1.z.object({
        email: zod_1.z.string().email().nonempty(),
        code: zod_1.z.string().nonempty()
      });
      exports.emailExists = zod_1.z.object({
        email: zod_1.z.string().email().nonempty()
      });
      exports.updatePassword = zod_1.z.object({
        email: zod_1.z.string().email().nonempty(),
        password: zod_1.z.string().nonempty()
      });
    }
  });

  // ../packages/validations/dist/validations/tripRoutesValidator.js
  var require_tripRoutesValidator = __commonJS({
    "../packages/validations/dist/validations/tripRoutesValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.queryTrip = exports.deleteTrip = exports.editTrip = exports.addTrip = exports.getTripById = exports.getTrips = exports.JoiObjectId = void 0;
      var zod_1 = require_lib2();
      var JoiObjectId6 = (message = "valid id") => zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g, { message });
      exports.JoiObjectId = JoiObjectId6;
      exports.getTrips = zod_1.z.object({
        owner_id: (0, exports.JoiObjectId)().nonempty()
      });
      exports.getTripById = zod_1.z.object({
        tripId: (0, exports.JoiObjectId)().nonempty()
      });
      exports.addTrip = zod_1.z.object({
        name: zod_1.z.string().nonempty(),
        description: zod_1.z.string().nonempty(),
        duration: zod_1.z.string().nonempty(),
        weather: zod_1.z.string().nonempty(),
        start_date: zod_1.z.string().nonempty(),
        end_date: zod_1.z.string().nonempty(),
        destination: zod_1.z.string().nonempty(),
        geoJSON: zod_1.z.object({}),
        owner_id: (0, exports.JoiObjectId)().nonempty(),
        packs: zod_1.z.string().nonempty(),
        is_public: zod_1.z.boolean()
      });
      exports.editTrip = zod_1.z.object({
        _id: (0, exports.JoiObjectId)().nonempty(),
        name: zod_1.z.string().nonempty(),
        duration: zod_1.z.string().nonempty(),
        weather: zod_1.z.string().nonempty(),
        start_date: zod_1.z.string().nonempty(),
        end_date: zod_1.z.string().nonempty(),
        destination: zod_1.z.string().nonempty(),
        is_public: zod_1.z.boolean()
      });
      exports.deleteTrip = zod_1.z.object({
        tripId: (0, exports.JoiObjectId)().nonempty()
      });
      exports.queryTrip = zod_1.z.object({
        queryBy: zod_1.z.string()
      });
    }
  });

  // ../packages/validations/dist/validations/objectIdValidator.js
  var require_objectIdValidator = __commonJS({
    "../packages/validations/dist/validations/objectIdValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var zod_1 = __importDefault(require_lib2());
      var objectId = (message = "valid id") => zod_1.default.string().regex(/^[0-9a-fA-F]{24}$/, { message });
      exports.default = objectId;
    }
  });

  // ../packages/validations/dist/validations/packRoutesValidator.js
  var require_packRoutesValidator = __commonJS({
    "../packages/validations/dist/validations/packRoutesValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPublicPacks = exports.duplicatePublicPack = exports.deletePack = exports.editPack = exports.addPack = exports.getPackById = exports.getPacks = void 0;
      var zod_1 = require_lib2();
      var objectIdValidator_1 = __importDefault(require_objectIdValidator());
      exports.getPacks = zod_1.z.object({
        ownerId: (0, objectIdValidator_1.default)(),
        queryBy: zod_1.z.string().optional()
      });
      exports.getPackById = zod_1.z.object({
        packId: (0, objectIdValidator_1.default)()
      });
      exports.addPack = zod_1.z.object({
        name: zod_1.z.string().nonempty(),
        owner_id: (0, objectIdValidator_1.default)(),
        is_public: zod_1.z.boolean()
      });
      exports.editPack = zod_1.z.object({
        _id: (0, objectIdValidator_1.default)(),
        name: zod_1.z.string().nonempty(),
        is_public: zod_1.z.boolean()
      });
      exports.deletePack = zod_1.z.object({
        packId: (0, objectIdValidator_1.default)()
      });
      exports.duplicatePublicPack = zod_1.z.object({
        packId: (0, objectIdValidator_1.default)(),
        ownerId: (0, objectIdValidator_1.default)(),
        items: zod_1.z.array(zod_1.z.object({}))
      });
      exports.getPublicPacks = zod_1.z.object({
        queryBy: zod_1.z.string()
      });
    }
  });

  // ../packages/validations/dist/validations/itemRoutesValidator.js
  var require_itemRoutesValidator = __commonJS({
    "../packages/validations/dist/validations/itemRoutesValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getItemsGlobally = exports.editGlobalItemAsDuplicate = exports.deleteGlobalItem = exports.addGlobalItemToPack = exports.addItemGlobal = exports.deleteItem = exports.editItem = exports.addItem = exports.getItemByName = exports.getItemById = exports.getItems = void 0;
      var zod_1 = require_lib2();
      var objectIdValidator_1 = __importDefault(require_objectIdValidator());
      exports.getItems = zod_1.z.object({
        packId: (0, objectIdValidator_1.default)()
      });
      exports.getItemById = zod_1.z.object({
        _id: (0, objectIdValidator_1.default)()
      });
      exports.getItemByName = zod_1.z.object({
        name: zod_1.z.string()
      });
      exports.addItem = zod_1.z.object({
        name: zod_1.z.string().nonempty(),
        weight: zod_1.z.string().nonempty(),
        quantity: zod_1.z.string().nonempty(),
        unit: zod_1.z.string().nonempty(),
        packId: (0, objectIdValidator_1.default)(),
        type: zod_1.z.string().optional(),
        ownerId: zod_1.z.string().optional()
      });
      exports.editItem = zod_1.z.object({
        _id: (0, objectIdValidator_1.default)(),
        name: zod_1.z.string().nonempty(),
        weight: zod_1.z.string().nonempty(),
        quantity: zod_1.z.string().nonempty(),
        unit: zod_1.z.string().nonempty(),
        type: zod_1.z.string()
      });
      exports.deleteItem = zod_1.z.object({
        itemId: (0, objectIdValidator_1.default)().nonempty(),
        packId: (0, objectIdValidator_1.default)().nonempty()
      });
      exports.addItemGlobal = zod_1.z.object({
        name: zod_1.z.string().nonempty(),
        weight: zod_1.z.string().nonempty(),
        quantity: zod_1.z.string().nonempty(),
        unit: zod_1.z.string().nonempty(),
        type: zod_1.z.string().optional()
      });
      exports.addGlobalItemToPack = zod_1.z.object({
        packId: zod_1.z.string(),
        itemId: zod_1.z.string(),
        ownerId: zod_1.z.string()
      });
      exports.deleteGlobalItem = zod_1.z.object({
        itemId: zod_1.z.string()
      });
      exports.editGlobalItemAsDuplicate = zod_1.z.object({
        itemId: zod_1.z.string(),
        packId: zod_1.z.string(),
        name: zod_1.z.string(),
        weight: zod_1.z.number(),
        quantity: zod_1.z.number(),
        unit: zod_1.z.string(),
        type: zod_1.z.string()
      });
      exports.getItemsGlobally = zod_1.z.object({
        limit: zod_1.z.number(),
        page: zod_1.z.number()
      });
    }
  });

  // ../packages/validations/dist/validations/destinationValidator.js
  var require_destinationValidator = __commonJS({
    "../packages/validations/dist/validations/destinationValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getDestinationByid = void 0;
      var zod_1 = require_lib2();
      var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
      exports.getDestinationByid = zod_1.z.object({
        id: zod_1.z.string()
      });
    }
  });

  // ../packages/validations/dist/validations/osmValidators.js
  var require_osmValidators = __commonJS({
    "../packages/validations/dist/validations/osmValidators.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.postSingleGeoJSON = exports.getTrailsOSM = exports.getPhotonResults = exports.getPhotonDetails = exports.getParksOSM = exports.getOsm = void 0;
      var zod_1 = require_lib2();
      var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
      exports.getOsm = zod_1.z.object({
        activityType: zod_1.z.string(),
        startPoint: zod_1.z.object({ latitude: zod_1.z.number(), longitude: zod_1.z.number() }),
        endPoint: zod_1.z.object({ latitude: zod_1.z.number(), longitude: zod_1.z.number() })
      });
      exports.getParksOSM = zod_1.z.object({
        lat: zod_1.z.number(),
        lon: zod_1.z.number(),
        radius: zod_1.z.number().optional()
      });
      exports.getPhotonDetails = zod_1.z.object({
        id: zod_1.z.union([zod_1.z.string(), zod_1.z.number()]),
        type: zod_1.z.string()
      });
      exports.getPhotonResults = zod_1.z.object({
        searchString: zod_1.z.string()
      });
      exports.getTrailsOSM = zod_1.z.object({
        lat: zod_1.z.number(),
        lon: zod_1.z.number(),
        radius: zod_1.z.number().optional()
      });
      exports.postSingleGeoJSON = zod_1.z.object({
        geojson: zod_1.z.any()
      });
    }
  });

  // ../packages/validations/dist/validations/parksRouteValidator.js
  var require_parksRouteValidator = __commonJS({
    "../packages/validations/dist/validations/parksRouteValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getParks = void 0;
      var zod_1 = require_lib2();
      var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
      exports.getParks = zod_1.z.object({
        abbrState: zod_1.z.string()
      });
    }
  });

  // ../packages/validations/dist/validations/trailsRouteValidator.js
  var require_trailsRouteValidator = __commonJS({
    "../packages/validations/dist/validations/trailsRouteValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTrails = void 0;
      var zod_1 = require_lib2();
      var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
      exports.getTrails = zod_1.z.object({
        administrative_area_level_1: zod_1.z.string(),
        country: zod_1.z.string(),
        locality: zod_1.z.string(),
        latitude: zod_1.z.number(),
        longitude: zod_1.z.number()
      });
    }
  });

  // ../packages/validations/dist/validations/openAIRoutesValidator.js
  var require_openAIRoutesValidator = __commonJS({
    "../packages/validations/dist/validations/openAIRoutesValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getUserChats = exports.getAIResponse = void 0;
      var zod_1 = require_lib2();
      exports.getAIResponse = zod_1.z.object({
        userId: zod_1.z.string(),
        conversationId: zod_1.z.string(),
        userInput: zod_1.z.string()
      });
      exports.getUserChats = zod_1.z.object({
        userId: zod_1.z.string()
      });
    }
  });

  // ../packages/validations/dist/validations/extrasValidator.js
  var require_extrasValidator = __commonJS({
    "../packages/validations/dist/validations/extrasValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.handlePasswordReset = exports.AddressArray = void 0;
      var zod_1 = require_lib2();
      var JoiObjectId6 = zod_1.z.string().regex(/^[0-9a-fA-F]{24}$/g);
      exports.AddressArray = zod_1.z.object({
        addressArray: zod_1.z.string()
      });
      exports.handlePasswordReset = zod_1.z.object({
        token: zod_1.z.string()
      });
    }
  });

  // ../packages/validations/dist/validations/templateRouteValidator.js
  var require_templateRouteValidator = __commonJS({
    "../packages/validations/dist/validations/templateRouteValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTemplateById = exports.deleteTemplate = exports.editTemplate = exports.addTemplate = void 0;
      var zod_1 = require_lib2();
      exports.addTemplate = zod_1.z.object({
        type: zod_1.z.string(),
        templateId: zod_1.z.string(),
        isGlobalTemplate: zod_1.z.boolean(),
        createdBy: zod_1.z.string()
      });
      exports.editTemplate = zod_1.z.object({
        templateId: zod_1.z.string(),
        type: zod_1.z.string(),
        isGlobalTemplate: zod_1.z.boolean()
      });
      exports.deleteTemplate = zod_1.z.object({
        templateId: zod_1.z.string()
      });
      exports.getTemplateById = zod_1.z.object({
        templateId: zod_1.z.string()
      });
    }
  });

  // ../packages/validations/dist/validations/weatherRoutesValidator.js
  var require_weatherRoutesValidator = __commonJS({
    "../packages/validations/dist/validations/weatherRoutesValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getWeather = exports.getWeatherWeek = void 0;
      var zod_1 = require_lib2();
      exports.getWeatherWeek = zod_1.z.object({
        lat: zod_1.z.number(),
        lon: zod_1.z.number()
      });
      exports.getWeather = zod_1.z.object({
        lat: zod_1.z.number(),
        lon: zod_1.z.number()
      });
    }
  });

  // ../packages/validations/dist/validations/zodParser.js
  var require_zodParser = __commonJS({
    "../packages/validations/dist/validations/zodParser.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.zodParser = void 0;
      var zodParser = (schema, input, next) => {
        schema.parse(input);
        next();
      };
      exports.zodParser = zodParser;
    }
  });

  // ../packages/validations/dist/validations/roleValidator.js
  var require_roleValidator = __commonJS({
    "../packages/validations/dist/validations/roleValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RoleSchema = void 0;
      var zod_1 = require_lib2();
      exports.RoleSchema = zod_1.z.union([zod_1.z.literal("user"), zod_1.z.literal("admin")]);
    }
  });

  // ../packages/validations/dist/validations/authTokenValidator.js
  var require_authTokenValidator = __commonJS({
    "../packages/validations/dist/validations/authTokenValidator.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.googleSignin = exports.TokenSchema = void 0;
      var zod_1 = require_lib2();
      exports.TokenSchema = zod_1.z.object({
        _id: zod_1.z.string()
      });
      exports.googleSignin = zod_1.z.object({
        idToken: zod_1.z.string().nonempty()
      });
    }
  });

  // ../packages/validations/dist/validations/index.js
  var require_validations = __commonJS({
    "../packages/validations/dist/validations/index.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m2[k2];
      });
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
            __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_userRoutesValidator(), exports);
      __exportStar(require_tripRoutesValidator(), exports);
      __exportStar(require_packRoutesValidator(), exports);
      __exportStar(require_itemRoutesValidator(), exports);
      __exportStar(require_destinationValidator(), exports);
      __exportStar(require_osmValidators(), exports);
      __exportStar(require_parksRouteValidator(), exports);
      __exportStar(require_trailsRouteValidator(), exports);
      __exportStar(require_openAIRoutesValidator(), exports);
      __exportStar(require_extrasValidator(), exports);
      __exportStar(require_templateRouteValidator(), exports);
      __exportStar(require_weatherRoutesValidator(), exports);
      __exportStar(require_zodParser(), exports);
      __exportStar(require_roleValidator(), exports);
      __exportStar(require_authTokenValidator(), exports);
      __exportStar(require_objectIdValidator(), exports);
    }
  });

  // ../packages/validations/dist/index.js
  var require_dist = __commonJS({
    "../packages/validations/dist/index.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m2[k2];
      });
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
            __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_validations(), exports);
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/bind.js
  var require_bind = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/bind.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = function bind2(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i2 = 0; i2 < args.length; i2++) {
            args[i2] = arguments[i2];
          }
          return fn.apply(thisArg, args);
        };
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/utils.js
  var require_utils = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/utils.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var bind2 = require_bind();
      var toString6 = Object.prototype.toString;
      function isArray4(val) {
        return Array.isArray(val);
      }
      function isUndefined3(val) {
        return typeof val === "undefined";
      }
      function isBuffer5(val) {
        return val !== null && !isUndefined3(val) && val.constructor !== null && !isUndefined3(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      function isArrayBuffer2(val) {
        return toString6.call(val) === "[object ArrayBuffer]";
      }
      function isFormData2(val) {
        return toString6.call(val) === "[object FormData]";
      }
      function isArrayBufferView2(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer2(val.buffer);
        }
        return result;
      }
      function isString3(val) {
        return typeof val === "string";
      }
      function isNumber3(val) {
        return typeof val === "number";
      }
      function isObject4(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject3(val) {
        if (toString6.call(val) !== "[object Object]") {
          return false;
        }
        var prototype3 = Object.getPrototypeOf(val);
        return prototype3 === null || prototype3 === Object.prototype;
      }
      function isDate3(val) {
        return toString6.call(val) === "[object Date]";
      }
      function isFile2(val) {
        return toString6.call(val) === "[object File]";
      }
      function isBlob2(val) {
        return toString6.call(val) === "[object Blob]";
      }
      function isFunction3(val) {
        return toString6.call(val) === "[object Function]";
      }
      function isStream2(val) {
        return isObject4(val) && isFunction3(val.pipe);
      }
      function isURLSearchParams2(val) {
        return toString6.call(val) === "[object URLSearchParams]";
      }
      function trim2(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv2() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach3(obj, fn) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray4(obj)) {
          for (var i2 = 0, l = obj.length; i2 < l; i2++) {
            fn.call(null, obj[i2], i2, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge2() {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject3(result[key]) && isPlainObject3(val)) {
            result[key] = merge2(result[key], val);
          } else if (isPlainObject3(val)) {
            result[key] = merge2({}, val);
          } else if (isArray4(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
          forEach3(arguments[i2], assignValue);
        }
        return result;
      }
      function extend2(a4, b2, thisArg) {
        forEach3(b2, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a4[key] = bind2(val, thisArg);
          } else {
            a4[key] = val;
          }
        });
        return a4;
      }
      function stripBOM2(content) {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      module.exports = {
        isArray: isArray4,
        isArrayBuffer: isArrayBuffer2,
        isBuffer: isBuffer5,
        isFormData: isFormData2,
        isArrayBufferView: isArrayBufferView2,
        isString: isString3,
        isNumber: isNumber3,
        isObject: isObject4,
        isPlainObject: isPlainObject3,
        isUndefined: isUndefined3,
        isDate: isDate3,
        isFile: isFile2,
        isBlob: isBlob2,
        isFunction: isFunction3,
        isStream: isStream2,
        isURLSearchParams: isURLSearchParams2,
        isStandardBrowserEnv: isStandardBrowserEnv2,
        forEach: forEach3,
        merge: merge2,
        extend: extend2,
        trim: trim2,
        stripBOM: stripBOM2
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/buildURL.js
  var require_buildURL = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      function encode3(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      module.exports = function buildURL2(url, params, paramsSerializer) {
        if (!params) {
          return url;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode3(key) + "=" + encode3(v));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/core/InterceptorManager.js
  var require_InterceptorManager = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      function InterceptorManager2() {
        this.handlers = [];
      }
      InterceptorManager2.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager2.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager2.prototype.forEach = function forEach3(fn) {
        utils.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn(h2);
          }
        });
      };
      module.exports = InterceptorManager2;
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/normalizeHeaderName.js
  var require_normalizeHeaderName = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/core/enhanceError.js
  var require_enhanceError = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/core/enhanceError.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = function enhanceError(error, config4, code, request, response) {
        error.config = config4;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON4() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        };
        return error;
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/defaults/transitional.js
  var require_transitional = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/defaults/transitional.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/core/createError.js
  var require_createError = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/core/createError.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var enhanceError = require_enhanceError();
      module.exports = function createError(message, config4, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config4, code, request, response);
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/core/settle.js
  var require_settle = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/core/settle.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var createError = require_createError();
      module.exports = function settle2(resolve2, reject, response) {
        var validateStatus2 = response.config.validateStatus;
        if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
          resolve2(response);
        } else {
          reject(createError(
            "Request failed with status code " + response.status,
            response.config,
            null,
            response.request,
            response
          ));
        }
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/cookies.js
  var require_cookies = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? (
        // Standard browser envs support document.cookie
        function standardBrowserEnv3() {
          return {
            write: function write4(name, value, expires, path, domain2, secure) {
              var cookie = [];
              cookie.push(name + "=" + encodeURIComponent(value));
              if (utils.isNumber(expires)) {
                cookie.push("expires=" + new Date(expires).toGMTString());
              }
              if (utils.isString(path)) {
                cookie.push("path=" + path);
              }
              if (utils.isString(domain2)) {
                cookie.push("domain=" + domain2);
              }
              if (secure === true) {
                cookie.push("secure");
              }
              document.cookie = cookie.join("; ");
            },
            read: function read2(name) {
              var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
              return match ? decodeURIComponent(match[3]) : null;
            },
            remove: function remove(name) {
              this.write(name, "", Date.now() - 864e5);
            }
          };
        }()
      ) : (
        // Non standard browser env (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv3() {
          return {
            write: function write4() {
            },
            read: function read2() {
              return null;
            },
            remove: function remove() {
            }
          };
        }()
      );
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/isAbsoluteURL.js
  var require_isAbsoluteURL = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = function isAbsoluteURL2(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/combineURLs.js
  var require_combineURLs = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = function combineURLs2(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/core/buildFullPath.js
  var require_buildFullPath = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var isAbsoluteURL2 = require_isAbsoluteURL();
      var combineURLs2 = require_combineURLs();
      module.exports = function buildFullPath2(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL2(requestedURL)) {
          return combineURLs2(baseURL, requestedURL);
        }
        return requestedURL;
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/parseHeaders.js
  var require_parseHeaders = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      var ignoreDuplicateOf2 = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i2;
        if (!headers) {
          return parsed;
        }
        utils.forEach(headers.split("\n"), function parser(line) {
          i2 = line.indexOf(":");
          key = utils.trim(line.substr(0, i2)).toLowerCase();
          val = utils.trim(line.substr(i2 + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf2.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/isURLSameOrigin.js
  var require_isURLSameOrigin = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? (
        // Standard browser envs have full support of the APIs needed to test
        // whether the request URL is of the same origin as current location.
        function standardBrowserEnv3() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement("a");
          var originURL;
          function resolveURL(url) {
            var href = url;
            if (msie) {
              urlParsingNode.setAttribute("href", href);
              href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute("href", href);
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            };
          }
          originURL = resolveURL(window.location.href);
          return function isURLSameOrigin(requestURL) {
            var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
            return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
          };
        }()
      ) : (
        // Non standard browser envs (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv3() {
          return function isURLSameOrigin() {
            return true;
          };
        }()
      );
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/cancel/Cancel.js
  var require_Cancel = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      function Cancel2(message) {
        this.message = message;
      }
      Cancel2.prototype.toString = function toString6() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel2.prototype.__CANCEL__ = true;
      module.exports = Cancel2;
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/adapters/xhr.js
  var require_xhr = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      var settle2 = require_settle();
      var cookies = require_cookies();
      var buildURL2 = require_buildURL();
      var buildFullPath2 = require_buildFullPath();
      var parseHeaders = require_parseHeaders();
      var isURLSameOrigin = require_isURLSameOrigin();
      var createError = require_createError();
      var transitionalDefaults = require_transitional();
      var Cancel2 = require_Cancel();
      module.exports = function xhrAdapter(config4) {
        return new Promise(function dispatchXhrRequest(resolve2, reject) {
          var requestData = config4.data;
          var requestHeaders = config4.headers;
          var responseType = config4.responseType;
          var onCanceled;
          function done2() {
            if (config4.cancelToken) {
              config4.cancelToken.unsubscribe(onCanceled);
            }
            if (config4.signal) {
              config4.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config4.auth) {
            var username = config4.auth.username || "";
            var password = config4.auth.password ? unescape(encodeURIComponent(config4.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath2(config4.baseURL, config4.url);
          request.open(config4.method.toUpperCase(), buildURL2(fullPath, config4.params, config4.paramsSerializer), true);
          request.timeout = config4.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config: config4,
              request
            };
            settle2(function _resolve(value) {
              resolve2(value);
              done2();
            }, function _reject(err) {
              reject(err);
              done2();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError("Request aborted", config4, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError("Network Error", config4, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config4.timeout ? "timeout of " + config4.timeout + "ms exceeded" : "timeout exceeded";
            var transitional2 = config4.transitional || transitionalDefaults;
            if (config4.timeoutErrorMessage) {
              timeoutErrorMessage = config4.timeoutErrorMessage;
            }
            reject(createError(
              timeoutErrorMessage,
              config4,
              transitional2.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              request
            ));
            request = null;
          };
          if (utils.isStandardBrowserEnv()) {
            var xsrfValue = (config4.withCredentials || isURLSameOrigin(fullPath)) && config4.xsrfCookieName ? cookies.read(config4.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config4.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils.isUndefined(config4.withCredentials)) {
            request.withCredentials = !!config4.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config4.responseType;
          }
          if (typeof config4.onDownloadProgress === "function") {
            request.addEventListener("progress", config4.onDownloadProgress);
          }
          if (typeof config4.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config4.onUploadProgress);
          }
          if (config4.cancelToken || config4.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new Cancel2("canceled") : cancel);
              request.abort();
              request = null;
            };
            config4.cancelToken && config4.cancelToken.subscribe(onCanceled);
            if (config4.signal) {
              config4.signal.aborted ? onCanceled() : config4.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/defaults/index.js
  var require_defaults = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/defaults/index.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      var normalizeHeaderName = require_normalizeHeaderName();
      var enhanceError = require_enhanceError();
      var transitionalDefaults = require_transitional();
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = require_xhr();
        } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
          adapter = require_xhr();
        }
        return adapter;
      }
      function stringifySafely2(rawValue, parser, encoder) {
        if (utils.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils.trim(rawValue);
          } catch (e8) {
            if (e8.name !== "SyntaxError") {
              throw e8;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      var defaults2 = {
        transitional: transitionalDefaults,
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest2(data, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
            return data;
          }
          if (utils.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data.toString();
          }
          if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return stringifySafely2(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse2(data) {
          var transitional2 = this.transitional || defaults2.transitional;
          var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
          var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
            try {
              return JSON.parse(data);
            } catch (e8) {
              if (strictJSONParsing) {
                if (e8.name === "SyntaxError") {
                  throw enhanceError(e8, this, "E_JSON_PARSE");
                }
                throw e8;
              }
            }
          }
          return data;
        }],
        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus2(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*"
          }
        }
      };
      utils.forEach(["delete", "get", "head"], function forEachMethodNoData2(method) {
        defaults2.headers[method] = {};
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
        defaults2.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });
      module.exports = defaults2;
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/core/transformData.js
  var require_transformData = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/core/transformData.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      var defaults2 = require_defaults();
      module.exports = function transformData2(data, headers, fns) {
        var context = this || defaults2;
        utils.forEach(fns, function transform(fn) {
          data = fn.call(context, data, headers);
        });
        return data;
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/cancel/isCancel.js
  var require_isCancel = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = function isCancel3(value) {
        return !!(value && value.__CANCEL__);
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/core/dispatchRequest.js
  var require_dispatchRequest = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      var transformData2 = require_transformData();
      var isCancel3 = require_isCancel();
      var defaults2 = require_defaults();
      var Cancel2 = require_Cancel();
      function throwIfCancellationRequested2(config4) {
        if (config4.cancelToken) {
          config4.cancelToken.throwIfRequested();
        }
        if (config4.signal && config4.signal.aborted) {
          throw new Cancel2("canceled");
        }
      }
      module.exports = function dispatchRequest2(config4) {
        throwIfCancellationRequested2(config4);
        config4.headers = config4.headers || {};
        config4.data = transformData2.call(
          config4,
          config4.data,
          config4.headers,
          config4.transformRequest
        );
        config4.headers = utils.merge(
          config4.headers.common || {},
          config4.headers[config4.method] || {},
          config4.headers
        );
        utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          function cleanHeaderConfig(method) {
            delete config4.headers[method];
          }
        );
        var adapter = config4.adapter || defaults2.adapter;
        return adapter(config4).then(function onAdapterResolution(response) {
          throwIfCancellationRequested2(config4);
          response.data = transformData2.call(
            config4,
            response.data,
            response.headers,
            config4.transformResponse
          );
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel3(reason)) {
            throwIfCancellationRequested2(config4);
            if (reason && reason.response) {
              reason.response.data = transformData2.call(
                config4,
                reason.response.data,
                reason.response.headers,
                config4.transformResponse
              );
            }
          }
          return Promise.reject(reason);
        });
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/core/mergeConfig.js
  var require_mergeConfig = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      module.exports = function mergeConfig3(config1, config22) {
        config22 = config22 || {};
        var config4 = {};
        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config22[prop])) {
            return getMergedValue(config1[prop], config22[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function valueFromConfig2(prop) {
          if (!utils.isUndefined(config22[prop])) {
            return getMergedValue(void 0, config22[prop]);
          }
        }
        function defaultToConfig2(prop) {
          if (!utils.isUndefined(config22[prop])) {
            return getMergedValue(void 0, config22[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function mergeDirectKeys(prop) {
          if (prop in config22) {
            return getMergedValue(config1[prop], config22[prop]);
          } else if (prop in config1) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        var mergeMap = {
          "url": valueFromConfig2,
          "method": valueFromConfig2,
          "data": valueFromConfig2,
          "baseURL": defaultToConfig2,
          "transformRequest": defaultToConfig2,
          "transformResponse": defaultToConfig2,
          "paramsSerializer": defaultToConfig2,
          "timeout": defaultToConfig2,
          "timeoutMessage": defaultToConfig2,
          "withCredentials": defaultToConfig2,
          "adapter": defaultToConfig2,
          "responseType": defaultToConfig2,
          "xsrfCookieName": defaultToConfig2,
          "xsrfHeaderName": defaultToConfig2,
          "onUploadProgress": defaultToConfig2,
          "onDownloadProgress": defaultToConfig2,
          "decompress": defaultToConfig2,
          "maxContentLength": defaultToConfig2,
          "maxBodyLength": defaultToConfig2,
          "transport": defaultToConfig2,
          "httpAgent": defaultToConfig2,
          "httpsAgent": defaultToConfig2,
          "cancelToken": defaultToConfig2,
          "socketPath": defaultToConfig2,
          "responseEncoding": defaultToConfig2,
          "validateStatus": mergeDirectKeys
        };
        utils.forEach(Object.keys(config1).concat(Object.keys(config22)), function computeConfigValue(prop) {
          var merge2 = mergeMap[prop] || mergeDeepProperties;
          var configValue = merge2(prop);
          utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config4[prop] = configValue);
        });
        return config4;
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/env/data.js
  var require_data = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/env/data.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = {
        "version": "0.26.1"
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/validator.js
  var require_validator = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/validator.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var VERSION3 = require_data().version;
      var validators8 = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i2) {
        validators8[type2] = function validator3(thing) {
          return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
        };
      });
      var deprecatedWarnings2 = {};
      validators8.transitional = function transitional2(validator3, version3, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION3 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return function(value, opt, opts) {
          if (validator3 === false) {
            throw new Error(formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")));
          }
          if (version3 && !deprecatedWarnings2[opt]) {
            deprecatedWarnings2[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version3 + " and will be removed in the near future"
              )
            );
          }
          return validator3 ? validator3(value, opt, opts) : true;
        };
      };
      function assertOptions2(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        var keys2 = Object.keys(options);
        var i2 = keys2.length;
        while (i2-- > 0) {
          var opt = keys2[i2];
          var validator3 = schema[opt];
          if (validator3) {
            var value = options[opt];
            var result = value === void 0 || validator3(value, opt, options);
            if (result !== true) {
              throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
          }
        }
      }
      module.exports = {
        assertOptions: assertOptions2,
        validators: validators8
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/core/Axios.js
  var require_Axios = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/core/Axios.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      var buildURL2 = require_buildURL();
      var InterceptorManager2 = require_InterceptorManager();
      var dispatchRequest2 = require_dispatchRequest();
      var mergeConfig3 = require_mergeConfig();
      var validator3 = require_validator();
      var validators8 = validator3.validators;
      function Axios3(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager2(),
          response: new InterceptorManager2()
        };
      }
      Axios3.prototype.request = function request(configOrUrl, config4) {
        if (typeof configOrUrl === "string") {
          config4 = config4 || {};
          config4.url = configOrUrl;
        } else {
          config4 = configOrUrl || {};
        }
        config4 = mergeConfig3(this.defaults, config4);
        if (config4.method) {
          config4.method = config4.method.toLowerCase();
        } else if (this.defaults.method) {
          config4.method = this.defaults.method.toLowerCase();
        } else {
          config4.method = "get";
        }
        var transitional2 = config4.transitional;
        if (transitional2 !== void 0) {
          validator3.assertOptions(transitional2, {
            silentJSONParsing: validators8.transitional(validators8.boolean),
            forcedJSONParsing: validators8.transitional(validators8.boolean),
            clarifyTimeoutError: validators8.transitional(validators8.boolean)
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config4) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest2, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config4);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config4;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest2(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios3.prototype.getUri = function getUri(config4) {
        config4 = mergeConfig3(this.defaults, config4);
        return buildURL2(config4.url, config4.params, config4.paramsSerializer).replace(/^\?/, "");
      };
      utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
        Axios3.prototype[method] = function(url, config4) {
          return this.request(mergeConfig3(config4 || {}, {
            method,
            url,
            data: (config4 || {}).data
          }));
        };
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
        Axios3.prototype[method] = function(url, data, config4) {
          return this.request(mergeConfig3(config4 || {}, {
            method,
            url,
            data
          }));
        };
      });
      module.exports = Axios3;
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/cancel/CancelToken.js
  var require_CancelToken = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var Cancel2 = require_Cancel();
      function CancelToken3(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        var token = this;
        this.promise.then(function(cancel) {
          if (!token._listeners)
            return;
          var i2;
          var l = token._listeners.length;
          for (i2 = 0; i2 < l; i2++) {
            token._listeners[i2](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve2) {
            token.subscribe(resolve2);
            _resolve = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new Cancel2(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken3.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken3.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken3.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      };
      CancelToken3.source = function source() {
        var cancel;
        var token = new CancelToken3(function executor(c2) {
          cancel = c2;
        });
        return {
          token,
          cancel
        };
      };
      module.exports = CancelToken3;
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/spread.js
  var require_spread = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/spread.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = function spread3(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/helpers/isAxiosError.js
  var require_isAxiosError = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      module.exports = function isAxiosError3(payload) {
        return utils.isObject(payload) && payload.isAxiosError === true;
      };
    }
  });

  // ../node_modules/openai/node_modules/axios/lib/axios.js
  var require_axios = __commonJS({
    "../node_modules/openai/node_modules/axios/lib/axios.js"(exports, module) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var utils = require_utils();
      var bind2 = require_bind();
      var Axios3 = require_Axios();
      var mergeConfig3 = require_mergeConfig();
      var defaults2 = require_defaults();
      function createInstance2(defaultConfig) {
        var context = new Axios3(defaultConfig);
        var instance = bind2(Axios3.prototype.request, context);
        utils.extend(instance, Axios3.prototype, context);
        utils.extend(instance, context);
        instance.create = function create(instanceConfig) {
          return createInstance2(mergeConfig3(defaultConfig, instanceConfig));
        };
        return instance;
      }
      var axios2 = createInstance2(defaults2);
      axios2.Axios = Axios3;
      axios2.Cancel = require_Cancel();
      axios2.CancelToken = require_CancelToken();
      axios2.isCancel = require_isCancel();
      axios2.VERSION = require_data().version;
      axios2.all = function all3(promises) {
        return Promise.all(promises);
      };
      axios2.spread = require_spread();
      axios2.isAxiosError = require_isAxiosError();
      module.exports = axios2;
      module.exports.default = axios2;
    }
  });

  // ../node_modules/openai/node_modules/axios/index.js
  var require_axios2 = __commonJS({
    "../node_modules/openai/node_modules/axios/index.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = require_axios();
    }
  });

  // ../node_modules/openai/dist/base.js
  var require_base = __commonJS({
    "../node_modules/openai/dist/base.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;
      var axios_1 = require_axios2();
      exports.BASE_PATH = "https://api.openai.com/v1".replace(/\/+$/, "");
      exports.COLLECTION_FORMATS = {
        csv: ",",
        ssv: " ",
        tsv: "	",
        pipes: "|"
      };
      var BaseAPI = class {
        constructor(configuration, basePath = exports.BASE_PATH, axios2 = axios_1.default) {
          this.basePath = basePath;
          this.axios = axios2;
          if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
          }
        }
      };
      exports.BaseAPI = BaseAPI;
      var RequiredError = class extends Error {
        constructor(field, msg) {
          super(msg);
          this.field = field;
          this.name = "RequiredError";
        }
      };
      exports.RequiredError = RequiredError;
    }
  });

  // ../node_modules/openai/dist/common.js
  var require_common = __commonJS({
    "../node_modules/openai/dist/common.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e8) {
              reject(e8);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e8) {
              reject(e8);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;
      var base_1 = require_base();
      exports.DUMMY_BASE_URL = "https://example.com";
      exports.assertParamExists = function(functionName, paramName, paramValue) {
        if (paramValue === null || paramValue === void 0) {
          throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
        }
      };
      exports.setApiKeyToObject = function(object, keyParamName, configuration) {
        return __awaiter(this, void 0, void 0, function* () {
          if (configuration && configuration.apiKey) {
            const localVarApiKeyValue = typeof configuration.apiKey === "function" ? yield configuration.apiKey(keyParamName) : yield configuration.apiKey;
            object[keyParamName] = localVarApiKeyValue;
          }
        });
      };
      exports.setBasicAuthToObject = function(object, configuration) {
        if (configuration && (configuration.username || configuration.password)) {
          object["auth"] = { username: configuration.username, password: configuration.password };
        }
      };
      exports.setBearerAuthToObject = function(object, configuration) {
        return __awaiter(this, void 0, void 0, function* () {
          if (configuration && configuration.accessToken) {
            const accessToken = typeof configuration.accessToken === "function" ? yield configuration.accessToken() : yield configuration.accessToken;
            object["Authorization"] = "Bearer " + accessToken;
          }
        });
      };
      exports.setOAuthToObject = function(object, name, scopes, configuration) {
        return __awaiter(this, void 0, void 0, function* () {
          if (configuration && configuration.accessToken) {
            const localVarAccessTokenValue = typeof configuration.accessToken === "function" ? yield configuration.accessToken(name, scopes) : yield configuration.accessToken;
            object["Authorization"] = "Bearer " + localVarAccessTokenValue;
          }
        });
      };
      function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
        if (parameter == null)
          return;
        if (typeof parameter === "object") {
          if (Array.isArray(parameter)) {
            parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
          } else {
            Object.keys(parameter).forEach((currentKey) => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== "" ? "." : ""}${currentKey}`));
          }
        } else {
          if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
          } else {
            urlSearchParams.set(key, parameter);
          }
        }
      }
      exports.setSearchParams = function(url, ...objects) {
        const searchParams = new URLSearchParams(url.search);
        setFlattenedQueryParams(searchParams, objects);
        url.search = searchParams.toString();
      };
      exports.serializeDataIfNeeded = function(value, requestOptions, configuration) {
        const nonString = typeof value !== "string";
        const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
        return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
      };
      exports.toPathString = function(url) {
        return url.pathname + url.search + url.hash;
      };
      exports.createRequestFunction = function(axiosArgs, globalAxios, BASE_PATH, configuration) {
        return (axios2 = globalAxios, basePath = BASE_PATH) => {
          const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });
          return axios2.request(axiosRequestArgs);
        };
      };
    }
  });

  // ../node_modules/openai/dist/api.js
  var require_api = __commonJS({
    "../node_modules/openai/dist/api.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e8) {
              reject(e8);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e8) {
              reject(e8);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OpenAIApi = exports.OpenAIApiFactory = exports.OpenAIApiFp = exports.OpenAIApiAxiosParamCreator = exports.CreateImageRequestResponseFormatEnum = exports.CreateImageRequestSizeEnum = exports.ChatCompletionResponseMessageRoleEnum = exports.ChatCompletionRequestMessageRoleEnum = void 0;
      var axios_1 = require_axios2();
      var common_1 = require_common();
      var base_1 = require_base();
      exports.ChatCompletionRequestMessageRoleEnum = {
        System: "system",
        User: "user",
        Assistant: "assistant",
        Function: "function"
      };
      exports.ChatCompletionResponseMessageRoleEnum = {
        System: "system",
        User: "user",
        Assistant: "assistant",
        Function: "function"
      };
      exports.CreateImageRequestSizeEnum = {
        _256x256: "256x256",
        _512x512: "512x512",
        _1024x1024: "1024x1024"
      };
      exports.CreateImageRequestResponseFormatEnum = {
        Url: "url",
        B64Json: "b64_json"
      };
      exports.OpenAIApiAxiosParamCreator = function(configuration) {
        return {
          /**
           *
           * @summary Immediately cancel a fine-tune job.
           * @param {string} fineTuneId The ID of the fine-tune job to cancel
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          cancelFineTune: (fineTuneId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("cancelFineTune", "fineTuneId", fineTuneId);
            const localVarPath = `/fine-tunes/{fine_tune_id}/cancel`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
           * @param {CreateAnswerRequest} createAnswerRequest
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          createAnswer: (createAnswerRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createAnswer", "createAnswerRequest", createAnswerRequest);
            const localVarPath = `/answers`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createAnswerRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Creates a model response for the given chat conversation.
           * @param {CreateChatCompletionRequest} createChatCompletionRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createChatCompletion: (createChatCompletionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createChatCompletion", "createChatCompletionRequest", createChatCompletionRequest);
            const localVarPath = `/chat/completions`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createChatCompletionRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
           * @param {CreateClassificationRequest} createClassificationRequest
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          createClassification: (createClassificationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createClassification", "createClassificationRequest", createClassificationRequest);
            const localVarPath = `/classifications`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createClassificationRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Creates a completion for the provided prompt and parameters.
           * @param {CreateCompletionRequest} createCompletionRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createCompletion: (createCompletionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createCompletion", "createCompletionRequest", createCompletionRequest);
            const localVarPath = `/completions`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createCompletionRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Creates a new edit for the provided input, instruction, and parameters.
           * @param {CreateEditRequest} createEditRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createEdit: (createEditRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createEdit", "createEditRequest", createEditRequest);
            const localVarPath = `/edits`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createEditRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Creates an embedding vector representing the input text.
           * @param {CreateEmbeddingRequest} createEmbeddingRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createEmbedding: (createEmbeddingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createEmbedding", "createEmbeddingRequest", createEmbeddingRequest);
            const localVarPath = `/embeddings`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createEmbeddingRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
           * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
           * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createFile: (file, purpose, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createFile", "file", file);
            common_1.assertParamExists("createFile", "purpose", purpose);
            const localVarPath = `/files`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (file !== void 0) {
              localVarFormParams.append("file", file);
            }
            if (purpose !== void 0) {
              localVarFormParams.append("purpose", purpose);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
           * @param {CreateFineTuneRequest} createFineTuneRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createFineTune: (createFineTuneRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createFineTune", "createFineTuneRequest", createFineTuneRequest);
            const localVarPath = `/fine-tunes`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createFineTuneRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Creates an image given a prompt.
           * @param {CreateImageRequest} createImageRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createImage: (createImageRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createImage", "createImageRequest", createImageRequest);
            const localVarPath = `/images/generations`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createImageRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Creates an edited or extended image given an original image and a prompt.
           * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
           * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
           * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
           * @param {number} [n] The number of images to generate. Must be between 1 and 10.
           * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
           * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
           * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createImageEdit: (image, prompt, mask, n3, size, responseFormat, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createImageEdit", "image", image);
            common_1.assertParamExists("createImageEdit", "prompt", prompt);
            const localVarPath = `/images/edits`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (image !== void 0) {
              localVarFormParams.append("image", image);
            }
            if (mask !== void 0) {
              localVarFormParams.append("mask", mask);
            }
            if (prompt !== void 0) {
              localVarFormParams.append("prompt", prompt);
            }
            if (n3 !== void 0) {
              localVarFormParams.append("n", n3);
            }
            if (size !== void 0) {
              localVarFormParams.append("size", size);
            }
            if (responseFormat !== void 0) {
              localVarFormParams.append("response_format", responseFormat);
            }
            if (user !== void 0) {
              localVarFormParams.append("user", user);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Creates a variation of a given image.
           * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
           * @param {number} [n] The number of images to generate. Must be between 1 and 10.
           * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
           * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
           * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createImageVariation: (image, n3, size, responseFormat, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createImageVariation", "image", image);
            const localVarPath = `/images/variations`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (image !== void 0) {
              localVarFormParams.append("image", image);
            }
            if (n3 !== void 0) {
              localVarFormParams.append("n", n3);
            }
            if (size !== void 0) {
              localVarFormParams.append("size", size);
            }
            if (responseFormat !== void 0) {
              localVarFormParams.append("response_format", responseFormat);
            }
            if (user !== void 0) {
              localVarFormParams.append("user", user);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Classifies if text violates OpenAI\'s Content Policy
           * @param {CreateModerationRequest} createModerationRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createModeration: (createModerationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createModeration", "createModerationRequest", createModerationRequest);
            const localVarPath = `/moderations`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createModerationRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
           * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
           * @param {CreateSearchRequest} createSearchRequest
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          createSearch: (engineId, createSearchRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createSearch", "engineId", engineId);
            common_1.assertParamExists("createSearch", "createSearchRequest", createSearchRequest);
            const localVarPath = `/engines/{engine_id}/search`.replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createSearchRequest, localVarRequestOptions, configuration);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Transcribes audio into the input language.
           * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
           * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
           * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
           * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
           * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
           * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createTranscription: (file, model, prompt, responseFormat, temperature, language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createTranscription", "file", file);
            common_1.assertParamExists("createTranscription", "model", model);
            const localVarPath = `/audio/transcriptions`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (file !== void 0) {
              localVarFormParams.append("file", file);
            }
            if (model !== void 0) {
              localVarFormParams.append("model", model);
            }
            if (prompt !== void 0) {
              localVarFormParams.append("prompt", prompt);
            }
            if (responseFormat !== void 0) {
              localVarFormParams.append("response_format", responseFormat);
            }
            if (temperature !== void 0) {
              localVarFormParams.append("temperature", temperature);
            }
            if (language !== void 0) {
              localVarFormParams.append("language", language);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Translates audio into into English.
           * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
           * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
           * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
           * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
           * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createTranslation: (file, model, prompt, responseFormat, temperature, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("createTranslation", "file", file);
            common_1.assertParamExists("createTranslation", "model", model);
            const localVarPath = `/audio/translations`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (file !== void 0) {
              localVarFormParams.append("file", file);
            }
            if (model !== void 0) {
              localVarFormParams.append("model", model);
            }
            if (prompt !== void 0) {
              localVarFormParams.append("prompt", prompt);
            }
            if (responseFormat !== void 0) {
              localVarFormParams.append("response_format", responseFormat);
            }
            if (temperature !== void 0) {
              localVarFormParams.append("temperature", temperature);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Delete a file.
           * @param {string} fileId The ID of the file to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          deleteFile: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("deleteFile", "fileId", fileId);
            const localVarPath = `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
           * @param {string} model The model to delete
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          deleteModel: (model, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("deleteModel", "model", model);
            const localVarPath = `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(model)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Returns the contents of the specified file
           * @param {string} fileId The ID of the file to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          downloadFile: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("downloadFile", "fileId", fileId);
            const localVarPath = `/files/{file_id}/content`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          listEngines: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/engines`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Returns a list of files that belong to the user\'s organization.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listFiles: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/files`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Get fine-grained status updates for a fine-tune job.
           * @param {string} fineTuneId The ID of the fine-tune job to get events for.
           * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listFineTuneEvents: (fineTuneId, stream, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("listFineTuneEvents", "fineTuneId", fineTuneId);
            const localVarPath = `/fine-tunes/{fine_tune_id}/events`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (stream !== void 0) {
              localVarQueryParameter["stream"] = stream;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary List your organization\'s fine-tuning jobs
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listFineTunes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/fine-tunes`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listModels: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/models`;
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
           * @param {string} engineId The ID of the engine to use for this request
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          retrieveEngine: (engineId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("retrieveEngine", "engineId", engineId);
            const localVarPath = `/engines/{engine_id}`.replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Returns information about a specific file.
           * @param {string} fileId The ID of the file to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          retrieveFile: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("retrieveFile", "fileId", fileId);
            const localVarPath = `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
           * @param {string} fineTuneId The ID of the fine-tune job
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          retrieveFineTune: (fineTuneId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("retrieveFineTune", "fineTuneId", fineTuneId);
            const localVarPath = `/fine-tunes/{fine_tune_id}`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          }),
          /**
           *
           * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
           * @param {string} model The ID of the model to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          retrieveModel: (model, options = {}) => __awaiter(this, void 0, void 0, function* () {
            common_1.assertParamExists("retrieveModel", "model", model);
            const localVarPath = `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(model)));
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
              baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
              url: common_1.toPathString(localVarUrlObj),
              options: localVarRequestOptions
            };
          })
        };
      };
      exports.OpenAIApiFp = function(configuration) {
        const localVarAxiosParamCreator = exports.OpenAIApiAxiosParamCreator(configuration);
        return {
          /**
           *
           * @summary Immediately cancel a fine-tune job.
           * @param {string} fineTuneId The ID of the fine-tune job to cancel
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          cancelFineTune(fineTuneId, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelFineTune(fineTuneId, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
           * @param {CreateAnswerRequest} createAnswerRequest
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          createAnswer(createAnswerRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createAnswer(createAnswerRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Creates a model response for the given chat conversation.
           * @param {CreateChatCompletionRequest} createChatCompletionRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createChatCompletion(createChatCompletionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createChatCompletion(createChatCompletionRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
           * @param {CreateClassificationRequest} createClassificationRequest
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          createClassification(createClassificationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createClassification(createClassificationRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Creates a completion for the provided prompt and parameters.
           * @param {CreateCompletionRequest} createCompletionRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createCompletion(createCompletionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createCompletion(createCompletionRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Creates a new edit for the provided input, instruction, and parameters.
           * @param {CreateEditRequest} createEditRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createEdit(createEditRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createEdit(createEditRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Creates an embedding vector representing the input text.
           * @param {CreateEmbeddingRequest} createEmbeddingRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createEmbedding(createEmbeddingRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createEmbedding(createEmbeddingRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
           * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
           * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createFile(file, purpose, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createFile(file, purpose, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
           * @param {CreateFineTuneRequest} createFineTuneRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createFineTune(createFineTuneRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createFineTune(createFineTuneRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Creates an image given a prompt.
           * @param {CreateImageRequest} createImageRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createImage(createImageRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createImage(createImageRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Creates an edited or extended image given an original image and a prompt.
           * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
           * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
           * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
           * @param {number} [n] The number of images to generate. Must be between 1 and 10.
           * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
           * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
           * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createImageEdit(image, prompt, mask, n3, size, responseFormat, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createImageEdit(image, prompt, mask, n3, size, responseFormat, user, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Creates a variation of a given image.
           * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
           * @param {number} [n] The number of images to generate. Must be between 1 and 10.
           * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
           * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
           * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createImageVariation(image, n3, size, responseFormat, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createImageVariation(image, n3, size, responseFormat, user, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Classifies if text violates OpenAI\'s Content Policy
           * @param {CreateModerationRequest} createModerationRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createModeration(createModerationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createModeration(createModerationRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
           * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
           * @param {CreateSearchRequest} createSearchRequest
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          createSearch(engineId, createSearchRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createSearch(engineId, createSearchRequest, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Transcribes audio into the input language.
           * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
           * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
           * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
           * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
           * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
           * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createTranscription(file, model, prompt, responseFormat, temperature, language, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createTranscription(file, model, prompt, responseFormat, temperature, language, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Translates audio into into English.
           * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
           * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
           * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
           * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
           * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createTranslation(file, model, prompt, responseFormat, temperature, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.createTranslation(file, model, prompt, responseFormat, temperature, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Delete a file.
           * @param {string} fileId The ID of the file to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          deleteFile(fileId, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFile(fileId, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
           * @param {string} model The model to delete
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          deleteModel(model, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteModel(model, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Returns the contents of the specified file
           * @param {string} fileId The ID of the file to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          downloadFile(fileId, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadFile(fileId, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          listEngines(options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.listEngines(options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Returns a list of files that belong to the user\'s organization.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listFiles(options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.listFiles(options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Get fine-grained status updates for a fine-tune job.
           * @param {string} fineTuneId The ID of the fine-tune job to get events for.
           * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listFineTuneEvents(fineTuneId, stream, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.listFineTuneEvents(fineTuneId, stream, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary List your organization\'s fine-tuning jobs
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listFineTunes(options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.listFineTunes(options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listModels(options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.listModels(options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
           * @param {string} engineId The ID of the engine to use for this request
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          retrieveEngine(engineId, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveEngine(engineId, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Returns information about a specific file.
           * @param {string} fileId The ID of the file to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          retrieveFile(fileId, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveFile(fileId, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
           * @param {string} fineTuneId The ID of the fine-tune job
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          retrieveFineTune(fineTuneId, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveFineTune(fineTuneId, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          },
          /**
           *
           * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
           * @param {string} model The ID of the model to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          retrieveModel(model, options) {
            return __awaiter(this, void 0, void 0, function* () {
              const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveModel(model, options);
              return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
          }
        };
      };
      exports.OpenAIApiFactory = function(configuration, basePath, axios2) {
        const localVarFp = exports.OpenAIApiFp(configuration);
        return {
          /**
           *
           * @summary Immediately cancel a fine-tune job.
           * @param {string} fineTuneId The ID of the fine-tune job to cancel
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          cancelFineTune(fineTuneId, options) {
            return localVarFp.cancelFineTune(fineTuneId, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
           * @param {CreateAnswerRequest} createAnswerRequest
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          createAnswer(createAnswerRequest, options) {
            return localVarFp.createAnswer(createAnswerRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Creates a model response for the given chat conversation.
           * @param {CreateChatCompletionRequest} createChatCompletionRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createChatCompletion(createChatCompletionRequest, options) {
            return localVarFp.createChatCompletion(createChatCompletionRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
           * @param {CreateClassificationRequest} createClassificationRequest
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          createClassification(createClassificationRequest, options) {
            return localVarFp.createClassification(createClassificationRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Creates a completion for the provided prompt and parameters.
           * @param {CreateCompletionRequest} createCompletionRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createCompletion(createCompletionRequest, options) {
            return localVarFp.createCompletion(createCompletionRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Creates a new edit for the provided input, instruction, and parameters.
           * @param {CreateEditRequest} createEditRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createEdit(createEditRequest, options) {
            return localVarFp.createEdit(createEditRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Creates an embedding vector representing the input text.
           * @param {CreateEmbeddingRequest} createEmbeddingRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createEmbedding(createEmbeddingRequest, options) {
            return localVarFp.createEmbedding(createEmbeddingRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
           * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
           * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createFile(file, purpose, options) {
            return localVarFp.createFile(file, purpose, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
           * @param {CreateFineTuneRequest} createFineTuneRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createFineTune(createFineTuneRequest, options) {
            return localVarFp.createFineTune(createFineTuneRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Creates an image given a prompt.
           * @param {CreateImageRequest} createImageRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createImage(createImageRequest, options) {
            return localVarFp.createImage(createImageRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Creates an edited or extended image given an original image and a prompt.
           * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
           * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
           * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
           * @param {number} [n] The number of images to generate. Must be between 1 and 10.
           * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
           * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
           * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createImageEdit(image, prompt, mask, n3, size, responseFormat, user, options) {
            return localVarFp.createImageEdit(image, prompt, mask, n3, size, responseFormat, user, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Creates a variation of a given image.
           * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
           * @param {number} [n] The number of images to generate. Must be between 1 and 10.
           * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
           * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
           * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createImageVariation(image, n3, size, responseFormat, user, options) {
            return localVarFp.createImageVariation(image, n3, size, responseFormat, user, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Classifies if text violates OpenAI\'s Content Policy
           * @param {CreateModerationRequest} createModerationRequest
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createModeration(createModerationRequest, options) {
            return localVarFp.createModeration(createModerationRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
           * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
           * @param {CreateSearchRequest} createSearchRequest
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          createSearch(engineId, createSearchRequest, options) {
            return localVarFp.createSearch(engineId, createSearchRequest, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Transcribes audio into the input language.
           * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
           * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
           * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
           * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
           * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
           * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createTranscription(file, model, prompt, responseFormat, temperature, language, options) {
            return localVarFp.createTranscription(file, model, prompt, responseFormat, temperature, language, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Translates audio into into English.
           * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
           * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
           * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
           * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
           * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          createTranslation(file, model, prompt, responseFormat, temperature, options) {
            return localVarFp.createTranslation(file, model, prompt, responseFormat, temperature, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Delete a file.
           * @param {string} fileId The ID of the file to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          deleteFile(fileId, options) {
            return localVarFp.deleteFile(fileId, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
           * @param {string} model The model to delete
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          deleteModel(model, options) {
            return localVarFp.deleteModel(model, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Returns the contents of the specified file
           * @param {string} fileId The ID of the file to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          downloadFile(fileId, options) {
            return localVarFp.downloadFile(fileId, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          listEngines(options) {
            return localVarFp.listEngines(options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Returns a list of files that belong to the user\'s organization.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listFiles(options) {
            return localVarFp.listFiles(options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Get fine-grained status updates for a fine-tune job.
           * @param {string} fineTuneId The ID of the fine-tune job to get events for.
           * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listFineTuneEvents(fineTuneId, stream, options) {
            return localVarFp.listFineTuneEvents(fineTuneId, stream, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary List your organization\'s fine-tuning jobs
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listFineTunes(options) {
            return localVarFp.listFineTunes(options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          listModels(options) {
            return localVarFp.listModels(options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
           * @param {string} engineId The ID of the engine to use for this request
           * @param {*} [options] Override http request option.
           * @deprecated
           * @throws {RequiredError}
           */
          retrieveEngine(engineId, options) {
            return localVarFp.retrieveEngine(engineId, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Returns information about a specific file.
           * @param {string} fileId The ID of the file to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          retrieveFile(fileId, options) {
            return localVarFp.retrieveFile(fileId, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
           * @param {string} fineTuneId The ID of the fine-tune job
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          retrieveFineTune(fineTuneId, options) {
            return localVarFp.retrieveFineTune(fineTuneId, options).then((request) => request(axios2, basePath));
          },
          /**
           *
           * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
           * @param {string} model The ID of the model to use for this request
           * @param {*} [options] Override http request option.
           * @throws {RequiredError}
           */
          retrieveModel(model, options) {
            return localVarFp.retrieveModel(model, options).then((request) => request(axios2, basePath));
          }
        };
      };
      var OpenAIApi2 = class extends base_1.BaseAPI {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        cancelFineTune(fineTuneId, options) {
          return exports.OpenAIApiFp(this.configuration).cancelFineTune(fineTuneId, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createAnswer(createAnswerRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createAnswer(createAnswerRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Creates a model response for the given chat conversation.
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createChatCompletion(createChatCompletionRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createChatCompletion(createChatCompletionRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createClassification(createClassificationRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createClassification(createClassificationRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createCompletion(createCompletionRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createCompletion(createCompletionRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createEdit(createEditRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createEdit(createEditRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createEmbedding(createEmbeddingRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createEmbedding(createEmbeddingRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createFile(file, purpose, options) {
          return exports.OpenAIApiFp(this.configuration).createFile(file, purpose, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createFineTune(createFineTuneRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createFineTune(createFineTuneRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createImage(createImageRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createImage(createImageRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createImageEdit(image, prompt, mask, n3, size, responseFormat, user, options) {
          return exports.OpenAIApiFp(this.configuration).createImageEdit(image, prompt, mask, n3, size, responseFormat, user, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createImageVariation(image, n3, size, responseFormat, user, options) {
          return exports.OpenAIApiFp(this.configuration).createImageVariation(image, n3, size, responseFormat, user, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createModeration(createModerationRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createModeration(createModerationRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createSearch(engineId, createSearchRequest, options) {
          return exports.OpenAIApiFp(this.configuration).createSearch(engineId, createSearchRequest, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createTranscription(file, model, prompt, responseFormat, temperature, language, options) {
          return exports.OpenAIApiFp(this.configuration).createTranscription(file, model, prompt, responseFormat, temperature, language, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        createTranslation(file, model, prompt, responseFormat, temperature, options) {
          return exports.OpenAIApiFp(this.configuration).createTranslation(file, model, prompt, responseFormat, temperature, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        deleteFile(fileId, options) {
          return exports.OpenAIApiFp(this.configuration).deleteFile(fileId, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        deleteModel(model, options) {
          return exports.OpenAIApiFp(this.configuration).deleteModel(model, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        downloadFile(fileId, options) {
          return exports.OpenAIApiFp(this.configuration).downloadFile(fileId, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        listEngines(options) {
          return exports.OpenAIApiFp(this.configuration).listEngines(options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        listFiles(options) {
          return exports.OpenAIApiFp(this.configuration).listFiles(options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        listFineTuneEvents(fineTuneId, stream, options) {
          return exports.OpenAIApiFp(this.configuration).listFineTuneEvents(fineTuneId, stream, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        listFineTunes(options) {
          return exports.OpenAIApiFp(this.configuration).listFineTunes(options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        listModels(options) {
          return exports.OpenAIApiFp(this.configuration).listModels(options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        retrieveEngine(engineId, options) {
          return exports.OpenAIApiFp(this.configuration).retrieveEngine(engineId, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        retrieveFile(fileId, options) {
          return exports.OpenAIApiFp(this.configuration).retrieveFile(fileId, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        retrieveFineTune(fineTuneId, options) {
          return exports.OpenAIApiFp(this.configuration).retrieveFineTune(fineTuneId, options).then((request) => request(this.axios, this.basePath));
        }
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof OpenAIApi
         */
        retrieveModel(model, options) {
          return exports.OpenAIApiFp(this.configuration).retrieveModel(model, options).then((request) => request(this.axios, this.basePath));
        }
      };
      exports.OpenAIApi = OpenAIApi2;
    }
  });

  // ../node_modules/openai/package.json
  var require_package2 = __commonJS({
    "../node_modules/openai/package.json"(exports, module) {
      module.exports = {
        name: "openai",
        version: "3.3.0",
        description: "Node.js library for the OpenAI API",
        repository: {
          type: "git",
          url: "git@github.com:openai/openai-node.git"
        },
        keywords: [
          "openai",
          "open",
          "ai",
          "gpt-3",
          "gpt3"
        ],
        author: "OpenAI",
        license: "MIT",
        main: "./dist/index.js",
        types: "./dist/index.d.ts",
        scripts: {
          build: "tsc --outDir dist/"
        },
        dependencies: {
          axios: "^0.26.0",
          "form-data": "^4.0.0"
        },
        devDependencies: {
          "@types/node": "^12.11.5",
          typescript: "^3.6.4"
        }
      };
    }
  });

  // ../node_modules/form-data/lib/browser.js
  var require_browser = __commonJS({
    "../node_modules/form-data/lib/browser.js"(exports, module) {
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      module.exports = typeof self == "object" ? self.FormData : window.FormData;
    }
  });

  // ../node_modules/openai/dist/configuration.js
  var require_configuration = __commonJS({
    "../node_modules/openai/dist/configuration.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Configuration = void 0;
      var packageJson = require_package2();
      var Configuration2 = class {
        constructor(param = {}) {
          this.apiKey = param.apiKey;
          this.organization = param.organization;
          this.username = param.username;
          this.password = param.password;
          this.accessToken = param.accessToken;
          this.basePath = param.basePath;
          this.baseOptions = param.baseOptions;
          this.formDataCtor = param.formDataCtor;
          if (!this.baseOptions) {
            this.baseOptions = {};
          }
          this.baseOptions.headers = Object.assign({ "User-Agent": `OpenAI/NodeJS/${packageJson.version}`, "Authorization": `Bearer ${this.apiKey}` }, this.baseOptions.headers);
          if (this.organization) {
            this.baseOptions.headers["OpenAI-Organization"] = this.organization;
          }
          if (!this.formDataCtor) {
            this.formDataCtor = require_browser();
          }
        }
        /**
         * Check if the given MIME is a JSON MIME.
         * JSON MIME examples:
         *   application/json
         *   application/json; charset=UTF8
         *   APPLICATION/JSON
         *   application/vnd.company+json
         * @param mime - MIME (Multipurpose Internet Mail Extensions)
         * @return True if the given MIME is JSON, false otherwise.
         */
        isJsonMime(mime) {
          const jsonMime = new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$", "i");
          return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
        }
      };
      exports.Configuration = Configuration2;
    }
  });

  // ../node_modules/openai/dist/index.js
  var require_dist2 = __commonJS({
    "../node_modules/openai/dist/index.js"(exports) {
      "use strict";
      init_checked_fetch();
      init_middleware_insertion_facade();
      init_modules_watch_stub();
      init_process();
      init_buffer();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        Object.defineProperty(o, k22, { enumerable: true, get: function() {
          return m2[k2];
        } });
      } : function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m2[k2];
      });
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_api(), exports);
      __exportStar(require_configuration(), exports);
    }
  });

  // src/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/elysia/dist/index.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/memoirist/dist/index.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var e = (e8, t5) => ({ part: e8, store: null, inert: void 0 !== t5 ? new Map(t5.map((e9) => [e9.part.charCodeAt(0), e9])) : null, params: null, wildcardStore: null });
  var t = (e8, t5) => ({ ...e8, part: t5 });
  var r = (e8) => ({ paramName: e8, store: null, inert: null });
  var _Memoirist = class {
    root = {};
    history = [];
    add(a4, l, i2) {
      let s3;
      if ("string" != typeof l)
        throw TypeError("Route path must be a string");
      "" === l ? l = "/" : "/" !== l[0] && (l = `/${l}`), this.history.push([a4, l, i2]);
      let n3 = "*" === l[l.length - 1];
      n3 && (l = l.slice(0, -1));
      let o = l.split(_Memoirist.regex.static), u2 = l.match(_Memoirist.regex.params) || [];
      "" === o[o.length - 1] && o.pop(), s3 = this.root[a4] ? this.root[a4] : this.root[a4] = e("/");
      let p2 = 0;
      for (let a5 = 0; a5 < o.length; ++a5) {
        let i3 = o[a5];
        if (a5 > 0) {
          let t5 = u2[p2++].slice(1);
          if (null === s3.params)
            s3.params = r(t5);
          else if (s3.params.paramName !== t5)
            throw Error(`Cannot create route "${l}" with parameter "${t5}" because a route already exists with a different parameter name ("${s3.params.paramName}") in the same location`);
          let a6 = s3.params;
          if (null === a6.inert) {
            s3 = a6.inert = e(i3);
            continue;
          }
          s3 = a6.inert;
        }
        for (let r6 = 0; ; ) {
          if (r6 === i3.length) {
            if (r6 < s3.part.length) {
              let a6 = t(s3, s3.part.slice(r6));
              Object.assign(s3, e(i3, [a6]));
            }
            break;
          }
          if (r6 === s3.part.length) {
            if (null === s3.inert)
              s3.inert = /* @__PURE__ */ new Map();
            else if (s3.inert.has(i3.charCodeAt(r6))) {
              s3 = s3.inert.get(i3.charCodeAt(r6)), i3 = i3.slice(r6), r6 = 0;
              continue;
            }
            let t5 = e(i3.slice(r6));
            s3.inert.set(i3.charCodeAt(r6), t5), s3 = t5;
            break;
          }
          if (i3[r6] !== s3.part[r6]) {
            let a6 = t(s3, s3.part.slice(r6)), l2 = e(i3.slice(r6));
            Object.assign(s3, e(s3.part.slice(0, r6), [a6, l2])), s3 = l2;
            break;
          }
          ++r6;
        }
      }
      if (p2 < u2.length) {
        let e8 = u2[p2], t5 = e8.slice(1);
        if (null === s3.params)
          s3.params = r(t5);
        else if (s3.params.paramName !== t5)
          throw Error(`Cannot create route "${l}" with parameter "${t5}" because a route already exists with a different parameter name ("${s3.params.paramName}") in the same location`);
        return null === s3.params.store && (s3.params.store = i2), s3.params.store;
      }
      return n3 ? (null === s3.wildcardStore && (s3.wildcardStore = i2), s3.wildcardStore) : (null === s3.store && (s3.store = i2), s3.store);
    }
    find(e8, t5) {
      let r6 = this.root[e8];
      return r6 ? a(t5, t5.length, r6, 0) : null;
    }
  };
  var Memoirist = _Memoirist;
  __publicField(Memoirist, "regex", { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g });
  var a = (e8, t5, r6, l) => {
    let i2 = r6?.part, s3 = l + i2.length;
    if (i2.length > 1) {
      if (s3 > t5)
        return null;
      if (i2.length < 15) {
        for (let t6 = 1, r7 = l + 1; t6 < i2.length; ++t6, ++r7)
          if (i2.charCodeAt(t6) !== e8.charCodeAt(r7))
            return null;
      } else if (e8.substring(l, s3) !== i2)
        return null;
    }
    if (s3 === t5)
      return null !== r6.store ? { store: r6.store, params: {} } : null !== r6.wildcardStore ? { store: r6.wildcardStore, params: { "*": "" } } : null;
    if (null !== r6.inert) {
      let l2 = r6.inert.get(e8.charCodeAt(s3));
      if (void 0 !== l2) {
        let r7 = a(e8, t5, l2, s3);
        if (null !== r7)
          return r7;
      }
    }
    if (null !== r6.params) {
      let l2 = r6.params, i3 = e8.indexOf("/", s3);
      if (i3 !== s3) {
        if (-1 === i3 || i3 >= t5) {
          if (null !== l2.store) {
            let r7 = {};
            return r7[l2.paramName] = e8.substring(s3, t5), { store: l2.store, params: r7 };
          }
        } else if (null !== l2.inert) {
          let r7 = a(e8, t5, l2.inert, i3);
          if (null !== r7)
            return r7.params[l2.paramName] = e8.substring(s3, i3), r7;
        }
      }
    }
    return null !== r6.wildcardStore ? { store: r6.wildcardStore, params: { "*": e8.substring(s3, t5) } } : null;
  };

  // ../node_modules/eventemitter3/index.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_index = __toESM(require_eventemitter3(), 1);
  var eventemitter3_default = import_index.default;

  // ../node_modules/elysia/dist/trace.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var createTraceListener = (e8, n3) => async function(s3) {
    let r6 = s3.id;
    if ("request" === s3.event && "begin" === s3.type) {
      let a4 = e8(), t5 = () => {
        let e9, n4;
        let s4 = -1, r7 = [], a5 = [], t6 = false, o2 = new Promise((n5) => {
          e9 = (e10) => {
            t6 || (t6 = true, n5(e10));
          };
        }), i3 = false, c3 = new Promise((e10) => {
          n4 = (n5) => {
            if (!i3) {
              for (i3 = true, -1 === s4 && (s4 = 0); s4 < a5.length; s4++) {
                let e11;
                let n6 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((n7) => {
                  n7(e11);
                }), children: [] };
                e11 = performance.now(), r7[s4](n6);
              }
              e10(n5);
            }
          };
        });
        return { signal: o2, consumeChild(e10) {
          switch (e10.type) {
            case "begin":
              let n5 = r7[++s4];
              n5 ? n5({ name: e10.name, time: e10.time, skip: false, end: new Promise((e11) => {
                a5.push(e11);
              }) }) : (this.resolve(), console.log("SKIP"));
              break;
            case "end":
              a5[s4]?.(e10.time);
          }
        }, consume(s5) {
          switch (s5.type) {
            case "begin":
              let a6 = [], t7 = s5.unit ?? 0;
              for (let e10 = 0; e10 < t7; e10++) {
                let e11;
                a6.push(new Promise((n5) => {
                  e11 = n5;
                })), r7.push(e11);
              }
              e9({
                // Begin always have name
                name: s5.name,
                time: s5.time,
                skip: false,
                end: c3,
                children: a6
              });
              break;
            case "end":
              n4(s5.time);
          }
        }, resolve() {
          let s5;
          if (t6 && i3)
            return;
          let r8 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((e10) => {
            e10(s5);
          }), children: [] };
          s5 = performance.now(), e9(r8), n4(s5);
        } };
      }, o = t5(), i2 = t5(), c2 = t5(), l = t5(), m2 = t5(), u2 = t5(), d2 = t5(), b2 = t5();
      o.consume(s3);
      let f = (e9) => {
        if (e9.id === r6)
          switch (e9.event) {
            case "request":
              o.consume(e9);
              break;
            case "request.unit":
              o.consumeChild(e9);
              break;
            case "parse":
              i2.consume(e9);
              break;
            case "parse.unit":
              i2.consumeChild(e9);
              break;
            case "transform":
              c2.consume(e9);
              break;
            case "transform.unit":
              c2.consumeChild(e9);
              break;
            case "beforeHandle":
              l.consume(e9);
              break;
            case "beforeHandle.unit":
              l.consumeChild(e9);
              break;
            case "handle":
              m2.consume(e9);
              break;
            case "afterHandle":
              u2.consume(e9);
              break;
            case "afterHandle.unit":
              u2.consumeChild(e9);
              break;
            case "error":
              d2.consume(e9);
              break;
            case "error.unit":
              d2.consumeChild(e9);
              break;
            case "response":
              "begin" === e9.type ? (o.resolve(), i2.resolve(), c2.resolve(), l.resolve(), m2.resolve(), u2.resolve(), d2.resolve()) : a4.off("event", f), b2.consume(e9);
              break;
            case "response.unit":
              b2.consumeChild(e9);
          }
      };
      a4.on("event", f), await n3({
        id: s3.id,
        // @ts-ignore
        context: s3.ctx,
        // @ts-ignore
        set: s3.ctx?.set,
        // @ts-ignore
        store: s3.ctx?.store,
        time: s3.time,
        request: o.signal,
        parse: i2.signal,
        transform: c2.signal,
        beforeHandle: l.signal,
        handle: m2.signal,
        afterHandle: u2.signal,
        error: d2.signal,
        response: b2.signal
      }), a4.emit(`res${r6}`, void 0);
    }
  };

  // ../node_modules/elysia/dist/ws/index.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/elysia/dist/error.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_value = __toESM(require_value2());
  var e2 = "undefined" != typeof Bun ? Bun.env : "undefined" != typeof process ? process?.env : void 0;
  var ERROR_CODE = Symbol("ErrorCode");
  var isProduction = (e2?.NODE_ENV ?? e2?.ENV) === "production";
  var InternalServerError = class extends Error {
    code = "INTERNAL_SERVER_ERROR";
    status = 500;
    constructor(r6) {
      super(r6 ?? "INTERNAL_SERVER_ERROR");
    }
  };
  var NotFoundError2 = class extends Error {
    code = "NOT_FOUND";
    status = 404;
    constructor(r6) {
      super(r6 ?? "NOT_FOUND");
    }
  };
  var InvalidCookieSignature = class extends Error {
    key;
    code;
    status;
    constructor(r6, e8) {
      super(e8 ?? `"${r6}" has invalid cookie signature`), this.key = r6, this.code = "INVALID_COOKIE_SIGNATURE", this.status = 400;
    }
  };
  var ValidationError = class extends Error {
    type;
    validator;
    value;
    code;
    status;
    constructor(e8, t5, s3) {
      let o = isProduction ? void 0 : t5.Errors(s3).First(), a4 = o?.schema.error ? "function" == typeof o.schema.error ? o.schema.error(e8, t5, s3) : o.schema.error : void 0, i2 = isProduction ? a4 ?? `Invalid ${e8 ?? o?.schema.error ?? o?.message}` : a4 ?? `Invalid ${e8}, '${o?.path?.slice(1) || "type"}': ${o?.message}

Expected: ` + // @ts-ignore
      JSON.stringify(import_value.Value.Create(t5.schema), null, 2) + "\n\nFound: " + JSON.stringify(s3, null, 2);
      super(i2), this.type = e8, this.validator = t5, this.value = s3, this.code = "VALIDATION", this.status = 400, Object.setPrototypeOf(this, ValidationError.prototype);
    }
    get all() {
      return [...this.validator.Errors(this.value)];
    }
    get model() {
      return import_value.Value.Create(this.validator.schema);
    }
    toResponse(r6) {
      return new Response(this.message, { status: 400, headers: r6 });
    }
  };

  // ../node_modules/elysia/dist/ws/index.js
  var websocket = { open(t5) {
    t5.data.open?.(t5);
  }, message(t5, r6) {
    t5.data.message?.(t5, r6);
  }, drain(t5) {
    t5.data.drain?.(t5);
  }, close(t5, r6, e8) {
    t5.data.close?.(t5, r6, e8);
  } };
  var ElysiaWS = class {
    raw;
    data;
    id;
    validator;
    constructor(t5, r6) {
      this.raw = t5, this.data = r6, this.validator = t5.data.validator, this.id = Date.now();
    }
    get publish() {
      return (r6, e8, s3) => {
        if (this.validator?.Check(e8) === false)
          throw new ValidationError("message", this.validator, e8);
        return "object" == typeof e8 && (e8 = JSON.stringify(e8)), this.raw.publish(r6, e8, s3), this;
      };
    }
    get send() {
      return (r6) => {
        if (this.validator?.Check(r6) === false)
          throw new ValidationError("message", this.validator, r6);
        return Buffer2.isBuffer(r6) || "object" == typeof r6 && (r6 = JSON.stringify(r6)), this.raw.send(r6), this;
      };
    }
    get subscribe() {
      return (t5) => (this.raw.subscribe(t5), this);
    }
    get unsubscribe() {
      return (t5) => (this.raw.unsubscribe(t5), this);
    }
    get cork() {
      return (t5) => (this.raw.cork(t5), this);
    }
    get close() {
      return () => (this.raw.close(), this);
    }
    get terminate() {
      return this.raw.terminate.bind(this.raw);
    }
    get isSubscribed() {
      return this.raw.isSubscribed.bind(this.raw);
    }
    get remoteAddress() {
      return this.raw.remoteAddress;
    }
  };

  // ../node_modules/elysia/dist/handler.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_cookie2 = __toESM(require_cookie());

  // ../node_modules/elysia/dist/utils.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_typebox = __toESM(require_typebox());
  var import_value2 = __toESM(require_value2());
  var import_compiler = __toESM(require_compiler2());
  var a2 = (e8) => e8 && "object" == typeof e8 && !Array.isArray(e8);
  var n = (e8) => "function" == typeof e8 && /^\s*class\s+/.test(e8.toString()) || // Handle import * as Sentry from '@sentry/bun'
  // This also handle [object Date], [object Array]
  // and FFI value like [object Prisma]
  e8.toString().startsWith("[object ") || // If object prototype is not pure, then probably a class-like object
  isNotEmpty(Object.getPrototypeOf(e8));
  var mergeDeep = (e8, r6, { skipKeys: t5 } = {}) => {
    if (a2(e8) && a2(r6)) {
      for (let [o, s3] of Object.entries(r6))
        if (!t5?.includes(o)) {
          if (!a2(s3) || !(o in e8) || n(s3)) {
            e8[o] = s3;
            continue;
          }
          e8[o] = mergeDeep(e8[o], s3);
        }
    }
    return e8;
  };
  var mergeCookie = (e8, r6) => mergeDeep(e8, r6, { skipKeys: ["properties"] });
  var mergeObjectArray = (e8, r6) => {
    let t5 = [...Array.isArray(e8) ? e8 : [e8]], o = [];
    for (let e9 of t5)
      e9.$elysiaChecksum && // @ts-ignore
      o.push(e9.$elysiaChecksum);
    for (let e9 of Array.isArray(r6) ? r6 : [r6])
      o.includes(e9?.$elysiaChecksum) || t5.push(e9);
    return t5;
  };
  var mergeHook = (e8, r6) => ({
    // Merge local hook first
    // @ts-ignore
    body: r6?.body ?? e8?.body,
    // @ts-ignore
    headers: r6?.headers ?? e8?.headers,
    // @ts-ignore
    params: r6?.params ?? e8?.params,
    // @ts-ignore
    query: r6?.query ?? e8?.query,
    // @ts-ignore
    response: r6?.response ?? e8?.response,
    type: e8?.type || r6?.type,
    detail: mergeDeep(
      // @ts-ignore
      r6?.detail ?? {},
      // @ts-ignore
      e8?.detail ?? {}
    ),
    parse: mergeObjectArray(e8?.parse ?? [], r6?.parse ?? []),
    transform: mergeObjectArray(e8?.transform ?? [], r6?.transform ?? []),
    beforeHandle: mergeObjectArray(e8?.beforeHandle ?? [], r6?.beforeHandle ?? []),
    afterHandle: mergeObjectArray(e8?.afterHandle ?? [], r6?.afterHandle ?? []),
    onResponse: mergeObjectArray(e8?.onResponse ?? [], r6?.onResponse ?? []),
    trace: mergeObjectArray(e8?.trace ?? [], r6?.trace ?? []),
    error: mergeObjectArray(e8?.error ?? [], r6?.error ?? [])
  });
  var getSchemaValidator = (e8, { models: o = {}, additionalProperties: a4 = false, dynamic: n3 = false }) => {
    if (!e8 || "string" == typeof e8 && !(e8 in o))
      return;
    let s3 = "string" == typeof e8 ? o[e8] : e8;
    return ("object" === s3.type && "additionalProperties" in s3 == false && (s3.additionalProperties = a4), n3) ? { schema: s3, references: "", checkFunc: () => {
    }, code: "", Check: (e9) => import_value2.Value.Check(s3, e9), Errors: (e9) => import_value2.Value.Errors(s3, e9), Code: () => "" } : import_compiler.TypeCompiler.Compile(s3);
  };
  var getResponseSchemaValidator = (o, { models: a4 = {}, additionalProperties: n3 = false, dynamic: s3 = false }) => {
    if (!o || "string" == typeof o && !(o in a4))
      return;
    let i2 = "string" == typeof o ? a4[o] : o, l = (e8) => s3 ? { schema: e8, references: "", checkFunc: () => {
    }, code: "", Check: (t5) => import_value2.Value.Check(e8, t5), Errors: (t5) => import_value2.Value.Errors(e8, t5), Code: () => "" } : import_compiler.TypeCompiler.Compile(e8);
    if (import_typebox.Kind in i2)
      return "additionalProperties" in i2 == false && (i2.additionalProperties = n3), { 200: l(i2) };
    let p2 = {};
    return Object.keys(i2).forEach((r6) => {
      let t5 = i2[+r6];
      if ("string" == typeof t5) {
        if (t5 in a4) {
          let o2 = a4[t5];
          o2.type, // Inherits model maybe already compiled
          p2[+r6] = import_typebox.Kind in o2 ? l(o2) : o2;
        }
        return;
      }
      "object" === t5.type && "additionalProperties" in t5 == false && (t5.additionalProperties = n3), // Inherits model maybe already compiled
      p2[+r6] = import_typebox.Kind in t5 ? l(t5) : t5;
    }), p2;
  };
  var checksum = (e8) => {
    let r6 = 9;
    for (let t5 = 0; t5 < e8.length; )
      r6 = Math.imul(r6 ^ e8.charCodeAt(t5++), 387420489);
    return r6 ^ r6 >>> 9;
  };
  var mergeLifeCycle = (e8, r6, t5) => {
    let o = (e9) => (t5 && // @ts-ignore
    (e9.$elysiaChecksum = t5), e9);
    return { start: mergeObjectArray(e8.start, ("start" in r6 ? r6.start ?? [] : []).map(o)), request: mergeObjectArray(e8.request, ("request" in r6 ? r6.request ?? [] : []).map(o)), parse: mergeObjectArray(e8.parse, "parse" in r6 ? r6?.parse ?? [] : []).map(o), transform: mergeObjectArray(e8.transform, (r6?.transform ?? []).map(o)), beforeHandle: mergeObjectArray(e8.beforeHandle, (r6?.beforeHandle ?? []).map(o)), afterHandle: mergeObjectArray(e8.afterHandle, (r6?.afterHandle ?? []).map(o)), onResponse: mergeObjectArray(e8.onResponse, (r6?.onResponse ?? []).map(o)), trace: mergeObjectArray(e8.trace, ("trace" in r6 ? r6.trace ?? [] : []).map(o)), error: mergeObjectArray(e8.error, (r6?.error ?? []).map(o)), stop: mergeObjectArray(e8.stop, ("stop" in r6 ? r6.stop ?? [] : []).map(o)) };
  };
  var asGlobal = (e8, r6 = true) => e8 ? "function" == typeof e8 ? (r6 ? (
    // @ts-ignore
    e8.$elysiaHookType = "global"
  ) : e8.$elysiaHookType = void 0, e8) : e8.map((e9) => (r6 ? (
    // @ts-ignore
    e9.$elysiaHookType = "global"
  ) : e9.$elysiaHookType = void 0, e9)) : e8;
  var s = (e8) => e8 ? "function" == typeof e8 ? "global" === e8.$elysiaHookType ? e8 : void 0 : e8.filter((e9) => "global" === e9.$elysiaHookType) : e8;
  var filterGlobalHook = (e8) => ({
    // rest is validator
    ...e8,
    type: e8?.type,
    detail: e8?.detail,
    parse: s(e8?.parse),
    transform: s(e8?.transform),
    beforeHandle: s(e8?.beforeHandle),
    afterHandle: s(e8?.afterHandle),
    onResponse: s(e8?.onResponse),
    error: s(e8?.error)
  });
  var StatusMap = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
  var signCookie = async (e8, r6) => {
    if ("string" != typeof e8)
      throw TypeError("Cookie value must be provided as a string.");
    if (null === r6)
      throw TypeError("Secret key must be provided.");
    let t5 = new TextEncoder(), o = await crypto.subtle.importKey("raw", t5.encode(r6), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), a4 = await crypto.subtle.sign("HMAC", o, t5.encode(e8)), n3 = Array.from(new Uint8Array(a4)), s3 = btoa(String.fromCharCode(...n3));
    return `${e8}.${s3.replace(/=+$/, "")}`;
  };
  var unsignCookie = async (e8, r6) => {
    if ("string" != typeof e8)
      throw TypeError("Signed cookie string must be provided.");
    if (null === r6)
      throw TypeError("Secret key must be provided.");
    let t5 = e8.slice(0, e8.lastIndexOf(".")), o = await signCookie(t5, r6);
    return o === e8 && t5;
  };

  // ../node_modules/elysia/dist/cookie.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_cookie = __toESM(require_cookie());
  var Cookie = class {
    _value;
    property;
    name;
    setter;
    constructor(e8, t5 = {}) {
      this._value = e8, this.property = t5;
    }
    get() {
      return this._value;
    }
    get value() {
      return this._value;
    }
    set value(e8) {
      if ("object" == typeof e8) {
        if (JSON.stringify(this.value) === JSON.stringify(e8))
          return;
      } else if (this.value === e8)
        return;
      this._value = e8, this.sync();
    }
    add(e8) {
      let t5 = Object.assign(this.property, "function" == typeof e8 ? e8(Object.assign(this.property, this.value)) : e8);
      return "value" in t5 && (this._value = t5.value, delete t5.value), this.property = t5, this.sync();
    }
    set(e8) {
      let t5 = "function" == typeof e8 ? e8(Object.assign(this.property, this.value)) : e8;
      return "value" in t5 && (this._value = t5.value, delete t5.value), this.property = t5, this.sync();
    }
    remove(e8) {
      void 0 !== this.value && this.set({ domain: e8?.domain, expires: /* @__PURE__ */ new Date(0), maxAge: 0, path: e8?.path, sameSite: e8?.sameSite, secure: e8?.secure, value: "" });
    }
    get domain() {
      return this.property.domain;
    }
    set domain(e8) {
      this.property.domain !== e8 && // @ts-ignore
      (this.property.domain = e8, this.sync());
    }
    get expires() {
      return this.property.expires;
    }
    set expires(e8) {
      this.property.expires?.getTime() !== e8?.getTime() && // @ts-ignore
      (this.property.expires = e8, this.sync());
    }
    get httpOnly() {
      return this.property.httpOnly;
    }
    set httpOnly(e8) {
      this.property.domain !== e8 && // @ts-ignore
      (this.property.httpOnly = e8, this.sync());
    }
    get maxAge() {
      return this.property.maxAge;
    }
    set maxAge(e8) {
      this.property.maxAge !== e8 && // @ts-ignore
      (this.property.maxAge = e8, this.sync());
    }
    get path() {
      return this.property.path;
    }
    set path(e8) {
      this.property.path !== e8 && // @ts-ignore
      (this.property.path = e8, this.sync());
    }
    get priority() {
      return this.property.priority;
    }
    set priority(e8) {
      this.property.priority !== e8 && // @ts-ignore
      (this.property.priority = e8, this.sync());
    }
    get sameSite() {
      return this.property.sameSite;
    }
    set sameSite(e8) {
      this.property.sameSite !== e8 && // @ts-ignore
      (this.property.sameSite = e8, this.sync());
    }
    get secure() {
      return this.property.secure;
    }
    set secure(e8) {
      this.property.secure !== e8 && // @ts-ignore
      (this.property.secure = e8, this.sync());
    }
    toString() {
      return "object" == typeof this.value ? JSON.stringify(this.value) : this.value?.toString() ?? "";
    }
    sync() {
      return this.name && this.setter && (this.setter.cookie ? this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() }) : this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) }), this;
    }
  };
  var createCookieJar = (e8, t5, r6) => new Proxy(e8, { get(e9, i2) {
    if (i2 in e9)
      return e9[i2];
    let s3 = new Cookie(void 0, r6 ? { ...r6 } : void 0);
    return (
      // @ts-ignore
      s3.setter = t5, s3.name = i2, s3
    );
  }, set: (e9, r7, i2) => i2 instanceof Cookie && (t5.cookie || (t5.cookie = {}), // @ts-ignore
  i2.setter = t5, i2.name = r7, // @ts-ignore
  i2.sync(), e9[r7] = i2, true) });
  var parseCookie = async (i2, s3, { secret: o, sign: p2, ...n3 } = {}) => {
    if (!s3)
      return createCookieJar({}, i2, n3);
    let a4 = {}, h2 = "string" == typeof o;
    p2 && true !== p2 && !Array.isArray(p2) && (p2 = [p2]);
    let y2 = Object.keys((0, import_cookie.parse)(s3));
    for (let u2 = 0; u2 < y2.length; u2++) {
      let c2 = y2[u2], l = (0, import_cookie.parse)(s3)[c2];
      if (true === p2 || p2?.includes(c2)) {
        if (!o)
          throw Error("No secret is provided to cookie plugin");
        if (h2) {
          if (false === // @ts-ignore
          (l = await unsignCookie(l, o)))
            throw new InvalidCookieSignature(c2);
        } else {
          let e8 = true;
          for (let r6 = 0; r6 < o.length; r6++) {
            let i3 = await unsignCookie(l, o[r6]);
            if (false !== i3) {
              l = i3, e8 = false;
              break;
            }
          }
          if (e8)
            throw new InvalidCookieSignature(c2);
        }
      }
      if (void 0 === l)
        continue;
      let m2 = l.charCodeAt(0);
      if (123 === m2 || 91 === m2)
        try {
          let e8 = new Cookie(JSON.parse(l));
          e8.setter = i2, e8.name = c2, a4[c2] = e8;
          continue;
        } catch {
        }
      Number.isNaN(+l) ? "true" === l ? l = true : "false" === l && (l = false) : l = +l;
      let g2 = new Cookie(l, n3);
      g2.setter = i2, g2.name = c2, a4[c2] = g2;
    }
    return createCookieJar(a4, i2);
  };

  // ../node_modules/elysia/dist/handler.js
  var r4 = "toJSON" in new Headers();
  var isNotEmpty = (e8) => {
    for (let s3 in e8)
      return true;
    return false;
  };
  var parseSetCookies = (e8, s3) => {
    if (!e8 || !Array.isArray(s3))
      return e8;
    e8.delete("Set-Cookie");
    for (let t5 = 0; t5 < s3.length; t5++) {
      let r6 = s3[t5].indexOf("=");
      e8.append("Set-Cookie", `${s3[t5].slice(0, r6)}=${s3[t5].slice(r6 + 1)}`);
    }
    return e8;
  };
  var cookieToHeader = (s3) => {
    if (!s3 || "object" != typeof s3 || !isNotEmpty(s3))
      return;
    let t5 = [];
    for (let [r6, n3] of Object.entries(s3))
      if (r6 && n3) {
        if (Array.isArray(n3.value))
          for (let s4 = 0; s4 < n3.value.length; s4++) {
            let o = n3.value[s4];
            null != o && ("object" == typeof o && (o = JSON.stringify(o)), t5.push((0, import_cookie2.serialize)(r6, o, n3)));
          }
        else {
          let s4 = n3.value;
          if (null == s4)
            continue;
          "object" == typeof s4 && (s4 = JSON.stringify(s4)), t5.push((0, import_cookie2.serialize)(r6, n3.value, n3));
        }
      }
    if (0 !== t5.length)
      return 1 === t5.length ? t5[0] : t5;
  };
  var mapResponse = (e8, n3) => {
    if (
      // @ts-ignore
      e8?.$passthrough && // @ts-ignore
      (e8 = e8[e8.$passthrough]), isNotEmpty(n3.headers) || 200 !== n3.status || n3.redirect || n3.cookie
    )
      switch ("string" == typeof n3.status && (n3.status = StatusMap[n3.status]), n3.redirect && (n3.headers.Location = n3.redirect, (!n3.status || n3.status < 300 || n3.status >= 400) && (n3.status = 302)), n3.cookie && isNotEmpty(n3.cookie) && (n3.headers["Set-Cookie"] = cookieToHeader(n3.cookie)), n3.headers["Set-Cookie"] && Array.isArray(n3.headers["Set-Cookie"]) && (n3.headers = parseSetCookies(new Headers(n3.headers), n3.headers["Set-Cookie"])), e8?.constructor?.name) {
        case "String":
        case "Blob":
          return new Response(e8, { status: n3.status, headers: n3.headers });
        case "Object":
        case "Array":
          return Response.json(e8, n3);
        case void 0:
          if (!e8)
            return new Response("", n3);
          return Response.json(e8, n3);
        case "Response":
          let o = { ...n3.headers };
          if (r4)
            n3.headers = e8.headers.toJSON();
          else
            for (let [s3, t5] of e8.headers.entries())
              s3 in n3.headers && (n3.headers[s3] = t5);
          for (let s3 in o)
            e8.headers.append(s3, o[s3]);
          return e8;
        case "Error":
          return errorToResponse(e8, n3);
        case "Promise":
          return e8.then((e9) => mapResponse(e9, n3));
        case "Function":
          return mapResponse(e8(), n3);
        case "Number":
        case "Boolean":
          return new Response(e8.toString(), n3);
        case "Cookie":
          if (e8 instanceof Cookie)
            return new Response(e8.value, n3);
          return new Response(e8?.toString(), n3);
        default:
          let a4 = JSON.stringify(e8);
          if (123 === a4.charCodeAt(0))
            return n3.headers["Content-Type"] || (n3.headers["Content-Type"] = "application/json"), new Response(JSON.stringify(e8), n3);
          return new Response(a4, n3);
      }
    else
      switch (e8?.constructor?.name) {
        case "String":
        case "Blob":
          return new Response(e8);
        case "Object":
        case "Array":
          return new Response(JSON.stringify(e8), { headers: { "content-type": "application/json" } });
        case void 0:
          if (!e8)
            return new Response("");
          return new Response(JSON.stringify(e8), { headers: { "content-type": "application/json" } });
        case "Response":
          return e8;
        case "Error":
          return errorToResponse(e8, n3);
        case "Promise":
          return e8.then((e9) => {
            let s3 = mapCompactResponse(e9);
            return void 0 !== s3 ? s3 : new Response("");
          });
        case "Function":
          return mapCompactResponse(e8());
        case "Number":
        case "Boolean":
          return new Response(e8.toString());
        case "Cookie":
          if (e8 instanceof Cookie)
            return new Response(e8.value, n3);
          return new Response(e8?.toString(), n3);
        default:
          let i2 = JSON.stringify(e8);
          if (123 === i2.charCodeAt(0))
            return new Response(JSON.stringify(e8), { headers: { "Content-Type": "application/json" } });
          return new Response(i2);
      }
  };
  var mapEarlyResponse = (e8, n3) => {
    if (null != e8) {
      if (
        // @ts-ignore
        e8?.$passthrough && // @ts-ignore
        (e8 = e8[e8.$passthrough]), isNotEmpty(n3.headers) || 200 !== n3.status || n3.redirect || n3.cookie
      )
        switch ("string" == typeof n3.status && (n3.status = StatusMap[n3.status]), n3.redirect && (n3.headers.Location = n3.redirect, (!n3.status || n3.status < 300 || n3.status >= 400) && (n3.status = 302)), n3.cookie && isNotEmpty(n3.cookie) && (n3.headers["Set-Cookie"] = cookieToHeader(n3.cookie)), n3.headers["Set-Cookie"] && Array.isArray(n3.headers["Set-Cookie"]) && (n3.headers = parseSetCookies(new Headers(n3.headers), n3.headers["Set-Cookie"])), e8?.constructor?.name) {
          case "String":
          case "Blob":
            return new Response(e8, n3);
          case "Object":
          case "Array":
            return Response.json(e8, n3);
          case "ReadableStream":
            return n3.headers["content-type"]?.startsWith("text/event-stream") || (n3.headers["content-type"] = "text/event-stream; charset=utf-8"), new Response(e8, n3);
          case void 0:
            if (!e8)
              return;
            return Response.json(e8, n3);
          case "Response":
            let o = Object.assign({}, n3.headers);
            if (r4)
              n3.headers = e8.headers.toJSON();
            else
              for (let [s3, t5] of e8.headers.entries())
                s3 in n3.headers || (n3.headers[s3] = t5);
            for (let s3 in o)
              e8.headers.append(s3, o[s3]);
            return e8.status !== n3.status && (n3.status = e8.status), e8;
          case "Promise":
            return e8.then((e9) => {
              let s3 = mapEarlyResponse(e9, n3);
              if (void 0 !== s3)
                return s3;
            });
          case "Error":
            return errorToResponse(e8, n3);
          case "Function":
            return mapEarlyResponse(e8(), n3);
          case "Number":
          case "Boolean":
            return new Response(e8.toString(), n3);
          case "Cookie":
            if (e8 instanceof Cookie)
              return new Response(e8.value, n3);
            return new Response(e8?.toString(), n3);
          default:
            let a4 = JSON.stringify(e8);
            if (123 === a4.charCodeAt(0))
              return n3.headers["Content-Type"] || (n3.headers["Content-Type"] = "application/json"), new Response(JSON.stringify(e8), n3);
            return new Response(a4, n3);
        }
      else
        switch (e8?.constructor?.name) {
          case "String":
          case "Blob":
            return new Response(e8);
          case "Object":
          case "Array":
            return new Response(JSON.stringify(e8), { headers: { "content-type": "application/json" } });
          case "ReadableStream":
            return new Response(e8, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
          case void 0:
            if (!e8)
              return new Response("");
            return new Response(JSON.stringify(e8), { headers: { "content-type": "application/json" } });
          case "Response":
            return e8;
          case "Promise":
            return e8.then((e9) => {
              let s3 = mapEarlyResponse(e9, n3);
              if (void 0 !== s3)
                return s3;
            });
          case "Error":
            return errorToResponse(e8, n3);
          case "Function":
            return mapCompactResponse(e8());
          case "Number":
          case "Boolean":
            return new Response(e8.toString());
          case "Cookie":
            if (e8 instanceof Cookie)
              return new Response(e8.value, n3);
            return new Response(e8?.toString(), n3);
          default:
            let i2 = JSON.stringify(e8);
            if (123 === i2.charCodeAt(0))
              return new Response(JSON.stringify(e8), { headers: { "Content-Type": "application/json" } });
            return new Response(i2);
        }
    }
  };
  var mapCompactResponse = (e8) => {
    switch (
      // @ts-ignore
      e8?.$passthrough && // @ts-ignore
      (e8 = e8[e8.$passthrough]), e8?.constructor?.name
    ) {
      case "String":
      case "Blob":
        return new Response(e8);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(e8), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response(e8, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case void 0:
        if (!e8)
          return new Response("");
        return new Response(JSON.stringify(e8), { headers: { "content-type": "application/json" } });
      case "Response":
        return e8;
      case "Error":
        return errorToResponse(e8);
      case "Promise":
        return e8.then((e9) => {
          let s4 = mapCompactResponse(e9);
          return void 0 !== s4 ? s4 : new Response("");
        });
      case "Function":
        return mapCompactResponse(e8());
      case "Number":
      case "Boolean":
        return new Response(e8.toString());
      default:
        let s3 = JSON.stringify(e8);
        if (123 === s3.charCodeAt(0))
          return new Response(JSON.stringify(e8), { headers: { "Content-Type": "application/json" } });
        return new Response(s3);
    }
  };
  var errorToResponse = (e8, s3) => new Response(JSON.stringify({ name: e8?.name, message: e8?.message, cause: e8?.cause }), { status: s3?.status !== 200 ? s3?.status ?? 500 : 500, headers: s3?.headers });

  // ../node_modules/elysia/dist/compose.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_fast_querystring = __toESM(require_lib());
  var u = new Headers().toJSON;
  var d = RegExp(" (\\w+) = context", "g");
  var p = { value: 0 };
  var m = ({ hasTrace: e8, hasTraceSet: t5 = false, addFn: r6, condition: s3 = {} }) => (r6(`
const reporter = getReporter()
`), e8) ? (e9, { name: n3, attribute: o = "", unit: a4 = 0 } = {}) => {
    let i2 = e9.indexOf("."), c2 = -1 === i2;
    if ("request" !== e9 && "response" !== e9 && !s3[c2 ? e9 : e9.slice(0, i2)])
      return () => {
        t5 && "afterHandle" === e9 && r6("\nawait traceDone\n");
      };
    c2 ? n3 ||= e9 : n3 ||= "anonymous", r6("\n" + `reporter.emit('event', { 
					id,
					event: '${e9}',
					type: 'begin',
					name: '${n3}',
					time: performance.now(),
					${c2 ? `unit: ${a4},` : ""}
					${o}
				})`.replace(/(\t| |\n)/g, "") + "\n");
    let l = false;
    return () => {
      !l && (l = true, r6("\n" + `reporter.emit('event', {
							id,
							event: '${e9}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), t5 && "afterHandle" === e9 && r6("\nawait traceDone\n"));
    };
  } : () => () => {
  };
  var hasReturn = (e8) => {
    let t5 = e8.indexOf(")");
    return (
      // Is direct arrow function return eg. () => 1
      61 === e8.charCodeAt(t5 + 2) && 123 !== e8.charCodeAt(t5 + 5) || e8.includes("return")
    );
  };
  var h = (e8, { injectResponse: t5 = "" } = {}) => ({ composeValidation: (t6, r6 = `c.${t6}`) => e8 ? `c.set.status = 400; throw new ValidationError(
'${t6}',
${t6},
${r6}
)` : `c.set.status = 400; return new ValidationError(
	'${t6}',
	${t6},
	${r6}
).toResponse(c.set.headers)`, composeResponseValidation: (r6 = "r") => {
    let s3 = e8 ? `throw new ValidationError(
'response',
response[c.set.status],
${r6}
)` : `return new ValidationError(
'response',
response[c.set.status],
${r6}
).toResponse(c.set.headers)`;
    return `
${t5}
		if(response[c.set.status]?.Check(${r6}) === false) { 
	if(!(response instanceof Error))
		${s3}
}
`;
  } });
  var isFnUse = (e8, t5) => {
    t5 = (t5 = t5.trimStart()).replaceAll(/^async /g, ""), /^(\w+)\(/g.test(t5) && (t5 = t5.slice(t5.indexOf("(")));
    let r6 = (
      // CharCode 40 is '('
      40 === t5.charCodeAt(0) || t5.startsWith("function") ? t5.slice(t5.indexOf("(") + 1, t5.indexOf(")")) : t5.slice(0, t5.indexOf("=") - 1)
    );
    if ("" === r6)
      return false;
    let s3 = 123 === r6.charCodeAt(0) ? r6.indexOf("...") : -1;
    if (123 === r6.charCodeAt(0)) {
      if (r6.includes(e8))
        return true;
      if (-1 === s3)
        return false;
    }
    if (t5.match(RegExp(`${r6}(.${e8}|\\["${e8}"\\])`)))
      return true;
    let n3 = -1 !== s3 ? r6.slice(s3 + 3, r6.indexOf(" ", s3 + 3)) : void 0;
    if (t5.match(RegExp(`${n3}(.${e8}|\\["${e8}"\\])`)))
      return true;
    let o = [r6];
    for (let e9 of (n3 && o.push(n3), t5.matchAll(d)))
      o.push(e9[1]);
    let a4 = RegExp(`{.*?} = (${o.join("|")})`, "g");
    for (let [r7] of t5.matchAll(a4))
      if (r7.includes(`{ ${e8}`) || r7.includes(`, ${e8}`))
        return true;
    return false;
  };
  var y = (e8) => {
    e8 = (e8 = e8.trimStart()).replaceAll(/^async /g, ""), /^(\w+)\(/g.test(e8) && (e8 = e8.slice(e8.indexOf("(")));
    let t5 = (
      // CharCode 40 is '('
      40 === e8.charCodeAt(0) || e8.startsWith("function") ? e8.slice(e8.indexOf("(") + 1, e8.indexOf(")")) : e8.slice(0, e8.indexOf("=") - 1)
    );
    if ("" === t5)
      return false;
    let r6 = 123 === t5.charCodeAt(0) ? t5.indexOf("...") : -1, s3 = -1 !== r6 ? t5.slice(r6 + 3, t5.indexOf(" ", r6 + 3)) : void 0, n3 = [t5];
    for (let t6 of (s3 && n3.push(s3), e8.matchAll(d)))
      n3.push(t6[1]);
    for (let t6 of n3)
      if (RegExp(`\\b\\w+\\([^)]*\\b${t6}\\b[^)]*\\)`).test(e8))
        return true;
    let o = RegExp(`{.*?} = (${n3.join("|")})`, "g");
    for (let [t6] of e8.matchAll(o))
      if (RegExp(`\\b\\w+\\([^)]*\\b${t6}\\b[^)]*\\)`).test(e8))
        return true;
    return false;
  };
  var $ = Symbol.for("TypeBox.Kind");
  var hasType = (e8, t5) => {
    if (t5) {
      if ($ in t5 && t5[$] === e8)
        return true;
      if ("object" === t5.type) {
        let r6 = t5.properties;
        for (let t6 of Object.keys(r6)) {
          let s3 = r6[t6];
          if ("object" === s3.type) {
            if (hasType(e8, s3))
              return true;
          } else if (s3.anyOf) {
            for (let t7 = 0; t7 < s3.anyOf.length; t7++)
              if (hasType(e8, s3.anyOf[t7]))
                return true;
          }
          if ($ in s3 && s3[$] === e8)
            return true;
        }
        return false;
      }
      return t5.properties && $ in t5.properties && t5.properties[$] === e8;
    }
  };
  var g = Symbol.for("TypeBox.Transform");
  var hasTransform = (e8) => {
    if (e8) {
      if ("object" === e8.type && e8.properties) {
        let t5 = e8.properties;
        for (let e9 of Object.keys(t5)) {
          let r6 = t5[e9];
          if ("object" === r6.type) {
            if (hasTransform(r6))
              return true;
          } else if (r6.anyOf) {
            for (let e10 = 0; e10 < r6.anyOf.length; e10++)
              if (hasTransform(r6.anyOf[e10]))
                return true;
          }
          let s3 = g in r6;
          if (s3)
            return true;
        }
        return false;
      }
      return g in e8 || e8.properties && g in e8.properties;
    }
  };
  var b = (e8) => {
    if (!e8)
      return;
    let t5 = e8?.schema;
    if (t5 && "anyOf" in t5) {
      let e9 = false, r6 = t5.anyOf[0].type;
      for (let s3 of t5.anyOf)
        if (s3.type !== r6) {
          e9 = true;
          break;
        }
      if (!e9)
        return r6;
    }
    return e8.schema?.type;
  };
  var k = /(?:return|=>) \S*\(/g;
  var isAsync = (e8) => "AsyncFunction" === e8.constructor.name || e8.toString().match(k);
  var composeHandler = ({ path: d2, method: $2, hooks: g2, validator: k2, handler: w, handleError: R, definitions: x2, schema: q, onRequest: H, config: E, getReporter: v }) => {
    let O = E.forceErrorEncapsulation || g2.error.length > 0 || "undefined" == typeof Bun || g2.onResponse.length > 0 || !!g2.trace.length, A = g2.onResponse.length ? `
;(async () => {${g2.onResponse.map((e8, t5) => `await res${t5}(c)`).join(";")}})();
` : "", C = g2.trace.map((e8) => e8.toString()), F = false;
    if (y(w.toString()) && (F = true), !F) {
      for (let [e8, t5] of Object.entries(g2))
        if (Array.isArray(t5) && t5.length && ["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(e8)) {
          for (let e9 of t5)
            if ("function" == typeof e9 && y(e9.toString())) {
              F = true;
              break;
            }
          if (F)
            break;
        }
    }
    let j = { parse: C.some((e8) => isFnUse("parse", e8)), transform: C.some((e8) => isFnUse("transform", e8)), handle: C.some((e8) => isFnUse("handle", e8)), beforeHandle: C.some((e8) => isFnUse("beforeHandle", e8)), afterHandle: C.some((e8) => isFnUse("afterHandle", e8)), error: O || C.some((e8) => isFnUse("error", e8)) }, T = g2.trace.length > 0, S = "", U = k2 || "GET" !== $2 && "HEAD" !== $2 ? [w, ...g2.transform, ...g2.beforeHandle, ...g2.afterHandle].map((e8) => e8.toString()) : [], D = F || "GET" !== $2 && "HEAD" !== $2 && "none" !== g2.type && (!!k2.body || !!g2.type || U.some((e8) => isFnUse("body", e8))), V = F || k2.headers || U.some((e8) => isFnUse("headers", e8)), N = F || k2.cookie || U.some((e8) => isFnUse("cookie", e8)), _ = k2?.cookie?.schema, I = "";
    if (_?.sign) {
      if (!_.secrets)
        throw Error(`t.Cookie required secret which is not set in (${$2}) ${d2}.`);
      let e8 = _.secrets ? "string" == typeof _.secrets ? _.secrets : _.secrets[0] : void 0;
      if (I += `const _setCookie = c.set.cookie
		if(_setCookie) {`, true === _.sign)
        I += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${e8}')
			}`;
      else
        for (let t5 of _.sign)
          I += `if(_setCookie['${t5}']?.value) { c.set.cookie['${t5}'].value = await signCookie(_setCookie['${t5}'].value, '${e8}') }
`;
      I += "}\n";
    }
    let { composeValidation: B, composeResponseValidation: W } = h(O);
    if (V && // This function is Bun specific
    // @ts-ignore
    (S += u ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`), N) {
      let e8 = (e9, t6) => {
        let r6 = _?.[e9] ?? t6;
        return r6 ? "string" == typeof r6 ? `${e9}: '${r6}',` : r6 instanceof Date ? `${e9}: new Date(${r6.getTime()}),` : `${e9}: ${r6},` : "string" == typeof t6 ? `${e9}: "${t6}",` : `${e9}: ${t6},`;
      }, t5 = _ ? `{
			secret: ${void 0 !== _.secrets ? "string" == typeof _.secrets ? `'${_.secrets}'` : "[" + _.secrets.reduce((e9, t6) => e9 + `'${t6}',`, "") + "]" : "undefined"},
			sign: ${true === _.sign || (void 0 !== _.sign ? "[" + _.sign.reduce((e9, t6) => e9 + `'${t6}',`, "") + "]" : "undefined")},
			${e8("domain")}
			${e8("expires")}
			${e8("httpOnly")}
			${e8("maxAge")}
			${e8("path", "/")}
			${e8("priority")}
			${e8("sameSite")}
			${e8("secure")}
		}` : "undefined";
      V ? S += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${t5})
` : S += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${t5})
`;
    }
    let G = F || k2.query || U.some((e8) => isFnUse("query", e8));
    G && (S += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`);
    let L = g2.trace.map((e8) => e8.toString()), P = L.some((e8) => isFnUse("set", e8) || y(e8));
    F || g2.trace.some((e8) => isFnUse("set", e8.toString()));
    let Q = P || N || U.some((e8) => isFnUse("set", e8)) || H.some((e8) => isFnUse("set", e8.toString()));
    T && (S += "\nconst id = c.$$requestId\n");
    let K = m({ hasTrace: T, hasTraceSet: P, condition: j, addFn: (e8) => {
      S += e8;
    } });
    S += O ? "try {\n" : "", T && (S += "\nconst traceDone = new Promise(r => { reporter.once(`res${id}`, r) })\n");
    let J = N || D || P || isAsync(w) || g2.parse.length > 0 || g2.afterHandle.some(isAsync) || g2.beforeHandle.some(isAsync) || g2.transform.some(isAsync), z2 = K("parse", { unit: g2.parse.length });
    if (D) {
      let e8 = b(k2?.body);
      if (g2.type && !Array.isArray(g2.type)) {
        if (g2.type)
          switch (g2.type) {
            case "json":
            case "application/json":
              S += `c.body = await c.request.json()
`;
              break;
            case "text":
            case "text/plain":
              S += `c.body = await c.request.text()
`;
              break;
            case "urlencoded":
            case "application/x-www-form-urlencoded":
              S += `c.body = parseQuery(await c.request.text())
`;
              break;
            case "arrayBuffer":
            case "application/octet-stream":
              S += `c.body = await c.request.arrayBuffer()
`;
              break;
            case "formdata":
            case "multipart/form-data":
              S += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`;
          }
        g2.parse.length && (S += "}}");
      } else {
        let t5 = (() => {
          if (g2.parse.length && e8 && !Array.isArray(g2.type)) {
            let t6 = k2?.body?.schema;
            if ("object" === e8 && (hasType("File", t6) || hasType("Files", t6)))
              return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
          }
        })();
        if (t5)
          S += t5;
        else {
          if (S += "\n" + (V ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')") + `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)
`, g2.parse.length) {
            S += `let used = false
`;
            let e9 = K("parse", { unit: g2.parse.length });
            for (let e10 = 0; e10 < g2.parse.length; e10++) {
              let t6 = K("parse.unit", { name: g2.parse[e10].name }), r6 = `bo${e10}`;
              0 !== e10 && (S += `if(!used) {
`), S += `let ${r6} = parse[${e10}](c, contentType)
if(${r6} instanceof Promise) ${r6} = await ${r6}
if(${r6} !== undefined) { c.body = ${r6}; used = true }
`, t6(), 0 !== e10 && (S += "}");
            }
            e9();
          }
          g2.parse.length && (S += "if (!used)"), S += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}
}
`;
        }
      }
      S += "\n";
    }
    if (z2(), g2?.transform) {
      let e8 = K("transform", { unit: g2.transform.length });
      for (let e9 = 0; e9 < g2.transform.length; e9++) {
        let t5 = g2.transform[e9], r6 = K("transform.unit", { name: t5.name });
        "derive" === t5.$elysia ? S += isAsync(g2.transform[e9]) ? `Object.assign(c, await transform[${e9}](c));` : `Object.assign(c, transform[${e9}](c));` : S += isAsync(g2.transform[e9]) ? `await transform[${e9}](c);` : `transform[${e9}](c);`, r6();
      }
      e8();
    }
    if (k2 && (S += "\n", k2.headers && (S += `if(headers.Check(c.headers) === false) {
				${B("headers")}
			}`, hasTransform(k2.headers.schema) && (S += `
c.headers = headers.Decode(c.headers)
`)), k2.params && (S += `if(params.Check(c.params) === false) {
				${B("params")}
			}`, hasTransform(k2.params.schema) && (S += `
c.params = params.Decode(c.params)
`)), k2.query && (S += `if(query.Check(c.query) === false) {
				${B("query")} 
			}`, hasTransform(k2.query.schema) && // Decode doesn't work with Object.create(null)
    (S += `
c.query = query.Decode(Object.assign({}, c.query))
`)), k2.body && (S += `if(body.Check(c.body) === false) { 
				${B("body")}
			}`, hasTransform(k2.body.schema) && (S += `
c.body = body.Decode(c.body)
`)), isNotEmpty(k2.cookie?.schema.properties ?? {}) && (S += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${B("cookie", "cookieValue")}
			}`, hasTransform(k2.cookie.schema) && (S += `
c.cookie = params.Decode(c.cookie)
`))), g2?.beforeHandle) {
      let e8 = K("beforeHandle", { unit: g2.beforeHandle.length });
      for (let e9 = 0; e9 < g2.beforeHandle.length; e9++) {
        let t5 = K("beforeHandle.unit", { name: g2.beforeHandle[e9].name }), r6 = `be${e9}`, s3 = hasReturn(g2.beforeHandle[e9].toString());
        if (s3) {
          S += isAsync(g2.beforeHandle[e9]) ? `let ${r6} = await beforeHandle[${e9}](c);
` : `let ${r6} = beforeHandle[${e9}](c);
`, t5(), S += `if(${r6} !== undefined) {
`;
          let s4 = K("afterHandle", { unit: g2.transform.length });
          if (g2.afterHandle)
            for (let e10 = 0; e10 < g2.afterHandle.length; e10++) {
              let t6 = hasReturn(g2.afterHandle[e10].toString()), s5 = K("afterHandle.unit", { name: g2.afterHandle[e10].name });
              if (S += `c.response = ${r6}
`, t6) {
                let t7 = `af${e10}`;
                S += (isAsync(g2.afterHandle[e10]) ? `const ${t7} = await afterHandle[${e10}](c);
` : `const ${t7} = afterHandle[${e10}](c);
`) + `if(${t7} !== undefined) { c.response = ${r6} = ${t7} }
`;
              } else
                S += isAsync(g2.afterHandle[e10]) ? `await afterHandle[${e10}](c, ${r6});
` : `afterHandle[${e10}](c, ${r6});
`;
              s5();
            }
          s4(), k2.response && (S += W(r6)), S += I + `return mapEarlyResponse(${r6}, c.set)}
`;
        } else
          S += isAsync(g2.beforeHandle[e9]) ? `await beforeHandle[${e9}](c);
` : `beforeHandle[${e9}](c);
`, t5();
      }
      e8();
    }
    if (g2?.afterHandle.length) {
      let e8 = K("handle", { name: w.name });
      g2.afterHandle.length ? S += isAsync(w) ? `let r = c.response = await handler(c);
` : `let r = c.response = handler(c);
` : S += isAsync(w) ? `let r = await handler(c);
` : `let r = handler(c);
`, e8();
      let t5 = K("afterHandle", { unit: g2.afterHandle.length });
      for (let e9 = 0; e9 < g2.afterHandle.length; e9++) {
        let r6 = `af${e9}`, s3 = hasReturn(g2.afterHandle[e9].toString()), n3 = K("afterHandle.unit", { name: g2.afterHandle[e9].name });
        s3 ? (k2.response ? S += isAsync(g2.afterHandle[e9]) ? `let ${r6} = await afterHandle[${e9}](c)
` : `let ${r6} = afterHandle[${e9}](c)
` : S += isAsync(g2.afterHandle[e9]) ? `let ${r6} = mapEarlyResponse(await afterHandle[${e9}](c), c.set)
` : `let ${r6} = mapEarlyResponse(afterHandle[${e9}](c), c.set)
`, n3(), k2.response ? (S += `if(${r6} !== undefined) {` + W(r6) + `${r6} = mapEarlyResponse(${r6}, c.set)
if(${r6}) {`, t5(), P && (S += `${r6} = mapEarlyResponse(${r6}, c.set)
`), S += `return ${r6} } }`) : (S += `if(${r6}) {`, t5(), P && (S += `${r6} = mapEarlyResponse(${r6}, c.set)
`), S += `return ${r6}}
`)) : (S += isAsync(g2.afterHandle[e9]) ? `await afterHandle[${e9}](c)
` : `afterHandle[${e9}](c)
`, n3());
      }
      t5(), S += `r = c.response
`, k2.response && (S += W()), S += I, Q ? S += `return mapResponse(r, c.set)
` : S += `return mapCompactResponse(r)
`;
    } else {
      let e8 = K("handle", { name: w.name });
      if (k2.response)
        S += isAsync(w) ? `const r = await handler(c);
` : `const r = handler(c);
`, e8(), S += W(), K("afterHandle")(), S += I, Q ? S += `return mapResponse(r, c.set)
` : S += `return mapCompactResponse(r)
`;
      else if (j.handle || N)
        S += isAsync(w) ? `let r = await handler(c);
` : `let r = handler(c);
`, e8(), K("afterHandle")(), S += I, Q ? S += `return mapResponse(r, c.set)
` : S += `return mapCompactResponse(r)
`;
      else {
        e8();
        let t5 = isAsync(w) ? "await handler(c) " : "handler(c)";
        K("afterHandle")(), Q ? S += `return mapResponse(${t5}, c.set)
` : S += `return mapCompactResponse(${t5})
`;
      }
    }
    if (O || A) {
      S += `
} catch(error) {`, J || (S += "return (async () => {"), S += `const set = c.set

		if (!set.status || set.status < 300) set.status = 500
	`;
      let e8 = K("error", { unit: g2.error.length });
      if (g2.error.length)
        for (let e9 = 0; e9 < g2.error.length; e9++) {
          let t5 = `er${e9}`, r6 = K("error.unit", { name: g2.error[e9].name });
          S += `
let ${t5} = handleErrors[${e9}](
					Object.assign(c, {
						error: error,
						code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
					})
				)
`, isAsync(g2.error[e9]) && (S += `if (${t5} instanceof Promise) ${t5} = await ${t5}
`), r6(), S += `${t5} = mapEarlyResponse(${t5}, set)
if (${t5}) {return ${t5} }
`;
        }
      if (e8(), S += `return handleError(c, error)

`, J || (S += "})()"), S += "}", A || T) {
        S += " finally { ";
        let e9 = K("response", { unit: g2.onResponse.length });
        S += A, e9(), S += "}";
      }
    }
    S = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${g2.onResponse.length ? `const ${g2.onResponse.map((e8, t5) => `res${t5} = onResponse[${t5}]`).join(",")}` : ""}

	return ${J ? "async" : ""} function(c) {
		${q && x2 ? "c.schema = schema; c.defs = definitions;" : ""}
		${S}
	}`;
    let M = Function("hooks", S);
    return M({ handler: w, hooks: g2, validator: k2, handleError: R, utils: { mapResponse, mapCompactResponse, mapEarlyResponse, parseQuery: import_fast_querystring.parse }, error: { NotFoundError: NotFoundError2, ValidationError, InternalServerError }, schema: q, definitions: x2, ERROR_CODE, getReporter: v, requestId: p, parseCookie, signCookie });
  };
  var composeGeneralHandler = (e8) => {
    let t5 = "", s3 = "";
    for (let r6 of Object.keys(e8.decorators))
      t5 += `,${r6}: app.decorators.${r6}`;
    let { router: n3, staticRouter: o } = e8, i2 = e8.event.trace.length > 0, c2 = `
	const route = find(request.method, path) ${n3.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${e8.event.error.length ? "app.handleError(ctx, notFound)" : `new Response(error404, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`}

	ctx.params = route.params

	return route.store(ctx)`, l = "";
    for (let [e9, { code: t6, all: r6 }] of Object.entries(o.map))
      l += `case '${e9}':
switch(request.method) {
${t6}
${r6 ?? "default: break map"}}

`;
    let f = e8.event.request.some(isAsync);
    s3 += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter
	} = data

	const notFound = new NotFoundError()

	${e8.event.request.length ? "const onRequest = app.event.request" : ""}

	${o.variables}

	const find = router.find.bind(router)
	const findWs = wsRouter.find.bind(wsRouter)
	const handleError = app.handleError.bind(this)

	${e8.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return ${f ? "async" : ""} function map(request) {
	`;
    let u2 = e8.event.trace.map((e9) => e9.toString()), d2 = m({ hasTrace: i2, hasTraceSet: e8.event.trace.some((e9) => {
      let t6 = e9.toString();
      return isFnUse("set", t6) || y(t6);
    }), condition: { request: u2.some((e9) => isFnUse("request", e9) || y(e9)) }, addFn: (e9) => {
      s3 += e9;
    } });
    if (e8.event.request.length) {
      s3 += `
			${i2 ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${i2 ? ",$$requestId: +id" : ""}
				${t5}
			}
		`;
      let r6 = d2("request", { attribute: "ctx", unit: e8.event.request.length });
      s3 += `try {
`;
      for (let t6 = 0; t6 < e8.event.request.length; t6++) {
        let r7 = e8.event.request[t6], n4 = hasReturn(r7.toString()), o2 = isAsync(r7), a4 = d2("request.unit", { name: e8.event.request[t6].name }), i3 = `re${t6}`;
        n4 ? (s3 += `const ${i3} = mapEarlyResponse(
					${o2 ? "await" : ""} onRequest[${t6}](ctx),
					ctx.set
				)
`, a4(), s3 += `if(${i3}) return ${i3}
`) : (s3 += `${o2 ? "await" : ""} onRequest[${t6}](ctx)
`, a4());
      }
      s3 += `} catch (error) {
			return app.handleError(ctx, error)
		}`, r6(), s3 += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
    } else
      s3 += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${i2 ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${i2 ? ",$$requestId: id" : ""}
			${t5}
		}`, d2("request", { unit: e8.event.request.length, attribute: u2.some((e9) => isFnUse("context", e9)) || u2.some((e9) => isFnUse("store", e9)) || u2.some((e9) => isFnUse("set", e9)) ? "ctx" : "" })();
    let h2 = e8.wsPaths, $2 = e8.wsRouter;
    if (Object.keys(h2).length || $2.history.length) {
      for (let [e9, t6] of (s3 += `
			if(request.method === 'GET') {
				switch(path) {`, Object.entries(h2)))
        s3 += `
					case '${e9}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${t6}(ctx)
							
						break`;
      s3 += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = findWs('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}
`;
    }
    return s3 += `
		map: switch(path) {
			${l}

			default:
				break
		}

		${c2}
	}`, // @ts-ignore
    e8.handleError = composeErrorHandler(e8), Function("data", s3)({
      app: e8,
      mapEarlyResponse,
      NotFoundError: NotFoundError2,
      // @ts-ignore
      getReporter: () => e8.reporter,
      requestId: p
    });
  };
  var composeErrorHandler = (e8) => {
    let t5 = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${e8.event.error.find(isAsync) ? "async" : ""} function(context, error) {
		const { set } = context
		`;
    for (let r6 = 0; r6 < e8.event.error.length; r6++) {
      let s3 = e8.event.error[r6], n3 = `${isAsync(s3) ? "await " : ""}onError[${r6}](
			Object.assign(context, {
				code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
				error
			})
		)`;
      hasReturn(s3.toString()) ? t5 += `const r${r6} = ${n3}; if(r${r6} !== undefined) return mapResponse(r${r6}, set)
` : t5 += n3 + "\n";
    }
    return Function("inject", t5 += `if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`)({ app: e8, mapResponse, ERROR_CODE });
  };

  // ../node_modules/elysia/dist/dynamic-handle.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_fast_querystring2 = __toESM(require_lib());
  var createDynamicHandler = (n3) => async (l) => {
    let f;
    let c2 = { cookie: {}, status: 200, headers: {} };
    n3.decorators ? (
      // @ts-ignore
      ((f = n3.decorators).request = l, f.set = c2, f.store = n3.store)
    ) : f = { set: c2, store: n3.store, request: l };
    let d2 = l.url, u2 = d2.indexOf("/", 11), h2 = d2.indexOf("?", u2 + 1), m2 = -1 === h2 ? d2.substring(u2) : d2.substring(u2, h2);
    try {
      let u3;
      for (let t5 = 0; t5 < n3.event.request.length; t5++) {
        let r6 = n3.event.request[t5], a4 = r6(f);
        if (a4 instanceof Promise && (a4 = await a4), a4 = mapEarlyResponse(a4, c2))
          return a4;
      }
      let p2 = (
        // @ts-ignore
        n3.dynamicRouter.find(l.method, m2) ?? // @ts-ignore
        n3.dynamicRouter.find("ALL", m2)
      );
      if (!p2)
        throw new NotFoundError2();
      let { handle: w, hooks: g2, validator: k2, content: y2 } = p2.store;
      if ("GET" !== l.method && "HEAD" !== l.method) {
        if (y2)
          switch (y2) {
            case "application/json":
              u3 = await l.json();
              break;
            case "text/plain":
              u3 = await l.text();
              break;
            case "application/x-www-form-urlencoded":
              u3 = (0, import_fast_querystring2.parse)(await l.text());
              break;
            case "application/octet-stream":
              u3 = await l.arrayBuffer();
              break;
            case "multipart/form-data":
              u3 = {};
              let e8 = await l.formData();
              for (let t5 of e8.keys()) {
                if (u3[t5])
                  continue;
                let r6 = e8.getAll(t5);
                1 === r6.length ? u3[t5] = r6[0] : u3[t5] = r6;
              }
          }
        else {
          let e8 = l.headers.get("content-type");
          if (e8) {
            let t5 = e8.indexOf(";");
            -1 !== t5 && (e8 = e8.slice(0, t5));
            for (let t6 = 0; t6 < n3.event.parse.length; t6++) {
              let r6 = n3.event.parse[t6](f, e8);
              if (r6 instanceof Promise && (r6 = await r6), r6) {
                u3 = r6;
                break;
              }
            }
            if (void 0 === u3)
              switch (e8) {
                case "application/json":
                  u3 = await l.json();
                  break;
                case "text/plain":
                  u3 = await l.text();
                  break;
                case "application/x-www-form-urlencoded":
                  u3 = (0, import_fast_querystring2.parse)(await l.text());
                  break;
                case "application/octet-stream":
                  u3 = await l.arrayBuffer();
                  break;
                case "multipart/form-data":
                  u3 = {};
                  let r6 = await l.formData();
                  for (let e9 of r6.keys()) {
                    if (u3[e9])
                      continue;
                    let t6 = r6.getAll(e9);
                    1 === t6.length ? u3[e9] = t6[0] : u3[e9] = t6;
                  }
              }
          }
        }
      }
      for (let [e8, t5] of (f.body = u3, // @ts-ignore
      f.params = p2?.params || void 0, f.query = -1 === h2 ? {} : (0, import_fast_querystring2.parse)(d2.substring(h2 + 1)), f.headers = {}, l.headers.entries()))
        f.headers[e8] = t5;
      let v = k2?.cookie?.schema;
      f.cookie = await parseCookie(f.set, f.headers.cookie, v ? { secret: void 0 !== v.secrets ? "string" == typeof v.secrets ? v.secrets : v.secrets.join(",") : void 0, sign: true === v.sign || (void 0 !== v.sign ? "string" == typeof v.sign ? v.sign : v.sign.join(",") : void 0) } : void 0);
      for (let e8 = 0; e8 < g2.transform.length; e8++) {
        let t5 = g2.transform[e8](f);
        "derive" === g2.transform[e8].$elysia ? t5 instanceof Promise ? Object.assign(f, await t5) : Object.assign(f, t5) : t5 instanceof Promise && await t5;
      }
      if (k2) {
        if (k2.headers) {
          let e8 = {};
          for (let t5 in l.headers)
            e8[t5] = l.headers.get(t5);
          if (false === k2.headers.Check(e8))
            throw new ValidationError("header", k2.headers, e8);
        }
        if (k2.params?.Check(f.params) === false)
          throw new ValidationError("params", k2.params, f.params);
        if (k2.query?.Check(f.query) === false)
          throw new ValidationError("query", k2.query, f.query);
        if (k2.cookie) {
          let e8 = {};
          for (let [t5, r6] of Object.entries(f.cookie))
            e8[t5] = r6.value;
          if (k2.cookie?.Check(e8) === false)
            throw new ValidationError("cookie", k2.cookie, e8);
        }
        if (k2.body?.Check(u3) === false)
          throw new ValidationError("body", k2.body, u3);
      }
      for (let t5 = 0; t5 < g2.beforeHandle.length; t5++) {
        let r6 = g2.beforeHandle[t5](f);
        if (r6 instanceof Promise && (r6 = await r6), void 0 !== r6) {
          f.response = r6;
          for (let e8 = 0; e8 < g2.afterHandle.length; e8++) {
            let t7 = g2.afterHandle[e8](f);
            t7 instanceof Promise && (t7 = await t7), t7 && (r6 = t7);
          }
          let t6 = mapEarlyResponse(r6, f.set);
          if (t6)
            return t6;
        }
      }
      let b2 = w(f);
      if (b2 instanceof Promise && (b2 = await b2), g2.afterHandle.length) {
        f.response = b2;
        for (let t5 = 0; t5 < g2.afterHandle.length; t5++) {
          let r6 = g2.afterHandle[t5](f);
          r6 instanceof Promise && (r6 = await r6);
          let s3 = mapEarlyResponse(r6, f.set);
          if (void 0 !== s3) {
            let e8 = k2?.response?.[b2.status];
            if (e8?.Check(s3) === false)
              throw new ValidationError("response", e8, s3);
            return s3;
          }
        }
      } else {
        let e8 = k2?.response?.[b2.status];
        if (e8?.Check(b2) === false)
          throw new ValidationError("response", e8, b2);
      }
      if (f.set.cookie && v?.sign) {
        let e8 = v.secrets ? "string" == typeof v.secrets ? v.secrets : v.secrets[0] : void 0;
        if (true === v.sign)
          for (let [e9, t5] of Object.entries(f.set.cookie))
            f.set.cookie[e9].value = await signCookie(t5.value, "${secret}");
        else
          for (let t5 of v.sign)
            t5 in v.properties && f.set.cookie[t5]?.value && (f.set.cookie[t5].value = await signCookie(f.set.cookie[t5].value, e8));
      }
      return mapResponse(b2, f.set);
    } catch (e8) {
      return e8.status && (c2.status = e8.status), n3.handleError(f, e8);
    } finally {
      for (let e8 of n3.event.onResponse)
        await e8(f);
    }
  };
  var createDynamicErrorHandler = (e8) => async (r6, a4) => {
    let s3 = Object.assign(r6, a4);
    s3.set = r6.set;
    for (let a5 = 0; a5 < e8.event.error.length; a5++) {
      let o = e8.event.error[a5](s3);
      if (o instanceof Promise && (o = await o), null != o)
        return mapResponse(o, r6.set);
    }
    return new Response("string" == typeof a4.cause ? a4.cause : a4.message, { headers: r6.set.headers, status: a4.status ?? 500 });
  };

  // ../node_modules/elysia/dist/custom-types.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_system = __toESM(require_system2());
  var import_typebox2 = __toESM(require_typebox());
  try {
    import_system.TypeSystem.Format("email", (e8) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(e8)), import_system.TypeSystem.Format("uuid", (e8) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e8)), import_system.TypeSystem.Format("date", (e8) => !Number.isNaN(new Date(e8).getTime())), import_system.TypeSystem.Format("date-time", (e8) => !Number.isNaN(new Date(e8).getTime()));
  } catch (e8) {
  }
  var r5 = (e8) => {
    if ("string" == typeof e8)
      switch (e8.slice(-1)) {
        case "k":
          return 1024 * +e8.slice(0, e8.length - 1);
        case "m":
          return 1048576 * +e8.slice(0, e8.length - 1);
        default:
          return +e8;
      }
    return e8;
  };
  var n2 = (e8, t5) => {
    if (!(t5 instanceof Blob) || e8.minSize && t5.size < r5(e8.minSize) || e8.maxSize && t5.size > r5(e8.maxSize))
      return false;
    if (e8.extension) {
      if ("string" == typeof e8.extension) {
        if (!t5.type.startsWith(e8.extension))
          return false;
      } else {
        for (let i2 = 0; i2 < e8.extension.length; i2++)
          if (t5.type.startsWith(e8.extension[i2]))
            return true;
        return false;
      }
    }
    return true;
  };
  var a3 = import_system.TypeSystem.Type("Files", (e8, t5) => {
    if (!Array.isArray(t5))
      return n2(e8, t5);
    if (e8.minItems && t5.length < e8.minItems || e8.maxItems && t5.length > e8.maxItems)
      return false;
    for (let i2 = 0; i2 < t5.length; i2++)
      if (!n2(e8, t5[i2]))
        return false;
    return true;
  });
  import_typebox2.FormatRegistry.Set("numeric", (e8) => !isNaN(+e8)), import_typebox2.FormatRegistry.Set("ObjectString", (e8) => {
    let t5 = e8.charCodeAt(0);
    if ((9 === t5 || 10 === t5 || 32 === t5) && (t5 = e8.trimStart().charCodeAt(0)), 123 !== t5 && 91 !== t5)
      return false;
    try {
      return JSON.parse(e8), true;
    } catch {
      return false;
    }
  });
  var ElysiaType = {
    Numeric: (e8) => import_typebox2.Type.Transform(import_typebox2.Type.Union([import_typebox2.Type.String({ format: "numeric", default: 0 }), import_typebox2.Type.Number(e8)])).Decode((e9) => {
      let t5 = +e9;
      return isNaN(t5) ? e9 : t5;
    }).Encode((e9) => e9),
    ObjectString: (e8, i2) => import_typebox2.Type.Transform(import_typebox2.Type.Union([import_typebox2.Type.String({ format: "ObjectString", default: "" }), import_typebox2.Type.Object(e8, i2)])).Decode((e9) => {
      if ("string" == typeof e9)
        try {
          return JSON.parse(e9);
        } catch {
        }
      return e9;
    }).Encode((e9) => JSON.stringify(e9)),
    File: import_system.TypeSystem.Type("File", n2),
    Files: (e8 = {}) => import_typebox2.Type.Transform(import_typebox2.Type.Union([a3(e8)])).Decode((e9) => Array.isArray(e9) ? e9 : [e9]).Encode((e9) => e9),
    Nullable: (e8) => import_typebox2.Type.Union([import_typebox2.Type.Null(), e8]),
    /**
    * Allow Optional, Nullable and Undefined
    */
    MaybeEmpty: (e8) => import_typebox2.Type.Union([import_typebox2.Type.Null(), import_typebox2.Type.Undefined(), e8]),
    Cookie: (e8, i2) => import_typebox2.Type.Object(e8, i2)
  };
  import_typebox2.Type.ObjectString = ElysiaType.ObjectString, /**
  * A Numeric string
  *
  * Will be parse to Number
  */
  import_typebox2.Type.Numeric = ElysiaType.Numeric, import_typebox2.Type.File = (e8 = {}) => ElysiaType.File({ default: "File", ...e8, extension: e8?.type, type: "string", format: "binary" }), import_typebox2.Type.Files = (e8 = {}) => ElysiaType.Files({ ...e8, elysiaMeta: "Files", default: "Files", extension: e8?.type, type: "array", items: { ...e8, default: "Files", type: "string", format: "binary" } }), import_typebox2.Type.Nullable = (e8) => ElysiaType.Nullable(e8), import_typebox2.Type.MaybeEmpty = ElysiaType.MaybeEmpty, import_typebox2.Type.Cookie = ElysiaType.Cookie;

  // ../node_modules/elysia/dist/index.js
  var x = class {
    config;
    dependencies = {};
    store = {};
    decorators = {};
    definitions = { type: {}, error: {} };
    schema = {};
    event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], trace: [], error: [], stop: [] };
    reporter = new eventemitter3_default();
    server = null;
    getServer() {
      return this.server;
    }
    validator = null;
    router = new Memoirist();
    wsRouter = new Memoirist();
    routes = [];
    staticRouter = { handlers: [], variables: "", map: {}, all: "" };
    wsPaths = {};
    dynamicRouter = new Memoirist();
    lazyLoadModules = [];
    path = "";
    constructor(e8) {
      this.config = { forceErrorEncapsulation: false, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, ...e8, seed: e8?.seed === void 0 ? "" : e8?.seed };
    }
    add(e8, t5, r6, s3, { allowMeta: i2 = false, skipPrefix: a4 = false } = { allowMeta: false, skipPrefix: false }) {
      for (let h2 of ("string" == typeof t5 && (t5 = [t5]), t5)) {
        if (h2 = "" === h2 ? h2 : 47 === h2.charCodeAt(0) ? h2 : `/${h2}`, this.config.prefix && !a4 && (h2 = this.config.prefix + h2), s3?.type)
          switch (s3.type) {
            case "text":
              s3.type = "text/plain";
              break;
            case "json":
              s3.type = "application/json";
              break;
            case "formdata":
              s3.type = "multipart/form-data";
              break;
            case "urlencoded":
              s3.type = "application/x-www-form-urlencoded";
              break;
            case "arrayBuffer":
              s3.type = "application/octet-stream";
          }
        let t6 = this.definitions.type, l = getSchemaValidator(s3?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: t6, additionalProperties: true });
        isNotEmpty(this.config.cookie ?? {}) && (l ? (
          // @ts-ignore
          l.schema = mergeCookie(
            // @ts-ignore
            l.schema,
            this.config.cookie ?? {}
          )
        ) : l = getSchemaValidator(
          // @ts-ignore
          import_typebox2.Type.Cookie({}, this.config.cookie),
          { dynamic: !this.config.aot, models: t6, additionalProperties: true }
        ));
        let p2 = { body: getSchemaValidator(s3?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: t6 }), headers: getSchemaValidator(s3?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: t6, additionalProperties: true }), params: getSchemaValidator(s3?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: t6 }), query: getSchemaValidator(s3?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: t6 }), cookie: l, response: getResponseSchemaValidator(s3?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: t6 }) }, m2 = mergeHook(this.event, s3), v = h2.endsWith("/") ? h2.slice(0, h2.length - 1) : h2 + "/";
        if (false === this.config.aot) {
          this.dynamicRouter.add(e8, h2, { validator: p2, hooks: m2, content: s3?.type, handle: r6 }), false === this.config.strictPath && this.dynamicRouter.add(e8, v, { validator: p2, hooks: m2, content: s3?.type, handle: r6 }), this.routes.push({ method: e8, path: h2, composed: null, handler: r6, hooks: m2 });
          return;
        }
        let y2 = composeHandler({ path: h2, method: e8, hooks: m2, validator: p2, handler: r6, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: i2 ? this.definitions.type : void 0, schema: i2 ? this.schema : void 0, getReporter: () => this.reporter }), g2 = this.routes.findIndex((t7) => t7.path === h2 && t7.method === e8);
        if (-1 !== g2 && // remove route previously defined
        this.routes.splice(g2, 1), this.routes.push({ method: e8, path: h2, composed: y2, handler: r6, hooks: m2 }), "$INTERNALWS" === e8) {
          let e9 = this.config.strictPath ? void 0 : h2.endsWith("/") ? h2.slice(0, h2.length - 1) : h2 + "/";
          if (-1 === h2.indexOf(":") && -1 === h2.indexOf("*")) {
            let t7 = this.staticRouter.handlers.length;
            this.staticRouter.handlers.push(y2), this.staticRouter.variables += `const st${t7} = staticRouter.handlers[${t7}]
`, this.wsPaths[h2] = t7, e9 && (this.wsPaths[e9] = t7);
          } else
            this.wsRouter.add("ws", h2, y2), e9 && this.wsRouter.add("ws", e9, y2);
          return;
        }
        if (-1 === h2.indexOf(":") && -1 === h2.indexOf("*")) {
          let t7 = this.staticRouter.handlers.length;
          this.staticRouter.handlers.push(y2), this.staticRouter.variables += `const st${t7} = staticRouter.handlers[${t7}]
`, this.staticRouter.map[h2] || (this.staticRouter.map[h2] = { code: "" }), "ALL" === e8 ? this.staticRouter.map[h2].all = `default: return st${t7}(ctx)
` : this.staticRouter.map[h2].code = `case '${e8}': return st${t7}(ctx)
${this.staticRouter.map[h2].code}`, this.config.strictPath || (this.staticRouter.map[v] || (this.staticRouter.map[v] = { code: "" }), "ALL" === e8 ? this.staticRouter.map[v].all = `default: return st${t7}(ctx)
` : this.staticRouter.map[v].code = `case '${e8}': return st${t7}(ctx)
${this.staticRouter.map[v].code}`);
        } else
          this.router.add(e8, h2, y2), this.config.strictPath || this.router.add(e8, h2.endsWith("/") ? h2.slice(0, h2.length - 1) : h2 + "/", y2);
      }
    }
    /**
    * ### start | Life cycle event
    * Called after server is ready for serving
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onStart(({ url, port }) => {
    *         console.log("Running at ${url}:${port}")
    *     })
    *     .listen(8080)
    * ```
    */
    onStart(e8) {
      return this.on("start", e8), this;
    }
    /**
    * ### request | Life cycle event
    * Called on every new request is accepted
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onRequest(({ method, url }) => {
    *         saveToAnalytic({ method, url })
    *     })
    * ```
    */
    onRequest(e8) {
      return this.on("request", e8), this;
    }
    /**
    * ### parse | Life cycle event
    * Callback function to handle body parsing
    *
    * If truthy value is returned, will be assigned to `context.body`
    * Otherwise will skip the callback and look for the next one.
    *
    * Equivalent to Express's body parser
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onParse((request, contentType) => {
    *         if(contentType === "application/json")
    *             return request.json()
    *     })
    * ```
    */
    onParse(e8) {
      return this.on("parse", e8), this;
    }
    /**
    * ### transform | Life cycle event
    * Assign or transform anything related to context before validation.
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onTransform(({ params }) => {
    *         if(params.id)
    *             params.id = +params.id
    *     })
    * ```
    */
    onTransform(e8) {
      return this.on("transform", e8), this;
    }
    /**
    * ### Before Handle | Life cycle event
    * Intercept request **before(()) main handler is called.
    *
    * If truthy value is returned, will be assigned as `Response` and skip the main handler
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onBeforeHandle(({ params: { id }, status }) => {
    *         if(id && !isExisted(id)) {
    * 	           status(401)
    *
    *             return "Unauthorized"
    * 	       }
    *     })
    * ```
    */
    onBeforeHandle(e8) {
      return this.on("beforeHandle", e8), this;
    }
    /**
    * ### After Handle | Life cycle event
    * Intercept request **after** main handler is called.
    *
    * If truthy value is returned, will be assigned as `Response`
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onAfterHandle((context, response) => {
    *         if(typeof response === "object")
    *             return JSON.stringify(response)
    *     })
    * ```
    */
    onAfterHandle(e8) {
      return this.on("afterHandle", e8), this;
    }
    /**
    * ### response | Life cycle event
    * Called when handler is executed
    * Good for analytic metrics
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onError(({ code }) => {
    *         if(code === "NOT_FOUND")
    *             return "Path not found :("
    *     })
    * ```
    */
    onResponse(e8) {
      return this.on("response", e8), this;
    }
    /**
    * ### After Handle | Life cycle event
    * Intercept request **after** main handler is called.
    *
    * If truthy value is returned, will be assigned as `Response`
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onAfterHandle((context, response) => {
    *         if(typeof response === "object")
    *             return JSON.stringify(response)
    *     })
    * ```
    */
    trace(e8) {
      return this.reporter.on("event", createTraceListener(() => this.reporter, e8)), this.on("trace", e8), this;
    }
    addError(e8, t5) {
      return this.error(e8, t5);
    }
    error(e8, t5) {
      switch (typeof e8) {
        case "string":
          return (
            // @ts-ignore
            t5.prototype[ERROR_CODE] = e8, // @ts-ignore
            this.definitions.error[e8] = t5, this
          );
        case "function":
          return this.definitions.error = e8(this.definitions.error), this;
      }
      for (let [t6, r6] of Object.entries(e8))
        r6.prototype[ERROR_CODE] = t6, // @ts-ignore
        this.definitions.error[t6] = r6;
      return this;
    }
    /**
    * ### Error | Life cycle event
    * Called when error is thrown during processing request
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onError(({ code }) => {
    *         if(code === "NOT_FOUND")
    *             return "Path not found :("
    *     })
    * ```
    */
    onError(e8) {
      return this.on("error", e8), this;
    }
    /**
    * ### stop | Life cycle event
    * Called after server stop serving request
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .onStop((app) => {
    *         cleanup()
    *     })
    * ```
    */
    onStop(e8) {
      return this.on("stop", e8), this;
    }
    /**
    * ### on
    * Syntax sugar for attaching life cycle event by name
    *
    * Does the exact same thing as `.on[Event]()`
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .on('error', ({ code }) => {
    *         if(code === "NOT_FOUND")
    *             return "Path not found :("
    *     })
    * ```
    */
    on(e8, t5) {
      for (let r6 of Array.isArray(t5) ? t5 : [t5])
        switch (r6 = asGlobal(r6), e8) {
          case "start":
            this.event.start.push(r6);
            break;
          case "request":
            this.event.request.push(r6);
            break;
          case "response":
            this.event.onResponse.push(r6);
            break;
          case "parse":
            this.event.parse.splice(this.event.parse.length - 1, 0, r6);
            break;
          case "transform":
            this.event.transform.push(r6);
            break;
          case "beforeHandle":
            this.event.beforeHandle.push(r6);
            break;
          case "afterHandle":
            this.event.afterHandle.push(r6);
            break;
          case "trace":
            this.event.trace.push(r6);
            break;
          case "error":
            this.event.error.push(r6);
            break;
          case "stop":
            this.event.stop.push(r6);
        }
      return this;
    }
    /**
    * ### group
    * Encapsulate and group path with prefix
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .group('/v1', app => app
    *         .get('/', () => 'Hi')
    *         .get('/name', () => 'Elysia')
    *     })
    * ```
    */
    group(e8, t5, r6) {
      let s3 = new x({ ...this.config, prefix: "" });
      s3.store = this.store;
      let i2 = "object" == typeof t5, o = (i2 ? r6 : t5)(s3);
      return this.decorators = mergeDeep(this.decorators, s3.decorators), o.event.request.length && (this.event.request = [...this.event.request, ...o.event.request]), o.event.onResponse.length && (this.event.onResponse = [...this.event.onResponse, ...o.event.onResponse]), this.model(o.definitions.type), Object.values(s3.routes).forEach(({ method: r7, path: s4, handler: n3, hooks: a4 }) => {
        s4 = (i2 ? "" : this.config.prefix) + e8 + s4, i2 ? this.add(r7, s4, n3, mergeHook(t5, { ...a4, error: a4.error ? Array.isArray(a4.error) ? [...a4.error, ...o.event.error] : [a4.error, ...o.event.error] : o.event.error })) : this.add(r7, s4, n3, mergeHook(a4, { error: o.event.error }), { skipPrefix: true });
      }), this;
    }
    /**
    * ### guard
    * Encapsulate and pass hook into all child handler
    *
    * ---
    * @example
    * ```typescript
    * import { t } from 'elysia'
    *
    * new Elysia()
    *     .guard({
    *          schema: {
    *              body: t.Object({
    *                  username: t.String(),
    *                  password: t.String()
    *              })
    *          }
    *     }, app => app
    *         .get("/", () => 'Hi')
    *         .get("/name", () => 'Elysia')
    *     })
    * ```
    */
    guard(e8, t5) {
      if (!t5)
        return this.event = mergeLifeCycle(this.event, e8), this.validator = { body: e8.body, headers: e8.headers, params: e8.params, query: e8.query, response: e8.response }, this;
      let r6 = new x();
      r6.store = this.store;
      let s3 = t5(r6);
      return this.decorators = mergeDeep(this.decorators, r6.decorators), s3.event.request.length && (this.event.request = [...this.event.request, ...s3.event.request]), s3.event.onResponse.length && (this.event.onResponse = [...this.event.onResponse, ...s3.event.onResponse]), this.model(s3.definitions.type), Object.values(r6.routes).forEach(({ method: t6, path: r7, handler: i2, hooks: o }) => {
        this.add(t6, r7, i2, mergeHook(e8, { ...o, error: o.error ? Array.isArray(o.error) ? [...o.error, ...s3.event.error] : [o.error, ...s3.event.error] : s3.event.error }));
      }), this;
    }
    /**
    * ### use
    * Merge separate logic of Elysia with current
    *
    * ---
    * @example
    * ```typescript
    * const plugin = (app: Elysia) => app
    *     .get('/plugin', () => 'hi')
    *
    * new Elysia()
    *     .use(plugin)
    * ```
    */
    use(e8) {
      return e8 instanceof Promise ? (this.lazyLoadModules.push(e8.then((e9) => "function" == typeof e9 ? e9(this) : "function" == typeof e9.default ? e9.default(this) : this._use(e9)).then((e9) => e9.compile())), this) : this._use(e8);
    }
    _use(e8) {
      if ("function" == typeof e8) {
        let t6 = e8(this);
        return t6 instanceof Promise ? (this.lazyLoadModules.push(t6.then((e9) => "function" == typeof e9 ? e9(this) : "function" == typeof e9.default ? e9.default(this) : this._use(e9)).then((e9) => e9.compile())), this) : t6;
      }
      let { name: t5, seed: r6 } = e8.config;
      e8.getServer = () => this.getServer();
      let s3 = e8.config.scoped;
      if (s3) {
        if (t5) {
          t5 in this.dependencies || (this.dependencies[t5] = []);
          let e9 = void 0 !== r6 ? checksum(t5 + JSON.stringify(r6)) : 0;
          if (this.dependencies[t5].some((t6) => e9 === t6))
            return this;
          this.dependencies[t5].push(e9);
        }
        e8.model(this.definitions.type), e8.error(this.definitions.error), e8.onRequest((e9) => {
          Object.assign(e9, this.decorators), Object.assign(e9.store, this.store);
        }), e8.event.trace = [...this.event.trace, ...e8.event.trace], e8.config.aot && e8.compile();
        let s4 = this.mount(e8.fetch);
        return this.routes = this.routes.concat(s4.routes), this;
      }
      for (let t6 of (e8.reporter = this.reporter, e8.event.trace))
        this.trace(t6);
      for (let { method: t6, path: r7, handler: s4, hooks: i2 } of (this.decorate(e8.decorators), this.state(e8.store), this.model(e8.definitions.type), this.error(e8.definitions.error), Object.values(e8.routes)))
        this.add(t6, r7, s4, mergeHook(i2, { error: e8.event.error }));
      if (!s3) {
        if (t5) {
          t5 in this.dependencies || (this.dependencies[t5] = []);
          let s4 = void 0 !== r6 ? checksum(t5 + JSON.stringify(r6)) : 0;
          if (this.dependencies[t5].some((e9) => s4 === e9))
            return this;
          this.dependencies[t5].push(s4), this.event = mergeLifeCycle(this.event, filterGlobalHook(e8.event), s4);
        } else
          this.event = mergeLifeCycle(this.event, filterGlobalHook(e8.event));
      }
      return this;
    }
    mount(e8, t5) {
      if ("function" == typeof e8 || 0 === e8.length || "/" === e8) {
        let r7 = "function" == typeof e8 ? e8 : t5, s4 = async ({ request: e9, path: t6 }) => r7(new Request("http://a.cc" + t6, e9));
        return this.all("/", s4, { type: "none" }), this.all("/*", s4, { type: "none" }), this;
      }
      let r6 = e8.length, s3 = async ({ request: e9, path: s4 }) => t5(new Request("http://a.cc" + s4.slice(r6), e9));
      return this.all(e8, s3, { type: "none" }), this.all(e8 + (e8.endsWith("/") ? "*" : "/*"), s3, { type: "none" }), this;
    }
    /**
    * ### get
    * Register handler for path with method [GET]
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .get('/', () => 'hi')
    *     .get('/with-hook', () => 'hi', {
    *         schema: {
    *             response: t.String()
    *         }
    *     })
    * ```
    */
    get(e8, t5, r6) {
      return this.add("GET", e8, t5, r6), this;
    }
    /**
    * ### post
    * Register handler for path with method [POST]
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .post('/', () => 'hi')
    *     .post('/with-hook', () => 'hi', {
    *         schema: {
    *             response: t.String()
    *         }
    *     })
    * ```
    */
    post(e8, t5, r6) {
      return this.add("POST", e8, t5, r6), this;
    }
    /**
    * ### put
    * Register handler for path with method [PUT]
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .put('/', () => 'hi')
    *     .put('/with-hook', () => 'hi', {
    *         schema: {
    *             response: t.String()
    *         }
    *     })
    * ```
    */
    put(e8, t5, r6) {
      return this.add("PUT", e8, t5, r6), this;
    }
    /**
    * ### patch
    * Register handler for path with method [PATCH]
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .patch('/', () => 'hi')
    *     .patch('/with-hook', () => 'hi', {
    *         schema: {
    *             response: t.String()
    *         }
    *     })
    * ```
    */
    patch(e8, t5, r6) {
      return this.add("PATCH", e8, t5, r6), this;
    }
    /**
    * ### delete
    * Register handler for path with method [DELETE]
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .delete('/', () => 'hi')
    *     .delete('/with-hook', () => 'hi', {
    *         schema: {
    *             response: t.String()
    *         }
    *     })
    * ```
    */
    delete(e8, t5, r6) {
      return this.add("DELETE", e8, t5, r6), this;
    }
    /**
    * ### options
    * Register handler for path with method [OPTIONS]
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .options('/', () => 'hi')
    *     .options('/with-hook', () => 'hi', {
    *         schema: {
    *             response: t.String()
    *         }
    *     })
    * ```
    */
    options(e8, t5, r6) {
      return this.add("OPTIONS", e8, t5, r6), this;
    }
    /**
    * ### all
    * Register handler for path with any method
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .all('/', () => 'hi')
    * ```
    */
    all(e8, t5, r6) {
      return this.add("ALL", e8, t5, r6), this;
    }
    /**
    * ### head
    * Register handler for path with method [HEAD]
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .head('/', () => 'hi')
    *     .head('/with-hook', () => 'hi', {
    *         schema: {
    *             response: t.String()
    *         }
    *     })
    * ```
    */
    head(e8, t5, r6) {
      return this.add("HEAD", e8, t5, r6), this;
    }
    /**
    * ### connect
    * Register handler for path with method [CONNECT]
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .connect('/', () => 'hi')
    *     .connect('/with-hook', () => 'hi', {
    *         schema: {
    *             response: t.String()
    *         }
    *     })
    * ```
    */
    connect(e8, t5, r6) {
      return this.add("CONNECT", e8, t5, r6), this;
    }
    /**
    * ### ws
    * Register handler for path with method [ws]
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .ws('/', {
    *         message(ws, message) {
    *             ws.send(message)
    *         }
    *     })
    * ```
    */
    ws(e8, t5) {
      let r6 = t5.transformMessage ? Array.isArray(t5.transformMessage) ? t5.transformMessage : [t5.transformMessage] : void 0, i2 = null, o = getSchemaValidator(t5?.body, { models: this.definitions.type }), n3 = getSchemaValidator(t5?.response, { models: this.definitions.type }), a4 = (e9) => {
        if ("string" == typeof e9) {
          let t6 = e9?.charCodeAt(0);
          if (47 === t6 || 123 === t6)
            try {
              e9 = JSON.parse(e9);
            } catch {
            }
          else
            Number.isNaN(+e9) || (e9 = +e9);
        }
        if (r6?.length)
          for (let t6 = 0; t6 < r6.length; t6++) {
            let s3 = r6[t6](e9);
            void 0 !== s3 && (e9 = s3);
          }
        return e9;
      };
      return this.route(
        "$INTERNALWS",
        e8,
        // @ts-ignore
        (e9) => {
          let { set: r7, path: h2, qi: c2, headers: d2, query: f, params: l } = e9;
          if (null === i2 && (i2 = this.getServer()), !i2?.upgrade(e9.request, { headers: "function" == typeof t5.upgrade ? t5.upgrade(e9) : t5.upgrade, data: { validator: n3, open(r8) {
            t5.open?.(new ElysiaWS(r8, e9));
          }, message: (r8, i3) => {
            let n4 = a4(i3);
            if (o?.Check(n4) === false)
              return void r8.send(new ValidationError("message", o, n4).message);
            t5.message?.(new ElysiaWS(r8, e9), n4);
          }, drain(r8) {
            t5.drain?.(new ElysiaWS(r8, e9));
          }, close(r8, i3, o2) {
            t5.close?.(new ElysiaWS(r8, e9), i3, o2);
          } } }))
            return r7.status = 400, "Expected a websocket connection";
        },
        { beforeHandle: t5.beforeHandle, transform: t5.transform, headers: t5.headers, params: t5.params, query: t5.query }
      ), this;
    }
    /**
    * ### route
    * Register handler for path with custom method
    *
    * ---
    * @example
    * ```typescript
    * import { Elysia, t } from 'elysia'
    *
    * new Elysia()
    *     .route('CUSTOM', '/', () => 'hi')
    *     .route('CUSTOM', '/with-hook', () => 'hi', {
    *         schema: {
    *             response: t.String()
    *         }
    *     })
    * ```
    */
    route(e8, t5, r6, { config: s3, ...i2 } = { config: { allowMeta: false } }) {
      return this.add(e8, t5, r6, i2, s3), this;
    }
    /**
    * ### state
    * Assign global mutatable state accessible for all handler
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .state('counter', 0)
    *     .get('/', (({ counter }) => ++counter)
    * ```
    */
    state(e8, t5) {
      switch (typeof e8) {
        case "object":
          return this.store = mergeDeep(this.store, e8), this;
        case "function":
          return this.store = e8(this.store), this;
      }
      return e8 in this.store || (this.store[e8] = t5), this;
    }
    /**
    * ### decorate
    * Define custom method to `Context` accessible for all handler
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .decorate('getDate', () => Date.now())
    *     .get('/', (({ getDate }) => getDate())
    * ```
    */
    decorate(e8, t5) {
      switch (typeof e8) {
        case "object":
          return this.decorators = mergeDeep(this.decorators, e8), this;
        case "function":
          return this.decorators = e8(this.decorators), this;
      }
      return e8 in this.decorators || (this.decorators[e8] = t5), this;
    }
    /**
    * Derive new property for each request with access to `Context`.
    *
    * If error is thrown, the scope will skip to handling error instead.
    *
    * ---
    * @example
    * new Elysia()
    *     .state('counter', 1)
    *     .derive(({ store }) => ({
    *         increase() {
    *             store.counter++
    *         }
    *     }))
    */
    derive(e8) {
      return (
        // @ts-ignore
        e8.$elysia = "derive", this.onTransform(e8)
      );
    }
    model(e8, t5) {
      switch (typeof e8) {
        case "object":
          return Object.entries(e8).forEach(([e9, t6]) => {
            e9 in this.definitions.type || // @ts-ignore
            (this.definitions.type[e9] = t6);
          }), this;
        case "function":
          return this.definitions.type = e8(this.definitions.type), this;
      }
      return this.definitions.type[e8] = t5, this;
    }
    mapDerive(e8) {
      return (
        // @ts-ignore
        e8.$elysia = "derive", this.onTransform(e8)
      );
    }
    affix(e8, t5, r6) {
      if ("" === r6)
        return this;
      let s3 = ["_", "-", " "], i2 = (e9) => e9[0].toUpperCase() + e9.slice(1), o = "prefix" === e8 ? (e9, t6) => s3.includes(e9.at(-1) ?? "") ? e9 + t6 : e9 + i2(t6) : s3.includes(r6.at(-1) ?? "") ? (e9, t6) => t6 + e9 : (e9, t6) => t6 + i2(e9), n3 = (e9) => {
        let t6 = {};
        switch (e9) {
          case "decorator":
            for (let e10 in this.decorators)
              t6[o(r6, e10)] = this.decorators[e10];
            this.decorators = t6;
            break;
          case "state":
            for (let e10 in this.store)
              t6[o(r6, e10)] = this.store[e10];
            this.store = t6;
            break;
          case "model":
            for (let e10 in this.definitions.type)
              t6[o(r6, e10)] = this.definitions.type[e10];
            this.definitions.type = t6;
            break;
          case "error":
            for (let e10 in this.definitions.error)
              t6[o(r6, e10)] = this.definitions.error[e10];
            this.definitions.error = t6;
        }
      }, a4 = Array.isArray(t5) ? t5 : [t5];
      for (let e9 of a4.some((e10) => "all" === e10) ? ["decorator", "state", "model", "error"] : a4)
        n3(e9);
      return this;
    }
    prefix(e8, t5) {
      return this.affix("prefix", e8, t5);
    }
    suffix(e8, t5) {
      return this.affix("suffix", e8, t5);
    }
    compile() {
      return this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this), "function" == typeof this.server?.reload && this.server.reload({ ...this.server, fetch: this.fetch }), this;
    }
    handle = async (e8) => this.fetch(e8);
    /**
    * Handle can be either sync or async to save performance.
    *
    * Beside benchmark purpose, please use 'handle' instead.
    */
    fetch = (e8) => (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(e8);
    handleError = async (e8, t5) => (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(e8, t5);
    outerErrorHandler = (e8) => new Response(e8.message || e8.name || "Error", {
      // @ts-ignore
      status: e8?.status ?? 500
    });
    /**
    * ### listen
    * Assign current instance to port and start serving
    *
    * ---
    * @example
    * ```typescript
    * new Elysia()
    *     .get("/", () => 'hi')
    *     .listen(8080)
    * ```
    */
    listen = (e8, t5) => {
      if (!Bun)
        throw Error("Bun to run");
      if (this.compile(), "string" == typeof e8 && Number.isNaN(e8 = +e8.trim()))
        throw Error("Port must be a numeric value");
      let r6 = this.fetch, s3 = "object" == typeof e8 ? { development: !isProduction, ...this.config.serve, ...e8, websocket: { ...this.config.websocket, ...websocket }, fetch: r6, error: this.outerErrorHandler } : { development: !isProduction, ...this.config.serve, websocket: { ...this.config.websocket, ...websocket }, port: e8, fetch: r6, error: this.outerErrorHandler };
      if ("undefined" == typeof Bun)
        throw Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
      return this.server = Bun?.serve(s3), this.event.start.length && (async () => {
        let e9 = Object.assign(this.decorators, { store: this.store, app: this });
        for (let t6 = 0; t6 < this.event.transform.length; t6++) {
          let r7 = this.event.transform[t6](e9);
          "derive" === this.event.transform[t6].$elysia && (r7 instanceof Promise ? Object.assign(e9, await r7) : Object.assign(e9, r7));
        }
        for (let t6 = 0; t6 < this.event.start.length; t6++)
          this.event.start[t6](e9);
      })(), t5 && t5(this.server), Promise.all(this.lazyLoadModules).then(() => {
        Bun?.gc(false);
      }), this;
    };
    /**
    * ### stop
    * Stop server from serving
    *
    * ---
    * @example
    * ```typescript
    * const app = new Elysia()
    *     .get("/", () => 'hi')
    *     .listen(8080)
    *
    * // Sometime later
    * app.stop()
    * ```
    */
    stop = async () => {
      if (!this.server)
        throw Error("Elysia isn't running. Call `app.listen` to start the server.");
      this.server.stop(), this.event.stop.length && (async () => {
        let e8 = Object.assign(this.decorators, { store: this.store, app: this });
        for (let t5 = 0; t5 < this.event.transform.length; t5++) {
          let r6 = this.event.transform[t5](e8);
          "derive" === this.event.transform[t5].$elysia && (r6 instanceof Promise ? Object.assign(e8, await r6) : Object.assign(e8, r6));
        }
        for (let t5 = 0; t5 < this.event.stop.length; t5++)
          this.event.stop[t5](e8);
      })();
    };
    /**
    * Wait until all lazy loaded modules all load is fully
    */
    get modules() {
      return Promise.all(this.lazyLoadModules);
    }
  };

  // ../node_modules/@elysiajs/trpc/dist/index.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/@trpc/server/dist/index.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/@trpc/server/dist/config-00ffd309.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/@trpc/server/dist/TRPCError-689e79f1.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function isObject(value) {
    return !!value && !Array.isArray(value) && typeof value === "object";
  }
  function getTRPCErrorFromUnknown(cause) {
    if (cause instanceof TRPCError) {
      return cause;
    }
    if (cause instanceof Error && cause.name === "TRPCError") {
      return cause;
    }
    const trpcError = new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      cause
    });
    if (cause instanceof Error && cause.stack) {
      trpcError.stack = cause.stack;
    }
    return trpcError;
  }
  var UnknownCauseError = class extends Error {
  };
  function getCauseFromUnknown(cause) {
    if (cause instanceof Error) {
      return cause;
    }
    const type2 = typeof cause;
    if (type2 === "undefined" || type2 === "function" || cause === null) {
      return void 0;
    }
    if (type2 !== "object") {
      return new Error(String(cause));
    }
    if (isObject(cause)) {
      const err = new UnknownCauseError();
      for (const key in cause) {
        err[key] = cause[key];
      }
      return err;
    }
    return void 0;
  }
  var TRPCError = class extends Error {
    constructor(opts) {
      const cause = getCauseFromUnknown(opts.cause);
      const message = opts.message ?? cause?.message ?? opts.code;
      super(message, {
        cause
      });
      this.code = opts.code;
      this.name = "TRPCError";
      if (!this.cause) {
        this.cause = cause;
      }
    }
  };

  // ../node_modules/@trpc/server/dist/index-f91d720c.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/@trpc/server/dist/codes-c924c3db.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function invert(obj) {
    const newObj = /* @__PURE__ */ Object.create(null);
    for (const key in obj) {
      const v = obj[key];
      newObj[v] = key;
    }
    return newObj;
  }
  var TRPC_ERROR_CODES_BY_KEY = {
    /**
    * Invalid JSON was received by the server.
    * An error occurred on the server while parsing the JSON text.
    */
    PARSE_ERROR: -32700,
    /**
    * The JSON sent is not a valid Request object.
    */
    BAD_REQUEST: -32600,
    // Internal JSON-RPC error
    INTERNAL_SERVER_ERROR: -32603,
    NOT_IMPLEMENTED: -32603,
    // Implementation specific errors
    UNAUTHORIZED: -32001,
    FORBIDDEN: -32003,
    NOT_FOUND: -32004,
    METHOD_NOT_SUPPORTED: -32005,
    TIMEOUT: -32008,
    CONFLICT: -32009,
    PRECONDITION_FAILED: -32012,
    PAYLOAD_TOO_LARGE: -32013,
    UNPROCESSABLE_CONTENT: -32022,
    TOO_MANY_REQUESTS: -32029,
    CLIENT_CLOSED_REQUEST: -32099
  };
  var TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);

  // ../node_modules/@trpc/server/dist/index-f91d720c.mjs
  var TRPC_ERROR_CODES_BY_NUMBER2 = invert(TRPC_ERROR_CODES_BY_KEY);
  var JSONRPC2_TO_HTTP_CODE = {
    PARSE_ERROR: 400,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    METHOD_NOT_SUPPORTED: 405,
    TIMEOUT: 408,
    CONFLICT: 409,
    PRECONDITION_FAILED: 412,
    PAYLOAD_TOO_LARGE: 413,
    UNPROCESSABLE_CONTENT: 422,
    TOO_MANY_REQUESTS: 429,
    CLIENT_CLOSED_REQUEST: 499,
    INTERNAL_SERVER_ERROR: 500,
    NOT_IMPLEMENTED: 501
  };
  function getStatusCodeFromKey(code) {
    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;
  }
  function getHTTPStatusCode(json) {
    const arr = Array.isArray(json) ? json : [
      json
    ];
    const httpStatuses = new Set(arr.map((res) => {
      if ("error" in res) {
        const data = res.error.data;
        if (typeof data.httpStatus === "number") {
          return data.httpStatus;
        }
        const code = TRPC_ERROR_CODES_BY_NUMBER2[res.error.code];
        return getStatusCodeFromKey(code);
      }
      return 200;
    }));
    if (httpStatuses.size !== 1) {
      return 207;
    }
    const httpStatus = httpStatuses.values().next().value;
    return httpStatus;
  }
  function getHTTPStatusCodeFromError(error) {
    return getStatusCodeFromKey(error.code);
  }
  var noop2 = () => {
  };
  function createInnerProxy(callback, path) {
    const proxy = new Proxy(noop2, {
      get(_obj, key) {
        if (typeof key !== "string" || key === "then") {
          return void 0;
        }
        return createInnerProxy(callback, [
          ...path,
          key
        ]);
      },
      apply(_1, _2, args) {
        const isApply = path[path.length - 1] === "apply";
        return callback({
          args: isApply ? args.length >= 2 ? args[1] : [] : args,
          path: isApply ? path.slice(0, -1) : path
        });
      }
    });
    return proxy;
  }
  var createRecursiveProxy = (callback) => createInnerProxy(callback, []);
  var createFlatProxy = (callback) => {
    return new Proxy(noop2, {
      get(_obj, name) {
        if (typeof name !== "string" || name === "then") {
          return void 0;
        }
        return callback(name);
      }
    });
  };

  // ../node_modules/@trpc/server/dist/config-00ffd309.mjs
  function getDataTransformer(transformer) {
    if ("input" in transformer) {
      return transformer;
    }
    return {
      input: transformer,
      output: transformer
    };
  }
  var defaultTransformer = {
    _default: true,
    input: {
      serialize: (obj) => obj,
      deserialize: (obj) => obj
    },
    output: {
      serialize: (obj) => obj,
      deserialize: (obj) => obj
    }
  };
  var defaultFormatter = ({ shape }) => {
    return shape;
  };
  function omitPrototype(obj) {
    return Object.assign(/* @__PURE__ */ Object.create(null), obj);
  }
  var procedureTypes = [
    "query",
    "mutation",
    "subscription"
  ];
  function isRouter(procedureOrRouter) {
    return "router" in procedureOrRouter._def;
  }
  var emptyRouter = {
    _ctx: null,
    _errorShape: null,
    _meta: null,
    queries: {},
    mutations: {},
    subscriptions: {},
    errorFormatter: defaultFormatter,
    transformer: defaultTransformer
  };
  var reservedWords = [
    /**
    * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
    * since JS will think that `.then` is something that exists
    */
    "then"
  ];
  function createRouterFactory(config4) {
    return function createRouterInner(procedures) {
      const reservedWordsUsed = new Set(Object.keys(procedures).filter((v) => reservedWords.includes(v)));
      if (reservedWordsUsed.size > 0) {
        throw new Error("Reserved words used in `router({})` call: " + Array.from(reservedWordsUsed).join(", "));
      }
      const routerProcedures = omitPrototype({});
      function recursiveGetPaths(procedures2, path = "") {
        for (const [key, procedureOrRouter] of Object.entries(procedures2 ?? {})) {
          const newPath = `${path}${key}`;
          if (isRouter(procedureOrRouter)) {
            recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);
            continue;
          }
          if (routerProcedures[newPath]) {
            throw new Error(`Duplicate key: ${newPath}`);
          }
          routerProcedures[newPath] = procedureOrRouter;
        }
      }
      recursiveGetPaths(procedures);
      const _def = {
        _config: config4,
        router: true,
        procedures: routerProcedures,
        ...emptyRouter,
        record: procedures,
        queries: Object.entries(routerProcedures).filter((pair) => pair[1]._def.query).reduce((acc, [key, val]) => ({
          ...acc,
          [key]: val
        }), {}),
        mutations: Object.entries(routerProcedures).filter((pair) => pair[1]._def.mutation).reduce((acc, [key, val]) => ({
          ...acc,
          [key]: val
        }), {}),
        subscriptions: Object.entries(routerProcedures).filter((pair) => pair[1]._def.subscription).reduce((acc, [key, val]) => ({
          ...acc,
          [key]: val
        }), {})
      };
      const router2 = {
        ...procedures,
        _def,
        createCaller(ctx) {
          const proxy = createRecursiveProxy(({ path, args }) => {
            if (path.length === 1 && procedureTypes.includes(path[0])) {
              return callProcedure({
                procedures: _def.procedures,
                path: args[0],
                rawInput: args[1],
                ctx,
                type: path[0]
              });
            }
            const fullPath = path.join(".");
            const procedure = _def.procedures[fullPath];
            let type2 = "query";
            if (procedure._def.mutation) {
              type2 = "mutation";
            } else if (procedure._def.subscription) {
              type2 = "subscription";
            }
            return procedure({
              path: fullPath,
              rawInput: args[0],
              ctx,
              type: type2
            });
          });
          return proxy;
        },
        getErrorShape(opts) {
          const { path, error } = opts;
          const { code } = opts.error;
          const shape = {
            message: error.message,
            code: TRPC_ERROR_CODES_BY_KEY[code],
            data: {
              code,
              httpStatus: getHTTPStatusCodeFromError(error)
            }
          };
          if (config4.isDev && typeof opts.error.stack === "string") {
            shape.data.stack = opts.error.stack;
          }
          if (typeof path === "string") {
            shape.data.path = path;
          }
          return this._def._config.errorFormatter({
            ...opts,
            shape
          });
        }
      };
      return router2;
    };
  }
  function callProcedure(opts) {
    const { type: type2, path } = opts;
    if (!(path in opts.procedures) || !opts.procedures[path]?._def[type2]) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: `No "${type2}"-procedure on path "${path}"`
      });
    }
    const procedure = opts.procedures[path];
    return procedure(opts);
  }
  var isServerDefault = typeof window === "undefined" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;

  // ../node_modules/@trpc/server/dist/index.mjs
  function getParseFn(procedureParser) {
    const parser = procedureParser;
    if (typeof parser === "function") {
      return parser;
    }
    if (typeof parser.parseAsync === "function") {
      return parser.parseAsync.bind(parser);
    }
    if (typeof parser.parse === "function") {
      return parser.parse.bind(parser);
    }
    if (typeof parser.validateSync === "function") {
      return parser.validateSync.bind(parser);
    }
    if (typeof parser.create === "function") {
      return parser.create.bind(parser);
    }
    if (typeof parser.assert === "function") {
      return (value) => {
        parser.assert(value);
        return value;
      };
    }
    throw new Error("Could not find a validator fn");
  }
  function mergeWithoutOverrides(obj1, ...objs) {
    const newObj = Object.assign(/* @__PURE__ */ Object.create(null), obj1);
    for (const overrides of objs) {
      for (const key in overrides) {
        if (key in newObj && newObj[key] !== overrides[key]) {
          throw new Error(`Duplicate key ${key}`);
        }
        newObj[key] = overrides[key];
      }
    }
    return newObj;
  }
  function createMiddlewareFactory() {
    function createMiddlewareInner(middlewares) {
      return {
        _middlewares: middlewares,
        unstable_pipe(middlewareBuilderOrFn) {
          const pipedMiddleware = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
            middlewareBuilderOrFn
          ];
          return createMiddlewareInner([
            ...middlewares,
            ...pipedMiddleware
          ]);
        }
      };
    }
    function createMiddleware(fn) {
      return createMiddlewareInner([
        fn
      ]);
    }
    return createMiddleware;
  }
  function isPlainObject(obj) {
    return obj && typeof obj === "object" && !Array.isArray(obj);
  }
  function createInputMiddleware(parse) {
    const inputMiddleware = async ({ next, rawInput, input }) => {
      let parsedInput;
      try {
        parsedInput = await parse(rawInput);
      } catch (cause) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          cause
        });
      }
      const combinedInput = isPlainObject(input) && isPlainObject(parsedInput) ? {
        ...input,
        ...parsedInput
      } : parsedInput;
      return next({
        input: combinedInput
      });
    };
    inputMiddleware._type = "input";
    return inputMiddleware;
  }
  function createOutputMiddleware(parse) {
    const outputMiddleware = async ({ next }) => {
      const result = await next();
      if (!result.ok) {
        return result;
      }
      try {
        const data = await parse(result.data);
        return {
          ...result,
          data
        };
      } catch (cause) {
        throw new TRPCError({
          message: "Output validation failed",
          code: "INTERNAL_SERVER_ERROR",
          cause
        });
      }
    };
    outputMiddleware._type = "output";
    return outputMiddleware;
  }
  var middlewareMarker = "middlewareMarker";
  function createNewBuilder(def1, def2) {
    const { middlewares = [], inputs, meta, ...rest } = def2;
    return createBuilder({
      ...mergeWithoutOverrides(def1, rest),
      inputs: [
        ...def1.inputs,
        ...inputs ?? []
      ],
      middlewares: [
        ...def1.middlewares,
        ...middlewares
      ],
      meta: def1.meta && meta ? {
        ...def1.meta,
        ...meta
      } : meta ?? def1.meta
    });
  }
  function createBuilder(initDef = {}) {
    const _def = {
      inputs: [],
      middlewares: [],
      ...initDef
    };
    return {
      _def,
      input(input) {
        const parser = getParseFn(input);
        return createNewBuilder(_def, {
          inputs: [
            input
          ],
          middlewares: [
            createInputMiddleware(parser)
          ]
        });
      },
      output(output) {
        const parseOutput = getParseFn(output);
        return createNewBuilder(_def, {
          output,
          middlewares: [
            createOutputMiddleware(parseOutput)
          ]
        });
      },
      meta(meta) {
        return createNewBuilder(_def, {
          meta
        });
      },
      /**
      * @deprecated
      * This functionality is deprecated and will be removed in the next major version.
      */
      unstable_concat(builder) {
        return createNewBuilder(_def, builder._def);
      },
      use(middlewareBuilderOrFn) {
        const middlewares = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
          middlewareBuilderOrFn
        ];
        return createNewBuilder(_def, {
          middlewares
        });
      },
      query(resolver) {
        return createResolver({
          ..._def,
          query: true
        }, resolver);
      },
      mutation(resolver) {
        return createResolver({
          ..._def,
          mutation: true
        }, resolver);
      },
      subscription(resolver) {
        return createResolver({
          ..._def,
          subscription: true
        }, resolver);
      }
    };
  }
  function createResolver(_def, resolver) {
    const finalBuilder = createNewBuilder(_def, {
      resolver,
      middlewares: [
        async function resolveMiddleware(opts) {
          const data = await resolver(opts);
          return {
            marker: middlewareMarker,
            ok: true,
            data,
            ctx: opts.ctx
          };
        }
      ]
    });
    return createProcedureCaller(finalBuilder._def);
  }
  var codeblock = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
  function createProcedureCaller(_def) {
    const procedure = async function resolve2(opts) {
      if (!opts || !("rawInput" in opts)) {
        throw new Error(codeblock);
      }
      const callRecursive = async (callOpts = {
        index: 0,
        ctx: opts.ctx
      }) => {
        try {
          const middleware2 = _def.middlewares[callOpts.index];
          const result2 = await middleware2({
            ctx: callOpts.ctx,
            type: opts.type,
            path: opts.path,
            rawInput: callOpts.rawInput ?? opts.rawInput,
            meta: _def.meta,
            input: callOpts.input,
            next(_nextOpts) {
              const nextOpts = _nextOpts;
              return callRecursive({
                index: callOpts.index + 1,
                ctx: nextOpts && "ctx" in nextOpts ? {
                  ...callOpts.ctx,
                  ...nextOpts.ctx
                } : callOpts.ctx,
                input: nextOpts && "input" in nextOpts ? nextOpts.input : callOpts.input,
                rawInput: nextOpts && "rawInput" in nextOpts ? nextOpts.rawInput : callOpts.rawInput
              });
            }
          });
          return result2;
        } catch (cause) {
          return {
            ok: false,
            error: getTRPCErrorFromUnknown(cause),
            marker: middlewareMarker
          };
        }
      };
      const result = await callRecursive();
      if (!result) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "No result from middlewares - did you forget to `return next()`?"
        });
      }
      if (!result.ok) {
        throw result.error;
      }
      return result.data;
    };
    procedure._def = _def;
    procedure.meta = _def.meta;
    return procedure;
  }
  function mergeRouters(...routerList) {
    const record = mergeWithoutOverrides({}, ...routerList.map((r6) => r6._def.record));
    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {
      if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {
        if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {
          throw new Error("You seem to have several error formatters");
        }
        return nextRouter._def._config.errorFormatter;
      }
      return currentErrorFormatter;
    }, defaultFormatter);
    const transformer = routerList.reduce((prev, current) => {
      if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {
        if (prev !== defaultTransformer && prev !== current._def._config.transformer) {
          throw new Error("You seem to have several transformers");
        }
        return current._def._config.transformer;
      }
      return prev;
    }, defaultTransformer);
    const router2 = createRouterFactory({
      errorFormatter,
      transformer,
      isDev: routerList.some((r6) => r6._def._config.isDev),
      allowOutsideOfServer: routerList.some((r6) => r6._def._config.allowOutsideOfServer),
      isServer: routerList.some((r6) => r6._def._config.isServer),
      $types: routerList[0]?._def._config.$types
    })(record);
    return router2;
  }
  var TRPCBuilder = class {
    context() {
      return new TRPCBuilder();
    }
    meta() {
      return new TRPCBuilder();
    }
    create(options) {
      return createTRPCInner()(options);
    }
  };
  var initTRPC = new TRPCBuilder();
  function createTRPCInner() {
    return function initTRPCInner(runtime) {
      const errorFormatter = runtime?.errorFormatter ?? defaultFormatter;
      const transformer = getDataTransformer(runtime?.transformer ?? defaultTransformer);
      const config4 = {
        transformer,
        isDev: runtime?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
        allowOutsideOfServer: runtime?.allowOutsideOfServer ?? false,
        errorFormatter,
        isServer: runtime?.isServer ?? isServerDefault,
        /**
        * @internal
        */
        $types: createFlatProxy((key) => {
          throw new Error(`Tried to access "$types.${key}" which is not available at runtime`);
        })
      };
      {
        const isServer = runtime?.isServer ?? isServerDefault;
        if (!isServer && runtime?.allowOutsideOfServer !== true) {
          throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);
        }
      }
      return {
        /**
        * These are just types, they can't be used
        * @internal
        */
        _config: config4,
        /**
        * Builder object for creating procedures
        */
        procedure: createBuilder({
          meta: runtime?.defaultMeta
        }),
        /**
        * Create reusable middlewares
        */
        middleware: createMiddlewareFactory(),
        /**
        * Create a router
        */
        router: createRouterFactory(config4),
        /**
        * Merge Routers
        */
        mergeRouters
      };
    };
  }

  // ../node_modules/@trpc/server/dist/adapters/fetch/index.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/@trpc/server/dist/resolveHTTPResponse-cd1a9112.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/@trpc/server/dist/transformTRPCResponse-1153b421.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getErrorShape(opts) {
    const { path, error, config: config4 } = opts;
    const { code } = opts.error;
    const shape = {
      message: error.message,
      code: TRPC_ERROR_CODES_BY_KEY[code],
      data: {
        code,
        httpStatus: getHTTPStatusCodeFromError(error)
      }
    };
    if (config4.isDev && typeof opts.error.stack === "string") {
      shape.data.stack = opts.error.stack;
    }
    if (typeof path === "string") {
      shape.data.path = path;
    }
    return config4.errorFormatter({
      ...opts,
      shape
    });
  }
  function transformTRPCResponseItem(config4, item) {
    if ("error" in item) {
      return {
        ...item,
        error: config4.transformer.output.serialize(item.error)
      };
    }
    if ("data" in item.result) {
      return {
        ...item,
        result: {
          ...item.result,
          data: config4.transformer.output.serialize(item.result.data)
        }
      };
    }
    return item;
  }
  function transformTRPCResponse(config4, itemOrItems) {
    return Array.isArray(itemOrItems) ? itemOrItems.map((item) => transformTRPCResponseItem(config4, item)) : transformTRPCResponseItem(config4, itemOrItems);
  }

  // ../node_modules/@trpc/server/dist/contentType-778b33c3.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getRawProcedureInputOrThrow(opts) {
    const { req } = opts;
    try {
      if (req.method === "GET") {
        if (!req.query.has("input")) {
          return void 0;
        }
        const raw2 = req.query.get("input");
        return JSON.parse(raw2);
      }
      if (!opts.preprocessedBody && typeof req.body === "string") {
        return req.body.length === 0 ? void 0 : JSON.parse(req.body);
      }
      return req.body;
    } catch (cause) {
      throw new TRPCError({
        code: "PARSE_ERROR",
        cause
      });
    }
  }
  var deserializeInputValue = (rawValue, transformer) => {
    return typeof rawValue !== "undefined" ? transformer.input.deserialize(rawValue) : rawValue;
  };
  var getJsonContentTypeInputs = (opts) => {
    const rawInput = getRawProcedureInputOrThrow(opts);
    const transformer = opts.router._def._config.transformer;
    if (!opts.isBatchCall) {
      return {
        0: deserializeInputValue(rawInput, transformer)
      };
    }
    if (rawInput == null || typeof rawInput !== "object" || Array.isArray(rawInput)) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: '"input" needs to be an object when doing a batch call'
      });
    }
    const input = {};
    for (const key in rawInput) {
      const k2 = key;
      const rawValue = rawInput[k2];
      const value = deserializeInputValue(rawValue, transformer);
      input[k2] = value;
    }
    return input;
  };

  // ../node_modules/@trpc/server/dist/resolveHTTPResponse-cd1a9112.mjs
  var HTTP_METHOD_PROCEDURE_TYPE_MAP = {
    GET: "query",
    POST: "mutation"
  };
  var fallbackContentTypeHandler = {
    getInputs: getJsonContentTypeInputs
  };
  function initResponse(initOpts) {
    const { ctx, paths, type: type2, responseMeta, untransformedJSON, errors = [] } = initOpts;
    let status = untransformedJSON ? getHTTPStatusCode(untransformedJSON) : 200;
    const headers = {
      "Content-Type": "application/json"
    };
    const eagerGeneration = !untransformedJSON;
    const data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [
      untransformedJSON
    ];
    const meta = responseMeta?.({
      ctx,
      paths,
      type: type2,
      data,
      errors,
      eagerGeneration
    }) ?? {};
    for (const [key, value] of Object.entries(meta.headers ?? {})) {
      headers[key] = value;
    }
    if (meta.status) {
      status = meta.status;
    }
    return {
      status,
      headers
    };
  }
  async function inputToProcedureCall(procedureOpts) {
    const { opts, ctx, type: type2, input, path } = procedureOpts;
    try {
      const data = await callProcedure({
        procedures: opts.router._def.procedures,
        path,
        rawInput: input,
        ctx,
        type: type2
      });
      return {
        result: {
          data
        }
      };
    } catch (cause) {
      const error = getTRPCErrorFromUnknown(cause);
      opts.onError?.({
        error,
        path,
        input,
        ctx,
        type: type2,
        req: opts.req
      });
      return {
        error: getErrorShape({
          config: opts.router._def._config,
          error,
          type: type2,
          path,
          input,
          ctx
        })
      };
    }
  }
  function caughtErrorToData(cause, errorOpts) {
    const { router: router2, req, onError } = errorOpts.opts;
    const error = getTRPCErrorFromUnknown(cause);
    onError?.({
      error,
      path: errorOpts.path,
      input: errorOpts.input,
      ctx: errorOpts.ctx,
      type: errorOpts.type,
      req
    });
    const untransformedJSON = {
      error: getErrorShape({
        config: router2._def._config,
        error,
        type: errorOpts.type,
        path: errorOpts.path,
        input: errorOpts.input,
        ctx: errorOpts.ctx
      })
    };
    const transformedJSON = transformTRPCResponse(router2._def._config, untransformedJSON);
    const body = JSON.stringify(transformedJSON);
    return {
      error,
      untransformedJSON,
      body
    };
  }
  async function resolveHTTPResponse(opts) {
    const { router: router2, req, unstable_onHead, unstable_onChunk } = opts;
    if (req.method === "HEAD") {
      const headResponse = {
        status: 204
      };
      unstable_onHead?.(headResponse, false);
      unstable_onChunk?.([
        -1,
        ""
      ]);
      return headResponse;
    }
    const contentTypeHandler = opts.contentTypeHandler ?? fallbackContentTypeHandler;
    const batchingEnabled = opts.batching?.enabled ?? true;
    const type2 = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method] ?? "unknown";
    let ctx = void 0;
    let paths;
    const isBatchCall = !!req.query.get("batch");
    const isStreamCall = isBatchCall && unstable_onHead && unstable_onChunk && req.headers["trpc-batch-mode"] === "stream";
    try {
      ctx = await opts.createContext();
      if (opts.error) {
        throw opts.error;
      }
      if (isBatchCall && !batchingEnabled) {
        throw new Error(`Batching is not enabled on the server`);
      }
      if (type2 === "subscription") {
        throw new TRPCError({
          message: "Subscriptions should use wsLink",
          code: "METHOD_NOT_SUPPORTED"
        });
      }
      if (type2 === "unknown") {
        throw new TRPCError({
          message: `Unexpected request method ${req.method}`,
          code: "METHOD_NOT_SUPPORTED"
        });
      }
      const inputs = await contentTypeHandler.getInputs({
        isBatchCall,
        req,
        router: router2,
        preprocessedBody: opts.preprocessedBody ?? false
      });
      paths = isBatchCall ? decodeURIComponent(opts.path).split(",") : [
        opts.path
      ];
      const promises = paths.map((path, index) => inputToProcedureCall({
        opts,
        ctx,
        type: type2,
        input: inputs[index],
        path
      }));
      if (!isStreamCall) {
        const untransformedJSON = await Promise.all(promises);
        const errors = untransformedJSON.flatMap((response) => "error" in response ? [
          response.error
        ] : []);
        const headResponse1 = initResponse({
          ctx,
          paths,
          type: type2,
          responseMeta: opts.responseMeta,
          untransformedJSON,
          errors
        });
        unstable_onHead?.(headResponse1, false);
        const result = isBatchCall ? untransformedJSON : untransformedJSON[0];
        const transformedJSON = transformTRPCResponse(router2._def._config, result);
        const body = JSON.stringify(transformedJSON);
        unstable_onChunk?.([
          -1,
          body
        ]);
        return {
          status: headResponse1.status,
          headers: headResponse1.headers,
          body
        };
      }
      const headResponse2 = initResponse({
        ctx,
        paths,
        type: type2,
        responseMeta: opts.responseMeta
      });
      unstable_onHead(headResponse2, true);
      const indexedPromises = new Map(promises.map((promise, index) => [
        index,
        promise.then((r6) => [
          index,
          r6
        ])
      ]));
      for (const _ of paths) {
        const [index, untransformedJSON1] = await Promise.race(indexedPromises.values());
        indexedPromises.delete(index);
        try {
          const transformedJSON1 = transformTRPCResponse(router2._def._config, untransformedJSON1);
          const body1 = JSON.stringify(transformedJSON1);
          unstable_onChunk([
            index,
            body1
          ]);
        } catch (cause) {
          const path = paths[index];
          const input = inputs[index];
          const { body: body2 } = caughtErrorToData(cause, {
            opts,
            ctx,
            type: type2,
            path,
            input
          });
          unstable_onChunk([
            index,
            body2
          ]);
        }
      }
      return;
    } catch (cause1) {
      const { error, untransformedJSON: untransformedJSON2, body: body3 } = caughtErrorToData(cause1, {
        opts,
        ctx,
        type: type2
      });
      const headResponse3 = initResponse({
        ctx,
        paths,
        type: type2,
        responseMeta: opts.responseMeta,
        untransformedJSON: untransformedJSON2,
        errors: [
          error
        ]
      });
      unstable_onHead?.(headResponse3, false);
      unstable_onChunk?.([
        -1,
        body3
      ]);
      return {
        status: headResponse3.status,
        headers: headResponse3.headers,
        body: body3
      };
    }
  }

  // ../node_modules/@trpc/server/dist/batchStreamFormatter-fc1ffb26.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getBatchStreamFormatter() {
    let first = true;
    function format2(index, string) {
      const prefix = first ? "{" : ",";
      first = false;
      return `${prefix}"${index}":${string}
`;
    }
    format2.end = () => "}";
    return format2;
  }

  // ../node_modules/@trpc/server/dist/adapters/fetch/index.mjs
  async function fetchRequestHandler(opts) {
    const resHeaders = new Headers();
    const createContext = async () => {
      return opts.createContext?.({
        req: opts.req,
        resHeaders
      });
    };
    const url = new URL(opts.req.url);
    const path = url.pathname.slice(opts.endpoint.length + 1);
    const req = {
      query: url.searchParams,
      method: opts.req.method,
      headers: Object.fromEntries(opts.req.headers),
      body: opts.req.headers.get("content-type")?.startsWith("application/json") ? await opts.req.text() : ""
    };
    let resolve2;
    const promise = new Promise((r6) => resolve2 = r6);
    let status = 200;
    let isStream2 = false;
    let controller;
    let encoder;
    let formatter;
    const unstable_onHead = (head, isStreaming) => {
      for (const [key, value] of Object.entries(head.headers ?? {})) {
        if (typeof value === "undefined") {
          continue;
        }
        if (typeof value === "string") {
          resHeaders.set(key, value);
          continue;
        }
        for (const v of value) {
          resHeaders.append(key, v);
        }
      }
      status = head.status;
      if (isStreaming) {
        resHeaders.set("Transfer-Encoding", "chunked");
        resHeaders.append("Vary", "trpc-batch-mode");
        const stream = new ReadableStream({
          start(c2) {
            controller = c2;
          }
        });
        const response = new Response(stream, {
          status,
          headers: resHeaders
        });
        resolve2(response);
        encoder = new TextEncoder();
        formatter = getBatchStreamFormatter();
        isStream2 = true;
      }
    };
    const unstable_onChunk = ([index, string]) => {
      if (index === -1) {
        const response = new Response(string || null, {
          status,
          headers: resHeaders
        });
        resolve2(response);
      } else {
        controller.enqueue(encoder.encode(formatter(index, string)));
      }
    };
    resolveHTTPResponse({
      req,
      createContext,
      path,
      router: opts.router,
      batching: opts.batching,
      responseMeta: opts.responseMeta,
      onError(o) {
        opts?.onError?.({
          ...o,
          req: opts.req
        });
      },
      unstable_onHead,
      unstable_onChunk
    }).then(() => {
      if (isStream2) {
        controller.enqueue(encoder.encode(formatter.end()));
        controller.close();
      }
    }).catch(() => {
      if (isStream2) {
        controller.close();
      }
    });
    return promise;
  }

  // ../node_modules/@trpc/server/dist/observable/index.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/@trpc/server/dist/observable-ade1bad8.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function isObservable(x2) {
    return typeof x2 === "object" && x2 !== null && "subscribe" in x2;
  }

  // ../node_modules/@elysiajs/trpc/dist/utils.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function transformTRPCResponseItem2(router2, item) {
    if ("error" in item) {
      return {
        ...item,
        error: router2._def._config.transformer.output.serialize(item.error)
      };
    }
    if ("data" in item.result) {
      return {
        ...item,
        result: {
          ...item.result,
          data: router2._def._config.transformer.output.serialize(item.result.data)
        }
      };
    }
    return item;
  }
  function transformTRPCResponse2(router2, itemOrItems) {
    return Array.isArray(itemOrItems) ? itemOrItems.map((item) => transformTRPCResponseItem2(router2, item)) : transformTRPCResponseItem2(router2, itemOrItems);
  }
  function getMessageFromUnknownError(err, fallback) {
    if (typeof err === "string") {
      return err;
    }
    if (err instanceof Error && typeof err.message === "string") {
      return err.message;
    }
    return fallback;
  }
  function getErrorFromUnknown(cause) {
    if (cause instanceof Error) {
      return cause;
    }
    const message = getMessageFromUnknownError(cause, "Unknown error");
    return new Error(message);
  }
  function getTRPCErrorFromUnknown2(cause) {
    const error = getErrorFromUnknown(cause);
    if (error.name === "TRPCError")
      return cause;
    const trpcError = new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      cause: error,
      message: error.message
    });
    trpcError.stack = error.stack;
    return trpcError;
  }

  // ../node_modules/@elysiajs/trpc/dist/index.js
  var getPath = (url) => {
    const start = url.indexOf("/", 9);
    const end = url.indexOf("?", start);
    if (end === -1)
      return url.slice(start);
    return url.slice(start, end);
  };
  var trpc = (router2, { endpoint = "/trpc", ...options } = {
    endpoint: "/trpc"
  }) => (eri) => {
    let app2 = eri.onParse(async ({ request: { url } }) => {
      if (getPath(url).startsWith(endpoint))
        return true;
    }).get(`${endpoint}/*`, async ({ query, request }) => {
      return fetchRequestHandler({
        ...options,
        req: request,
        router: router2,
        endpoint
      });
    }).post(`${endpoint}/*`, async ({ query, request }) => {
      return fetchRequestHandler({
        ...options,
        req: request,
        router: router2,
        endpoint
      });
    });
    const observers = /* @__PURE__ */ new Map();
    if (app2.wsRouter)
      app2.ws(endpoint, {
        async message(ws, message) {
          const messages = Array.isArray(message) ? message : [message];
          let observer;
          for (const incoming of messages) {
            if (!incoming.method || !incoming.params) {
              continue;
            }
            if (incoming.method === "subscription.stop") {
              observer?.unsubscribe();
              observers.delete(ws.data.id.toString());
              return void ws.send(JSON.stringify({
                id: incoming.id,
                jsonrpc: incoming.jsonrpc,
                result: {
                  type: "stopped"
                }
              }));
            }
            const result = await callProcedure({
              procedures: router2._def.procedures,
              path: incoming.params.path,
              rawInput: incoming.params.input?.json,
              type: incoming.method,
              ctx: {}
            });
            if (incoming.method !== "subscription")
              return void ws.send(JSON.stringify(transformTRPCResponse2(router2, {
                id: incoming.id,
                jsonrpc: incoming.jsonrpc,
                result: {
                  type: "data",
                  data: result
                }
              })));
            ws.send(JSON.stringify({
              id: incoming.id,
              jsonrpc: incoming.jsonrpc,
              result: {
                type: "started"
              }
            }));
            if (!isObservable(result))
              throw new TRPCError({
                message: `Subscription ${incoming.params.path} did not return an observable`,
                code: "INTERNAL_SERVER_ERROR"
              });
            observer = result.subscribe({
              next(data) {
                ws.send(JSON.stringify(transformTRPCResponse2(router2, {
                  id: incoming.id,
                  jsonrpc: incoming.jsonrpc,
                  result: {
                    type: "data",
                    data
                  }
                })));
              },
              error(err) {
                ws.send(JSON.stringify(transformTRPCResponse2(router2, {
                  id: incoming.id,
                  jsonrpc: incoming.jsonrpc,
                  error: router2.getErrorShape({
                    error: getTRPCErrorFromUnknown2(err),
                    type: incoming.method,
                    path: incoming.params.path,
                    input: incoming.params.input,
                    ctx: {}
                  })
                })));
              },
              complete() {
                ws.send(JSON.stringify(transformTRPCResponse2(router2, {
                  id: incoming.id,
                  jsonrpc: incoming.jsonrpc,
                  result: {
                    type: "stopped"
                  }
                })));
              }
            });
            observers.set(ws.data.id.toString(), observer);
          }
        },
        close(ws) {
          observers.get(ws.data.id.toString())?.unsubscribe();
          observers.delete(ws.data.id.toString());
        }
      });
    return app2;
  };

  // src/routes/trpcRouter.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/getOsm/getPhotonDetails.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/helpers/errors.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var UserNotFoundError = { statusCode: 404, message: "User not found" };
  var ErrorFetchingGeoCodeError = {
    statusCode: 500,
    message: "Error fetching GeoCode"
  };
  var ErrorProcessingOverpassError = {
    statusCode: 500,
    message: "Error processing Overpass Data"
  };
  var ErrorRetrievingOverpassError = {
    statusCode: 500,
    message: "Error retrieving Overpass Data"
  };
  var RetrievingParksDataError = {
    statusCode: 500,
    message: "Error retrieving Parks Data"
  };
  var RetrievingTrailsDataError = {
    statusCode: 500,
    message: "Error retrieving Trails Data"
  };
  var TemplateNotFoundError = {
    statusCode: 404,
    message: "Template not found"
  };

  // src/helpers/responseHandler.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/zod/lib/index.mjs
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
      const filtered = {};
      for (const k2 of validKeys) {
        filtered[k2] = obj[k2];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e8) {
        return obj[e8];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys2 = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys2.push(key);
        }
      }
      return keys2;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t5 = typeof data;
    switch (t5) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i2 = 0;
            while (i2 < issue.path.length) {
              const el = issue.path[i2];
              const terminal = i2 === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i2++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage
    };
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
        // then global default map
      ].filter((x2) => !!x2)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s3 of results) {
        if (s3.status === "aborted")
          return INVALID;
        if (s3.status === "dirty")
          status.dirty();
        arrayValue.push(s3.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x2) => x2.status === "aborted";
  var isDirty = (x2) => x2.status === "dirty";
  var isValid = (x2) => x2.status === "valid";
  var isAsync2 = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync2(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync2(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[a-z][a-z0-9]*$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  var datetimeRegex = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
      }
    }
  };
  function isValidIP(ip, version3) {
    if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(
          ctx2,
          {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          }
          //
        );
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  var ZodNumber = class extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i2) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i2) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys2 = util.objectKeys(shape);
      return this._cached = { shape, keys: keys2 };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip")
          ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type2) => {
    if (type2 instanceof ZodLazy) {
      return getDiscriminator(type2.schema);
    } else if (type2 instanceof ZodEffects) {
      return getDiscriminator(type2.innerType());
    } else if (type2 instanceof ZodLiteral) {
      return [type2.value];
    } else if (type2 instanceof ZodEnum) {
      return type2.options;
    } else if (type2 instanceof ZodNativeEnum) {
      return Object.keys(type2.enum);
    } else if (type2 instanceof ZodDefault) {
      return getDiscriminator(type2._def.innerType);
    } else if (type2 instanceof ZodUndefined) {
      return [void 0];
    } else if (type2 instanceof ZodNull) {
      return [null];
    } else {
      return null;
    }
  };
  var ZodDiscriminatedUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type2 of options) {
        const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type2);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a4, b2) {
    const aType = getParsedType(a4);
    const bType = getParsedType(b2);
    if (a4 === b2) {
      return { valid: true, data: a4 };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b2);
      const sharedKeys = util.objectKeys(a4).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a4, ...b2 };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a4[key], b2[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a4.length !== b2.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a4.length; index++) {
        const itemA = a4[index];
        const itemB = b2[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a4 === +b2) {
      return { valid: true, data: a4 };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x2) => !!x2);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e8) => {
            error.addIssue(makeArgsIssue(args, e8));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e8) => {
            error.addIssue(makeReturnsIssue(result, e8));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values) {
      return ZodEnum.create(values);
    }
    exclude(values) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
  };
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.issues.length) {
          return {
            status: "dirty",
            value: ctx.data
          };
        }
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => {
            return this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type2, params) => {
    return new ZodOptional({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type2, params) => {
    return new ZodNullable({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type2, params) => {
    return new ZodDefault({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync2(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type2, params) => {
    return new ZodCatch({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a4, b2) {
      return new ZodPipeline({
        in: a4,
        out: b2,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var ZodReadonly = class extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      if (isValid(result)) {
        result.value = Object.freeze(result.value);
      }
      return result;
    }
  };
  ZodReadonly.create = (type2, params) => {
    return new ZodReadonly({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  var custom = (check, params = {}, fatal) => {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a, _b;
        if (!check(data)) {
          const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
          const p22 = typeof p2 === "string" ? { message: p2 } : p2;
          ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
        }
      });
    return ZodAny.create();
  };
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  var NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync: isAsync2,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });

  // src/trpc.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var t4 = initTRPC.create();
  var router = t4.router;
  var middleware = t4.middleware;
  var publicProcedure = t4.procedure;

  // src/services/osm/getPhotonDetailsService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_osmtogeojson = __toESM(require_osmtogeojson());

  // ../node_modules/axios/index.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/axios.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/utils.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/helpers/bind.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }

  // ../node_modules/axios/lib/utils.js
  var { toString: toString2 } = Object.prototype;
  var { getPrototypeOf } = Object;
  var kindOf = ((cache) => (thing) => {
    const str = toString2.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  var kindOfTest = (type2) => {
    type2 = type2.toLowerCase();
    return (thing) => kindOf(thing) === type2;
  };
  var typeOfTest = (type2) => (thing) => typeof thing === type2;
  var { isArray } = Array;
  var isUndefined = typeOfTest("undefined");
  function isBuffer2(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  var isString = typeOfTest("string");
  var isFunction = typeOfTest("function");
  var isNumber = typeOfTest("number");
  var isObject2 = (thing) => thing !== null && typeof thing === "object";
  var isBoolean = (thing) => thing === true || thing === false;
  var isPlainObject2 = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype3 = getPrototypeOf(val);
    return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  var isDate = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  var isStream = (val) => isObject2(val) && isFunction(val.pipe);
  var isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  var isURLSearchParams = kindOfTest("URLSearchParams");
  var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i2;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i2 = 0, l = obj.length; i2 < l; i2++) {
        fn.call(null, obj[i2], i2, obj);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys2 = Object.keys(obj);
    let i2 = keys2.length;
    let _key;
    while (i2-- > 0) {
      _key = keys2[i2];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  var _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : globalThis;
  })();
  var isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject2(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
      arguments[i2] && forEach(arguments[i2], assignValue);
    }
    return result;
  }
  var extend = (a4, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key) => {
      if (thisArg && isFunction(val)) {
        a4[key] = bind(val, thisArg);
      } else {
        a4[key] = val;
      }
    }, { allOwnKeys });
    return a4;
  };
  var stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  var inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  var toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
    let props;
    let i2;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i2 = props.length;
      while (i2-- > 0) {
        prop = props[i2];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  var endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  var toArray = (thing) => {
    if (!thing)
      return null;
    if (isArray(thing))
      return thing;
    let i2 = thing.length;
    if (!isNumber(i2))
      return null;
    const arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  };
  var isTypedArray = ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  var forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  var matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  var isHTMLForm = kindOfTest("HTMLFormElement");
  var toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
  var isRegExp = kindOfTest("RegExp");
  var reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  var freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  var toObjectSet = (arrayOrString, delimiter2) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
    return obj;
  };
  var noop3 = () => {
  };
  var toFiniteNumber = (value, defaultValue) => {
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
  };
  var ALPHA = "abcdefghijklmnopqrstuvwxyz";
  var DIGIT = "0123456789";
  var ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length } = alphabet;
    while (size--) {
      str += alphabet[Math.random() * length | 0];
    }
    return str;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  var toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i2) => {
      if (isObject2(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i2] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i2 + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i2] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  var isAsyncFn = kindOfTest("AsyncFunction");
  var isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  var utils_default = {
    isArray,
    isArrayBuffer,
    isBuffer: isBuffer2,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject: isObject2,
    isPlainObject: isPlainObject2,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop3,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
  };

  // ../node_modules/axios/lib/core/Axios.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/helpers/buildURL.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/helpers/AxiosURLSearchParams.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/helpers/toFormData.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/core/AxiosError.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function AxiosError(message, code, config4, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config4 && (this.config = config4);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils_default.inherits(AxiosError, Error, {
    toJSON: function toJSON2() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils_default.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  var prototype = AxiosError.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype, "isAxiosError", { value: true });
  AxiosError.from = (error, code, config4, request, response, customProps) => {
    const axiosError = Object.create(prototype);
    utils_default.toFlatObject(error, axiosError, function filter3(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config4, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var AxiosError_default = AxiosError;

  // ../node_modules/axios/lib/helpers/null.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var null_default = null;

  // ../node_modules/axios/lib/helpers/toFormData.js
  function isVisitable(thing) {
    return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
  }
  function removeBrackets(key) {
    return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path)
      return key;
    return path.concat(key).map(function each(token, i2) {
      token = removeBrackets(token);
      return !dots && i2 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils_default.isArray(arr) && !arr.some(isVisitable);
  }
  var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils_default.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new (null_default || FormData)();
    options = utils_default.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils_default.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
    if (!utils_default.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils_default.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils_default.isBlob(value)) {
        throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
      }
      if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer2.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils_default.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index) {
            !(utils_default.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils_default.isUndefined(value))
        return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils_default.forEach(value, function each(el, key) {
        const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils_default.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils_default.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  var toFormData_default = toFormData;

  // ../node_modules/axios/lib/helpers/AxiosURLSearchParams.js
  function encode(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData_default(params, this, options);
  }
  var prototype2 = AxiosURLSearchParams.prototype;
  prototype2.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype2.toString = function toString3(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  var AxiosURLSearchParams_default = AxiosURLSearchParams;

  // ../node_modules/axios/lib/helpers/buildURL.js
  function encode2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode2;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }

  // ../node_modules/axios/lib/core/InterceptorManager.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var InterceptorManager = class {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils_default.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    }
  };
  var InterceptorManager_default = InterceptorManager;

  // ../node_modules/axios/lib/core/dispatchRequest.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/core/transformData.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/defaults/index.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/defaults/transitional.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var transitional_default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };

  // ../node_modules/axios/lib/helpers/toURLEncodedForm.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/platform/index.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/platform/browser/index.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

  // ../node_modules/axios/lib/platform/browser/classes/FormData.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var FormData_default = typeof FormData !== "undefined" ? FormData : null;

  // ../node_modules/axios/lib/platform/browser/classes/Blob.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var Blob_default = typeof Blob !== "undefined" ? Blob : null;

  // ../node_modules/axios/lib/platform/browser/index.js
  var isStandardBrowserEnv = (() => {
    let product;
    if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  })();
  var isStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  var browser_default = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams_default,
      FormData: FormData_default,
      Blob: Blob_default
    },
    isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv,
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };

  // ../node_modules/axios/lib/helpers/toURLEncodedForm.js
  function toURLEncodedForm(data, options) {
    return toFormData_default(data, new browser_default.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (browser_default.isNode && utils_default.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }

  // ../node_modules/axios/lib/helpers/formDataToJSON.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function parsePropPath(name) {
    return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i2;
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils_default.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils_default.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils_default.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils_default.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
      const obj = {};
      utils_default.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  var formDataToJSON_default = formDataToJSON;

  // ../node_modules/axios/lib/defaults/index.js
  function stringifySafely(rawValue, parser, encoder) {
    if (utils_default.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils_default.trim(rawValue);
      } catch (e8) {
        if (e8.name !== "SyntaxError") {
          throw e8;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults = {
    transitional: transitional_default,
    adapter: ["xhr", "http"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils_default.isObject(data);
      if (isObjectPayload && utils_default.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils_default.isFormData(data);
      if (isFormData2) {
        if (!hasJSONContentType) {
          return data;
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
      }
      if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
        return data;
      }
      if (utils_default.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils_default.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData_default(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional2 = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e8) {
          if (strictJSONParsing) {
            if (e8.name === "SyntaxError") {
              throw AxiosError_default.from(e8, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e8;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: browser_default.classes.FormData,
      Blob: browser_default.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  var defaults_default = defaults;

  // ../node_modules/axios/lib/core/AxiosHeaders.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/helpers/parseHeaders.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var ignoreDuplicateOf = utils_default.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  var parseHeaders_default = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i2;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
      i2 = line.indexOf(":");
      key = line.substring(0, i2).trim().toLowerCase();
      val = line.substring(i2 + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };

  // ../node_modules/axios/lib/core/AxiosHeaders.js
  var $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
    if (utils_default.isFunction(filter3)) {
      return filter3.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils_default.isString(value))
      return;
    if (utils_default.isString(filter3)) {
      return value.indexOf(filter3) !== -1;
    }
    if (utils_default.isRegExp(filter3)) {
      return filter3.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils_default.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  var AxiosHeaders = class {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils_default.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders_default(header), valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils_default.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils_default.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils_default.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils_default.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils_default.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils_default.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i2 = keys2.length;
      let deleted = false;
      while (i2--) {
        const key = keys2[i2];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils_default.forEach(this, (value, header) => {
        const key = utils_default.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils_default.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype3 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype3, _header);
          accessors[lHeader] = true;
        }
      }
      utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils_default.freezeMethods(AxiosHeaders);
  var AxiosHeaders_default = AxiosHeaders;

  // ../node_modules/axios/lib/core/transformData.js
  function transformData(fns, response) {
    const config4 = this || defaults_default;
    const context = response || config4;
    const headers = AxiosHeaders_default.from(context.headers);
    let data = context.data;
    utils_default.forEach(fns, function transform(fn) {
      data = fn.call(config4, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }

  // ../node_modules/axios/lib/cancel/isCancel.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }

  // ../node_modules/axios/lib/cancel/CanceledError.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function CanceledError(message, config4, request) {
    AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config4, request);
    this.name = "CanceledError";
  }
  utils_default.inherits(CanceledError, AxiosError_default, {
    __CANCEL__: true
  });
  var CanceledError_default = CanceledError;

  // ../node_modules/axios/lib/adapters/adapters.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/adapters/xhr.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/core/settle.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function settle(resolve2, reject, response) {
    const validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError_default(
        "Request failed with status code " + response.status,
        [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }

  // ../node_modules/axios/lib/helpers/cookies.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var cookies_default = browser_default.isStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write4(name, value, expires, path, domain2, secure) {
          const cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils_default.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils_default.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils_default.isString(domain2)) {
            cookie.push("domain=" + domain2);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read2(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write4() {
        },
        read: function read2() {
          return null;
        },
        remove: function remove() {
        }
      };
    }()
  );

  // ../node_modules/axios/lib/core/buildFullPath.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/helpers/isAbsoluteURL.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }

  // ../node_modules/axios/lib/helpers/combineURLs.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }

  // ../node_modules/axios/lib/core/buildFullPath.js
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }

  // ../node_modules/axios/lib/helpers/isURLSameOrigin.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var isURLSameOrigin_default = browser_default.isStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv2() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url) {
        let href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv2() {
      return function isURLSameOrigin() {
        return true;
      };
    }()
  );

  // ../node_modules/axios/lib/helpers/parseProtocol.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }

  // ../node_modules/axios/lib/helpers/speedometer.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i2 = tail;
      let bytesCount = 0;
      while (i2 !== head) {
        bytesCount += bytes[i2++];
        i2 = i2 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  var speedometer_default = speedometer;

  // ../node_modules/axios/lib/adapters/xhr.js
  function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer_default(50, 250);
    return (e8) => {
      const loaded = e8.loaded;
      const total = e8.lengthComputable ? e8.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e8
      };
      data[isDownloadStream ? "download" : "upload"] = true;
      listener(data);
    };
  }
  var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  var xhr_default = isXHRAdapterSupported && function(config4) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      let requestData = config4.data;
      const requestHeaders = AxiosHeaders_default.from(config4.headers).normalize();
      const responseType = config4.responseType;
      let onCanceled;
      function done2() {
        if (config4.cancelToken) {
          config4.cancelToken.unsubscribe(onCanceled);
        }
        if (config4.signal) {
          config4.signal.removeEventListener("abort", onCanceled);
        }
      }
      let contentType;
      if (utils_default.isFormData(requestData)) {
        if (browser_default.isStandardBrowserEnv || browser_default.isStandardBrowserWebWorkerEnv) {
          requestHeaders.setContentType(false);
        } else if (!requestHeaders.getContentType(/^\s*multipart\/form-data/)) {
          requestHeaders.setContentType("multipart/form-data");
        } else if (utils_default.isString(contentType = requestHeaders.getContentType())) {
          requestHeaders.setContentType(contentType.replace(/^\s*(multipart\/form-data);+/, "$1"));
        }
      }
      let request = new XMLHttpRequest();
      if (config4.auth) {
        const username = config4.auth.username || "";
        const password = config4.auth.password ? unescape(encodeURIComponent(config4.auth.password)) : "";
        requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
      }
      const fullPath = buildFullPath(config4.baseURL, config4.url);
      request.open(config4.method.toUpperCase(), buildURL(fullPath, config4.params, config4.paramsSerializer), true);
      request.timeout = config4.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders_default.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config4,
          request
        };
        settle(function _resolve(value) {
          resolve2(value);
          done2();
        }, function _reject(err) {
          reject(err);
          done2();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config4, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config4, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config4.timeout ? "timeout of " + config4.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config4.transitional || transitional_default;
        if (config4.timeoutErrorMessage) {
          timeoutErrorMessage = config4.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config4,
          request
        ));
        request = null;
      };
      if (browser_default.isStandardBrowserEnv) {
        const xsrfValue = isURLSameOrigin_default(fullPath) && config4.xsrfCookieName && cookies_default.read(config4.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config4.xsrfHeaderName, xsrfValue);
        }
      }
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils_default.isUndefined(config4.withCredentials)) {
        request.withCredentials = !!config4.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = config4.responseType;
      }
      if (typeof config4.onDownloadProgress === "function") {
        request.addEventListener("progress", progressEventReducer(config4.onDownloadProgress, true));
      }
      if (typeof config4.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", progressEventReducer(config4.onUploadProgress));
      }
      if (config4.cancelToken || config4.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError_default(null, config4, request) : cancel);
          request.abort();
          request = null;
        };
        config4.cancelToken && config4.cancelToken.subscribe(onCanceled);
        if (config4.signal) {
          config4.signal.aborted ? onCanceled() : config4.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(fullPath);
      if (protocol && browser_default.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config4));
        return;
      }
      request.send(requestData || null);
    });
  };

  // ../node_modules/axios/lib/adapters/adapters.js
  var knownAdapters = {
    http: null_default,
    xhr: xhr_default
  };
  utils_default.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e8) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  var renderReason = (reason) => `- ${reason}`;
  var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
  var adapters_default = {
    getAdapter: (adapters) => {
      adapters = utils_default.isArray(adapters) ? adapters : [adapters];
      const { length } = adapters;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i2 = 0; i2 < length; i2++) {
        nameOrAdapter = adapters[i2];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError_default(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i2] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s3 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError_default(
          `There is no suitable adapter to dispatch the request ` + s3,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };

  // ../node_modules/axios/lib/core/dispatchRequest.js
  function throwIfCancellationRequested(config4) {
    if (config4.cancelToken) {
      config4.cancelToken.throwIfRequested();
    }
    if (config4.signal && config4.signal.aborted) {
      throw new CanceledError_default(null, config4);
    }
  }
  function dispatchRequest(config4) {
    throwIfCancellationRequested(config4);
    config4.headers = AxiosHeaders_default.from(config4.headers);
    config4.data = transformData.call(
      config4,
      config4.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config4.method) !== -1) {
      config4.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters_default.getAdapter(config4.adapter || defaults_default.adapter);
    return adapter(config4).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config4);
      response.data = transformData.call(
        config4,
        config4.transformResponse,
        response
      );
      response.headers = AxiosHeaders_default.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config4);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config4,
            config4.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }

  // ../node_modules/axios/lib/core/mergeConfig.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
  function mergeConfig(config1, config22) {
    config22 = config22 || {};
    const config4 = {};
    function getMergedValue(target, source, caseless) {
      if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
        return utils_default.merge.call({ caseless }, target, source);
      } else if (utils_default.isPlainObject(source)) {
        return utils_default.merge({}, source);
      } else if (utils_default.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a4, b2, caseless) {
      if (!utils_default.isUndefined(b2)) {
        return getMergedValue(a4, b2, caseless);
      } else if (!utils_default.isUndefined(a4)) {
        return getMergedValue(void 0, a4, caseless);
      }
    }
    function valueFromConfig2(a4, b2) {
      if (!utils_default.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a4, b2) {
      if (!utils_default.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils_default.isUndefined(a4)) {
        return getMergedValue(void 0, a4);
      }
    }
    function mergeDirectKeys(a4, b2, prop) {
      if (prop in config22) {
        return getMergedValue(a4, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a4);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a4, b2) => mergeDeepProperties(headersToObject(a4), headersToObject(b2), true)
    };
    utils_default.forEach(Object.keys(Object.assign({}, config1, config22)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config22[prop], prop);
      utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config4[prop] = configValue);
    });
    return config4;
  }

  // ../node_modules/axios/lib/helpers/validator.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // ../node_modules/axios/lib/env/data.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var VERSION = "1.6.0";

  // ../node_modules/axios/lib/helpers/validator.js
  var validators = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i2) => {
    validators[type2] = function validator3(thing) {
      return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
    };
  });
  var deprecatedWarnings = {};
  validators.transitional = function transitional(validator3, version3, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator3 === false) {
        throw new AxiosError_default(
          formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
          AxiosError_default.ERR_DEPRECATED
        );
      }
      if (version3 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version3 + " and will be removed in the near future"
          )
        );
      }
      return validator3 ? validator3(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options);
    let i2 = keys2.length;
    while (i2-- > 0) {
      const opt = keys2[i2];
      const validator3 = schema[opt];
      if (validator3) {
        const value = options[opt];
        const result = value === void 0 || validator3(value, opt, options);
        if (result !== true) {
          throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
      }
    }
  }
  var validator_default = {
    assertOptions,
    validators
  };

  // ../node_modules/axios/lib/core/Axios.js
  var validators2 = validator_default.validators;
  var Axios = class {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_default(),
        response: new InterceptorManager_default()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config4) {
      if (typeof configOrUrl === "string") {
        config4 = config4 || {};
        config4.url = configOrUrl;
      } else {
        config4 = configOrUrl || {};
      }
      config4 = mergeConfig(this.defaults, config4);
      const { transitional: transitional2, paramsSerializer, headers } = config4;
      if (transitional2 !== void 0) {
        validator_default.assertOptions(transitional2, {
          silentJSONParsing: validators2.transitional(validators2.boolean),
          forcedJSONParsing: validators2.transitional(validators2.boolean),
          clarifyTimeoutError: validators2.transitional(validators2.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils_default.isFunction(paramsSerializer)) {
          config4.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator_default.assertOptions(paramsSerializer, {
            encode: validators2.function,
            serialize: validators2.function
          }, true);
        }
      }
      config4.method = (config4.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils_default.merge(
        headers.common,
        headers[config4.method]
      );
      headers && utils_default.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config4.headers = AxiosHeaders_default.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config4) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i2 = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config4);
        while (i2 < len) {
          promise = promise.then(chain[i2++], chain[i2++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config4;
      i2 = 0;
      while (i2 < len) {
        const onFulfilled = requestInterceptorChain[i2++];
        const onRejected = requestInterceptorChain[i2++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i2 = 0;
      len = responseInterceptorChain.length;
      while (i2 < len) {
        promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
      }
      return promise;
    }
    getUri(config4) {
      config4 = mergeConfig(this.defaults, config4);
      const fullPath = buildFullPath(config4.baseURL, config4.url);
      return buildURL(fullPath, config4.params, config4.paramsSerializer);
    }
  };
  utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config4) {
      return this.request(mergeConfig(config4 || {}, {
        method,
        url,
        data: (config4 || {}).data
      }));
    };
  });
  utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config4) {
        return this.request(mergeConfig(config4 || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios_default = Axios;

  // ../node_modules/axios/lib/cancel/CancelToken.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var CancelToken = class {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners)
          return;
        let i2 = token._listeners.length;
        while (i2-- > 0) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve2) => {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config4, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError_default(message, config4, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c2) {
        cancel = c2;
      });
      return {
        token,
        cancel
      };
    }
  };
  var CancelToken_default = CancelToken;

  // ../node_modules/axios/lib/helpers/spread.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }

  // ../node_modules/axios/lib/helpers/isAxiosError.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function isAxiosError(payload) {
    return utils_default.isObject(payload) && payload.isAxiosError === true;
  }

  // ../node_modules/axios/lib/helpers/HttpStatusCode.js
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  var HttpStatusCode_default = HttpStatusCode;

  // ../node_modules/axios/lib/axios.js
  function createInstance(defaultConfig) {
    const context = new Axios_default(defaultConfig);
    const instance = bind(Axios_default.prototype.request, context);
    utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
    utils_default.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var axios = createInstance(defaults_default);
  axios.Axios = Axios_default;
  axios.CanceledError = CanceledError_default;
  axios.CancelToken = CancelToken_default;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData_default;
  axios.AxiosError = AxiosError_default;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders_default;
  axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters_default.getAdapter;
  axios.HttpStatusCode = HttpStatusCode_default;
  axios.default = axios;
  var axios_default = axios;

  // ../node_modules/axios/index.js
  var {
    Axios: Axios2,
    AxiosError: AxiosError2,
    CanceledError: CanceledError2,
    isCancel: isCancel2,
    CancelToken: CancelToken2,
    VERSION: VERSION2,
    all: all2,
    Cancel,
    isAxiosError: isAxiosError2,
    spread: spread2,
    toFormData: toFormData2,
    AxiosHeaders: AxiosHeaders2,
    HttpStatusCode: HttpStatusCode2,
    formToJSON,
    getAdapter,
    mergeConfig: mergeConfig2
  } = axios_default;

  // src/services/osm/getPhotonDetailsService.ts
  async function getPhotonDetailsService(id, type2) {
    type2 = type2.toLowerCase();
    switch (type2) {
      case "way":
      case "w":
        type2 = "way";
        break;
      case "node":
      case "n":
        type2 = "node";
        break;
      case "relation":
      case "r":
        type2 = "relation";
        break;
      default:
        break;
    }
    const overpassUrl = process.env.OSM_URI;
    const overpassQuery = `[out:json][timeout:25];${type2}(${id});(._;>;);out body;`;
    console.log("overpassQuery", overpassQuery);
    const response = await axios_default.post(overpassUrl, overpassQuery, {
      headers: { "Content-Type": "text/plain" }
    });
    const geojsonData = (0, import_osmtogeojson.default)(response.data);
    return geojsonData;
  }

  // src/controllers/getOsm/getPhotonDetails.ts
  function getPhotonDetailsRoute() {
    return publicProcedure.input(
      z.object({ id: z.union([z.string(), z.number()]), type: z.string() })
    ).query(async (opts) => {
      const { id, type: type2 } = opts.input;
      return await getPhotonDetailsService(id, type2);
    });
  }

  // src/controllers/user/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/user/addToFavorite.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/favorite/addToFavoriteService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/prisma/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/prisma/extension.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/prisma/client.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_edge = __toESM(require_edge3());
  var prisma = new import_edge.PrismaClient();
  var client_default = prisma;

  // src/prisma/statics/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/prisma/statics/user.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/config.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_dotenv = __toESM(require_main());
  (0, import_dotenv.config)();
  var MONGODB_URI = process.env.MONGODB_URI;
  var SERVICE_ACCOUNT_KEY = {
    type: process.env.SERVICE_ACCOUNT_KEY_TYPE,
    project_id: process.env.SERVICE_ACCOUNT_KEY_PROJECT_ID,
    private_key_id: process.env.SERVICE_ACCOUNT_KEY_PRIVATE_KEY_ID,
    private_key: process.env.SERVICE_ACCOUNT_KEY_PRIVATE_KEY,
    client_email: process.env.SERVICE_ACCOUNT_KEY_CLIENT_EMAIL,
    client_id: process.env.SERVICE_ACCOUNT_KEY_CLIENT_ID,
    auth_uri: process.env.SERVICE_ACCOUNT_KEY_AUTH_URI,
    token_uri: process.env.SERVICE_ACCOUNT_KEY_TOKEN_URI,
    auth_provider_x509_cert_url: process.env.SERVICE_ACCOUNT_KEY_AUTH_PROVIDER_X509_CERT_URL,
    client_x509_cert_url: process.env.SERVICE_ACCOUNT_KEY_CLIENT_X509_CERT_URL
  };
  var GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
  var GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
  var STMP_EMAIL = process.env.STMP_EMAIL;
  var STMP_PASSWORD = process.env.STMP_PASSWORD;
  var CLIENT_URL = process.env.CLIENT_URL;
  var JWT_SECRET = process.env.JWT_SECRET;
  var SEND_GRID_API_KEY = process.env.SEND_GRID_API_KEY;
  var SERVER_ROOT_URI = process.env.SERVER_ROOT_URI;
  var UI_ROOT_URI = process.env.CLIENT_URL;
  var CORS_ORIGIN = process.env.CORS_ORIGIN;

  // src/prisma/statics/user.ts
  var import_jsonwebtoken = __toESM(require_jsonwebtoken());
  async function findByCredentials({
    email,
    password
  }) {
    const user = await client_default.user.findFirst({ where: { email } });
    if (!user)
      throw new Error("Unable to login");
    return user;
  }
  async function alreadyLogin(email) {
    const user = client_default.user.findFirst({
      where: { email }
    });
    if (user)
      throw new Error("Already email registered");
  }
  async function validateResetToken(token) {
    if (!JWT_SECRET)
      throw new Error("JWT_SECRET is not defined");
    const decoded = import_jsonwebtoken.default.verify(token, JWT_SECRET);
    const user = await client_default.user.findFirst({
      where: { id: decoded.id, passwordResetToken: token }
    });
    if (!user)
      throw new Error("User not Found");
    return user;
  }
  var user_default = {
    alreadyLogin,
    findByCredentials,
    validateResetToken
  };

  // src/prisma/statics/geojson.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function saveOne(feature) {
    return client_default.geoJSON.upsert({
      where: { id: feature.id },
      update: feature,
      create: feature
    });
  }
  async function saveMany(features) {
    return client_default.$transaction(
      features.map((feature) => client_default.geoJSON.create({ data: feature }))
    );
  }
  var geojson_default = { saveOne, saveMany };

  // src/prisma/statics/node.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var findOrCreateMany = async (ids, nodes) => {
    const existingNodes = await client_default.node.findMany({
      where: {
        id: {
          in: ids
        }
      }
    });
    const existingIds = existingNodes.map((node) => node.id);
    const filteredNodes = nodes.filter(
      (node) => !existingIds.includes(node.id)
    );
    if (filteredNodes.length > 0) {
      await client_default.node.createMany({
        data: filteredNodes
      });
    }
    return client_default.node.findMany({ where: { id: { in: ids } } });
  };
  var node_default = { findOrCreateMany };

  // src/prisma/extension.ts
  var prisma2 = client_default.$extends({
    // Model level extensions
    model: {
      geoJSON: {
        ...geojson_default
      },
      user: {
        ...user_default
      },
      node: {
        ...node_default
      }
    }
  });

  // src/services/favorite/addToFavoriteService.ts
  var addToFavoriteService = async (packId, userId) => {
    const user = await prisma2.user.findUnique({
      where: {
        id: userId
      },
      include: {
        favorites: true
      }
    });
    if (user.favorites.includes(packId)) {
      await prisma2.user.update({
        where: {
          id: userId
        },
        data: {
          favorites: {
            disconnect: {
              id: packId
            }
          }
        }
      });
      await prisma2.pack.update({
        where: {
          id: packId
        },
        data: {
          favorited_by: {
            disconnect: {
              id: userId
            }
          }
        }
      });
    } else {
      await prisma2.user.update({
        where: {
          id: userId
        },
        data: {
          favorites: {
            connect: {
              id: packId
            }
          }
        }
      });
      await prisma2.pack.update({
        where: {
          id: packId
        },
        data: {
          favorited_by: {
            connect: {
              id: userId
            }
          }
        }
      });
    }
  };

  // src/controllers/user/getMe.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getMeRoute() {
    return publicProcedure.query(async (opts) => {
      return opts.input;
    });
  }

  // src/controllers/user/resetPassword.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/middleware/validators/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/middleware/validators/userRoutesValidator.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_edge2 = __toESM(require_edge3());
  var JoiObjectId = z.string().regex(/^[0-9a-fA-F]{24}$/g);
  var userSignUp = z.object({
    name: z.string().min(1).nonempty(),
    email: z.string().email().nonempty(),
    password: z.string().nonempty(),
    username: z.string().nonempty()
  });
  var userSignIn = z.object({
    email: z.string().email().nonempty(),
    password: z.string().nonempty()
  });
  var getUserById = z.object({
    userId: JoiObjectId.nonempty()
  });
  var sentEmail = z.object({
    email: z.string().email().nonempty()
  });
  var resetPassword = z.object({
    resetToken: z.string().nonempty(),
    password: z.string().nonempty()
  });
  var addToFavorite = z.object({
    packId: JoiObjectId.nonempty(),
    userId: JoiObjectId.nonempty()
  });
  var editUser = z.object({
    userId: JoiObjectId.nonempty(),
    name: z.string(),
    password: z.string(),
    email: z.string(),
    token: z.string().optional(),
    code: z.string().optional(),
    googleId: z.string().optional(),
    is_certified_guide: z.boolean().optional(),
    passwordResetToken: z.string().optional(),
    passwordResetTokenExpiration: z.date().nullable().optional(),
    role: z.nativeEnum(import_edge2.Role).optional(),
    username: z.string().refine((value) => value.length > 0).optional(),
    profileImage: z.string().optional(),
    preferredWeather: z.string().optional(),
    preferredWeight: z.string().optional(),
    favourite_ids: z.array(JoiObjectId.nonempty()).optional(),
    pack_ids: z.array(JoiObjectId.nonempty()).optional(),
    item_id: JoiObjectId.nonempty().nullable().optional(),
    template_ids: z.array(JoiObjectId.nonempty()).optional(),
    trip_ids: z.array(JoiObjectId.nonempty()).optional()
  });
  var deleteUser = z.object({
    userId: JoiObjectId.nonempty()
  });
  var linkFirebaseAuth = z.object({
    firebaseAuthToken: z.string().nonempty()
  });
  var createMongoDBUser = z.object({
    email: z.string().email().nonempty(),
    name: z.string().min(1).nonempty(),
    password: z.string().nonempty()
  });
  var getFirebaseUserByEmail = z.object({
    email: z.string().email().nonempty()
  });
  var login = z.object({
    email: z.string().email().nonempty(),
    password: z.string().nonempty()
  });
  var checkCode = z.object({
    email: z.string().email().nonempty(),
    code: z.string().nonempty()
  });
  var emailExists = z.object({
    email: z.string().email().nonempty()
  });
  var updatePassword = z.object({
    email: z.string().email().nonempty(),
    password: z.string().nonempty()
  });

  // src/middleware/validators/tripRoutesValidator.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var JoiObjectId2 = (message = "valid id") => z.string().regex(/^[0-9a-fA-F]{24}$/g, { message });
  var getTrips = z.object({
    owner_id: JoiObjectId2().nonempty()
  });
  var getTripById = z.object({
    tripId: JoiObjectId2().nonempty()
  });
  var addTrip = z.object({
    name: z.string().nonempty(),
    description: z.string().nonempty(),
    duration: z.string().nonempty(),
    weather: z.string().nonempty(),
    start_date: z.string().nonempty(),
    end_date: z.string().nonempty(),
    destination: z.string().nonempty(),
    geoJSON: z.object({}),
    owner_id: JoiObjectId2().nonempty(),
    packs: z.string().nonempty(),
    is_public: z.boolean()
  });
  var editTrip = z.object({
    id: JoiObjectId2().nonempty(),
    name: z.string().nonempty(),
    duration: z.string().nonempty(),
    weather: z.string().nonempty(),
    start_date: z.string().nonempty(),
    end_date: z.string().nonempty(),
    destination: z.string().nonempty(),
    is_public: z.boolean()
  });
  var deleteTrip = z.object({
    tripId: JoiObjectId2().nonempty()
  });

  // src/middleware/validators/packRoutesValidator.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var JoiObjectId3 = (message = "valid id") => z.string().regex(/^[0-9a-fA-F]{24}$/, { message });
  var getPacks = z.object({
    ownerId: JoiObjectId3(),
    queryBy: z.string().optional()
  });
  var getPackById = z.object({
    packId: JoiObjectId3()
  });
  var addPack = z.object({
    name: z.string().nonempty(),
    owner_id: JoiObjectId3(),
    is_public: z.boolean()
  });
  var editPack = z.object({
    id: JoiObjectId3(),
    name: z.string().nonempty(),
    is_public: z.boolean()
  });
  var deletePack = z.object({
    packId: JoiObjectId3()
  });
  var duplicatePublicPack = z.object({
    packId: JoiObjectId3(),
    ownerId: JoiObjectId3(),
    items: z.array(z.object({}))
  });

  // src/middleware/validators/itemRoutesValidator.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var JoiObjectId4 = (message = "valid id") => z.string().regex(/^[0-9a-fA-F]{24}$/, { message });
  var getItems = z.object({
    packId: JoiObjectId4()
  });
  var getItemById = z.object({
    id: JoiObjectId4()
  });
  var addItem = z.object({
    name: z.string().nonempty(),
    weight: z.number(),
    quantity: z.number(),
    unit: z.string().nonempty(),
    packId: JoiObjectId4(),
    type: z.string().optional(),
    ownerId: z.string().optional()
  });
  var editItem = z.object({
    id: JoiObjectId4(),
    name: z.string().nonempty(),
    weight: z.number(),
    quantity: z.number(),
    unit: z.string().nonempty(),
    type: z.string()
  });
  var deleteItem = z.object({
    itemId: JoiObjectId4().nonempty(),
    packId: JoiObjectId4().nonempty()
  });
  var addItemGlobal = z.object({
    name: z.string().nonempty(),
    weight: z.number(),
    quantity: z.number(),
    unit: z.string().nonempty(),
    type: z.string().optional()
  });

  // src/controllers/user/resetPassword.ts
  function resetPasswordRoute() {
    return publicProcedure.input(resetPassword).mutation(async (opts) => {
      const { resetToken, password } = opts.input;
      const user = await prisma2.user.validateResetToken(resetToken);
      await prisma2.user.update({
        where: { id: user.id },
        data: {
          password
        }
      });
      return "Successfully reset password";
    });
  }

  // src/controllers/user/sentEmail.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/prisma/methods/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/prisma/methods/user.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_jsonwebtoken2 = __toESM(require_jsonwebtoken());
  var User = (prismaUser) => {
    if (!prismaUser)
      return;
    return Object.assign(prismaUser, {
      async save() {
        const user = this;
        if (user.username)
          return User(user);
        let generatedUsername = user.email ? user.email.split("@")[0] : "packratuser";
        let counter = 1;
        let exists = await client_default.user.findFirst({
          where: { username: generatedUsername }
        });
        while (!!exists) {
          generatedUsername = `${user.email.split("@")[0]}${counter}`;
          counter++;
          exists = await client_default.user.findFirst({
            where: { username: generatedUsername }
          });
        }
        const {
          save,
          toJSON: toJSON4,
          generateAuthToken,
          generateResetToken,
          ...userObject
        } = user;
        const updatedUser = await client_default.user.upsert({
          where: {
            username: generatedUsername
          },
          update: {
            username: generatedUsername
          },
          create: { ...userObject, username: generatedUsername }
        });
        return User(updatedUser);
      },
      toJSON() {
        const {
          password,
          passwordResetToken,
          // Remove function properties
          generateAuthToken,
          generateResetToken,
          save,
          toJSON: toJSON4,
          ...userObject
        } = this;
        return userObject;
      },
      async generateAuthToken() {
        if (!JWT_SECRET)
          throw new Error("JWT_SECRET is not defined");
        const token = await import_jsonwebtoken2.default.sign({ id: this.id.toString() }, JWT_SECRET, {
          expiresIn: "7 days"
        });
        this.token = token;
        await client_default.user.update({
          where: { id: this.id },
          data: { token }
        });
        return token;
      },
      async generateResetToken() {
        if (this.passwordResetToken) {
          if (!JWT_SECRET)
            throw new Error("JWT_SECRET is not defined");
          const decoded = import_jsonwebtoken2.default.verify(this.passwordResetToken, JWT_SECRET);
          if (decoded.id)
            return this.passwordResetToken;
        }
        if (!JWT_SECRET)
          throw new Error("JWT_SECRET is not defined");
        const resetToken = await import_jsonwebtoken2.default.sign(
          { id: this.id.toString() },
          JWT_SECRET,
          {
            expiresIn: "12h"
          }
        );
        this.passwordResetToken = resetToken;
        await client_default.user.update({
          where: { id: this.id },
          data: { passwordResetToken: resetToken }
        });
        return `${CLIENT_URL}/password-reset?token=${resetToken}`;
      }
    });
  };

  // src/prisma/methods/trip.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var Trip = (prismaTrip) => {
    if (!prismaTrip)
      return;
    return Object.assign(prismaTrip, {
      toJSON() {
        const {
          // destructure methods
          toJSON: toJSON4,
          ...trip
        } = this;
        const { ...tripObject } = trip;
        if (!trip.geojson)
          return tripObject;
        tripObject.geojson = {
          type: "FeatureCollection",
          features: tripObject.geojson
        };
        return tripObject;
      }
    });
  };

  // src/prisma/methods/way.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var Way = (prismaWay) => {
    if (!prismaWay)
      return;
    return Object.assign(prismaWay, {
      toJSON() {
        const {
          id,
          // destructure methods
          toJSON: toJSON4,
          save,
          ...wayObject
        } = this;
        return wayObject;
      },
      async save() {
        if (this.osm_type !== "way") {
          console.log(
            'ERROR in WaySchema.pre("save"): this.osm_type !== "way"',
            this.osm_type
          );
          throw new Error("This is not a way");
        }
        const {
          id,
          // destructure methods
          toJSON: toJSON4,
          save,
          ...wayObject
        } = this;
        await client_default.way.upsert({
          where: {
            id
          },
          update: wayObject,
          create: wayObject
        });
      }
    });
  };

  // src/prisma/methods/node.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/prisma/methods/relation.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/user/sentEmail.ts
  function sentEmailRoute() {
    return publicProcedure.input(sentEmail).query(async (opts) => {
      const { email } = opts.input;
      const user = await prisma2.user.findUnique({ where: { email } });
      const userWithMethods = User(user);
      if (!user) {
        throw new Error("User not found");
      }
      const resetUrl = await userWithMethods.generateResetToken();
      return "Reset Token has been sent successfully";
    });
  }

  // src/controllers/user/googleSignin.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/utils/utils.service.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var utilsService = (() => {
    function generatePassword(length = 8) {
      const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      let retVal = "";
      for (let i2 = 0, n3 = charset.length; i2 < length; ++i2) {
        retVal += charset.charAt(Math.floor(Math.random() * n3));
      }
      return retVal;
    }
    function generateUsernameCode(email, length = 4) {
      const charset = "123456789";
      let retVal = "";
      for (let i2 = 0, n3 = charset.length; i2 < length; ++i2) {
        retVal += charset.charAt(Math.floor(Math.random() * n3));
      }
      return email.split("@")[0] + retVal;
    }
    return {
      randomPasswordGenerator: generatePassword,
      randomUserNameCode: generateUsernameCode
    };
  })();

  // src/controllers/user/getGoogleAuthUrl.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getGoogleAuthURLRoute() {
    const scopes = [
      "https://www.googleapis.com/auth/userinfo.profile",
      "https://www.googleapis.com/auth/userinfo.email"
    ];
    return publicProcedure.query(async (opts) => {
      return {
        // googleUrl: oauth2Client.generateAuthUrl({
        //   access_type: 'offline',
        //   prompt: 'consent',
        //   scope: scopes,
        // }),
        status: "success",
        statusCode: 200
      };
    });
  }

  // src/controllers/user/getUserById.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/user/getUserByIdService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getUserByIdService = async (userId) => {
    try {
      const user = await prisma2.user.findUnique({
        where: {
          id: userId
        },
        include: {
          favorites: true
        }
      });
      if (user) {
        return User(user).toJSON();
      } else {
        throw new Error("User cannot be found");
      }
    } catch (error) {
      throw new Error("Server Error");
    }
  };

  // src/controllers/user/getUserById.ts
  function getUserByIdRoute() {
    return publicProcedure.input(getUserById).mutation(async (opts) => {
      const { input } = opts;
      return await getUserByIdService(input.userId);
    });
  }

  // src/controllers/user/deleteUser.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function deleteUserRoute() {
    return publicProcedure.input(deleteUser).mutation(async (opts) => {
      const { userId } = opts.input;
      await prisma2.user.delete({
        where: {
          id: userId
        }
      });
      return "User deleted successfully";
    });
  }

  // src/controllers/user/editUser.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function editUserRoute() {
    return publicProcedure.input(editUser).mutation(async (opts) => {
      const {
        userId,
        favourite_ids,
        pack_ids,
        template_ids,
        trip_ids,
        item_id,
        ...rest
      } = opts.input;
      const editedUser = await prisma2.user.update({
        where: {
          id: userId
        },
        data: {
          ...rest,
          favorites: {
            connect: favourite_ids?.map((favourite) => ({ id: favourite }))
          },
          packs: {
            connect: pack_ids?.map((pack) => ({ id: pack }))
          },
          templates: {
            connect: template_ids?.map((template) => ({ id: template }))
          },
          item: { connect: { id: item_id } }
        },
        select: {
          favorites: true
        }
      });
      return editedUser;
    });
  }

  // src/controllers/user/userSignUp.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function signUpRoute() {
    return publicProcedure.input(userSignUp).mutation(async (opts) => {
      let { email, password, name, username } = opts.input;
      console.log(opts.input);
      await prisma2.user.alreadyLogin(email);
      const user = await prisma2.user.create({
        data: {
          email,
          password,
          name,
          username
        }
      });
      const userWithMethods = User(user);
      await userWithMethods.generateAuthToken();
      return user;
    });
  }

  // src/controllers/user/getUsers.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getUsersRoute() {
    return publicProcedure.query(async (input) => {
      const users = await prisma2.user.findMany({
        include: {
          favorites: true
        }
      });
      return users;
    });
  }

  // src/controllers/user/userSignIn.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function userSignInRoute() {
    return publicProcedure.input(userSignIn).mutation(async (opts) => {
      const { input } = opts;
      const user = await prisma2.user.findByCredentials(input);
      console.log();
      await User(user).generateAuthToken();
      return user;
    });
  }

  // src/controllers/auth/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/auth/checkCode.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var validator = __toESM(require_dist());

  // src/services/user/checkCodeService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function checkCodeService({ email, code }) {
    const user = await prisma2.user.findFirst({
      where: {
        email: email.toLowerCase(),
        code
      }
    });
    return User(user)?.toJSON();
  }

  // src/controllers/auth/checkCode.ts
  function checkCodeRoute() {
    return publicProcedure.input(validator.checkCode).mutation(async (opts) => {
      return await checkCodeService(opts.input);
    });
  }

  // src/controllers/auth/emailExists.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var validator2 = __toESM(require_dist());

  // src/services/user/emailExistsService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/user/user.service.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/user/findUserAndUpdate.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function findUserAndUpdate(email, data, datatype) {
    try {
      const user = await prisma2.user.update({
        where: {
          email: email.toLowerCase()
        },
        data: {
          [datatype]: data
        }
      });
      if (user) {
        return User(user).toJSON();
      } else {
        return false;
      }
    } catch (error) {
      return false;
    }
  }

  // src/services/user/findUserByEmail.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function findUserByEmail(email) {
    try {
      const user = await prisma2.user.findUnique({
        where: {
          email: email.toLowerCase()
        }
      });
      if (user) {
        return true;
      } else {
        return "User not found";
      }
    } catch (error) {
      return "Server Error";
    }
  }

  // src/services/user/addToFavoritesService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/user/emailExistsService.ts
  async function emailExistsService({ email }) {
    const val = await findUserByEmail(email);
    if (val) {
      sendEmailNotice(email).then(async (result1) => {
        if (result1.status) {
          const { newcode } = result1;
          findUserAndUpdate(email, newcode, "code").then(async (result2) => {
            if (result2.status) {
              return result2;
            }
          });
        }
      });
    } else {
      return val;
    }
  }
  async function sendEmailNotice(email) {
    return await new Promise((resolve2, reject) => {
      const newcode = Math.floor(Math.random() * 999999 + 111111);
      const mailOptions = {
        from: "Hailemelekot@gmail.com",
        to: email,
        subject: "PackRat verification code",
        text: "Your verification code is " + newcode
      };
    });
  }

  // src/controllers/auth/emailExists.ts
  function emailExistsRoute() {
    return publicProcedure.input(validator2.emailExists).mutation(async (opts) => {
      return await emailExistsService(opts.input);
    });
  }

  // src/controllers/auth/updatePassword.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function updatePasswordRoute() {
    return publicProcedure.input(updatePassword).mutation(async (opts) => {
      const { email, password } = opts.input;
      const val = await findUserAndUpdate(email, password, "password");
      return val;
    });
  }

  // src/controllers/weather/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/weather/getWeather.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/weather/getWeatherService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function getWeatherService(lat, lon) {
    const root = process.env.WEATHER_URL;
    const OPENWEATHER_KEY = process.env.OPENWEATHER_KEY;
    const latParams = lat;
    const lonParams = lon;
    const unitParams = "imperial";
    const apiParams = true;
    let params = "?";
    if (latParams)
      params += `lat=${latParams}`;
    if (lonParams)
      params += `&lon=${lonParams}`;
    if (unitParams)
      params += `&units=${unitParams}`;
    if (apiParams)
      params += `&appid=${OPENWEATHER_KEY}`;
    const url = root + params;
    const response = await axios_default.get(url);
    return response;
  }

  // src/controllers/weather/getWeather.ts
  function getWeatherRoute() {
    return publicProcedure.input(z.object({ lat: z.number(), lon: z.number() })).query(async (opts) => {
      const { lat, lon } = opts.input;
      const response = await getWeatherService(lat, lon);
      return response.data;
    });
  }

  // src/controllers/weather/getWeatherWeek.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/weather/getWeatherWeekService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function getWeatherWeekService(lat, lon) {
    const root = process.env.WEATHER_WEEK_URL;
    const OPENWEATHER_KEY = process.env.OPENWEATHER_KEY;
    const latParams = lat;
    const lonParams = lon;
    const unitParams = "imperial";
    const apiParams = true;
    let params = "?";
    if (latParams)
      params += `lat=${latParams}`;
    if (lonParams)
      params += `&lon=${lonParams}`;
    if (unitParams)
      params += `&units=${unitParams}`;
    if (apiParams)
      params += `&appid=${OPENWEATHER_KEY}`;
    const url = root + params;
    const response = await axios_default.get(url);
    return response;
  }

  // src/controllers/weather/getWeatherWeek.ts
  function getWeatherWeekRoute() {
    return publicProcedure.input(z.object({ lat: z.number(), lon: z.number() })).query(async (opts) => {
      const { lat, lon } = opts.input;
      const response = await getWeatherWeekService(lat, lon);
      return response.data;
    });
  }

  // src/controllers/trip/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/trip/addTrip.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/trip/addTripService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var addTripService = async (tripDetails) => {
    try {
      const {
        name,
        description,
        duration,
        weather,
        start_date,
        end_date,
        destination,
        geoJSON,
        owner_id,
        packs,
        is_public
      } = tripDetails;
      const savedGeoJSONs = await prisma2.geoJSON.saveMany(geoJSON.features);
      const geojsonIds = savedGeoJSONs.map((feature) => feature.id);
      const newTrip = await prisma2.trip.create({
        data: {
          name,
          description,
          duration,
          weather,
          start_date,
          end_date,
          destination,
          geojson: {
            connect: geojsonIds.map((id) => ({ id }))
          },
          packs: {
            connect: packs.map((packId) => ({ id: packId }))
          },
          is_public,
          owner: {
            connect: { id: owner_id }
          }
        }
      });
      return {
        message: "Trip added successfully",
        trip: Trip(newTrip)?.toJSON()
      };
    } catch (error) {
      console.error(error);
      throw new Error("Unable to add trip");
    }
  };

  // src/controllers/trip/addTrip.ts
  function addTripRoute() {
    return publicProcedure.input(addTrip).mutation(async (opts) => {
      const {
        name,
        description,
        duration,
        weather,
        start_date,
        end_date,
        destination,
        geoJSON,
        owner_id,
        packs,
        is_public
      } = opts.input;
      const tripDetails = {
        name,
        description,
        duration,
        weather,
        start_date,
        end_date,
        destination,
        geoJSON,
        owner_id,
        packs,
        is_public
      };
      return await addTripService(tripDetails);
    });
  }

  // src/controllers/trip/deleteTrip.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function deleteTripRoute() {
    return publicProcedure.input(deleteTrip).mutation(async (opts) => {
      const { tripId } = opts.input;
      await prisma2.trip.delete({
        where: { id: tripId }
        // Assuming tripId is the ID of the trip to delete
      });
      return "trip was deleted successfully";
    });
  }

  // src/controllers/trip/editTrip.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function editTripRoute() {
    return publicProcedure.input(editTrip).mutation(async (opts) => {
      const { id } = opts.input;
      return await prisma2.trip.update({
        where: { id },
        // Assuming id is the ID of the trip to update
        data: opts.input,
        include: {
          packs: true
          // Fetch associated packs
        }
      });
    });
  }

  // src/controllers/trip/getPublicTrips.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/trip/getPublicTripService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getPublicTripsService = async (queryBy) => {
    try {
      const publicTrips = await prisma2.trip.findMany({
        where: { is_public: true },
        select: {
          id: true,
          name: true,
          description: true,
          duration: true,
          weather: true,
          start_date: true,
          end_date: true,
          destination: true,
          owner: {
            select: {
              id: true,
              username: true
            }
          },
          packs: {
            select: {
              id: true
            }
          },
          createdAt: true,
          updatedAt: true
        },
        orderBy: queryBy === "Favorite" ? { id: "desc" } : { id: "asc" }
      });
      const trips = publicTrips.map((trip) => {
        const owner = Array.isArray(trip.owner) ? trip.owner[0] : trip.owner;
        return {
          ...trip,
          owner
        };
      });
      return trips;
    } catch (error) {
      console.error(error);
      throw new Error("Trips cannot be found");
    }
  };

  // src/controllers/trip/getPublicTrips.ts
  function getPublicTripsRoute() {
    return publicProcedure.input(z.object({ queryBy: z.string() })).query(async (opts) => {
      const { queryBy } = opts.input;
      return await getPublicTripsService(queryBy);
    });
  }

  // src/controllers/trip/getTrip.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/trip/getTripsService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getTripsService = async (ownerId) => {
    try {
      const trips = await prisma2.trip.findMany({
        where: { owner_id: ownerId },
        include: {
          packs: true
        }
      });
      return trips;
    } catch (error) {
      console.error(error);
      throw new Error("Trips cannot be found");
    }
  };

  // src/controllers/trip/getTrip.ts
  function getTripsRoute() {
    return publicProcedure.input(getTrips).query(async (opts) => {
      const { owner_id } = opts.input;
      return await getTripsService(owner_id);
    });
  }

  // src/controllers/trip/getTripById.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/trip/getTripByIdService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getTripByIdService = async (tripId) => {
    try {
      const trip = await prisma2.trip.findUnique({
        where: { id: tripId },
        include: { owner: true, geojson: true }
        // Assuming 'owner_id' is a foreign key to the 'User' model
      });
      if (!trip) {
        throw new Error("Trip cannot be found");
      }
      const tripObject = {
        id: trip.id,
        name: trip.name,
        // Replace with the actual fields you have
        // Add more fields as needed
        geojson: {
          type: "FeatureCollection",
          features: trip.geojson
        },
        owner: trip.owner
        // This will have the owner details if included
      };
      return tripObject;
    } catch (error) {
      console.error(error);
      throw new Error("Trip cannot be found");
    }
  };

  // src/controllers/trip/getTripById.ts
  function getTripByIdRoute() {
    return publicProcedure.input(getTripById).query(async (opts) => {
      const { tripId } = opts.input;
      return await getTripByIdService(tripId);
    });
  }

  // src/controllers/template/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/template/addTemplate.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/template/template.service.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/template/addTemplateService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var addTemplateService = async (type2, templateId, isGlobalTemplate, createdBy) => {
    try {
      const user = await prisma2.user.findUnique({
        where: {
          id: createdBy
        }
      });
      if (!user) {
        throw new Error("User not found");
      }
      await prisma2.template.create({
        data: {
          type: type2,
          templateId,
          isGlobalTemplate,
          createdBy: {
            connect: { id: createdBy }
          }
        }
      });
    } catch (error) {
      throw new Error(error.toString());
    }
  };

  // src/services/template/editTemplateService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var editTemplateService = async (templateId, type2, isGlobalTemplate) => {
    try {
      const template = await prisma2.template.findUnique({
        where: {
          id: templateId
        }
      });
      if (!template) {
        throw new Error("Template not found");
      }
      const updatedTemplate = await prisma2.template.update({
        where: {
          id: templateId
        },
        data: {
          type: type2 || template.type,
          isGlobalTemplate: isGlobalTemplate !== void 0 ? isGlobalTemplate : template.isGlobalTemplate
        }
      });
      return updatedTemplate;
    } catch (error) {
      throw new Error(error.toString());
    }
  };

  // src/controllers/template/addTemplate.ts
  var import_edge3 = __toESM(require_edge3());
  function addTemplateRoute() {
    return publicProcedure.input(
      z.object({
        type: z.nativeEnum(import_edge3.TemplateType),
        templateId: z.string(),
        isGlobalTemplate: z.boolean(),
        createdBy: z.string()
      })
    ).mutation(async (opts) => {
      const { type: type2, templateId, isGlobalTemplate, createdBy } = opts.input;
      const user = await prisma2.user.findUnique({
        where: {
          id: createdBy
        }
      });
      if (!user) {
        throw new Error(UserNotFoundError.message);
      }
      await addTemplateService(type2, templateId, isGlobalTemplate, createdBy);
      return { message: "Template added successfully" };
    });
  }

  // src/controllers/template/deleteTemplate.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function deleteTemplateRoute() {
    return publicProcedure.input(z.object({ templateId: z.string() })).mutation(async (opts) => {
      const { templateId } = opts.input;
      const template = await prisma2.template.findUnique({
        where: {
          id: templateId
        }
      });
      if (template) {
        await prisma2.template.delete({
          where: {
            id: templateId
          }
        });
        return { message: "Template removed" };
      } else {
        throw new Error(TemplateNotFoundError.message);
      }
    });
  }

  // src/controllers/template/editTemplate.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_edge4 = __toESM(require_edge3());
  function editTemplateRoute() {
    return publicProcedure.input(
      z.object({
        templateId: z.string(),
        type: z.nativeEnum(import_edge4.TemplateType),
        isGlobalTemplate: z.boolean()
      })
    ).mutation(async (opts) => {
      const { templateId, type: type2, isGlobalTemplate } = opts.input;
      const updatedTemplate = await editTemplateService(
        templateId,
        type2,
        isGlobalTemplate
      );
      return updatedTemplate;
    });
  }

  // src/controllers/template/getTemplateById.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getTemplateByIdRoute() {
    return publicProcedure.input(z.object({ templateId: z.string() })).query(async (opts) => {
      const { templateId } = opts.input;
      const template = await prisma2.template.findUnique({
        where: {
          id: templateId
        },
        include: {
          createdBy: {
            select: {
              username: true
            }
          }
        }
      });
      return template;
    });
  }

  // src/controllers/template/getTemplates.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getTemplatesRoute() {
    return publicProcedure.query(async (opts) => {
      const templates = await prisma2.template.findMany({
        include: {
          createdBy: {
            select: {
              username: true
            }
          }
        }
      });
      return templates;
    });
  }

  // src/controllers/passwordReset/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/passwordReset/handlePasswordReset.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_jsonwebtoken3 = __toESM(require_jsonwebtoken());
  var verifyPasswordResetToken = (token) => {
    const secret = JWT_SECRET;
    try {
      const decoded = import_jsonwebtoken3.default.verify(token, secret);
      return decoded.email;
    } catch (error) {
      console.error("Error verifying password reset token:", error);
      return null;
    }
  };
  function handlePasswordResetRoute() {
    return publicProcedure.input(z.object({ token: z.string() })).mutation(async (opts) => {
      const { token } = opts.input;
      const email = verifyPasswordResetToken(token);
      const user = await prisma2.user.findUnique({
        where: {
          email
        }
      });
      if (!user) {
        return { error: "No user found with this email address" };
      }
      if (Date.now() > user.passwordResetTokenExpiration.getTime()) {
        return { error: "Password reset token has expired" };
      }
    });
  }

  // src/controllers/passwordReset/requestPasswordReset.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_jsonwebtoken4 = __toESM(require_jsonwebtoken());
  var generatePasswordResetToken = (email) => {
    const payload = { email };
    const secret = JWT_SECRET;
    const expiresIn = "1h";
    return import_jsonwebtoken4.default.sign(payload, secret, { expiresIn });
  };
  var sendPasswordResetEmail = async (email, resetUrl) => {
    const mailOptions = {
      to: email,
      from: {
        email: STMP_EMAIL,
        name: "PackRat Support"
      },
      subject: "Password Reset",
      // text: `Click the link below to reset your password:\n\n${resetUrl}\n\nIf you did not request to reset your password, please ignore this email.`,
      html: `
        <div style="font-family: Arial, sans-serif; font-size: 14px; line-height: 1.5;">
          <h2 style="font-size: 18px; font-weight: bold; margin-bottom: 16px;">Password Reset</h2>
          <p style="margin-bottom: 16px;">Click the link below to reset your password:</p>
          <a href="${resetUrl}" style="display: inline-block; padding: 8px 16px; background-color: #0070f3; color: #fff; text-decoration: none; border-radius: 4px; margin-bottom: 16px;">Reset Password</a>
          <p>If you did not request to reset your password, please ignore this email.</p>
        </div>
      `
    };
    try {
      console.log("Password reset email sent successfully");
    } catch (error) {
      console.error("Error sending password reset email:", error);
    }
  };
  function requestPasswordResetEmailAndTokenRoute() {
    return publicProcedure.input(z.object({ email: z.string() })).mutation(async (opts) => {
      const { email } = opts.input;
      const user = await prisma2.user.findUnique({
        where: {
          email
        }
      });
      if (!user) {
        return { error: "No user found with this email address" };
      }
      const resetToken = generatePasswordResetToken(email);
      const resetTokenExpiration = new Date(Date.now() + 24 * 60 * 60 * 1e3);
      await prisma2.user.update({
        where: {
          email
        },
        data: {
          passwordResetToken: resetToken,
          passwordResetTokenExpiration: resetTokenExpiration
        }
      });
      const resetUrl = `${CLIENT_URL}/password-reset?token=${resetToken}`;
      sendPasswordResetEmail(email, resetUrl);
      return { message: "Password reset email sent successfully" };
    });
  }

  // src/controllers/pack/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/pack/addPack.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/pack/pack.service.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/pack/addPackService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var addPackService = async (name, owner_id) => {
    const newPack = {
      name,
      owner_id,
      is_public: false,
      createdAt: (/* @__PURE__ */ new Date()).toDateString()
    };
    const existingPack = await prisma2.pack.findFirst({
      where: {
        name
      }
    });
    if (existingPack) {
      throw new Error("A pack with the same name already exists");
    }
    const createdPack = await prisma2.pack.create({
      data: {
        ...newPack,
        owners: {
          connect: { id: owner_id }
        }
      }
    });
    return { createdPack };
  };

  // src/services/pack/deletePackService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var deletePackService = async (packId) => {
    const pack = await prisma2.pack.delete({
      where: {
        id: packId
        // Replace 'id' with the actual primary key field in your model
      }
    });
    return { message: "pack was deleted successfully" };
  };

  // src/services/pack/duplicatePublicPackService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var duplicatePublicPackService = async (packId, ownerId, items) => {
    const existingPack = await prisma2.pack.findUnique({
      where: {
        id: packId
        // Replace 'id' with the actual primary key field in your model
      },
      include: {
        owners: true
      }
    });
    if (!existingPack) {
      throw new Error("Pack not found");
    }
    const newPack = await prisma2.pack.create({
      data: {
        name: existingPack.name,
        is_public: false,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        grades: {
          set: { ...existingPack.grades }
        },
        scores: {
          set: { ...existingPack.scores }
        },
        owners: {
          connect: existingPack.owners.map((owner) => ({ id: owner.id }))
        },
        owner: {
          connect: ownerId
        },
        items: {
          connect: items
        },
        type: existingPack.type
      }
    });
    return { pack: newPack };
  };

  // src/services/pack/editPackService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var editPackService = async (packId, packData) => {
    const updatedPack = await prisma2.pack.update({
      where: { id: packId },
      data: packData
    });
    return updatedPack;
  };

  // src/services/pack/getPackByIdService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getPackByIdService = async (packId) => {
    try {
      const pack = await prisma2.pack.findFirst({
        where: { id: packId },
        include: {
          favorited_by: true,
          items: true,
          owner: true,
          owners: true,
          trips: true
        }
      });
      const owner = User(pack.owner)?.toJSON();
      const favorited_by = pack.favorited_by.map((user) => User(user)?.toJSON());
      const owners = pack.owners.map((user) => User(user)?.toJSON());
      const trips = pack.trips.map((trip) => Trip(trip)?.toJSON());
      return {
        ...pack,
        owner,
        owners,
        favorited_by,
        trips
      };
    } catch (error) {
      console.error(error);
      throw error;
    }
  };

  // src/services/pack/getPackService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var SORT_OPTIONS = {
    Favorite: { favoritesCount: "desc" },
    Lightest: { totalWeight: "asc" },
    Heaviest: { totalWeight: "desc" },
    "Most Items": { itemsCount: "desc" },
    "Fewest Items": { itemsCount: "asc" },
    Oldest: { createdAt: "asc" },
    "Most Recent": { updatedAt: "desc" },
    "Highest Score": { scores: { totalScore: "desc" } },
    "Lowest Score": { scores: { totalScore: "asc" } },
    "A-Z": { name: "asc" },
    "Z-A": { name: "desc" },
    "Most Owners": { owners: "desc" }
  };
  var DEFAULT_SORT = { createdAt: "desc" };
  var getPacksService = async (ownerId, queryBy = null) => {
    try {
      const packs = await prisma2.pack.findMany({
        where: {
          owners: { some: { id: ownerId } }
        },
        include: {
          items: {
            select: {
              category: {
                select: {
                  name: true
                }
              }
            }
          },
          owners: true
        },
        orderBy: SORT_OPTIONS[queryBy] || DEFAULT_SORT
      });
      return packs;
    } catch (error) {
      throw new Error("Packs cannot be found: " + error.message);
    }
  };

  // src/services/pack/scorePackService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/utils/scorePack.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function checkEssentialItems(packItems) {
    const essentialItems = {
      water: ["water", "hydration"],
      food: ["food", "nutrition"],
      map: ["map", "navigation"],
      compass: ["compass"],
      firstAidKit: ["first aid kit", "medical kit"],
      clothing: ["clothing", "apparel"],
      shelter: ["shelter", "tent"],
      firestarter: ["firestarter", "firelighter"],
      navigationTools: ["navigation tools"],
      lightSource: ["light source", "flashlight"],
      communicationDevice: ["communication device", "phone"]
    };
    const totalItems = Object.keys(essentialItems).length;
    let presentItems = 0;
    for (const item in essentialItems) {
      const matchingItem = packItems.find(
        (packItem) => essentialItems[item].some(
          (itemName) => packItem.name.toLowerCase().includes(itemName.toLowerCase())
        )
      );
      if (matchingItem) {
        presentItems++;
      }
    }
    const essentialItemsScore = presentItems / totalItems * 10;
    return essentialItemsScore;
  }
  function checkRedundancy(packItems) {
    const redundantItems = {
      tools: ["multi-tool", "hammer"],
      lightSources: ["flashlight", "extra flashlight"],
      powerSources: ["batteries", "extra batteries"],
      clothing: ["socks", "extra socks"],
      food: ["food", "extra food"],
      waterContainers: ["water container", "backup water container"]
    };
    const totalRedundantItems = Object.keys(redundantItems).length;
    let presentRedundantItems = 0;
    const uniquePackItems = new Set(
      packItems.map((item) => item.name.toLowerCase())
    );
    for (const item in redundantItems) {
      const matchingItems = packItems.filter(
        (packItem) => redundantItems[item].some(
          (itemName) => packItem.name.toLowerCase().includes(itemName.toLowerCase())
        )
      );
      if (matchingItems.length > 1) {
        presentRedundantItems++;
      }
    }
    const excludedItems = ["extra socks", "extra food", "backup water container"];
    const effectiveTotalRedundantItems = totalRedundantItems - excludedItems.length;
    const redundancyScore = (effectiveTotalRedundantItems - presentRedundantItems) / effectiveTotalRedundantItems * 10;
    return redundancyScore;
  }
  function calculatePackScore(packData) {
    console.log("Calculating pack score...");
    console.log("packData: ", packData);
    const { items } = packData;
    const totalWeight = packData.items.reduce((total, item) => {
      if (item.unit === "lb") {
        return total + item.weight * 16 * item.quantity;
      } else {
        return total + item.weight * item.quantity;
      }
    }, 0);
    const weightThreshold = 7;
    const essentialItemsThreshold = 8;
    const redundancyAndVersatilityThreshold = 8;
    const weightScore = Math.max(11 - Math.floor(totalWeight / 10), 1);
    const essentialItemsScore = checkEssentialItems(items);
    const redundancyAndVersatilityScore = checkRedundancy(items);
    const weightGrade = weightScore >= weightThreshold ? "Good" : "Needs Improvement";
    const essentialItemsGrade = essentialItemsScore >= essentialItemsThreshold ? "Good" : "Needs Improvement";
    const redundancyAndVersatilityGrade = redundancyAndVersatilityScore >= redundancyAndVersatilityThreshold ? "Good" : "Needs Improvement";
    const totalScore = (weightScore + essentialItemsScore + redundancyAndVersatilityScore) / 3;
    const roundedScore = Math.round(totalScore * 100) / 100;
    return {
      totalScore: roundedScore,
      grades: {
        weight: weightGrade,
        essentialItems: essentialItemsGrade,
        redundancyAndVersatility: redundancyAndVersatilityGrade
      },
      scores: {
        weightScore,
        essentialItemsScore,
        redundancyAndVersatilityScore
      }
    };
  }

  // src/services/pack/scorePackService.ts
  async function scorePackService(packId) {
    try {
      const packData = await prisma2.pack.findUnique({
        where: { id: packId },
        include: { items: true }
        // Assuming you have a relationship defined in your Prisma schema
      });
      if (!packData) {
        throw new Error("Pack not found");
      }
      const packScore = calculatePackScore(packData);
      const updatedPack = await prisma2.pack.update({
        where: { id: packId },
        data: {
          scores: packScore.scores,
          grades: packScore.grades
        }
      });
      return updatedPack;
    } catch (error) {
      throw new Error("Unable to score pack: " + error.message);
    }
  }

  // src/services/pack/getPublicPacksService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/prisma/virtuals/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/prisma/virtuals/pack.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/utils/convertWeight.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var units = {
    g: 1,
    kg: 1e3,
    oz: 28.3495,
    lb: 453.592,
    lbs: 453.592
  };
  var convertWeight = (weight, fromUnit, toUnit) => {
    if (typeof weight !== "number" || !fromUnit || !toUnit) {
      return 0;
    }
    const weightInGrams = weight * units[fromUnit];
    const convertedWeight = weightInGrams / units[toUnit];
    return convertedWeight;
  };

  // src/prisma/virtuals/pack.ts
  var computeTotalWeight = (pack) => {
    if (pack.items && pack.items.length > 0) {
      const totalWeight = pack.items.reduce((total, item) => {
        const weightInGrams = convertWeight(item.weight, item.unit, "g");
        return total + weightInGrams * item.quantity;
      }, 0);
      return {
        ...pack,
        total_weight: totalWeight
      };
    } else {
      return {
        ...pack,
        total_weight: 0
      };
    }
  };
  var computeFavouritesCount = (pack) => ({ ...pack, favorites_count: pack.favorited_by.length });
  var computeTotalScores = (pack) => {
    if (!pack.scores)
      return { ...pack, total_score: 0 };
    const scoresArray = Object.values(pack.scores);
    const sum = scoresArray.reduce(
      (total, score) => total + score,
      0
    );
    const average = scoresArray.length > 0 ? sum / scoresArray.length : 0;
    return { ...pack, total_score: Math.round(average * 100) / 100 };
  };

  // src/services/pack/getPublicPacksService.ts
  var SORT_OPTIONS2 = {
    Favorite: { favorites_count: -1 },
    Lightest: { total_weight: 1 },
    Heaviest: { total_weight: -1 },
    "Most Items": { items_count: -1 },
    "Fewest Items": { items_count: 1 },
    Oldest: { createdAt: 1 },
    "Most Recent": { updatedAt: -1 },
    "Highest Score": { total_score: -1 },
    "Lowest Score": { total_score: 1 },
    "A-Z": { name: 1 },
    "Z-A": { name: -1 },
    "Most Owners": { "owners.length": -1 }
  };
  var sortPacks = (propertyName, sortOrder) => (packA, packB) => {
    const valueA = propertyName !== "owners.length" ? packA[propertyName] : packA.owners.length;
    const valueB = propertyName !== "owners.length" ? packB[propertyName] : packB.owners.length;
    if (valueA < valueB) {
      return -1 * Number(sortOrder);
    } else if (valueA > valueB) {
      return 1 * Number(sortOrder);
    }
    return 0;
  };
  var computeVirtualFields = (pack) => {
    const packWithTotalWeight = computeTotalWeight(pack);
    const packWithTotalScore = computeTotalScores(packWithTotalWeight);
    const packWithFavoritesCount = computeFavouritesCount(packWithTotalScore);
    return {
      ...packWithFavoritesCount,
      favorited_by: pack.favorited_by.map((user) => User(user)?.toJSON()),
      owners: pack.owners.map((owner) => User(owner)?.toJSON()),
      owner: User(pack.owner)?.toJSON(),
      items_count: pack.items.length
    };
  };
  var DEFAULT_SORT2 = { createdAt: -1 };
  async function getPublicPacksService(queryBy = null) {
    try {
      const sortOption = SORT_OPTIONS2[queryBy] || DEFAULT_SORT2;
      const [[propertyName, sortOrder]] = Object.entries(sortOption);
      const publicPacks = await prisma2.pack.findMany({
        where: {
          is_public: true
        },
        include: {
          favorited_by: true,
          items: true,
          owner: true,
          owners: true
        }
      });
      console.log(publicPacks);
      return publicPacks.map(computeVirtualFields).sort(sortPacks(propertyName, sortOrder));
    } catch (error) {
      throw new Error("Packs cannot be found: " + error.message);
    }
  }

  // src/controllers/pack/addPack.ts
  function addPackRoute() {
    return publicProcedure.input(addPack).mutation(async (opts) => {
      const { name, owner_id } = opts.input;
      return addPackService(name, owner_id);
    });
  }

  // src/controllers/pack/deletePack.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function deletePackRoute() {
    return publicProcedure.input(deletePack).mutation(async (opts) => {
      const { packId } = opts.input;
      await deletePackService(packId);
      return { msg: "pack was deleted successfully" };
    });
  }

  // src/controllers/pack/getPacks.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getPacksRoute() {
    return publicProcedure.input(getPacks).query(async (opts) => {
      const { ownerId, queryBy } = opts.input;
      const packs = await getPacksService(ownerId, queryBy);
      return { packs, message: "Packs retrieved successfully" };
    });
  }

  // src/controllers/pack/editPack.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function editPackRoute() {
    return publicProcedure.input(editPack).mutation(async (opts) => {
      const { id } = opts.input;
      return await editPackService(id, opts.input);
    });
  }

  // src/controllers/pack/duplicatePublicPack.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function duplicatePublicPackRoute() {
    return publicProcedure.input(duplicatePublicPack).mutation(async (opts) => {
      const { packId, ownerId, items } = opts.input;
      const result = await duplicatePublicPackService(packId, ownerId, items);
      return result.pack;
    });
  }

  // src/controllers/pack/getPackById.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getPackByIdRoute() {
    return publicProcedure.input(getPackById).query(async (opts) => {
      const { packId } = opts.input;
      return await getPackByIdService(packId);
    });
  }

  // src/controllers/pack/getPublicPacks.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getPublicPacksRoute() {
    return publicProcedure.input(z.object({ queryBy: z.string() })).query(async (opts) => {
      const { queryBy } = opts.input;
      return await getPublicPacksService(queryBy);
    });
  }

  // src/controllers/pack/scorePack.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function scorePackRoute() {
    return publicProcedure.input(getPackById).mutation(async (opts) => {
      const { packId } = opts.input;
      return await scorePackService(packId);
    });
  }

  // src/controllers/getOsm/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/getOsm/getOsm.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/osm/getOsmService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_osmtogeojson2 = __toESM(require_osmtogeojson());
  var getOsmService = async ({ activityType, startPoint, endPoint }) => {
    const overpassUrl = process.env.OSM_URI;
    try {
      const overpassQuery = await formatOverpassQuery(
        activityType,
        startPoint,
        endPoint
      );
      const response = await axios_default.post(overpassUrl, overpassQuery, {
        headers: { "Content-Type": "text/plain" }
      });
      if (response.status === 200) {
        const responseFormat = response.data;
        const geojsonData = (0, import_osmtogeojson2.default)(responseFormat);
        return geojsonData;
      } else {
        return ErrorProcessingOverpassError;
      }
    } catch (error) {
      return ErrorRetrievingOverpassError;
    }
  };
  async function formatOverpassQuery(activityType, startPoint, endPoint) {
    const activityTypeTags = {
      hiking: '["highway"~"path|footway"]',
      skiing: '["piste:type"~"downhill|nordic"]',
      climbing: '["sport"="climbing"]',
      cycling: '["highway"~"cycleway(:left|:right)?"]',
      canoeing: '["waterway"~"riverbank|canal|stream"]',
      horseback_riding: '["highway"="bridleway"]',
      kayaking: '["waterway"~"riverbank|canal|stream|rapids|waterfall"]',
      rock_climbing: '["natural"="cliff"]',
      sailing: '["waterway"~"riverbank|canal|harbour|basin"]'
    };
    const tagString = activityTypeTags[activityType];
    const overpassQuery = `[out:json][timeout:25];
        (
          way${tagString}(${startPoint.latitude},${startPoint.longitude},${endPoint.latitude},${endPoint.longitude});
        );
        (._;>;);
        out skel qt;`;
    return overpassQuery;
  }

  // src/controllers/getOsm/getOsm.ts
  function getOsmRoute() {
    return publicProcedure.input(
      z.object({
        activityType: z.string(),
        startPoint: z.object({ latitude: z.number(), longitude: z.number() }),
        endPoint: z.object({ latitude: z.number(), longitude: z.number() })
      })
    ).mutation(async (opts) => {
      try {
        const { activityType, startPoint, endPoint } = opts.input;
        return await getOsmService({ activityType, startPoint, endPoint });
      } catch (error) {
        return ErrorRetrievingOverpassError;
      }
    });
  }

  // src/controllers/getOsm/getDestination.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/osm/osm.service.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/osm/getDestinationService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getDestinationService = async (id) => {
    const way = await prisma2.way.findUnique({ where: { id } });
    if (way) {
      return Way(way).toJSON();
    }
    const node = await prisma2.node.findUnique({ where: { id } });
    return node;
  };

  // src/services/osm/postCollectionGeoJSONService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/utils/osmFunctions/modelHandlers.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/utils/osmFunctions/coordinateHandlers.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function createInstanceFromCoordinates(Model, [lon, lat]) {
    if (typeof lon !== "number" || typeof lat !== "number") {
      console.error("Invalid coordinate format");
      return null;
    }
    const instance = await Model.create({
      data: {
        lon,
        lat
      }
    });
    return instance.id;
  }
  async function coordinatesToInstances(Model, coordinates) {
    if (!Array.isArray(coordinates)) {
      console.error("Coordinates is not an array");
      return [];
    }
    if (coordinates.length === 0) {
      return [];
    }
    const isNestedArray = Array.isArray(coordinates[0]);
    if (!isNestedArray) {
      if (typeof coordinates[0] === "number") {
        return [
          await createInstanceFromCoordinates(
            Model,
            coordinates
          )
        ];
      } else {
        return coordinates;
      }
    }
    if (typeof coordinates[0][0] === "number") {
      return await Promise.all(
        coordinates.map(
          async (coordinate) => await createInstanceFromCoordinates(Model, coordinate)
        )
      );
    } else {
      return coordinates;
    }
  }
  function handleGeoJSONGeometry(geometry) {
    if (!geometry || !Array.isArray(geometry.coordinates)) {
      console.error("geometry is undefined or not an array");
      return [];
    }
    const nodes = [];
    if (geometry.type === "Point") {
      nodes.push(geometry.coordinates);
    } else {
      for (const coords of geometry.coordinates) {
        nodes.push(coords);
      }
    }
    return nodes;
  }

  // src/utils/osmFunctions/dataFormatters.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var extractIdAndType = (string) => {
    if (string.includes("/")) {
      const [type2, idString] = string.split("/");
      const idNumber = Number(idString);
      return { type: type2, id: idNumber };
    } else {
      return { type: "node", id: string };
    }
  };
  function isOSMFormat(data) {
    return data?.type && data.id && data.tags && data.nodes;
  }
  function isGeoJSONFormat(data) {
    return data && data.type === "Feature" && data.geometry && data.properties;
  }
  function propertiesToTags(properties) {
    if (!properties) {
      console.error("properties is undefined or null");
      return {};
    }
    if (typeof properties !== "object" || properties === null) {
      throw new Error("Properties should be an object");
    }
    const tags = {};
    for (const [k2, v] of Object.entries(properties)) {
      tags[k2] = v;
    }
    return tags;
  }

  // src/utils/osmFunctions/modelHandlers.ts
  var modelMappingFunc = (type2) => {
    switch (type2) {
      case "node":
      case "n":
      case "N":
        return prisma2.node;
      case "way":
      case "w":
      case "W":
        return prisma2.way;
      case "relation":
      case "r":
      case "R":
        return prisma2.relation;
      default:
        return null;
    }
  };
  async function fromOSM(Model, data) {
    const { type: type2, id } = extractIdAndType(data.id);
    const instanceData = {
      osm_id: id,
      osm_type: type2,
      tags: propertiesToTags(data.tags),
      updated_at: data.timestamp
    };
    const ids = data.nodes.map((node) => node.id);
    const instances = await prisma2.node.findOrCreateMany(ids, data.nodes);
    instanceData.nodes = instances.map((instance) => instance._id);
    const newInstance = await Model.create({ data: instanceData });
    return newInstance;
  }
  async function fromGeoJSON(Model, geoJSON) {
    let osm_type;
    let osm_id;
    if (geoJSON.id) {
      const extractedObj = extractIdAndType(geoJSON.id);
      osm_type = extractedObj.type;
      osm_id = extractedObj.id;
    }
    const tags = propertiesToTags(geoJSON.properties || {});
    const nodes = await coordinatesToInstances(
      prisma2.node,
      handleGeoJSONGeometry(geoJSON.geometry)
    );
    let instanceGeoJSON;
    if (isGeoJSONFormat(geoJSON)) {
      instanceGeoJSON = geoJSON;
    } else {
      console.error("geoJSON is not in GeoJSON format");
    }
    const instance = await Model.create({
      data: {
        osm_id,
        osm_type,
        geoJSON: instanceGeoJSON,
        nodes: {
          connect: nodes.map((node) => ({ id: node.id }))
        },
        tags
      }
    });
    return instance;
  }
  function findExisting(Model, id, type2) {
    return Model.findFirst({ where: { osm_id: id, osm_type: type2 } });
  }
  async function updateInstanceFromGeoJSON(instance, geoJSON) {
    instance.updated_at = geoJSON.properties.timestamp;
    instance.tags = propertiesToTags(geoJSON.properties);
    instance.nodes = await coordinatesToInstances(
      prisma2.node,
      handleGeoJSONGeometry(geoJSON.geometry)
    );
    instance.geoJSON = geoJSON;
    return instance;
  }
  async function createNewInstance(Model, element) {
    if (isOSMFormat(element)) {
      return await fromOSM(Model, element);
    } else if (isGeoJSONFormat(element)) {
      return await fromGeoJSON(Model, element);
    }
    throw new Error("Element is neither in OSM or GeoJSON format.");
  }
  function ensureIdProperty(element) {
    if (!element.id && element.properties?.osm_id) {
      let { osm_type, osm_id } = element.properties;
      if (osm_type === "N") {
        osm_type = "node";
      } else if (osm_type === "W") {
        osm_type = "way";
      } else if (osm_type === "R") {
        osm_type = "relation";
      }
      element.id = `${osm_type}/${osm_id}`;
    }
    if (!element.type && element.properties?.osm_type) {
      element.type = element.properties.osm_type;
    }
    return element;
  }
  async function processElement(element) {
    const id = element.id ? Number(element.id.split("/")[1]) : Number(element.properties.osm_id);
    const type2 = element.id ? element.id.split("/")[0] : element.properties.osm_type;
    const ModelForElement = modelMappingFunc(type2);
    if (!ModelForElement) {
      console.error(`Invalid type: ${type2}`);
      return;
    }
    let instance = await findExisting(ModelForElement, id, type2);
    if (instance) {
      if (isGeoJSONFormat(element)) {
        instance = await updateInstanceFromGeoJSON(instance, element);
        await instance.save();
      }
    } else {
      instance = await createNewInstance(ModelForElement, element);
    }
    return instance;
  }

  // src/services/osm/postSingleGeoJSONService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var postSingleGeoJSONService = async (geojson) => {
    if (!geojson || !isGeoJSONFormat(geojson)) {
      throw new Error("Invalid or missing geoJSON");
    }
    const processedElement = ensureIdProperty(geojson);
    const newInstance = await processElement(processedElement);
    return newInstance;
  };

  // src/controllers/getOsm/getDestination.ts
  function getDestinationRoute() {
    return publicProcedure.input(z.object({ id: z.string() })).query(async (opts) => {
      const { id } = opts.input;
      return await getDestinationService(id);
    });
  }

  // src/controllers/getOsm/postSingleGeoJSON.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function postSingleGeoJSONRoute() {
    return publicProcedure.input(z.object({ geojson: z.any() })).mutation(async (opts) => {
      const { geojson } = opts.input;
      return await postSingleGeoJSONService(geojson);
    });
  }

  // src/controllers/getOsm/postCollectionGeoJSON.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/getOsm/updateDatabaseWithGeoJSONDataFromOverpass.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var updateDatabaseWithGeoJSONDataFromOverpass = async (data) => {
    if (!data) {
      throw new Error("No data provided");
    }
  };

  // src/controllers/getOsm/getPhotonResults.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/osm/getPhotonResultsService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function getPhotonResultsService(searchString) {
    const params = {
      q: searchString,
      osm_tag: ["highway:footway", "highway:cycleway", "place"]
      // osm_tag: "highway:footway",
      // osm_tag: "highway:cycleway",
      // osm_tag: "place",
    };
    const queryString = Object.entries(params).flatMap(
      ([key, values]) => Array.isArray(values) ? values.map((val) => `${key}=${val}`) : `${key}=${values}`
    ).join("&");
    const response = await axios_default.get(
      `https://photon.komoot.io/api/?${queryString}`
    );
    return response;
  }

  // src/controllers/getOsm/getPhotonResults.ts
  var validators3 = __toESM(require_dist());
  function getPhotonResultsRoute() {
    return publicProcedure.input(validators3.getPhotonResults).query(async (opts) => {
      const response = await getPhotonResultsService(opts.input.searchString);
      return response.data.features;
    });
  }

  // src/controllers/getOsm/getEnhancedPhotonDetails.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_osmtogeojson3 = __toESM(require_osmtogeojson());

  // src/controllers/getOsm/getParksOSM.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/osm/getParksOSMService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_osmtogeojson4 = __toESM(require_osmtogeojson());
  async function getParksOSMService(lat, lon, radius) {
    const overpassUrl = process.env.OSM_URI;
    const overpassQuery = `
        [out:json][timeout:25];
        (
          way["leisure"~"park|nature_reserve|garden|recreation_ground"](around:${radius},${lat},${lon});
        );
        (._;>;);
        out tags geom qt;
        `;
    const response = await axios_default.post(overpassUrl, overpassQuery, {
      headers: { "Content-Type": "text/plain" }
    });
    const geojsonData = (0, import_osmtogeojson4.default)(response.data);
    console.log("geojsonData==============", geojsonData);
    updateDatabaseWithGeoJSONDataFromOverpass(geojsonData);
    return geojsonData;
  }

  // src/controllers/getOsm/getParksOSM.ts
  var validators4 = __toESM(require_dist());
  function getParksOSMRoute() {
    return publicProcedure.input(validators4.getParksOSM).query(async (opts) => {
      const { lat = 45.5231, lon = -122.6765, radius = 5e4 } = opts.input;
      return await getParksOSMService(lat, lon, radius);
    });
  }

  // src/controllers/getOsm/getNominatimDetails.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/getOsm/getTrailsOSM.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/osm/getTrailsOSMService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_osmtogeojson5 = __toESM(require_osmtogeojson());
  async function getTrailsOsmService(lat, lon, radius) {
    const overpassUrl = process.env.OSM_URI;
    const overpassQuery = `
       [out:json][timeout:25];
       (
         way["highway"~"footway"]["name"](around:${radius},${lat},${lon});
       );
       out tags geom qt;
       `;
    const response = await axios_default.post(overpassUrl, overpassQuery, {
      headers: { "Content-Type": "text/plain" }
    });
    const geojsonData = (0, import_osmtogeojson5.default)(response.data);
    updateDatabaseWithGeoJSONDataFromOverpass(geojsonData);
    return geojsonData;
  }

  // src/controllers/getOsm/getTrailsOSM.ts
  var validators5 = __toESM(require_dist());
  function getTrailsOSMRoute() {
    return publicProcedure.input(validators5.getTrailsOSM).query(async (opts) => {
      const { lat = 45.5231, lon = -122.6765, radius = 5e4 } = opts.input;
      return await getTrailsOsmService(lat, lon, radius);
    });
  }

  // src/controllers/openAi/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/openAi/getAIResponse.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/openAi/openAi.service.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/openAi/getAIResponseService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_openai = __toESM(require_dist2());
  var getAIResponseService = async (userId, conversationId, userInput) => {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error(
        "Failed to get response from AI. OPENAI_API_KEY is not set."
      );
    }
    const configuration = new import_openai.Configuration({
      apiKey: process.env.OPENAI_API_KEY
    });
    const openai = new import_openai.OpenAIApi(configuration);
    const user = await prisma2.user.findUnique({
      where: { id: userId }
    });
    if (!user) {
      throw new Error("User not found");
    }
    let conversation = await prisma2.conversation.findFirst({
      where: { userId, id: conversationId }
    });
    console.log("conversation after find ---->", conversation);
    let conversationHistory = conversation ? conversation.history : "";
    const messages = conversationHistory ? conversationHistory.split("\n").map((message, i2) => ({
      role: i2 % 2 === 0 ? "user" : "assistant",
      content: message
    })) : [
      {
        role: "system",
        content: "You are a helpful Outdoor Adventure Planning assistant for PackRat. Please assist the user with planning their trip using the following information:"
      }
    ];
    messages.push({ role: "user", content: userInput });
    const response = await openai.createChatCompletion({
      model: "gpt-3.5-turbo",
      messages
    });
    const aiResponse = response.data.choices[0].message.content.trim();
    conversationHistory += `
${userInput}
AI: ${aiResponse}`;
    if (conversation) {
      await prisma2.conversation.update({
        where: { id: conversationId },
        data: { history: conversationHistory }
      });
    } else {
      conversation = await prisma2.conversation.create({
        data: {
          userId,
          history: conversationHistory
        }
      });
    }
    return {
      aiResponse,
      conversation
    };
  };

  // src/services/openAi/getUserChatsService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getUserChatsService = async (userId) => {
    const user = await prisma2.user.findUnique({
      where: { id: userId }
    });
    if (!user) {
      throw new Error("User not found");
    }
    const conversations = await prisma2.conversation.findMany({
      where: { userId }
    });
    return { conversations };
  };

  // src/controllers/openAi/getAIResponse.ts
  function getAIResponseRoute() {
    return publicProcedure.input(
      z.object({
        userId: z.string(),
        conversationId: z.string(),
        userInput: z.string()
      })
    ).query(async (opts) => {
      const { userId, conversationId, userInput } = opts.input;
      return getAIResponseService(userId, conversationId, userInput);
    });
  }

  // src/controllers/openAi/getUserChats.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getUserChatsRoute() {
    return publicProcedure.input(z.object({ userId: z.string() })).query(async (opts) => {
      const { userId } = opts.input;
      return getUserChatsService(userId);
    });
  }

  // src/controllers/item/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/item/addGlobalItemToPack.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/item/item.service.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/item/addGlobalItemToPackService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var addGlobalItemToPackService = async (packId, itemId, ownerId) => {
    const item = await prisma2.item.findUnique({
      where: { id: itemId },
      include: { category: { select: { name: true } } }
    });
    await prisma2.pack.update({
      where: { id: packId },
      data: {
        items: {
          connect: { id: item.id }
        }
      }
    });
    const updatedItem = await prisma2.item.update({
      where: { id: item.id },
      data: {
        owners: {
          connect: { id: ownerId }
        }
      }
    });
    return item;
  };

  // src/services/item/editGlobalItemAsDuplicateService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var editGlobalItemAsDuplicateService = async (itemId, packId, name, weight, quantity, unit, type2) => {
    const category = await prisma2.itemCategory.findFirst({
      where: {
        name: type2
      }
    });
    let newItem = await prisma2.item.create({
      data: {
        name,
        weight,
        unit,
        quantity,
        global: false,
        category: {
          connect: { id: category.id }
        },
        packs: {
          connect: { id: packId }
        }
      }
    });
    newItem = await prisma2.item.findUnique({
      where: {
        id: newItem.id
      },
      include: {
        category: true
      }
    });
    await prisma2.pack.update({
      where: {
        id: packId
      },
      data: {
        items: {
          connect: { id: newItem.id },
          disconnect: [{ id: itemId }, { id: packId }]
        }
      }
    });
    return newItem;
  };

  // src/services/item/deleteGlobalItemService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var deleteGlobalItemService = async (itemId) => {
    const itemDeleted = await prisma2.item.delete({
      where: {
        id: itemId
      }
    });
    return itemDeleted;
  };

  // src/services/item/addItemGlobalService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/utils/itemCategory.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var ItemCategoryEnum = {
    FOOD: "Food",
    WATER: "Water",
    ESSENTIALS: "Essentials"
  };

  // src/services/item/addItemGlobalService.ts
  var import_edge5 = __toESM(require_edge3());
  var addItemGlobalService = async (name, weight, quantity, unit, type2) => {
    let category = null;
    let newItem = null;
    switch (type2) {
      case ItemCategoryEnum.FOOD: {
        const category2 = await prisma2.itemCategory.findFirst({
          where: {
            name: import_edge5.ItemCategoryName.Food
          }
        });
        let newItem2 = await prisma2.item.create({
          data: {
            name,
            weight,
            quantity,
            unit,
            category: {
              connect: { id: category2.id }
            },
            global: true
          }
        });
        newItem2 = await prisma2.item.findUnique({
          where: {
            id: newItem2.id
          },
          include: {
            category: {
              select: {
                name: true
              }
            }
          }
        });
        break;
      }
      case ItemCategoryEnum.WATER: {
        const category2 = await prisma2.itemCategory.findFirst({
          where: {
            name: import_edge5.ItemCategoryName.Water
          }
        });
        newItem = await prisma2.item.create({
          data: {
            name,
            weight,
            quantity: 1,
            unit,
            category: {
              connect: { id: category2.id }
            },
            global: true
          }
        });
        newItem = await prisma2.item.findUnique({
          where: {
            id: newItem.id
          },
          include: {
            category: {
              select: {
                name: true
              }
            }
          }
        });
        break;
      }
      default: {
        category = await prisma2.itemCategory.findFirst({
          where: {
            name: import_edge5.ItemCategoryName.Essentials
          }
        });
        newItem = await prisma2.item.create({
          data: {
            name,
            weight,
            quantity,
            unit,
            category: {
              connect: {
                id: category.id
              }
            },
            global: true
          }
        });
        newItem = await prisma2.item.findUnique({
          where: {
            id: newItem.id
          },
          include: {
            category: {
              select: {
                name: true
              }
            }
          }
        });
        break;
      }
    }
    return newItem;
  };

  // src/services/item/addItemService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var import_edge6 = __toESM(require_edge3());
  var addItemService = async (name, weight, quantity, unit, packId, type2, ownerId) => {
    let category = null;
    let newItem = null;
    switch (type2) {
      case ItemCategoryEnum.FOOD: {
        category = await prisma2.itemCategory.findFirst({
          where: {
            name: import_edge6.ItemCategoryName.Food
          }
        });
        newItem = await prisma2.item.create({
          data: {
            name,
            weight,
            quantity,
            unit,
            packs: {
              connect: { id: packId }
            },
            category: {
              connect: { id: category.id }
            }
          }
        });
        break;
      }
      case ItemCategoryEnum.WATER: {
        category = await prisma2.itemCategory.findFirst({
          where: {
            name: "Water"
          }
        });
        const existingWaterItem = await prisma2.item.findFirst({
          where: {
            category: { id: category.id },
            packs: { some: { id: packId } }
          },
          select: {
            weight: true,
            id: true
          }
        });
        if (existingWaterItem) {
          existingWaterItem.weight += Number(weight);
          newItem = await prisma2.item.update({
            where: { id: existingWaterItem.id },
            data: {
              weight: existingWaterItem.weight
            }
          });
        } else {
          newItem = await prisma2.item.create({
            data: {
              name,
              weight,
              quantity: 1,
              unit,
              packs: {
                connect: { id: packId }
              },
              category: {
                connect: { id: category.id }
              }
            }
          });
        }
        break;
      }
      default: {
        category = await prisma2.itemCategory.findFirst({
          where: {
            name: ItemCategoryEnum.ESSENTIALS
          }
        });
        newItem = await prisma2.item.create({
          data: {
            name,
            weight,
            quantity,
            unit,
            packs: {
              connect: { id: packId }
            },
            category: {
              connect: { id: category.id }
            }
          }
        });
        break;
      }
    }
    const pack = await prisma2.pack.update({
      where: { id: packId },
      data: {
        items: {
          connect: { id: newItem.id }
        }
      },
      include: {
        owners: true
      }
    });
    const updatedItem = await prisma2.item.update({
      where: { id: newItem.id },
      data: {
        owners: {
          connect: pack.owners.map((owner) => ({ id: owner.id }))
        }
      },
      include: {
        category: true
      }
    });
    return { newItem: updatedItem, packId };
  };

  // src/services/item/deleteItemService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var deleteItemService = async (itemId, packId) => {
    let itemDeleted;
    const item = await prisma2.item.findUnique({
      where: {
        id: itemId
      }
    });
    if (item.global) {
      await prisma2.pack.update({
        where: {
          id: packId
        },
        data: {
          items: {
            disconnect: { id: itemId }
          }
        }
      });
      await prisma2.item.update({
        where: {
          id: itemId
        },
        data: {
          packs: {
            disconnect: { id: packId }
          }
        }
      });
      itemDeleted = await prisma2.item.findUnique({
        where: {
          id: itemId
        }
      });
    } else {
      itemDeleted = await prisma2.item.delete({
        where: {
          id: itemId
        }
      });
    }
    return itemDeleted;
  };

  // src/services/item/editItemService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var editItemService = async (id, name, weight, unit, quantity, type2) => {
    const category = await prisma2.itemCategory.findFirst({
      where: {
        name: type2
      }
    });
    const newItem = await prisma2.item.update({
      where: {
        id
      },
      data: {
        name,
        weight,
        unit,
        quantity,
        category: {
          connect: { id: category.id }
        }
      },
      include: {
        category: true
      }
    });
    return newItem;
  };

  // src/services/item/getItemByIdService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getItemByIdService = async (id) => {
    const item = await prisma2.item.findUnique({
      where: {
        id
      }
    });
    return item;
  };

  // src/services/item/getItemsGloballyService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getItemsGloballyService = async (reqlimit, reqpage) => {
    const totalItems = await prisma2.item.count({
      where: {
        global: true
      }
    });
    const limit = Number(reqlimit) || totalItems;
    const totalPages = Math.ceil(totalItems / limit);
    const page = Number(reqpage) || 1;
    const startIndex = (page - 1) * limit;
    const items = await prisma2.item.findMany({
      where: {
        global: true
      },
      include: {
        category: {
          select: {
            name: true
          }
        }
      },
      skip: startIndex,
      take: limit,
      orderBy: {
        createdAt: "desc"
      }
    });
    return {
      items,
      page,
      totalPages
    };
  };

  // src/services/item/searchItemsByNameService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var searchItemsByNameService = async (name, packId) => {
    const items = await prisma2.item.findMany({
      where: {
        ...packId && {
          pack_ids: {
            has: packId
          }
        },
        name: {
          contains: name
          // Case-insensitive search for name
        }
      }
    });
    return items;
  };

  // src/services/item/getItemsService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getItemsService = async (packId) => {
    const items = await prisma2.item.findMany({
      where: {
        packs: {
          some: {
            id: packId
          }
        }
      }
    });
    return items;
  };

  // src/controllers/item/addGlobalItemToPack.ts
  function addGlobalItemToPackRoute() {
    return publicProcedure.input(
      z.object({
        packId: z.string(),
        itemId: z.string(),
        ownerId: z.string()
      })
    ).query(async (opts) => {
      const { packId, itemId, ownerId } = opts.input;
      return await addGlobalItemToPackService(packId, itemId, ownerId);
    });
  }

  // src/controllers/item/addItem.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function addItemRoute() {
    return publicProcedure.input(addItem).mutation(async (opts) => {
      const { name, weight, quantity, unit, packId, type: type2, ownerId } = opts.input;
      const result = await addItemService(
        name,
        weight,
        quantity,
        unit,
        packId,
        type2,
        ownerId
      );
      return { newItem: result.newItem, packId: result.packId };
    });
  }

  // src/controllers/item/addItemGlobal.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function addItemGlobalRoute() {
    return publicProcedure.input(addItemGlobal).mutation(async (opts) => {
      const { name, weight, quantity, unit, type: type2 } = opts.input;
      return await addItemGlobalService(name, weight, quantity, unit, type2);
    });
  }

  // src/controllers/item/deleteGlobalItem.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function deleteGlobalItemRoute() {
    return publicProcedure.input(
      z.object({
        itemId: z.string()
      })
    ).mutation(async (opts) => {
      const { itemId } = opts.input;
      return await deleteGlobalItemService(itemId);
    });
  }

  // src/controllers/item/deleteItem.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function deleteItemRoute() {
    return publicProcedure.input(deleteItem).mutation(async (opts) => {
      const { itemId, packId } = opts.input;
      return await deleteItemService(itemId, packId);
    });
  }

  // src/controllers/item/editItem.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function editItemRoute() {
    return publicProcedure.input(editItem).mutation(async (opts) => {
      const { id, name, weight, unit, quantity, type: type2 } = opts.input;
      return await editItemService(id, name, weight, unit, quantity, type2);
    });
  }

  // src/controllers/item/getItems.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getItemsRoute() {
    return publicProcedure.input(getItems).query(async (opts) => {
      const { packId } = opts.input;
      return await getItemsService(packId);
    });
  }

  // src/controllers/item/getItemById.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getItemByIdRoute() {
    return publicProcedure.input(getItemById).query(async (opts) => {
      const { id } = opts.input;
      return getItemByIdService(id);
    });
  }

  // src/controllers/item/editGlobalItemAsDuplicate.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function editGlobalItemAsDuplicateRoute() {
    return publicProcedure.input(
      z.object({
        itemId: z.string(),
        packId: z.string(),
        name: z.string(),
        weight: z.number(),
        quantity: z.number(),
        unit: z.string(),
        type: z.string()
      })
    ).mutation(async (opts) => {
      const { itemId, packId, name, weight, quantity, unit, type: type2 } = opts.input;
      return await editGlobalItemAsDuplicateService(
        itemId,
        packId,
        name,
        weight,
        quantity,
        unit,
        type2
      );
    });
  }

  // src/controllers/item/getItemsGlobally.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getItemsGloballyRoute() {
    return publicProcedure.input(
      z.object({
        limit: z.number(),
        page: z.number(),
        searchString: z.string().optional()
      })
    ).query(async (opts) => {
      return await getItemsGloballyService(opts.input.limit, opts.input.page);
    });
  }

  // src/controllers/item/searchItemsByName.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var JoiObjectId5 = (message = "valid id") => z.string().regex(/^[0-9a-fA-F]{24}$/, { message });
  function searchItemsByNameRoute() {
    return publicProcedure.input(z.object({ name: z.string(), packId: JoiObjectId5().optional() })).query(async (opts) => {
      const { name, packId } = opts.input;
      return searchItemsByNameService(name, packId);
    });
  }

  // src/controllers/getTrail/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/getTrail/getTrails.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/trails/getTrailsService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function getTrailsService(administrative_area_level_1, country, locality, latitude, longitude, radiusParams, activityParams) {
    const state = administrative_area_level_1;
    const city = locality;
    let paramsConditional = "";
    const root = process.env.GET_TRAIL_ROOT_URL;
    if (latitude)
      paramsConditional += `lat=${latitude}`;
    if (longitude)
      paramsConditional += `&lon=${longitude}`;
    if (city)
      paramsConditional += `&q-city_cont=${city.replace(/\s/g, "")}`;
    if (radiusParams)
      paramsConditional += `&radius=${radiusParams}`;
    if (activityParams) {
      paramsConditional += "&q-activities_activity_type_name_eq=hiking";
    }
    const url1 = root + paramsConditional;
    const url = "https://trailapi-trailapi.p.rapidapi.com/activity/?lat=34.1&lon=-105.2&q-city_cont=Denver&radius=25&q-activities_activity_type_name_eq=hiking";
    const X_RAPIDAPI_KEY = process.env.X_RAPIDAPI_KEY;
    const options = {
      method: "GET",
      headers: {
        "X-RapidAPI-Key": `${X_RAPIDAPI_KEY}`,
        "X-RapidAPI-Host": "trailapi-trailapi.p.rapidapi.com"
      }
    };
    return await fetch(url1, options).then(async (res) => await res.json()).then((json) => {
      return json;
    }).catch((_err) => {
      return RetrievingTrailsDataError;
    });
  }

  // src/controllers/getTrail/getTrails.ts
  function getTrailsRoute() {
    return publicProcedure.input(
      z.object({
        administrative_area_level_1: z.string(),
        country: z.string(),
        locality: z.string(),
        latitude: z.number(),
        longitude: z.number()
      })
    ).mutation(async (opts) => {
      const radiusParams = 25;
      const activityParams = true;
      const {
        administrative_area_level_1,
        country,
        locality,
        latitude,
        longitude
      } = opts.input;
      return await getTrailsService(
        administrative_area_level_1,
        country,
        locality,
        latitude,
        longitude,
        radiusParams,
        activityParams
      );
    });
  }

  // src/controllers/getParks/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/getParks/getParks.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var validators6 = __toESM(require_dist());

  // src/services/parks/getParksService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/utils/oneEntity.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var oneEntity = async (val) => {
    if (!val) {
      throw new Error("Required");
    }
    return val;
  };

  // src/services/parks/getParksService.ts
  async function getParksService(abbrStates) {
    const abbrState = await oneEntity(abbrStates);
    const X_RAPIDAPI_KEY = process.env.X_RAPIDAPI_KEY;
    const NPS_API = process.env.NPS_API;
    const PARKS_HOST = process.env.PARKS_HOST;
    const host = `${PARKS_HOST}?stateCode=${abbrState}`;
    const options = {
      method: "GET",
      headers: {
        "X-Api-Key": `${NPS_API}`,
        "X-RapidAPI-Key": `${X_RAPIDAPI_KEY}`,
        "X-RapidAPI-Host": "jonahtaylor-national-park-service-v1.p.rapidapi.com",
        "User-Agent": "PackRat"
      }
    };
    return await fetch(host, options).then(async (res) => await res.json()).then((json) => {
      return json;
    }).catch(() => {
      return RetrievingParksDataError;
    });
  }

  // src/controllers/getParks/getParks.ts
  function getParksRoute() {
    return publicProcedure.input(validators6.getParks).query(async (opts) => {
      return await getParksService(opts.input.abbrState);
    });
  }

  // src/controllers/geoCode/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/geoCode/getGeoCode.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var validators7 = __toESM(require_dist());

  // src/services/geocode/geoCodeService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  async function geoCodeService({ addressArray }) {
    const address = await oneEntity(addressArray);
    const transform = address.split(", ").join("%20").split(" ").join("%20");
    const GEO_CODE_URL = process.env.GEO_CODE_URL;
    const GEOAPIFY_KEY = process.env.GEOAPIFY_KEY;
    let params = "?";
    if (address)
      params += `text=${transform}`;
    const api_key = `&apiKey=${GEOAPIFY_KEY}`;
    params += api_key;
    const url = GEO_CODE_URL + params;
    return await fetch(url).then(async (response) => response.json()).then((result) => {
      return { message: "ok", result };
    }).catch(() => {
      return ErrorFetchingGeoCodeError;
    });
  }

  // src/controllers/geoCode/getGeoCode.ts
  function getGeoCodeRoute() {
    return publicProcedure.input(validators7.AddressArray).query(async (opts) => {
      const result = await geoCodeService(opts.input);
      return result.message === "ok" ? result.result : ErrorFetchingGeoCodeError;
    });
  }

  // src/controllers/favorite/index.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/favorite/addToFavorite.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/favorite/favorite.service.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/services/favorite/getFavoritePacksByUserService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  var getFavoritePacksByUserService = async (userId) => {
    const packs = await prisma2.pack.findMany({
      where: {
        favorited_by: {
          some: {
            id: userId
          }
        }
      }
    });
    return packs;
  };

  // src/services/favorite/getUserFavoritesService.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();

  // src/controllers/favorite/addToFavorite.ts
  function addToFavoriteRoute() {
    return publicProcedure.input(addToFavorite).mutation(async (opts) => {
      const { packId, userId } = opts.input;
      await addToFavoriteService(packId, userId);
      const user = await prisma2.user.findUnique({
        where: {
          id: userId
          // Assuming userId is the user's ID
        },
        select: {
          // Exclude the 'password' field
          id: true,
          email: true,
          name: true
          // Include other fields you want
        }
      });
      if (!user)
        return UserNotFoundError;
      return user;
    });
  }

  // src/controllers/favorite/getFavoritePacksByUser.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getFavoritePacksByUserRoute() {
    return publicProcedure.input(z.object({ userId: z.string() })).query(async (opts) => {
      const { userId } = opts.input;
      const packs = await getFavoritePacksByUserService(userId);
      return packs;
    });
  }

  // src/controllers/favorite/getUserFavorites.ts
  init_checked_fetch();
  init_middleware_insertion_facade();
  init_modules_watch_stub();
  init_process();
  init_buffer();
  function getUserFavoritesRoute() {
    return publicProcedure.input(z.object({ userId: z.string() })).query(async (opts) => {
      const { userId } = opts.input;
      const user = await prisma2.user.findUnique({
        where: {
          id: userId
          // Assuming userId is the user's ID
        },
        include: {
          favorites: true
        }
      });
      return user.favorites;
    });
  }

  // src/routes/trpcRouter.ts
  var helloRouter = router({
    world: publicProcedure.input(z.string()).query(async ({ input }) => {
      console.log("input", input);
      return `Hello ${input}!`;
    })
  });
  var appRouter = router({
    hello1: router({
      world: publicProcedure.query(() => {
        return "Hello World";
      })
    }),
    hello2: helloRouter,
    // hello: publicProcedure
    // .input(z.string())
    // .query(async ({ input }) => {
    //   return `Hello ${input}!`
    // }),
    // user routes
    getUserById: getUserByIdRoute(),
    signIn: userSignInRoute(),
    signUp: signUpRoute(),
    resetPassword: resetPasswordRoute(),
    getGoogleAuthURL: getGoogleAuthURLRoute(),
    // googleSignin: googleSigninRoute(),
    editUser: editUserRoute(),
    deleteUser: deleteUserRoute(),
    getMe: getMeRoute(),
    emaileExists: emailExistsRoute(),
    checkCode: checkCodeRoute(),
    getUsers: getUsersRoute(),
    resetPasswordEmail: sentEmailRoute(),
    updatePassword: updatePasswordRoute(),
    // weather routes
    getWeather: getWeatherRoute(),
    getWeatherWeek: getWeatherWeekRoute(),
    // trips routes
    getPublicTripsRoute: getPublicTripsRoute(),
    getTrips: getTripsRoute(),
    getTripById: getTripByIdRoute(),
    addTrip: addTripRoute(),
    editTrip: editTripRoute(),
    deleteTrip: deleteTripRoute(),
    // templates routes
    getTemplates: getTemplatesRoute(),
    getTemplateById: getTemplateByIdRoute(),
    addTemplate: addTemplateRoute(),
    editTemplate: editTemplateRoute(),
    deleteTemplate: deleteTemplateRoute(),
    // password reset routes
    requestPasswordResetEmailAndToken: requestPasswordResetEmailAndTokenRoute(),
    handlePasswordReset: handlePasswordResetRoute(),
    // packs routes
    getPublicPacks: getPublicPacksRoute(),
    getPacks: getPacksRoute(),
    getPackById: getPackByIdRoute(),
    addPack: addPackRoute(),
    editPack: editPackRoute(),
    deletePack: deletePackRoute(),
    scorePack: scorePackRoute(),
    duplicatePublicPack: duplicatePublicPackRoute(),
    // osm routes
    getPhotonResults: getPhotonResultsRoute(),
    getTrailsOSM: getTrailsOSMRoute(),
    getParksOSM: getParksOSMRoute(),
    getOsm: getOsmRoute(),
    postSingleGeoJSON: postSingleGeoJSONRoute(),
    getDestination: getDestinationRoute(),
    getPhotonDetails: getPhotonDetailsRoute(),
    // open ai routes
    getAIResponse: getAIResponseRoute(),
    getUserChats: getUserChatsRoute(),
    // item routes
    getItems: getItemsRoute(),
    getItemById: getItemByIdRoute(),
    searchItemsByName: searchItemsByNameRoute(),
    addItem: addItemRoute(),
    editItem: editItemRoute(),
    deleteItem: deleteItemRoute(),
    addItemGlobal: addItemGlobalRoute(),
    getItemsGlobally: getItemsGloballyRoute(),
    addGlobalItemToPack: addGlobalItemToPackRoute(),
    editGlobalItemAsDuplicate: editGlobalItemAsDuplicateRoute(),
    deleteGlobalItem: deleteGlobalItemRoute(),
    // trails routes
    getTrails: getTrailsRoute(),
    // parks route
    getParks: getParksRoute(),
    // geo code routes
    getGeoCode: getGeoCodeRoute(),
    // favorite routes
    addToFavorite: addToFavoriteRoute(),
    getUserFavorites: getUserFavoritesRoute(),
    getFavoritePacksByUser: getFavoritePacksByUserRoute()
  });

  // src/index.ts
  var app = new x({ aot: false }).get("/", () => "Hello World").use(
    trpc(appRouter, {
      endpoint: "/api/trpc"
    })
  ).listen(3e3);
})();
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! Bundled license information:

@esbuild-plugins/node-globals-polyfill/Buffer.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

osmtogeojson/lodash.custom.js:
  (**
   * @license
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash exports="node" include="clone,merge,isEmpty,isArray,compact,each" -d`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@trpc/server/dist/resolveHTTPResponse-cd1a9112.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/server/dist/adapters/fetch/index.mjs:
  (* istanbul ignore if -- @preserve *)
*/
//# sourceMappingURL=index.js.map
